{
  "title": "Transactions",
  "url": "https://docs.snowflake.com/en/sql-reference/transactions",
  "sections": [
    {
      "heading": "Introduction"
    },
    {
      "heading": "What is a transaction?",
      "description": "\nA transaction is a sequence of SQL statements that are processed as an atomic unit. All statements in the transaction\nare either applied (committed) or undone (rolled back) together.\nSnowflake transactions guaranteeACID properties.\nA transaction can include both reads and writes.\nTransactions follow these rules:\nTransactions are nevernested. For example, you cannot create anoutertransaction that would roll back aninnertransaction that was committed, or create anoutertransaction that would commit aninnertransaction\nthat had been rolled back. A transaction is associated with a single session. Multiple sessions cannot share the same transaction. For\ninformation about handling transactions with overlapping threads in the same session, seeTransactions and multi-threading.\nTransactions are nevernested. For example, you cannot create anoutertransaction that would roll back aninnertransaction that was committed, or create anoutertransaction that would commit aninnertransaction\nthat had been rolled back.\nA transaction is associated with a single session. Multiple sessions cannot share the same transaction. For\ninformation about handling transactions with overlapping threads in the same session, seeTransactions and multi-threading."
    },
    {
      "heading": "Terminology",
      "description": "\nIn this topic:\nThe termDDLincludes CTAS statements (CREATE TABLE AS SELECT) as well as other DDL statements that define database objects. The termDMLrefers to INSERT, UPDATE, DELETE, MERGE, and TRUNCATE statements. The termquery statementrefers to SELECT andCALLstatements.\nThe termDDLincludes CTAS statements (CREATE TABLE AS SELECT) as well as other DDL statements that define database objects.\nThe termDMLrefers to INSERT, UPDATE, DELETE, MERGE, and TRUNCATE statements.\nThe termquery statementrefers to SELECT andCALLstatements.\nAlthough a CALL statement (which calls astored procedure) is a\nsingle statement, the stored procedure it calls can contain multiple statements. There arespecial rules for stored procedures and transactions."
    },
    {
      "heading": "Explicit transactions",
      "description": "\nA transaction can be started explicitly by executing aBEGINstatement. Snowflake\nsupports the synonyms BEGIN WORK and BEGIN TRANSACTION. Snowflake recommends using BEGIN TRANSACTION.\nA transaction can be ended explicitly by executingCOMMITorROLLBACK. Snowflake supports the synonym COMMIT WORK for COMMIT, and the synonym\nROLLBACK WORK for ROLLBACK.\nIn general, if a transaction is already active, any BEGIN TRANSACTION statements are ignored. Users should avoid\nextra BEGIN TRANSACTION statements, however, because they make it much more difficult for human readers to pair up a COMMIT (or ROLLBACK)\nstatement with the corresponding BEGIN TRANSACTION statement.\nOne exception to this rule involves a nested stored procedure call. For details, seeScoped transactions.\nNote\nExplicit transactions should contain only DML statements and query statements. DDL statements implicitly commit\nactive transactions (for details, see theDDLsection)."
    },
    {
      "heading": "Implicit transactions",
      "description": "\nTransactions can be started and ended implicitly, without an explicit BEGIN TRANSACTION or COMMIT/ROLLBACK.\nImplicit transactions behave the same way as explicit transactions. However, the rules that determine when the\nimplicit transaction starts are different from the rules that determine when an explicit transaction starts.\nThe rules for stopping and starting depend upon whether the statement is a DDL statement, a DML statement, or a\nquery statement. If the statement is a DML or query statement, the rules depend upon whetherAUTOCOMMITis enabled.\nEach DDL statement executes as a separate transaction.\nIf a DDL statement is executed while a transaction is active, the DDL statement:\nImplicitly commits the active transaction. Executes the DDL statement as a separate transaction.\nImplicitly commits the active transaction.\nExecutes the DDL statement as a separate transaction.\nBecause a DDL statement is its own transaction, you cannot roll back a DDL statement; the transaction containing the\nDDL completes before you can execute an explicit ROLLBACK.\nIf a DDL statement is followed immediately by a DML statement, that DML statement implicitly starts a new transaction.\nSnowflake supports anAUTOCOMMITparameter. The default setting for AUTOCOMMIT is TRUE (enabled).\nWhile AUTOCOMMIT is enabled:\nEach statement outside an explicit transaction is treated as though it is inside its own implicit\nsingle-statement transaction. In other words, that statement is automatically committed if it succeeds, and\nautomatically rolled back if it fails.Statements inside an explicit transaction are not affected by AUTOCOMMIT. For example,\nstatements inside an explicit BEGIN TRANSACTION … ROLLBACK are rolled back even if AUTOCOMMIT is TRUE.\nEach statement outside an explicit transaction is treated as though it is inside its own implicit\nsingle-statement transaction. In other words, that statement is automatically committed if it succeeds, and\nautomatically rolled back if it fails.\nStatements inside an explicit transaction are not affected by AUTOCOMMIT. For example,\nstatements inside an explicit BEGIN TRANSACTION  ROLLBACK are rolled back even if AUTOCOMMIT is TRUE.\nWhile AUTOCOMMIT is disabled:\nAn implicit BEGIN TRANSACTION is executed at:The first DML statement after a transaction ends. This is true regardless of what ended the\npreceding transaction (for example, a DDL statement, or an explicit COMMIT or ROLLBACK).The first DML statement after disabling AUTOCOMMIT. The first DML statement after a transaction ends. This is true regardless of what ended the\npreceding transaction (for example, a DDL statement, or an explicit COMMIT or ROLLBACK). The first DML statement after disabling AUTOCOMMIT. An implicit COMMIT is executed as follows (if a transaction is already active):When a DDL statement is executed.When anALTERSESSIONSETAUTOCOMMITstatement is executed, regardless of whether the new value is\nTRUE or FALSE, and whether the new value is different from the previous value.\nFor example, even if you set AUTOCOMMIT to FALSE when it is already FALSE, an implicit COMMIT is executed. When a DDL statement is executed. When anALTERSESSIONSETAUTOCOMMITstatement is executed, regardless of whether the new value is\nTRUE or FALSE, and whether the new value is different from the previous value.\nFor example, even if you set AUTOCOMMIT to FALSE when it is already FALSE, an implicit COMMIT is executed. An implicit ROLLBACK is executed as follows (if a transaction is already active):At the end of a session.At the end of a stored procedure.Regardless of whether the stored procedure’s active transaction was started explicitly or implicitly,\nSnowflake rolls back the active transaction and issues an error message. At the end of a session. At the end of a stored procedure.Regardless of whether the stored procedure’s active transaction was started explicitly or implicitly,\nSnowflake rolls back the active transaction and issues an error message.\nAn implicit BEGIN TRANSACTION is executed at:\nThe first DML statement after a transaction ends. This is true regardless of what ended the\npreceding transaction (for example, a DDL statement, or an explicit COMMIT or ROLLBACK). The first DML statement after disabling AUTOCOMMIT.\nThe first DML statement after a transaction ends. This is true regardless of what ended the\npreceding transaction (for example, a DDL statement, or an explicit COMMIT or ROLLBACK).\nThe first DML statement after disabling AUTOCOMMIT.\nAn implicit COMMIT is executed as follows (if a transaction is already active):\nWhen a DDL statement is executed. When anALTERSESSIONSETAUTOCOMMITstatement is executed, regardless of whether the new value is\nTRUE or FALSE, and whether the new value is different from the previous value.\nFor example, even if you set AUTOCOMMIT to FALSE when it is already FALSE, an implicit COMMIT is executed.\nWhen a DDL statement is executed.\nWhen anALTERSESSIONSETAUTOCOMMITstatement is executed, regardless of whether the new value is\nTRUE or FALSE, and whether the new value is different from the previous value.\nFor example, even if you set AUTOCOMMIT to FALSE when it is already FALSE, an implicit COMMIT is executed.\nAn implicit ROLLBACK is executed as follows (if a transaction is already active):\nAt the end of a session. At the end of a stored procedure.Regardless of whether the stored procedure’s active transaction was started explicitly or implicitly,\nSnowflake rolls back the active transaction and issues an error message.\nAt the end of a session.\nAt the end of a stored procedure.\nRegardless of whether the stored procedures active transaction was started explicitly or implicitly,\nSnowflake rolls back the active transaction and issues an error message.\nCaution\nDo not change AUTOCOMMIT settings inside astored procedure.\nYou will get an error message."
    },
    {
      "heading": "Mixing implicit and explicit starts and ends of a transaction",
      "description": "\nTo avoid writing confusing code, you should avoid mixing implicit and explicit starts and ends in the same\ntransaction. The following are legal, but discouraged:\nAn implicitly started transaction can be ended by an explicit COMMIT or ROLLBACK. An explicitly started transaction can be ended by an implicit COMMIT or ROLLBACK.\nAn implicitly started transaction can be ended by an explicit COMMIT or ROLLBACK.\nAn explicitly started transaction can be ended by an implicit COMMIT or ROLLBACK."
    },
    {
      "heading": "Failed statements within a transaction",
      "description": "\nAlthough a transaction is committed or rolled back as a unit, that is not quite the same as saying that\nit succeeds or fails as a unit. If a statement fails within a transaction, you can still commit the transaction, rather than roll\nit back.\nWhen a DML statement or CALL statement in a transaction fails, the changes made by that failed statement are rolled back. However, the\ntransaction stays active until the entire transaction is committed or rolled back. If the transaction is committed,\nthe changes made by the successful statements are applied.\nFor example, consider the following code, which inserts two valid values and one invalid value into a table:\nIf the statements after the failed INSERT statement are executed, the output of the final SELECT statement includes the rows with\ninteger values 1 and 2, even though one of the other statements in the transaction failed.\nNote\nThe statements after the failed INSERT statement might or might not be executed. The behavior depends on how the statements are run and\nhow errors are handled.\nFor example:\nIf these statements are inside a stored procedure written in Snowflake Scripting language, the failed INSERT statement\nthrows an exception.If the exception is not handled, the stored procedure never completes, and the COMMIT is never executed, so the open\ntransaction is implicitly rolled back. In that case, the table does not contain the values1or2.If the stored procedure handles the exception and commits the statements prior to the failed INSERT statement, but does not\nexecute the statements after the failed INSERT statement, only the row with the value1is stored in the table. If the exception is not handled, the stored procedure never completes, and the COMMIT is never executed, so the open\ntransaction is implicitly rolled back. In that case, the table does not contain the values1or2. If the stored procedure handles the exception and commits the statements prior to the failed INSERT statement, but does not\nexecute the statements after the failed INSERT statement, only the row with the value1is stored in the table. If these statements are not inside a stored procedure, the behavior depends on how the statements are executed. For example:If the statements are executed through Snowsight, execution halts at the first error.If the statements are executed by SnowSQL using the-f(filename) option, execution does not halt at the first error,\nand the statements after the error are executed. If the statements are executed through Snowsight, execution halts at the first error. If the statements are executed by SnowSQL using the-f(filename) option, execution does not halt at the first error,\nand the statements after the error are executed.\nIf these statements are inside a stored procedure written in Snowflake Scripting language, the failed INSERT statement\nthrows an exception.\nIf the exception is not handled, the stored procedure never completes, and the COMMIT is never executed, so the open\ntransaction is implicitly rolled back. In that case, the table does not contain the values1or2. If the stored procedure handles the exception and commits the statements prior to the failed INSERT statement, but does not\nexecute the statements after the failed INSERT statement, only the row with the value1is stored in the table.\nIf the exception is not handled, the stored procedure never completes, and the COMMIT is never executed, so the open\ntransaction is implicitly rolled back. In that case, the table does not contain the values1or2.\nIf the stored procedure handles the exception and commits the statements prior to the failed INSERT statement, but does not\nexecute the statements after the failed INSERT statement, only the row with the value1is stored in the table.\nIf these statements are not inside a stored procedure, the behavior depends on how the statements are executed. For example:\nIf the statements are executed through Snowsight, execution halts at the first error. If the statements are executed by SnowSQL using the-f(filename) option, execution does not halt at the first error,\nand the statements after the error are executed.\nIf the statements are executed through Snowsight, execution halts at the first error.\nIf the statements are executed by SnowSQL using the-f(filename) option, execution does not halt at the first error,\nand the statements after the error are executed.",
      "syntax": [
        "CREATE TABLE table1 (i int);\nBEGIN TRANSACTION;\nINSERT INTO table1 (i) VALUES (1);\nINSERT INTO table1 (i) VALUES ('This is not a valid integer.');    -- FAILS!\nINSERT INTO table1 (i) VALUES (2);\nCOMMIT;\nSELECT i FROM table1 ORDER BY i;"
      ]
    },
    {
      "heading": "Transactions and multi-threading",
      "description": "\nAlthough multiple sessions cannot share the same transaction, multiplethreadsthat use a single connection\nshare the same session, and thus share the same transaction. This behavior can lead to unexpected results, such\nas one thread rolling back work that was done in another thread.\nThis situation can occur when a client application using a Snowflake driver (such as the\nSnowflake JDBC Driver) or a connector (such as the Snowflake Connector for Python) is multi-threaded. If two\nor more threads share the same connection, those threads also share the current transaction in that\nconnection. A BEGIN TRANSACTION, COMMIT, or ROLLBACK by one thread affects all threads using that shared connection.\nIf the threads are running asynchronously, the results can be unpredictable.\nSimilarly, changing the AUTOCOMMIT setting in one thread affects the AUTOCOMMIT setting in all other threads\nthat use the same connection.\nSnowflake recommends that multi-threaded client programs do at least one of the following:\nUse a separate connection for each thread.Note that even with separate connections, your code can still hit race conditions that generate unpredictable\noutput; for example, one thread might delete data before another thread tries to update it. Execute the threads synchronously rather than asynchronously, to control the order in which steps are performed.\nUse a separate connection for each thread.\nNote that even with separate connections, your code can still hit race conditions that generate unpredictable\noutput; for example, one thread might delete data before another thread tries to update it.\nExecute the threads synchronously rather than asynchronously, to control the order in which steps are performed."
    },
    {
      "heading": "Stored procedures and transactions",
      "description": "\nIn general, the rules described in the previous sections also apply to stored procedures.\nThis section provides additional information specific to stored procedures.\nA transaction can be inside a stored procedure, or a stored procedure can be inside a transaction; however, a\ntransaction cannot be partly inside and partly outside a stored procedure, or started in one stored procedure and\nfinished in a different stored procedure.\nFor example:\nYou cannot start a transaction before calling the stored procedure, then complete the transaction inside the\nstored procedure. If you try to do this, Snowflake reports an error like this:Modifying a transaction that has started at a different scope is not allowed. You cannot start a transaction inside the stored procedure, then complete the transaction after returning from the\nprocedure. If a transaction is started inside a stored procedure and is still active when the stored procedure\nfinishes, an error occurs and the transaction is rolled back.\nYou cannot start a transaction before calling the stored procedure, then complete the transaction inside the\nstored procedure. If you try to do this, Snowflake reports an error like this:\nYou cannot start a transaction inside the stored procedure, then complete the transaction after returning from the\nprocedure. If a transaction is started inside a stored procedure and is still active when the stored procedure\nfinishes, an error occurs and the transaction is rolled back.\nThese rules also apply to nested stored procedures. If procedureAcalls procedureB, procedureBcannot complete a transaction that was started in procedureAor vice versa. Each BEGIN TRANSACTION inAmust\nhave a corresponding COMMIT (or ROLLBACK) inA, and each BEGIN TRANSACTION inBmust have a corresponding\nCOMMIT (or ROLLBACK) inB.\nIf a stored procedure contains an explicit transaction, that transaction can contain either part or all of the body of the\nstored procedure. For example, in the following stored procedure, only some of the statements are inside the explicit\ntransaction. (This example, and several subsequent examples, use pseudo-code for simplicity.)",
      "syntax": [
        "Modifying a transaction that has started at a different scope is not allowed.",
        "CREATE PROCEDURE ...\n  AS\n  $$\n    ...\n    statement1;\n\n    BEGIN TRANSACTION;\n    statement2;\n    COMMIT;\n\n    statement3;\n    ...\n\n  $$;"
      ]
    },
    {
      "heading": "Non-overlapping transactions",
      "description": "\nThe sections below describe:\nUsing a stored procedure inside a transaction. Using a transaction inside a stored procedure.\nUsing a stored procedure inside a transaction.\nUsing a transaction inside a stored procedure.\nIn the simplest case, a stored procedure is considered to be inside of a transaction if the following conditions are\nmet:\nA BEGIN TRANSACTION is executed before the stored procedure is called. The corresponding COMMIT (or ROLLBACK) is executed after the stored procedure completes. The body of the stored procedure does not contain an explicit or implicit BEGIN TRANSACTION or COMMIT\n(or ROLLBACK).\nA BEGIN TRANSACTION is executed before the stored procedure is called.\nThe corresponding COMMIT (or ROLLBACK) is executed after the stored procedure completes.\nThe body of the stored procedure does not contain an explicit or implicit BEGIN TRANSACTION or COMMIT\n(or ROLLBACK).\nThe stored procedure inside the transaction follows the rules of the enclosing transaction:\nIf the transaction is committed, all the statements inside the procedure are committed. If the transaction is rolled back, all statements inside the procedure are rolled back.\nIf the transaction is committed, all the statements inside the procedure are committed.\nIf the transaction is rolled back, all statements inside the procedure are rolled back.\nThe following pseudo-code shows a stored procedure called entirely inside an explicit transaction:\nThis is equivalent to executing the following sequence of statements:\nYou can execute zero, one, or more transactions inside a stored procedure. The following pseudo-code shows an example\nof two transactions in one stored procedure:\nThe stored procedure could be called as shown here:\nThis is equivalent to executing the following sequence:\nIn this code, four separate transactions are executed. Each transaction either starts and completes outside the\nprocedure, or starts and completes inside the procedure. No transaction is split across a procedure boundary (partly\ninside and partly outside the stored procedure). No transaction is nested in another transaction.",
      "syntax": [
        "CREATE PROCEDURE my_procedure()\n  ...\n  AS\n  $$\n    statement X;\n    statement Y;\n  $$;\n\nBEGIN TRANSACTION;\n  statement W;\n  CALL my_procedure();\n  statement Z;\nCOMMIT;",
        "BEGIN TRANSACTION;\nstatement W;\nstatement X;\nstatement Y;\nstatement Z;\nCOMMIT;",
        "CREATE PROCEDURE p1()\n...\n$$\n  BEGIN TRANSACTION;\n  statement C;\n  statement D;\n  COMMIT;\n\n  BEGIN TRANSACTION;\n  statement E;\n  statement F;\n  COMMIT;\n$$;",
        "BEGIN TRANSACTION;\nstatement A;\nstatement B;\nCOMMIT;\n\nCALL p1();\n\nBEGIN TRANSACTION;\nstatement G;\nstatement H;\nCOMMIT;",
        "BEGIN TRANSACTION;\nstatement A;\nstatement B;\nCOMMIT;\n\nBEGIN TRANSACTION;\nstatement C;\nstatement D;\nCOMMIT;\n\nBEGIN TRANSACTION;\nstatement E;\nstatement F;\nCOMMIT;\n\nBEGIN TRANSACTION;\nstatement G;\nstatement H;\nCOMMIT;"
      ]
    },
    {
      "heading": "Scoped transactions",
      "description": "\nAstored procedurethat contains a transaction can be called from within another\ntransaction. For example, a transaction inside a stored procedure can include a call to another stored procedure that contains a\ntransaction.\nSnowflake doesnottreat the inner transaction as nested; instead, the inner transaction isa separate transaction. Snowflake calls these autonomous scoped transactions (or simply scoped\ntransactions).\nThe starting point and ending point of each scoped transaction determine which statements are included in the transaction. The start and\nend can be explicit or implicit. Each SQL statement is part of only one transaction. An enclosing ROLLBACK or COMMIT does not undo an\nenclosed COMMIT or ROLLBACK.\nNote\nThe terms inner and outer are commonly used when describing nested operations, such as nested stored procedure\ncalls. However, transactions in Snowflake are not truly nested; therefore, to reduce confusion when referring to\ntransactions, this document frequently uses the terms enclosed and enclosing, rather than inner and outer.\nThe diagram below shows two stored procedures and two scoped transactions. In this example, each stored\nprocedure contains its own independent transaction. The first stored procedure calls the second stored procedure,\nso the procedures overlap in time; however, they do not overlap in content. All the statements inside the shaded\ninner box are in one transaction; all the other statements are in another transaction.\nIn the next example, the transaction boundaries are different from the stored procedure boundaries; the transaction\nthat starts in the enclosing stored procedure includes some but not all of the statements in the enclosed stored procedure.\nIn the code above, the second stored procedure contains some statements (SP2_T1_S2andSP2_T1_S3) that are in the\nscope of the first transaction. Only statementSP2_T2_S1, inside the shaded inner box, is in the scope of the second\ntransaction.\nThe next example demonstrates the problems that occur if a transaction does not begin and end within the same stored\nprocedure. The example contains the same number of COMMIT statements as BEGIN statements. However, the\nBEGIN and COMMIT statements are not paired properly, so this example contains two errors:\nThe enclosing stored procedure starts a scoped transaction, but doesn’t explicitly complete it. Therefore\nthat scoped transaction causes an error at the end of that stored procedure, and the active transaction is\nimplicitly rolled back. The second stored procedure contains a COMMIT, but there is no corresponding BEGIN in that stored procedure.\nThis COMMIT doesnotcommit the open transaction started in the first stored procedure. Instead, the\nimproperly paired COMMIT causes an error.\nThe enclosing stored procedure starts a scoped transaction, but doesnt explicitly complete it. Therefore\nthat scoped transaction causes an error at the end of that stored procedure, and the active transaction is\nimplicitly rolled back.\nThe second stored procedure contains a COMMIT, but there is no corresponding BEGIN in that stored procedure.\nThis COMMIT doesnotcommit the open transaction started in the first stored procedure. Instead, the\nimproperly paired COMMIT causes an error.\nThe next example shows three scoped transactions that overlap in time. In this example,\nstored procedurep1()calls another stored procedurep2()from inside a transaction, andp2()contains its own transaction, so the transaction started inp2()also runs independently.\n(This example uses pseudo-code.)\nIn these three scoped transactions:\nThe transaction that is outside any stored procedure contains statementsAandE. The transaction in stored procedurep1()contains statementsBandD The transaction inp2()contains statementC.\nThe transaction that is outside any stored procedure contains statementsAandE.\nThe transaction in stored procedurep1()contains statementsBandD\nThe transaction inp2()contains statementC.\nThe rules for scoped transactions also apply to recursive stored procedure calls. A recursive call is just a specific\ntype of nested call, and follows the same transaction rules as a nested call.\nCaution\nOverlapping scoped transactions can cause adeadlockif they manipulate the\nsame database object (such as a table). Scoped transactions should be used only when necessary.\nWhen AUTOCOMMIT is disabled, be especially careful with combining implicit transactions and stored procedures. If you\naccidentally leave a transaction active at the end of a stored procedure, the transaction is rolled back.\nFor example, the following pseudo-code example causes an implicit ROLLBACK at the end of the stored procedure:\nIn this example, the command to set AUTOCOMMIT commits any active transaction. A new transaction is not started\nimmediately. The stored procedure contains a DML statement, which implicitly begins a new transaction. That\nimplicit BEGIN TRANSACTION does not have a matching COMMIT or ROLLBACK in the stored procedure. Because there is an\nactive transaction at the end of the stored procedure, that active transaction is implicitly rolled back.\nIf you want to run the entire stored procedure in a single transaction, start the transaction before you call\nthe stored procedure, and commit the transaction after the call:\nIn this case, the BEGIN and COMMIT are properly paired, and the code executes without error.\nAs an alternative, put both the BEGIN TRANSACTION and the COMMIT inside the stored procedure, as shown in the\nfollowing pseudo-code example:\nIf you do not pair your BEGIN/COMMIT blocks properly in a scoped transaction, Snowflake reports an error. That error can have further\nimpacts, such as preventing a stored procedure from being completed or preventing an enclosing transaction from being committed. For\nexample, in the following pseudo-code example, some statements in the enclosing stored procedure, as well as the enclosed stored\nprocedure, are rolled back:\nIn this example, the only value that is inserted isosp1_alpha. None of the other values are inserted because a COMMIT is not correctly\npaired with a BEGIN. The error is handled as follows:\nWhen procedureinner_sp2()finishes, Snowflake detects that the BEGIN ininner_sp2()has no corresponding COMMIT (or ROLLBACK).Snowflake implicitly rolls back the scoped transaction that started ininner_sp2().Snowflake also returns an error because the CALL toinner_sp2()failed. Snowflake implicitly rolls back the scoped transaction that started ininner_sp2(). Snowflake also returns an error because the CALL toinner_sp2()failed. Because the CALL toinner_sp2()failed, and because that CALL statement was inouter_sp1(), the stored procedureouter_sp1()itself also fails and returns an error, rather than continuing. Becauseouter_sp1()does not finish executing:The INSERT statements for valuesosp1_deltaandosp1_omeganever execute.The open transaction inouter_sp1()is implicitly rolled back rather than committed, so the insert of valueosp1_betais never\ncommitted. The INSERT statements for valuesosp1_deltaandosp1_omeganever execute. The open transaction inouter_sp1()is implicitly rolled back rather than committed, so the insert of valueosp1_betais never\ncommitted.\nWhen procedureinner_sp2()finishes, Snowflake detects that the BEGIN ininner_sp2()has no corresponding COMMIT (or ROLLBACK).\nSnowflake implicitly rolls back the scoped transaction that started ininner_sp2(). Snowflake also returns an error because the CALL toinner_sp2()failed.\nSnowflake implicitly rolls back the scoped transaction that started ininner_sp2().\nSnowflake also returns an error because the CALL toinner_sp2()failed.\nBecause the CALL toinner_sp2()failed, and because that CALL statement was inouter_sp1(), the stored procedureouter_sp1()itself also fails and returns an error, rather than continuing.\nBecauseouter_sp1()does not finish executing:\nThe INSERT statements for valuesosp1_deltaandosp1_omeganever execute. The open transaction inouter_sp1()is implicitly rolled back rather than committed, so the insert of valueosp1_betais never\ncommitted.\nThe INSERT statements for valuesosp1_deltaandosp1_omeganever execute.\nThe open transaction inouter_sp1()is implicitly rolled back rather than committed, so the insert of valueosp1_betais never\ncommitted.",
      "syntax": [
        "CREATE PROCEDURE p2()\n...\n$$\n  BEGIN TRANSACTION;\n  statement C;\n  COMMIT;\n$$;\n\nCREATE PROCEDURE p1()\n...\n$$\n  BEGIN TRANSACTION;\n  statement B;\n  CALL p2();\n  statement D;\n  COMMIT;\n$$;\n\nBEGIN TRANSACTION;\nstatement A;\nCALL p1();\nstatement E;\nCOMMIT;",
        "CREATE PROCEDURE p1() ...\n$$\n  INSERT INTO parent_table ...;\n  INSERT INTO child_table ...;\n$$;\n\nALTER SESSION SET AUTOCOMMIT = FALSE;\nCALL p1;\nCOMMIT WORK;",
        "CREATE PROCEDURE p1() ...\n$$\n  INSERT INTO parent_table ...;\n  INSERT INTO child_table ...;\n$$;\n\nALTER SESSION SET AUTOCOMMIT = FALSE;\nBEGIN TRANSACTION;\nCALL p1;\nCOMMIT WORK;",
        "CREATE PROCEDURE p1() ...\n$$\n  BEGIN TRANSACTION;\n  INSERT INTO parent_table ...;\n  INSERT INTO child_table ...;\n  COMMIT WORK;\n$$;\n\nALTER SESSION SET AUTOCOMMIT = FALSE;\nCALL p1;",
        "CREATE OR REPLACE PROCEDURE outer_sp1()\n...\nAS\n$$\n  INSERT 'osp1_alpha';\n  BEGIN WORK;\n  INSERT 'osp1_beta';\n  CALL inner_sp2();\n  INSERT 'osp1_delta';\n  COMMIT WORK;\n  INSERT 'osp1_omega';\n$$;\n\nCREATE OR REPLACE PROCEDURE inner_sp2()\n...\nAS\n$$\n  BEGIN WORK;\n  INSERT 'isp2';\n  -- Missing COMMIT, so implicitly rolls back!\n$$;\n\nCALL outer_sp1();\n\nSELECT * FROM st;"
      ]
    },
    {
      "heading": "Apache Iceberg tables and transactions",
      "description": "\nThe Snowflake transaction principles generally apply to Apache Iceberg tables. For more information\nabout transactions specific to Iceberg tables, see theIceberg topic on transactions."
    },
    {
      "heading": "READ COMMITTED isolation level",
      "description": "\nREAD COMMITTED is the only isolation level currently supported for tables. With READ COMMITTED isolation, a statement sees only data that was\ncommitted before the statement began. It never sees uncommitted data.\nWhen a statement is executed inside a multi-statement transaction:\nA statement sees only data that was committed before thestatementbegan.Two successive statements in the same transaction can see different data if another transaction is committed\nbetween the execution of the first and the second statements. A statementdoessee the changes made by previous statements executedwithinthe same transaction,\neven though those changes are not yet committed.\nA statement sees only data that was committed before thestatementbegan.Two successive statements in the same transaction can see different data if another transaction is committed\nbetween the execution of the first and the second statements.\nA statementdoessee the changes made by previous statements executedwithinthe same transaction,\neven though those changes are not yet committed."
    },
    {
      "heading": "Resource locking",
      "description": "\nTransactional operations acquire locks on a resource, such as a table, while that resource is being modified. Locks\nblock other statements from modifying the resource until the lock is released.\nThe following guidelines apply in most situations:\nCOMMIT operations (including both AUTOCOMMIT and explicit COMMIT) lock resources, but usually only briefly. CREATE TABLE, CREATE DYNAMIC TABLE, CREATE STREAM, and ALTER TABLE operations all lock their underlying resources when setting CHANGE_TRACKING = TRUE, but usually only briefly.\nOnly UPDATE and DELETE DML operations are blocked when a table is locked. INSERT operations arenotblocked. UPDATE, DELETE, and MERGE statements hold locks that generally prevent them from running in parallel with other UPDATE, DELETE, and MERGE statements.Forhybrid tables, locks are held on individual rows. Locks on UPDATE, DELETE, and MERGE statements only prevent parallel\nUPDATE, DELETE, and MERGE statements that operate on the same row or rows. UPDATE, DELETE, and MERGE on different rows in the same table can progress. Most INSERT and COPY statements write only new partitions. Those statements often can run in parallel with other\nINSERT and COPY operations, and sometimes can run in parallel with an UPDATE, DELETE, or MERGE statement.Avoid executing INSERT and COPY statements concurrently with DDL statements on the same object in different sessions, because doing so can result in\ninconsistencies. When INSERT or COPY statements are executed on an object in anexplicit transaction,\navoid DDL statements on the same object in different sessions for the duration of the transaction. For example, don’t run INSERT statements on a table\nin one session while simultaneously running a DDL statement that changes the data type of a column in the table in a different session.\nCOMMIT operations (including both AUTOCOMMIT and explicit COMMIT) lock resources, but usually only briefly.\nCREATE TABLE, CREATE DYNAMIC TABLE, CREATE STREAM, and ALTER TABLE operations all lock their underlying resources when setting CHANGE_TRACKING = TRUE, but usually only briefly.\nOnly UPDATE and DELETE DML operations are blocked when a table is locked. INSERT operations arenotblocked.\nUPDATE, DELETE, and MERGE statements hold locks that generally prevent them from running in parallel with other UPDATE, DELETE, and MERGE statements.\nForhybrid tables, locks are held on individual rows. Locks on UPDATE, DELETE, and MERGE statements only prevent parallel\nUPDATE, DELETE, and MERGE statements that operate on the same row or rows. UPDATE, DELETE, and MERGE on different rows in the same table can progress.\nMost INSERT and COPY statements write only new partitions. Those statements often can run in parallel with other\nINSERT and COPY operations, and sometimes can run in parallel with an UPDATE, DELETE, or MERGE statement.\nAvoid executing INSERT and COPY statements concurrently with DDL statements on the same object in different sessions, because doing so can result in\ninconsistencies. When INSERT or COPY statements are executed on an object in anexplicit transaction,\navoid DDL statements on the same object in different sessions for the duration of the transaction. For example, dont run INSERT statements on a table\nin one session while simultaneously running a DDL statement that changes the data type of a column in the table in a different session.\nLocks held by a statement are released onCOMMITorROLLBACKof the transaction."
    },
    {
      "heading": "Lock timeout parameters",
      "description": "\nTwo parameters control timeout for locks:LOCK_TIMEOUTandHYBRID_TABLE_LOCK_TIMEOUT.\nA blocked statement either acquires a lock on the resource it is waiting for or times out, while waiting for the resource to become available. You can set the\nlength of time (in seconds) that a statement should block by setting the LOCK_TIMEOUT parameter.\nFor example, to change the lock timeout to 2 hours (7200 seconds) for the current session:\nA blocked statement on a hybrid table either acquires a row-level lock on the table it is waiting for or times out, while waiting for the table to become available.\nYou can set the length of time (in seconds) that a statement should block by setting the HYBRID_TABLE_LOCK_TIMEOUT parameter.\nFor example, to change the hybrid table lock timeout to 10 minutes (600 seconds) for the current session:",
      "syntax": [
        "ALTER SESSION SET LOCK_TIMEOUT=7200;\nSHOW PARAMETERS LIKE 'lock_timeout';",
        "+--------------+-------+---------+---------+-------------------------------------------------------------------------------+--------+\n| key          | value | default | level   | description                                                                   | type   |\n|--------------+-------+---------+---------+-------------------------------------------------------------------------------+--------|\n| LOCK_TIMEOUT | 7200  | 43200   | SESSION | Number of seconds to wait while trying to lock a resource, before timing out  | NUMBER |\n|              |       |         |         | and aborting the statement. A value of 0 turns off lock waiting i.e. the      |        |\n|              |       |         |         | statement must acquire the lock immediately or abort. If multiple resources   |        |\n|              |       |         |         | need to be locked by the statement, the timeout applies separately to each    |        |\n|              |       |         |         | lock attempt.                                                                 |        |\n+--------------+-------+---------+---------+-------------------------------------------------------------------------------+--------+",
        "ALTER SESSION SET HYBRID_TABLE_LOCK_TIMEOUT=600;\nSHOW PARAMETERS LIKE 'hybrid_table_lock_timeout';",
        "+---------------------------+-------+---------+---------+--------------------------------------------------------------------------------+--------|\n| key                       | value | default | level   | description                                                                    | type   |\n|---------------------------+-------+---------+---------+--------------------------------------------------------------------------------+--------+\n| HYBRID_TABLE_LOCK_TIMEOUT | 600   | 3600    | SESSION | Number of seconds to wait while trying to acquire locks, before timing out and | NUMBER |\n|                           |       |         |         | aborting the statement. A value of 0 turns off lock waiting i.e. the statement |        |\n|                           |       |         |         | must acquire the lock immediately or abort.                                    |        |\n+---------------------------+-------+---------+---------+--------------------------------------------------------------------------------+--------+"
      ]
    },
    {
      "heading": "Deadlocks",
      "description": "\nDeadlocks may occur when concurrent transactions are waiting on resources that are locked by each other.\nNote the following rules:\nDeadlocks cannot occur while autocommit query statements are being executed concurrently. This is true for both standard tables and hybrid tables because\nSELECT statements are always read-only. Deadlocks cannot occur with autocommit DML operations on standard tables, but they can occur with autocommit DML operations on hybrid tables. Deadlocks can occur when transactions are started explicitly and multiple statements are executed in each transaction. Snowflake detects deadlocks and\nchooses the most recent statement that is part of the deadlock as the victim. The statement is rolled back, but the transaction itself remains active\nand must be committed or rolled back.\nDeadlocks cannot occur while autocommit query statements are being executed concurrently. This is true for both standard tables and hybrid tables because\nSELECT statements are always read-only.\nDeadlocks cannot occur with autocommit DML operations on standard tables, but they can occur with autocommit DML operations on hybrid tables.\nDeadlocks can occur when transactions are started explicitly and multiple statements are executed in each transaction. Snowflake detects deadlocks and\nchooses the most recent statement that is part of the deadlock as the victim. The statement is rolled back, but the transaction itself remains active\nand must be committed or rolled back.\nDeadlock detection can take time."
    },
    {
      "heading": "Managing transactions and locks",
      "description": "\nSnowflake provides the following SQL commands to help you monitor and manage transactions and locks:\nDESCRIBE TRANSACTION ROLLBACK SHOW LOCKS SHOW TRANSACTIONS\nDESCRIBE TRANSACTION\nROLLBACK\nSHOW LOCKS\nSHOW TRANSACTIONS\nTheLOCK_WAIT_HISTORY viewlogs a detailed history of transactions with respect\nto locking, showing when specific locks were requested and acquired.\nIn addition, Snowflake provides the following context functions for obtaining information about transactions within a session:\nCURRENT_STATEMENT CURRENT_TRANSACTION LAST_QUERY_ID LAST_TRANSACTION\nCURRENT_STATEMENT\nCURRENT_TRANSACTION\nLAST_QUERY_ID\nLAST_TRANSACTION\nYou can call the following function to abort a transaction:SYSTEM$ABORT_TRANSACTION."
    },
    {
      "heading": "Aborting transactions",
      "description": "\nIf a transaction is running in a session and the session disconnects abruptly, preventing the transaction from committing or rolling back, the transaction is left in a\ndetached state, including any locks that the transaction is holding on resources. If this happens, you might need to abort the transaction.\nTo abort a running transaction, the user who started the transaction or an account administrator can call the system function,SYSTEM$ABORT_TRANSACTION.\nIf the transaction is not aborted by the user:\nAnd it blocks another transaction from acquiring a lock on the same tableandis idle for 5 minutes, it is automatically aborted and rolled back. And it doesnotblock other transactions from modifying the same table and is older than 4 hours, it is automatically aborted and rolled back. And it reads from or writes to hybrid tables, and is idle for 5 minutes, it is automatically aborted and rolled back, regardless of whether it blocks\nother transactions from modifying the same table.\nAnd it blocks another transaction from acquiring a lock on the same tableandis idle for 5 minutes, it is automatically aborted and rolled back.\nAnd it doesnotblock other transactions from modifying the same table and is older than 4 hours, it is automatically aborted and rolled back.\nAnd it reads from or writes to hybrid tables, and is idle for 5 minutes, it is automatically aborted and rolled back, regardless of whether it blocks\nother transactions from modifying the same table.\nTo allow a statement error within a transaction to abort the transaction, set theTRANSACTION_ABORT_ON_ERRORparameter at the session or account level."
    },
    {
      "heading": "Analyzing blocked transactions with the LOCK_WAIT_HISTORY view",
      "description": "\nTheLOCK_WAIT_HISTORY viewreturns transaction details that can be useful in analyzing blocked transactions.\nEach row in the output includes the details for a transaction that is waiting on a lock and the details of transactions that are holding\nthat lock or waiting ahead for that lock.\nFor example, see the scenario below:\nIn this scenario, the following data is returned:\nTransaction B is the transaction that is waiting for a lock. Transaction B requested the lock at timestamp T1. Transaction A is the transaction that holds the lock. Query 2 in Transaction A is the blocker query.\nTransaction B is the transaction that is waiting for a lock.\nTransaction B requested the lock at timestamp T1.\nTransaction A is the transaction that holds the lock.\nQuery 2 in Transaction A is the blocker query.\nQuery 2 is the blocker query because it is the first statement in Transaction A (the transaction holding the lock) that\nTransaction B (the transaction waiting for the lock) started waiting on.\nHowever, note that a later query in Transaction A (Query 5) also acquired the lock. It is possible that subsequent concurrent executions of these\ntransactions could cause Transaction B to block on a different query that acquires the lock in Transaction A. Therefore, you must investigate all queries in\nthe first blocker transaction.\nSee alsoTransaction and lock visibility for hybrid tables.\nQuery the Account UsageQUERY_HISTORY viewfor transactions that waited for locks in the last 24 hours:SELECTquery_id,query_text,start_time,session_id,execution_status,total_elapsed_time,compilation_time,execution_time,transaction_blocked_timeFROMsnowflake.account_usage.query_historyWHEREstart_time>=dateadd('hours',-24,current_timestamp())ANDtransaction_blocked_time>0ORDERBYtransaction_blocked_timeDESC;CopyReview the results of the query and note the query IDs of the queries with high TRANSACTION_BLOCKED_TIME values. To find blocker transactions for the queries identified from the previous step, query the LOCK_WAIT_HISTORY view for rows with\nthose query IDs:SELECTobject_name,lock_type,transaction_id,blocker_queriesFROMsnowflake.account_usage.lock_wait_historyWHEREquery_id='<query_id>';CopyThere may be multiple queries in theblocker_queriescolumn in the results. Note thetransaction_idof each blocker query\nin the output. Query the QUERY_HISTORY view for each transaction in theblocker_queriesoutput:SELECTquery_id,query_text,start_time,session_id,execution_status,total_elapsed_time,compilation_time,execution_timeFROMsnowflake.account_usage.query_historyWHEREtransaction_id='<transaction_id>';CopyInvestigate the query results. If a statement in the transaction was a DML statement and operated on the locked resource, it may\nhave acquired the lock at some point during the transaction.\nQuery the Account UsageQUERY_HISTORY viewfor transactions that waited for locks in the last 24 hours:\nReview the results of the query and note the query IDs of the queries with high TRANSACTION_BLOCKED_TIME values.\nTo find blocker transactions for the queries identified from the previous step, query the LOCK_WAIT_HISTORY view for rows with\nthose query IDs:\nThere may be multiple queries in theblocker_queriescolumn in the results. Note thetransaction_idof each blocker query\nin the output.\nQuery the QUERY_HISTORY view for each transaction in theblocker_queriesoutput:\nInvestigate the query results. If a statement in the transaction was a DML statement and operated on the locked resource, it may\nhave acquired the lock at some point during the transaction.",
      "syntax": [
        "SELECT query_id, query_text, start_time, session_id, execution_status, total_elapsed_time,\n       compilation_time, execution_time, transaction_blocked_time\n  FROM snowflake.account_usage.query_history\n  WHERE start_time >= dateadd('hours', -24, current_timestamp())\n  AND transaction_blocked_time > 0\n  ORDER BY transaction_blocked_time DESC;",
        "SELECT object_name, lock_type, transaction_id, blocker_queries\n  FROM snowflake.account_usage.lock_wait_history\n  WHERE query_id = '<query_id>';",
        "SELECT query_id, query_text, start_time, session_id, execution_status, total_elapsed_time, compilation_time, execution_time\n  FROM snowflake.account_usage.query_history\n  WHERE transaction_id = '<transaction_id>';"
      ]
    },
    {
      "heading": "Monitoring transactions and locks",
      "description": "\nYou can use theSHOW TRANSACTIONScommand to return a list of transactions being run by the current user (in all of that users sessions) or by all users in all sessions in the account. The following example is for the current users sessions.\nEvery Snowflake transaction is assigned a unique transaction ID. Theidvalue is a signed 64-bit (long) integer. The range of\nvalues is -9,223,372,036,854,775,808 (-263) to 9,223,372,036,854,775,807 (263- 1).\nYou can also use theCURRENT_TRANSACTIONfunction to return the transaction ID of the transaction currently running in the session.\nIf you know the transaction ID you want to monitor, you can use theDESCRIBE TRANSACTIONcommand to return details about the transaction,\nwhile it is still running or after it has committed or aborted. For example:",
      "syntax": [
        "SHOW TRANSACTIONS;",
        "+---------------------+---------+-----------------+--------------------------------------+-------------------------------+---------+-------+\n|                  id | user    |         session | name                                 | started_on                    | state   | scope |\n|---------------------+---------+-----------------+--------------------------------------+-------------------------------+---------+-------|\n| 1721165674582000000 | CALIBAN | 186457423713330 | 551f494d-90ed-438d-b32b-1161396c3a22 | 2024-07-16 14:34:34.582 -0700 | running |     0 |\n| 1721165584820000000 | CALIBAN | 186457423749354 | a092aa44-9a0a-4955-9659-123b35c0efeb | 2024-07-16 14:33:04.820 -0700 | running |     0 |\n+---------------------+---------+-----------------+--------------------------------------+-------------------------------+---------+-------+",
        "SELECT CURRENT_TRANSACTION();",
        "+-----------------------+\n| CURRENT_TRANSACTION() |\n|-----------------------|\n| 1721161383427000000   |\n+-----------------------+",
        "DESCRIBE TRANSACTION 1721161383427000000;",
        "+---------------------+---------+----------------+--------------------------------------+-------------------------------+-----------+-------------------------------+\n|                  id | user    |        session | name                                 | started_on                    | state     | ended_on                      |\n|---------------------+---------+----------------+--------------------------------------+-------------------------------+-----------+-------------------------------|\n| 1721161383427000000 | CALIBAN | 10363774361222 | 7db0ec5c-2e5d-47be-ac37-66cbf905668b | 2024-07-16 13:23:03.427 -0700 | committed | 2024-07-16 13:24:14.402 -0700 |\n+---------------------+---------+----------------+--------------------------------------+-------------------------------+-----------+-------------------------------+"
      ]
    },
    {
      "heading": "Transaction and lock visibility for hybrid tables",
      "description": "\nWhen you are looking at the output of commands and views for transactions that access hybrid tables, or locks on hybrid table rows,\nnote the following behavior:\nTransactions are listed only if they are blocking other transactions, or if they are blocked. Keep in mind that transactions that access hybrid tables hold row-level locks (ROWtype). If two transactions access different rows in the same table, they do not\nblock each other. Transactions are listed only if a blocked transaction has been blocked for more than 5 seconds. When a transaction is no longer blocked, it might still appear in the output, but for no more than 15 seconds.\nTransactions are listed only if they are blocking other transactions, or if they are blocked.\nKeep in mind that transactions that access hybrid tables hold row-level locks (ROWtype). If two transactions access different rows in the same table, they do not\nblock each other.\nTransactions are listed only if a blocked transaction has been blocked for more than 5 seconds.\nWhen a transaction is no longer blocked, it might still appear in the output, but for no more than 15 seconds.\nSimilarly, in the SHOW LOCKS output, the following rules apply:\nA lock is listed only if one transaction holds the lock and the other transaction is blocked on that particular lock. In thetypecolumn, hybrid table locks showROW. Theresourcecolumn always shows the blocking transaction ID. (The blocked transaction is blocked by the transaction with this ID.) In many cases, queries against hybrid tables do not generate query IDs. SeeUsage notes.\nA lock is listed only if one transaction holds the lock and the other transaction is blocked on that particular lock.\nIn thetypecolumn, hybrid table locks showROW.\nTheresourcecolumn always shows the blocking transaction ID. (The blocked transaction is blocked by the transaction with this ID.)\nIn many cases, queries against hybrid tables do not generate query IDs. SeeUsage notes.\nFor example:\nIn theLOCK_WAIT_HISTORY view, the output behaves as follows:\nTherequested_atandacquired_atcolumns define when row-level locks were requested and acquired, subject to the general\nrules for reporting transaction activity with hybrid tables. Thelock_typeandobject_namecolumns both show the valueRow. Theschema_idandschema_namecolumns are always empty (0and NULL, respectively). Theobject_idcolumn always shows the blocking object’s ID. Theblocker_queriescolumn is a JSON array with exactly one element, which shows the blocking transaction. Even if multiple transactions are blocked on the same row, they are shown as multiple rows in the output.\nTherequested_atandacquired_atcolumns define when row-level locks were requested and acquired, subject to the general\nrules for reporting transaction activity with hybrid tables.\nThelock_typeandobject_namecolumns both show the valueRow.\nTheschema_idandschema_namecolumns are always empty (0and NULL, respectively).\nTheobject_idcolumn always shows the blocking objects ID.\nTheblocker_queriescolumn is a JSON array with exactly one element, which shows the blocking transaction.\nEven if multiple transactions are blocked on the same row, they are shown as multiple rows in the output.\nFor example:",
      "syntax": [
        "SHOW LOCKS;",
        "+---------------------+------+---------------------+-------------------------------+---------+-------------+--------------------------------------+\n| resource            | type |         transaction | transaction_started_on        | status  | acquired_on | query_id                             |\n|---------------------+------+---------------------+-------------------------------+---------+-------------+--------------------------------------|\n| 1721165584820000000 | ROW  | 1721165584820000000 | 2024-07-16 14:33:04.820 -0700 | HOLDING | NULL        |                                      |\n| 1721165584820000000 | ROW  | 1721165674582000000 | 2024-07-16 14:34:34.582 -0700 | WAITING | NULL        | 01b5b715-0002-852b-0000-a99500665352 |\n+---------------------+------+---------------------+-------------------------------+---------+-------------+--------------------------------------+",
        "SELECT query_id, object_name, transaction_id, blocker_queries\n  FROM SNOWFLAKE.ACCOUNT_USAGE.LOCK_WAIT_HISTORY\n  WHERE requested_at >= DATEADD('hours', -48, CURRENT_TIMESTAMP()) LIMIT 1;",
        "+--------------------------------------+-------------+---------------------+---------------------------------------------------------+\n| QUERY_ID                             | OBJECT_NAME |      TRANSACTION_ID | BLOCKER_QUERIES                                         |\n|--------------------------------------+-------------+---------------------+---------------------------------------------------------|\n| 01b5b715-0002-852b-0000-a99500665352 | Row         | 1721165674582000000 | [                                                       |\n|                                      |             |                     |   {                                                     |\n|                                      |             |                     |     \"is_snowflake\": false,                              |\n|                                      |             |                     |     \"query_id\": \"01b5b70d-0002-8513-0000-a9950065d43e\", |\n|                                      |             |                     |     \"transaction_id\": 1721165584820000000               |\n|                                      |             |                     |   }                                                     |\n|                                      |             |                     | ]                                                       |\n+--------------------------------------+-------------+---------------------+---------------------------------------------------------+"
      ]
    },
    {
      "heading": "Best practices",
      "description": "\nA transaction should contain statements that are related and should succeed or fail together, for example,\nwithdrawing money from one account and depositing that same money to another account. If a rollback occurs, either\nthe payer or the recipient ends up with the money; the money never “disappears” (withdrawn from one account but\nnever deposited to the other account).In general, one transaction should contain only related statements. Making a statement less granular means that\nwhen a transaction is rolled back, it might roll back useful work that didn’t actually need to be rolled back. Larger transactions can improve performance in some cases for standard tables, but not typically for hybrid tables.Although the preceding bullet point emphasized the importance of grouping only statements that truly need to be\ncommitted or rolled back as a group, larger transactions can sometimes be useful.\nIn Snowflake, as in most databases, managing transactions consumes resources. For example, inserting 10 rows in\none transaction is generally faster and cheaper than inserting one row each in 10 separate transactions.\nCombining multiple statements into a single transaction can improve performance. Overly large transactions can reduce parallelism or increase deadlocks. If you do decide to group unrelated\nstatements to improve performance (as described in the previous bullet point), keep in mind that a transaction\ncan acquirelockson resources, which can delay other queries or lead todeadlocks. For hybrid tables:AUTOCOMMIT DML statements in general run much faster than non-AUTOCOMMIT DML statements.Relatively small AUTOCOMMIT DML statements run much faster than non-AUTOCOMMIT DML statements.\nDML statements that run in under 5 seconds or access no more than 1 MB of data take advantage of a fast mode\nthat is not available to longer-running or larger DML statements. AUTOCOMMIT DML statements in general run much faster than non-AUTOCOMMIT DML statements. Relatively small AUTOCOMMIT DML statements run much faster than non-AUTOCOMMIT DML statements.\nDML statements that run in under 5 seconds or access no more than 1 MB of data take advantage of a fast mode\nthat is not available to longer-running or larger DML statements. Snowflake recommends keeping AUTOCOMMIT enabled and using explicit transactions as much as possible. Using\nexplicit transactions makes it easier for human readers to see where transactions begin and end. This, combined with\nAUTOCOMMIT, makes your code less likely to experience unintended rollbacks, for example at the end of a\nstored procedure. Avoid changing AUTOCOMMIT merely to start a new transaction implicitly. Instead, use BEGIN TRANSACTION\nto make it more obvious where a new transaction starts. Avoid executing more than one BEGIN TRANSACTION statement in a row. Extra BEGIN TRANSACTION statements make it harder to see where\na transaction actually begins, and make it harder to pair COMMIT/ROLLBACK commands with the corresponding BEGIN TRANSACTION.\nA transaction should contain statements that are related and should succeed or fail together, for example,\nwithdrawing money from one account and depositing that same money to another account. If a rollback occurs, either\nthe payer or the recipient ends up with the money; the money never disappears (withdrawn from one account but\nnever deposited to the other account).\nIn general, one transaction should contain only related statements. Making a statement less granular means that\nwhen a transaction is rolled back, it might roll back useful work that didnt actually need to be rolled back.\nLarger transactions can improve performance in some cases for standard tables, but not typically for hybrid tables.\nAlthough the preceding bullet point emphasized the importance of grouping only statements that truly need to be\ncommitted or rolled back as a group, larger transactions can sometimes be useful.\nIn Snowflake, as in most databases, managing transactions consumes resources. For example, inserting 10 rows in\none transaction is generally faster and cheaper than inserting one row each in 10 separate transactions.\nCombining multiple statements into a single transaction can improve performance.\nOverly large transactions can reduce parallelism or increase deadlocks. If you do decide to group unrelated\nstatements to improve performance (as described in the previous bullet point), keep in mind that a transaction\ncan acquirelockson resources, which can delay other queries or lead todeadlocks.\nFor hybrid tables:\nAUTOCOMMIT DML statements in general run much faster than non-AUTOCOMMIT DML statements. Relatively small AUTOCOMMIT DML statements run much faster than non-AUTOCOMMIT DML statements.\nDML statements that run in under 5 seconds or access no more than 1 MB of data take advantage of a fast mode\nthat is not available to longer-running or larger DML statements.\nAUTOCOMMIT DML statements in general run much faster than non-AUTOCOMMIT DML statements.\nRelatively small AUTOCOMMIT DML statements run much faster than non-AUTOCOMMIT DML statements.\nDML statements that run in under 5 seconds or access no more than 1 MB of data take advantage of a fast mode\nthat is not available to longer-running or larger DML statements.\nSnowflake recommends keeping AUTOCOMMIT enabled and using explicit transactions as much as possible. Using\nexplicit transactions makes it easier for human readers to see where transactions begin and end. This, combined with\nAUTOCOMMIT, makes your code less likely to experience unintended rollbacks, for example at the end of a\nstored procedure.\nAvoid changing AUTOCOMMIT merely to start a new transaction implicitly. Instead, use BEGIN TRANSACTION\nto make it more obvious where a new transaction starts.\nAvoid executing more than one BEGIN TRANSACTION statement in a row. Extra BEGIN TRANSACTION statements make it harder to see where\na transaction actually begins, and make it harder to pair COMMIT/ROLLBACK commands with the corresponding BEGIN TRANSACTION."
    },
    {
      "heading": "Examples"
    },
    {
      "heading": "Simple example of scoped transaction and stored procedure",
      "description": "\nThis is a simple example of scoped transactions. The stored procedure contains a transaction that inserts a\nrow with the value 12 and then rolls back. The outer transaction commits. The output shows that all rows\nin the scope of the outer transaction are kept, while the row in the scope of the inner transaction\nis not kept.\nNote that because only part of the stored procedure is inside its own transaction, values inserted by the INSERT statements that are\nin the stored procedure, but outside the stored procedures transaction, are kept.\nCreate two tables:\nCreate the stored procedure:\nCall the stored procedure:\nThe results should include 00, 11, 13, and 09. The row with ID = 12 should not be included. This row was in the scope\nof the enclosed transaction, which was rolled back. All other rows were in the scope of the outer transaction, and\nwere committed. Note in particular that the rows with IDs 11 and 13 were inside the stored procedure, but outside the\ninnermost transaction; they are in the scope of the enclosing transaction, and were committed with that.",
      "syntax": [
        "select id, name FROM tracker_1\nunion all\nselect id, name FROM tracker_2\norder by id;\n+----+-------------+\n| ID | NAME        |\n|----+-------------|\n|  0 | outer_alpha |\n|  9 | outer_zulu  |\n| 11 | p1_alpha    |\n| 13 | p1_charlie  |\n+----+-------------+"
      ],
      "examples": [
        "create table tracker_1 (id integer, name varchar);\ncreate table tracker_2 (id integer, name varchar);",
        "create procedure sp1()\nreturns varchar\nlanguage javascript\nAS\n$$\n    // This is part of the outer transaction that started before this\n    // stored procedure was called. This is committed or rolled back\n    // as part of that outer transaction.\n    snowflake.execute (\n        {sqlText: \"insert into tracker_1 values (11, 'p1_alpha')\"}\n        );\n\n    // This is an independent transaction. Anything inserted as part of this\n    // transaction is committed or rolled back based on this transaction.\n    snowflake.execute (\n        {sqlText: \"begin transaction\"}\n        );\n    snowflake.execute (\n        {sqlText: \"insert into tracker_2 values (12, 'p1_bravo')\"}\n        );\n    snowflake.execute (\n        {sqlText: \"rollback\"}\n        );\n\n    // This is part of the outer transaction started before this\n    // stored procedure was called. This is committed or rolled back\n    // as part of that outer transaction.\n    snowflake.execute (\n        {sqlText: \"insert into tracker_1 values (13, 'p1_charlie')\"}\n        );\n\n    // Dummy value.\n    return \"\";\n$$;",
        "begin transaction;\ninsert into tracker_1 values (00, 'outer_alpha');\ncall sp1();\ninsert into tracker_1 values (09, 'outer_zulu');\ncommit;"
      ]
    },
    {
      "heading": "Logging information independently of a transactions success",
      "description": "\nThis is a simple, practical example of how to use a scoped transaction. In this example, a transaction\nlogs certain information; that logged information is preserved whether the transaction itself succeeds or fails.\nThis technique can be used to track all attempted actions, whether or not each succeeded.\nCreate two tables:\nCreate the stored procedure:\nCall the stored procedure:\nThe data table is empty because the transaction was rolled back:\nHowever, the logging table is not empty; the insert into the logging table was done in a separate transaction from\nthe insert into data_table.",
      "syntax": [
        "create table data_table (id integer);\ncreate table log_table (message varchar);",
        "create procedure log_message(MESSAGE VARCHAR)\nreturns varchar\nlanguage javascript\nAS\n$$\n    // This is an independent transaction. Anything inserted as part of this\n    // transaction is committed or rolled back based on this transaction.\n    snowflake.execute (\n        {sqlText: \"begin transaction\"}\n        );\n    snowflake.execute (\n        {sqlText: \"insert into log_table values ('\" + MESSAGE + \"')\"}\n        );\n    snowflake.execute (\n        {sqlText: \"commit\"}\n        );\n\n    // Dummy value.\n    return \"\";\n$$;\n\ncreate procedure update_data()\nreturns varchar\nlanguage javascript\nAS\n$$\n    snowflake.execute (\n        {sqlText: \"begin transaction\"}\n        );\n    snowflake.execute (\n        {sqlText: \"insert into data_table (id) values (17)\"}\n        );\n    snowflake.execute (\n        {sqlText: \"call log_message('You should see this saved.')\"}\n        );\n    snowflake.execute (\n        {sqlText: \"rollback\"}\n        );\n\n    // Dummy value.\n    return \"\";\n$$;",
        "begin transaction;\ncall update_data();\nrollback;",
        "select * from data_table;\n+----+\n| ID |\n|----|\n+----+",
        "select * from log_table;\n+----------------------------+\n| MESSAGE                    |\n|----------------------------|\n| You should see this saved. |\n+----------------------------+"
      ]
    },
    {
      "heading": "Examples of scoped transactions and stored procedures",
      "description": "\nThe next few examples use the tables and stored procedures shown below. By passing appropriate parameters, the caller\ncan control where BEGIN TRANSACTION, COMMIT, and ROLLBACK statements are executed inside the stored procedures.\nCreate the tables:\nThis procedure is the enclosing stored procedure, and depending upon the parameters passed to it, can create an\nenclosing transaction.\nThis procedure is the inner stored procedure, and depending upon the parameters passed to it, can create an\nenclosed transaction.\nThis example contains 3 transactions. This example commits the middle level (the transaction enclosed by the\nouter-most transaction and enclosing the inner-most transaction). This rolls back the outer-most and\ninner-most transactions.\nThe result is that only the rows in the middle transaction (12, 21, and 23) are committed. The rows in the outer\ntransaction and the inner transaction are not committed.\nThis example contains 3 transactions. This example rolls back the middle level (the transaction enclosed by the\nouter-most transaction and enclosing the inner-most transaction). This commits the outer-most and inner-most\ntransactions.\nThe result is that all rows except the rows in the middle transaction (12, 21, and 23) are committed.",
      "syntax": [
        "-- Should return only 12, 21, 23.\nselect id, name from tracker_1\nunion all\nselect id, name from tracker_2\nunion all\nselect id, name from tracker_3\norder by id;\n+----+------------+\n| ID | NAME       |\n|----+------------|\n| 12 | p1_bravo   |\n| 21 | p2_alpha   |\n| 23 | p2_charlie |\n+----+------------+",
        "select id, name from tracker_1\nunion all\nselect id, name from tracker_2\nunion all\nselect id, name from tracker_3\norder by id;\n+----+---------------+\n| ID | NAME          |\n|----+---------------|\n|  0 | outer_alpha   |\n|  9 | outer_charlie |\n| 11 | p1_alpha      |\n| 13 | p1_charlie    |\n| 22 | p2_bravo      |\n+----+---------------+"
      ],
      "examples": [
        "create table tracker_1 (id integer, name varchar);\ncreate table tracker_2 (id integer, name varchar);\ncreate table tracker_3 (id integer, name varchar);",
        "create procedure sp1_outer(\n    USE_BEGIN varchar,\n    USE_INNER_BEGIN varchar,\n    USE_INNER_COMMIT_OR_ROLLBACK varchar,\n    USE_COMMIT_OR_ROLLBACK varchar\n    )\nreturns varchar\nlanguage javascript\nAS\n$$\n    // This should be part of the outer transaction started before this\n    // stored procedure was called. This should be committed or rolled back\n    // as part of that outer transaction.\n    snowflake.execute (\n        {sqlText: \"insert into tracker_1 values (11, 'p1_alpha')\"}\n        );\n\n    // This is an independent transaction. Anything inserted as part of this\n    // transaction is committed or rolled back based on this transaction.\n    if (USE_BEGIN != '')  {\n        snowflake.execute (\n            {sqlText: USE_BEGIN}\n            );\n        }\n    snowflake.execute (\n        {sqlText: \"insert into tracker_2 values (12, 'p1_bravo')\"}\n        );\n    // Call (and optionally begin/commit-or-rollback) an inner stored proc...\n    var command = \"call sp2_inner('\";\n    command = command.concat(USE_INNER_BEGIN);\n    command = command.concat(\"', '\");\n    command = command.concat(USE_INNER_COMMIT_OR_ROLLBACK);\n    command = command.concat( \"')\" );\n    snowflake.execute (\n        {sqlText: command}\n        );\n    if (USE_COMMIT_OR_ROLLBACK != '') {\n        snowflake.execute (\n            {sqlText: USE_COMMIT_OR_ROLLBACK}\n            );\n        }\n\n    // This is part of the outer transaction started before this\n    // stored procedure was called. This is committed or rolled back\n    // as part of that outer transaction.\n    snowflake.execute (\n        {sqlText: \"insert into tracker_1 values (13, 'p1_charlie')\"}\n        );\n\n    // Dummy value.\n    return \"\";\n$$;",
        "create procedure sp2_inner(\n    USE_BEGIN varchar,\n    USE_COMMIT_OR_ROLLBACK varchar)\nreturns varchar\nlanguage javascript\nAS\n$$\n    snowflake.execute (\n        {sqlText: \"insert into tracker_2 values (21, 'p2_alpha')\"}\n        );\n\n    if (USE_BEGIN != '')  {\n        snowflake.execute (\n            {sqlText: USE_BEGIN}\n            );\n        }\n    snowflake.execute (\n        {sqlText: \"insert into tracker_3 values (22, 'p2_bravo')\"}\n        );\n    if (USE_COMMIT_OR_ROLLBACK != '')  {\n        snowflake.execute (\n            {sqlText: USE_COMMIT_OR_ROLLBACK}\n            );\n        }\n\n    snowflake.execute (\n        {sqlText: \"insert into tracker_2 values (23, 'p2_charlie')\"}\n        );\n\n    // Dummy value.\n    return \"\";\n$$;",
        "begin transaction;\ninsert into tracker_1 values (00, 'outer_alpha');\ncall sp1_outer('begin transaction', 'begin transaction', 'rollback', 'commit');\ninsert into tracker_1 values (09, 'outer_charlie');\nrollback;",
        "begin transaction;\ninsert into tracker_1 values (00, 'outer_alpha');\ncall sp1_outer('begin transaction', 'begin transaction', 'commit', 'rollback');\ninsert into tracker_1 values (09, 'outer_charlie');\ncommit;"
      ]
    },
    {
      "heading": "Using error handling with transactions in stored procedures",
      "description": "\nThe following code shows simple error handling for a transaction in a stored procedure. If the parameter value fail\nis passed, the stored procedure tries to delete from two tables that exist and one table that doesnt exist, and the\nstored procedure catches the error and returns an error message. If the parameter value fail is not passed, the\nprocedure tries to delete from two tables that do exist, and succeeds.\nCreate the tables and stored procedure:\nCall the stored procedure and force an error:\nCall the stored procedure without forcing an error:\nOn this page\nIntroduction What is a transaction? Terminology Explicit transactions Implicit transactions Mixing implicit and explicit starts and ends of a transaction Failed statements within a transaction Transactions and multi-threading Stored procedures and transactions Non-overlapping transactions Scoped transactions Apache Iceberg™ tables and transactions READ COMMITTED isolation level Resource locking Lock timeout parameters Deadlocks Managing transactions and locks Aborting transactions Analyzing blocked transactions with the LOCK_WAIT_HISTORY view Monitoring transactions and locks Transaction and lock visibility for hybrid tables Best practices Examples Simple example of scoped transaction and stored procedure Logging information independently of a transaction’s success Examples of scoped transactions and stored procedures Using error handling with transactions in stored procedures\nRelated content\nData Manipulation Language (DML) commands\nWe use cookies to improve your experience on our site. By accepting, you agree to ourprivacy policy.\nEnglish Français Deutsch 日本語 한국어 Português\n",
      "syntax": [
        "begin transaction;\n\ncreate table parent(id integer);\ncreate table child (child_id integer, parent_ID integer);\n\n-- ----------------------------------------------------- --\n-- Wrap multiple related statements in a transaction,\n-- and use try/catch to commit or roll back.\n-- ----------------------------------------------------- --\n-- Create the procedure\ncreate or replace procedure cleanup(FORCE_FAILURE varchar)\n  returns varchar not null\n  language javascript\n  as\n  $$\n  var result = \"\";\n  snowflake.execute( {sqlText: \"begin transaction;\"} );\n  try {\n      snowflake.execute( {sqlText: \"delete from child where parent_id = 1;\"} );\n      snowflake.execute( {sqlText: \"delete from parent where id = 1;\"} );\n      if (FORCE_FAILURE === \"fail\")  {\n          // To see what happens if there is a failure/rollback,\n          snowflake.execute( {sqlText: \"delete from no_such_table;\"} );\n          }\n      snowflake.execute( {sqlText: \"commit;\"} );\n      result = \"Succeeded\";\n      }\n  catch (err)  {\n      snowflake.execute( {sqlText: \"rollback;\"} );\n      return \"Failed: \" + err;   // Return a success/error indicator.\n      }\n  return result;\n  $$\n  ;\n\ncommit;",
        "call cleanup('fail');\n+----------------------------------------------------------+\n| CLEANUP                                                  |\n|----------------------------------------------------------|\n| Failed: SQL compilation error:                           |\n| Object 'NO_SUCH_TABLE' does not exist or not authorized. |\n+----------------------------------------------------------+",
        "call cleanup('do not fail');\n+-----------+\n| CLEANUP   |\n|-----------|\n| Succeeded |\n+-----------+"
      ]
    }
  ]
}