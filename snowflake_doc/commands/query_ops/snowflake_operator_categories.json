[
  {
    "category": "Arithmetic operators",
    "url": "https://docs.snowflake.com/en/sql-reference/operators-arithmetic",
    "operators": [
      "+",
      "-",
      "*",
      "/",
      "%"
    ],
    "details": [
      {
        "heading": "Arithmetic operators",
        "description": "\nArithmetic operators are used to generate numeric output from one or more input expressions.\nThe input expressions must be numeric (fixed-point or floating point), except in the following cases:\nThe unary operator + can take a number string, but the string is implicitly converted to its corresponding numeric value.\nThe binary operator - can be applied to DATE expressions.\nThe unary operator + can take a number string, but the string is implicitly converted to its corresponding numeric value.\nThe binary operator - can be applied to DATE expressions."
      },
      {
        "heading": "List of arithmetic operators",
        "tables": [
          {
            "headers": [
              "Operator",
              "Syntax",
              "Description"
            ],
            "rows": [
              [
                "+ (unary)",
                "+a",
                "Returns a, which causes implicit conversion of a to a numeric value. If a is a string, but the string can’t be converted to a numeric value, an error is returned."
              ],
              [
                "+",
                "a + b",
                "Adds two numeric expressions (a and b)."
              ],
              [
                "- (unary)",
                "-a",
                "Negates the input numeric expression."
              ],
              [
                "-",
                "a - b",
                "Subtracts one numeric expression (b) from another (a)."
              ],
              [
                "-",
                "a - b",
                "Subtracts one date expression (b) from another (a). The result is an integer number of days. Subtraction is the only arithmetic operation allowed on DATE expressions."
              ],
              [
                "*",
                "a * b",
                "Multiplies two numeric expressions (a and b)."
              ],
              [
                "/",
                "a / b",
                "Divides one numeric expression (a) by another (b). For functions that return 0 when dividing by 0 or NULL, see DIV0 and DIV0NULL."
              ],
              [
                "%",
                "a % b",
                "Computes the modulo of numeric expression a per b. For more information, see MOD."
              ]
            ]
          }
        ]
      },
      {
        "heading": "Scale and precision in arithmetic operations",
        "description": "\nThe scale and precision of the output of an arithmetic operation depends on the scale and precision of the input.\nSnowflake uses calculations to preserve scale and precision in the numeric output generated by various arithmetic operations (multiplication,\ndivision, and so on). The following descriptions are used in this section:\nFor outputs, note that these are maximum number of digits; the actual number of digits for any given output might be less.",
        "definitions": [
          {
            "term": "Leading digits:",
            "definition": "Number of digits (L) to the left of the decimal point in a numeric value."
          },
          {
            "term": "Scale:",
            "definition": "Number of digits (S) to the right of the decimal point in a numeric value."
          },
          {
            "term": "Precision:",
            "definition": "Total number of digits (P) in a numeric value, calculated as the sum of its leading digits and scale (that is, P = L + S). Note that precision in Snowflake is always limited to 38. Also: Fixed-point data types (NUMBER, DECIMAL, and so on) utilize precision and scale. For example, for the DECIMAL(8,2) data type, precision is 8,\nscale is 2, and the number of leading digits is 6. Floating-point data types (FLOAT, DOUBLE, REAL, and so on) utilize 8-byte doubles."
          }
        ]
      },
      {
        "heading": "Multiplication",
        "description": "\nWhen performing multiplication:\nThe number of leading digits in the output is the sum of the leading digits in both inputs.\nSnowflake minimizes potential overflow (due to chained multiplication) by adding the number of digits in the scale of both inputs, up to a maximum threshold of 12 digits, unless either of the inputs has\na scale larger than 12, in which case the larger input scale is used as the output scale.\nThe number of leading digits in the output is the sum of the leading digits in both inputs.\nSnowflake minimizes potential overflow (due to chained multiplication) by adding the number of digits in the scale of both inputs, up to a maximum threshold of 12 digits, unless either of the inputs has\na scale larger than 12, in which case the larger input scale is used as the output scale.\nIn other words, assuming a multiplication operation with two inputs (L1.S1 and L2.S2), the maximum number of digits in the output are calculated as follows:\nNote\nSnowflake performs integer multiplication for numeric values, so intermediate results might cause some overflow; however, the final output wont overflow.",
        "syntax": [
          "SELECT 10.01 n1, 1.1 n2, n1 * n2;",
          "+-------+-----+---------+\n|    N1 |  N2 | N1 * N2 |\n|-------+-----+---------|\n| 10.01 | 1.1 |  11.011 |\n+-------+-----+---------+",
          "SELECT 10.001 n1, .001 n2, n1 * n2;",
          "+--------+-------+----------+\n|     I1 |    I2 |  I1 * I2 |\n|--------+-------+----------|\n| 10.001 | 0.001 | 0.010001 |\n+--------+-------+----------+",
          "SELECT .1 n1, .0000000000001 n2, n1 * n2;",
          "+-----+-----------------+-----------------+\n|  N1 |              N2 |         N1 * N2 |\n|-----+-----------------+-----------------|\n| 0.1 | 0.0000000000001 | 0.0000000000000 |\n+-----+-----------------+-----------------+"
        ],
        "definitions": [
          {
            "term": "Leading digits:",
            "definition": "L = L1 + L2"
          },
          {
            "term": "Scale:",
            "definition": "S = min(S1 + S2, max(S1, S2, 12))"
          },
          {
            "term": "Precision:",
            "definition": "P = L + S"
          }
        ]
      },
      {
        "heading": "Division",
        "description": "\nWhen performing division:\nThe number of leading digits in the output is the sum of the leading digits of the numerator and the scale of the denominator.\nSnowflake minimizes potential overflow in the output (due to chained division) and loss of scale by adding 6 digits to the scale of the numerator, up to a maximum threshold of 12 digits, unless the\nscale of the numerator is larger than 12, in which case the numerator scale is used as the output scale.\nThe number of leading digits in the output is the sum of the leading digits of the numerator and the scale of the denominator.\nSnowflake minimizes potential overflow in the output (due to chained division) and loss of scale by adding 6 digits to the scale of the numerator, up to a maximum threshold of 12 digits, unless the\nscale of the numerator is larger than 12, in which case the numerator scale is used as the output scale.\nIn other words, assuming a division operation with numerator L1.S1 and denominator L2.S2, the maximum number of digits in the output are calculated as follows:\nIf the result of the division operation exceeds the output scale, Snowflake rounds the output (rather than truncating the output).\nNote\nSimilar to multiplication, intermediate division results might cause some overflow; however, the final output wont overflow.",
        "syntax": [
          "SELECT 2 n1, 7 n2, n1 / n2;",
          "+----+----+----------+\n| N1 | N2 |  N1 / N2 |\n|----+----+----------|\n|  2 |  7 | 0.285714 |\n+----+----+----------+",
          "SELECT 10.1 n1, 2.1 n2, n1 / n2;",
          "+------+-----+-----------+\n|   N1 |  N2 |   N1 / N2 |\n|------+-----+-----------|\n| 10.1 | 2.1 | 4.8095238 |\n+------+-----+-----------+",
          "SELECT 10.001 n1, .001 n2, n1 / n2;",
          "+--------+-------+-----------------+\n|     N1 |    N2 |         N1 / N2 |\n|--------+-------+-----------------|\n| 10.001 | 0.001 | 10001.000000000 |\n+--------+-------+-----------------+",
          "SELECT .1 n1, .0000000000001 n2, n1 / n2;",
          "+-----+-----------------+-----------------------+\n|  N1 |              N2 |               N1 / N2 |\n|-----+-----------------+-----------------------|\n| 0.1 | 0.0000000000001 | 1000000000000.0000000 |\n+-----+-----------------+-----------------------+"
        ],
        "definitions": [
          {
            "term": "Leading digits:",
            "definition": "L = L1 + S2"
          },
          {
            "term": "Scale:",
            "definition": "S = max(S1, min(S1 + 6, 12))"
          },
          {
            "term": "Precision:",
            "definition": "P = L + S"
          }
        ]
      },
      {
        "heading": "Addition and subtraction",
        "description": "\nFor addition or subtraction:\nThe number of leading digits in the output is the largest number of leading digits of the inputs plus 1 (to preserve carried values).\nThe scale for the output is the largest scale of the inputs.\nThe number of leading digits in the output is the largest number of leading digits of the inputs plus 1 (to preserve carried values).\nThe scale for the output is the largest scale of the inputs.\nIn other words, assuming an addition or subtraction operation has two inputs (L1.S1 and L2.S2), the maximum number of digits in the output are calculated as follows:",
        "definitions": [
          {
            "term": "Leading digits:",
            "definition": "L = max(L1, L2) + 1"
          },
          {
            "term": "Scale:",
            "definition": "S = max(S1, S2)"
          },
          {
            "term": "Precision:",
            "definition": "P = L + S"
          }
        ]
      },
      {
        "heading": "Other N-ary operations",
        "description": "\nFor all other arithmetic operations with more than one numeric input, such as modulo (a % b or MOD):\nThe number of leading digits in the output is the largest number of leading digits of the inputs.\nThe scale for the output is the largest scale of the inputs.\nThe number of leading digits in the output is the largest number of leading digits of the inputs.\nThe scale for the output is the largest scale of the inputs.\nIn other words, assuming an n-ary operation with inputs L1.S1, L2.S2, etc., the maximum number of digits in the output are calculated as follows:",
        "definitions": [
          {
            "term": "Leading digits:",
            "definition": "L = max(L1, L2, ...)"
          },
          {
            "term": "Scale:",
            "definition": "S = max(S1, S2, ...)"
          },
          {
            "term": "Precision:",
            "definition": "P = L + S"
          }
        ]
      },
      {
        "heading": "Unary operations",
        "description": "\nUnary arithmetic operations have the same output precision and scale as the input precision and scale, except for ROUND, which allows explicitly specifying the output\nscale."
      },
      {
        "heading": "Bitwise operations",
        "description": "\nThe list of supported bitwise arithmetic operations is available at Conditional expression functions.\nNote\nFor numeric values, bitwise operations only operate on the leading digits in the input. The output always has a scale of zero.\nFor binary bitwise operations, the output has the same number of leading digits as the maximum leading digits in the input.\nFor numeric values, bitwise operations only operate on the leading digits in the input. The output always has a scale of zero.\nFor binary bitwise operations, the output has the same number of leading digits as the maximum leading digits in the input.\nOn this page\nList of arithmetic operators\nScale and precision in arithmetic operations\nRelated content\nNumeric data types\nNumeric functions\nConversion functions\nWe use cookies to improve your experience on our site. By accepting, you agree to our privacy policy.\nEnglish\nFranais\nDeutsch\n\n\nPortugus\n",
        "examples": [
          "SELECT 10.01 n1, 1.1 n2, n1 * n2;",
          "+-------+-----+---------+\n|    N1 |  N2 | N1 * N2 |\n|-------+-----+---------|\n| 10.01 | 1.1 |  11.011 |\n+-------+-----+---------+",
          "SELECT 10.001 n1, .001 n2, n1 * n2;",
          "+--------+-------+----------+\n|     I1 |    I2 |  I1 * I2 |\n|--------+-------+----------|\n| 10.001 | 0.001 | 0.010001 |\n+--------+-------+----------+",
          "SELECT .1 n1, .0000000000001 n2, n1 * n2;",
          "+-----+-----------------+-----------------+\n|  N1 |              N2 |         N1 * N2 |\n|-----+-----------------+-----------------|\n| 0.1 | 0.0000000000001 | 0.0000000000000 |\n+-----+-----------------+-----------------+",
          "SELECT 2 n1, 7 n2, n1 / n2;",
          "+----+----+----------+\n| N1 | N2 |  N1 / N2 |\n|----+----+----------|\n|  2 |  7 | 0.285714 |\n+----+----+----------+",
          "SELECT 10.1 n1, 2.1 n2, n1 / n2;",
          "+------+-----+-----------+\n|   N1 |  N2 |   N1 / N2 |\n|------+-----+-----------|\n| 10.1 | 2.1 | 4.8095238 |\n+------+-----+-----------+",
          "SELECT 10.001 n1, .001 n2, n1 / n2;",
          "+--------+-------+-----------------+\n|     N1 |    N2 |         N1 / N2 |\n|--------+-------+-----------------|\n| 10.001 | 0.001 | 10001.000000000 |\n+--------+-------+-----------------+",
          "SELECT .1 n1, .0000000000001 n2, n1 / n2;",
          "+-----+-----------------+-----------------------+\n|  N1 |              N2 |               N1 / N2 |\n|-----+-----------------+-----------------------|\n| 0.1 | 0.0000000000001 | 1000000000000.0000000 |\n+-----+-----------------+-----------------------+"
        ]
      }
    ]
  },
  {
    "category": "Comparison operators",
    "url": "https://docs.snowflake.com/en/sql-reference/operators-comparison",
    "operators": [
      "=",
      "!=",
      "<>",
      "<",
      "<=",
      ">",
      ">="
    ],
    "details": [
      {
        "heading": "Comparison operators",
        "tables": [
          {
            "headers": [
              "Operator",
              "Syntax",
              "Description"
            ],
            "rows": [
              [
                "=",
                "a = b",
                "a is equal to b."
              ],
              [
                "!=",
                "a != b",
                "a is not equal to b."
              ],
              [
                "<>",
                "a <> b",
                "a is not equal to b."
              ],
              [
                ">",
                "a > b",
                "a is greater than b."
              ],
              [
                ">=",
                "a >= b",
                "a is greater than or equal to b."
              ],
              [
                "<",
                "a < b",
                "a is less than b."
              ],
              [
                "<=",
                "a <= b",
                "a is less than or equal to b."
              ]
            ]
          }
        ]
      }
    ]
  },
  {
    "category": "Expansion operators",
    "url": "https://docs.snowflake.com/en/sql-reference/operators-expansion",
    "operators": [
      "**"
    ],
    "details": [
      {
        "heading": "Expansion operators",
        "description": "\nExpansion operators expand a query expression that represents a list into the individual values in\nthe list. Currently, the spread operator (**) is the only expansion operator supported by Snowflake."
      },
      {
        "heading": "Spread",
        "description": "\nThe spread operator expands an array into a list of individual values. This\noperator is useful for the following use cases:\nQueries containing IN clauses.\nCalls to system-defined functions that take a list of values as arguments, such as\nCOALESCE, GREATEST, and\nLEAST.\nSQL user-defined functions that use an argument\nto provide an array of values.\nSnowflake Scripting stored procedures\nthat use a bind variable to provide an array of values. For more information about using bind variables\nin Snowflake Scripting, see Using a variable in a SQL statement (binding) and\nUsing an argument in a SQL statement (binding).\nQueries containing IN clauses.\nCalls to system-defined functions that take a list of values as arguments, such as\nCOALESCE, GREATEST, and\nLEAST.\nSQL user-defined functions that use an argument\nto provide an array of values.\nSnowflake Scripting stored procedures\nthat use a bind variable to provide an array of values. For more information about using bind variables\nin Snowflake Scripting, see Using a variable in a SQL statement (binding) and\nUsing an argument in a SQL statement (binding).\nFor more information about these use cases, see the\nSnowflake Introduces SQL Spread Operator (**)\nblog post."
      },
      {
        "heading": "Syntax",
        "syntax": [
          "** <array>"
        ]
      },
      {
        "heading": "Limitations",
        "description": "\nThe input must be an array of constant values, which can be an array of literal values or a bind variable that represents\nan array of literal values.\nEach value in a semi-structured array is of type VARIANT. A VARIANT value can\ncontain a value of any other data type. The spread operator supports the following data types for the value\nstored in the VARIANT value:\n\nNumeric (for example, INTEGER and NUMERIC)\nString & binary (for example, VARCHAR and BINARY)\nLogical (for example, BOOLEAN)\nDate & time (for example, DATE, TIME, and TIMESTAMP)\nNumeric (for example, INTEGER and NUMERIC)\nString & binary (for example, VARCHAR and BINARY)\nLogical (for example, BOOLEAN)\nDate & time (for example, DATE, TIME, and TIMESTAMP)\nUser-defined functions and stored procedures written in languages other than SQL cant use the\nspread operator.\nExpanding very large arrays with the spread operator might degrade performance.\nThe input must be an array of constant values, which can be an array of literal values or a bind variable that represents\nan array of literal values.\nEach value in a semi-structured array is of type VARIANT. A VARIANT value can\ncontain a value of any other data type. The spread operator supports the following data types for the value\nstored in the VARIANT value:\nNumeric (for example, INTEGER and NUMERIC)\nString & binary (for example, VARCHAR and BINARY)\nLogical (for example, BOOLEAN)\nDate & time (for example, DATE, TIME, and TIMESTAMP)\nNumeric (for example, INTEGER and NUMERIC)\nString & binary (for example, VARCHAR and BINARY)\nLogical (for example, BOOLEAN)\nDate & time (for example, DATE, TIME, and TIMESTAMP)\nUser-defined functions and stored procedures written in languages other than SQL cant use the\nspread operator.\nExpanding very large arrays with the spread operator might degrade performance."
      },
      {
        "heading": "Examples",
        "description": "\nSome of the examples use the data the following table:\nCreate a table and insert data:\nThe following examples use the spread operator.\nExpand an array of literal values in an IN clause\nExpand an array of literal values in a system-defined function call\nUse the spread operator with a bind variable in a SQL user-defined function\nUse the spread operator with a bind variable in a Snowflake Scripting stored procedure\nExpand an array of literal values in an IN clause\nExpand an array of literal values in a system-defined function call\nUse the spread operator with a bind variable in a SQL user-defined function\nUse the spread operator with a bind variable in a Snowflake Scripting stored procedure\nExpand an array of numbers using the spread operator in a query on the spread_demo table\ncreated previously:\nExpand an array of strings using the spread operator:\nUse an IN clause in a query with a mix of INTEGER values and expanded array values:\nExpand an array of strings in a call to the COALESCE function:\nExpand an array of numbers in a call to the GREATEST function:\nCreate a SQL user-defined function that uses the spread operator. The function takes an array as\nan argument and then expands the array values to query the spread_demo table\ncreated previously:\nQuery the table using the function:\nCreate a Snowflake Scripting stored procedure that uses the spread operator. The stored procedure takes\nan array as an argument and then expands the array values in a bind variable to query the spread_demo\ntable created previously:\nCall the stored procedure:\nOn this page\nSpread\nSyntax\nLimitations\nExamples\nExpand an array of literal values in an IN clause\nExpand an array of literal values in a system-defined function call\nUse the spread operator with a bind variable in a SQL user-defined function\nUse the spread operator with a bind variable in a Snowflake Scripting stored procedure\nWe use cookies to improve your experience on our site. By accepting, you agree to our privacy policy.\nEnglish\nFranais\nDeutsch\n\n\nPortugus\n",
        "syntax": [
          "CREATE OR REPLACE TABLE spread_demo (col1 INT, col2 VARCHAR);\n\nINSERT INTO spread_demo VALUES\n  (1, 'a'),\n  (2, 'b'),\n  (3, 'c'),\n  (4, 'd'),\n  (5, 'e');\n\nSELECT * FROM spread_demo;",
          "+------+------+\n| COL1 | COL2 |\n|------+------|\n|    1 | a    |\n|    2 | b    |\n|    3 | c    |\n|    4 | d    |\n|    5 | e    |\n+------+------+",
          "SELECT * FROM spread_demo\n  WHERE col1 IN (** [3, 4])\n  ORDER BY col1;",
          "+------+------+\n| COL1 | COL2 |\n|------+------|\n|    3 | c    |\n|    4 | d    |\n+------+------+",
          "SELECT * FROM spread_demo\n  WHERE col2 IN (** ['b', 'd'])\n  ORDER BY col1;",
          "+------+------+\n| COL1 | COL2 |\n|------+------|\n|    2 | b    |\n|    4 | d    |\n+------+------+",
          "SELECT * FROM spread_demo\n  WHERE col1 IN (** [1, 2], 4, 5)\n  ORDER BY col1;",
          "+------+------+\n| COL1 | COL2 |\n|------+------|\n|    1 | a    |\n|    2 | b    |\n|    4 | d    |\n|    5 | e    |\n+------+------+",
          "SELECT COALESCE(** [NULL, NULL, 'my_string_1', 'my_string_2']) AS first_non_null;",
          "+----------------+\n| FIRST_NON_NULL |\n|----------------|\n| my_string_1    |\n+----------------+",
          "SELECT GREATEST(** [1, 2, 5, 4, 5]) AS greatest_value;",
          "+----------------+\n| GREATEST_VALUE |\n|----------------|\n|              5 |\n+----------------+",
          "CREATE OR REPLACE FUNCTION spread_function_demo(col_1_values ARRAY)\n  RETURNS TABLE(\n    col1 INT,\n    col2 VARCHAR)\nAS\n$$\n   SELECT * FROM spread_demo\n     WHERE col1 IN (** col_1_values)\n     ORDER BY col1\n$$;",
          "SELECT * FROM TABLE(spread_function_demo([1, 3, 5]));",
          "+------+------+\n| COL1 | COL2 |\n|------+------|\n|    1 | a    |\n|    3 | c    |\n|    5 | e    |\n+------+------+",
          "CREATE OR REPLACE PROCEDURE spread_sp_demo(col_1_values ARRAY)\n  RETURNS TABLE(\n    col1 INT,\n    col2 VARCHAR)\n  LANGUAGE SQL\nAS\n$$\nDECLARE\n  res RESULTSET;\nBEGIN\n  res := (SELECT * FROM spread_demo\n     WHERE col1 IN (** :col_1_values)\n     ORDER BY col1);\n  RETURN TABLE(res);\nEND;\n$$;",
          "CALL spread_sp_demo([2, 4]);",
          "+------+------+\n| COL1 | COL2 |\n|------+------|\n|    2 | b    |\n|    4 | d    |\n+------+------+"
        ],
        "examples": [
          "CREATE OR REPLACE TABLE spread_demo (col1 INT, col2 VARCHAR);\n\nINSERT INTO spread_demo VALUES\n  (1, 'a'),\n  (2, 'b'),\n  (3, 'c'),\n  (4, 'd'),\n  (5, 'e');\n\nSELECT * FROM spread_demo;",
          "+------+------+\n| COL1 | COL2 |\n|------+------|\n|    1 | a    |\n|    2 | b    |\n|    3 | c    |\n|    4 | d    |\n|    5 | e    |\n+------+------+",
          "SELECT * FROM spread_demo\n  WHERE col1 IN (** [3, 4])\n  ORDER BY col1;",
          "+------+------+\n| COL1 | COL2 |\n|------+------|\n|    3 | c    |\n|    4 | d    |\n+------+------+",
          "SELECT * FROM spread_demo\n  WHERE col2 IN (** ['b', 'd'])\n  ORDER BY col1;",
          "+------+------+\n| COL1 | COL2 |\n|------+------|\n|    2 | b    |\n|    4 | d    |\n+------+------+",
          "SELECT * FROM spread_demo\n  WHERE col1 IN (** [1, 2], 4, 5)\n  ORDER BY col1;",
          "+------+------+\n| COL1 | COL2 |\n|------+------|\n|    1 | a    |\n|    2 | b    |\n|    4 | d    |\n|    5 | e    |\n+------+------+",
          "SELECT COALESCE(** [NULL, NULL, 'my_string_1', 'my_string_2']) AS first_non_null;",
          "+----------------+\n| FIRST_NON_NULL |\n|----------------|\n| my_string_1    |\n+----------------+",
          "SELECT GREATEST(** [1, 2, 5, 4, 5]) AS greatest_value;",
          "+----------------+\n| GREATEST_VALUE |\n|----------------|\n|              5 |\n+----------------+",
          "CREATE OR REPLACE FUNCTION spread_function_demo(col_1_values ARRAY)\n  RETURNS TABLE(\n    col1 INT,\n    col2 VARCHAR)\nAS\n$$\n   SELECT * FROM spread_demo\n     WHERE col1 IN (** col_1_values)\n     ORDER BY col1\n$$;",
          "SELECT * FROM TABLE(spread_function_demo([1, 3, 5]));",
          "+------+------+\n| COL1 | COL2 |\n|------+------|\n|    1 | a    |\n|    3 | c    |\n|    5 | e    |\n+------+------+",
          "CREATE OR REPLACE PROCEDURE spread_sp_demo(col_1_values ARRAY)\n  RETURNS TABLE(\n    col1 INT,\n    col2 VARCHAR)\n  LANGUAGE SQL\nAS\n$$\nDECLARE\n  res RESULTSET;\nBEGIN\n  res := (SELECT * FROM spread_demo\n     WHERE col1 IN (** :col_1_values)\n     ORDER BY col1);\n  RETURN TABLE(res);\nEND;\n$$;",
          "CALL spread_sp_demo([2, 4]);",
          "+------+------+\n| COL1 | COL2 |\n|------+------|\n|    2 | b    |\n|    4 | d    |\n+------+------+"
        ]
      }
    ]
  },
  {
    "category": "Flow operators",
    "url": "https://docs.snowflake.com/en/sql-reference/operators-flow",
    "operators": [
      "->>"
    ],
    "details": [
      {
        "heading": "Flow operators",
        "description": "\nFlow operators chain SQL statements together, where the results of one statement serve as the input to another statement.\nCurrently, the pipe operator (->>) is the only flow operator supported by Snowflake."
      },
      {
        "heading": "Pipe",
        "description": "\nPipe operators are similar to Unix pipes (|) on the command line, but for SQL statements instead of Unix\ncommands. To use the pipe operator, specify a series of SQL statements separated by the operator. You can specify any\nvalid SQL statement, such as SHOW, SELECT, CREATE, INSERT, and so on. After the first SQL statement, each\nsubsequent statement can take the results of any previous statement as input. In the FROM clause, a previous SQL\nstatement is referenced by a parameter with the dollar sign ($) and the pipe number, which is the relative\nposition of the statement in the chain counting back from the current statement.\nThe pipe operator chains the following series of SQL statements together, and the comments show the relative\nreference numbers for each statement:\nFor example, this series of SQL statements has a pipe number reference in three SELECT statements, and each one takes\nthe results of the first SELECT statement as input:\nAs shown, you end the chain of SQL statements by placing a semicolon after the last statement. Dont place a semicolon\nafter the previous statements in the chain. The output of the entire chain is the final result of the last SQL statement.\nClient tools, such as SnowSQL, treat the chain of statements as a single statement.\nThe pipe operator provides the following benefits:\nSimplifies the execution of dependent SQL statements.\nImproves the readability and flexibility of complex SQL operations.\nSimplifies the execution of dependent SQL statements.\nImproves the readability and flexibility of complex SQL operations.",
        "syntax": [
          "first_st -- Referenced as $4 in last_st, $3 in fourth_st, $2 in third_st, and $1 in second_st\n  ->> second_st -- Referenced as $3 in last_st, $2 in fourth_st, and $1 in third_st\n  ->> third_st  -- Referenced as $2 in last_st and $1 in fourth_st\n  ->> fourth_st -- Referenced as $1 in last_st\n  ->> last_st;",
          "SELECT ...\n  ->> SELECT ... FROM $1\n  ->> SELECT ... FROM $2\n  ->> SELECT ... FROM $3;"
        ]
      },
      {
        "heading": "Syntax",
        "syntax": [
          "<sql_statement_1> ->> <sql_statement_2> [ ->> <sql_statement_n> ... ]"
        ]
      },
      {
        "heading": "Usage notes",
        "description": "\nEach statement produces a result that can only be consumed by a subsequent statement in the chain.\nStatements are executed in their specified order. Unlike RESULT_SCAN(LAST_QUERY_ID()), the pipe number\nresolves to the correct result set in the chain, whether other queries were run concurrently\noutside of the chain or not.\nWhen a statement consumes the results of a previous statement, the result set consumed is equivalent to the\nresult set returned by the RESULT_SCAN function that was passed the query\nID of the previous statement.\nFor example, these statements limit the output of the SHOW WAREHOUSES command to specific columns:\nSHOW WAREHOUSES;\n\nSELECT \"name\", \"state\", \"type\", \"size\"\n  FROM TABLE(RESULT_SCAN(LAST_QUERY_ID(-1)));\n\nCopy\nThis statement uses the pipe operator to produce the same results:\nSHOW WAREHOUSES\n  ->> SELECT \"name\", \"state\", \"type\", \"size\" FROM $1;\n\nCopy\nA query that uses the pipe operator isnt guaranteed to return rows in the same order as the input result set of\na previous query in the chain. You can include an ORDER BY clause with the query to specify the order.\nAn error raised by any SQL statement stops the execution of the chain, and that error is returned to the client.\nThe last statement result is returned to the client.\nThe statements are executed as a Snowflake Scripting\nanonymous block.\nEach statement produces a result that can only be consumed by a subsequent statement in the chain.\nStatements are executed in their specified order. Unlike RESULT_SCAN(LAST_QUERY_ID()), the pipe number\nresolves to the correct result set in the chain, whether other queries were run concurrently\noutside of the chain or not.\nWhen a statement consumes the results of a previous statement, the result set consumed is equivalent to the\nresult set returned by the RESULT_SCAN function that was passed the query\nID of the previous statement.\nFor example, these statements limit the output of the SHOW WAREHOUSES command to specific columns:\nThis statement uses the pipe operator to produce the same results:\nA query that uses the pipe operator isnt guaranteed to return rows in the same order as the input result set of\na previous query in the chain. You can include an ORDER BY clause with the query to specify the order.\nAn error raised by any SQL statement stops the execution of the chain, and that error is returned to the client.\nThe last statement result is returned to the client.\nThe statements are executed as a Snowflake Scripting\nanonymous block.",
        "syntax": [
          "SHOW WAREHOUSES;\n\nSELECT \"name\", \"state\", \"type\", \"size\"\n  FROM TABLE(RESULT_SCAN(LAST_QUERY_ID(-1)));",
          "SHOW WAREHOUSES\n  ->> SELECT \"name\", \"state\", \"type\", \"size\" FROM $1;"
        ]
      },
      {
        "heading": "Limitations",
        "description": "\nThe $n parameter is only valid in the FROM clause of a SQL statement.\nEach SQL statement produces a result that can only be consumed by a subsequent statement in the pipe\nchain. The results cant be consumed outside of the pipe chain, except for the results of the last\nstatement.\nPositional bind variables arent supported.\nThe $n parameter is only valid in the FROM clause of a SQL statement.\nEach SQL statement produces a result that can only be consumed by a subsequent statement in the pipe\nchain. The results cant be consumed outside of the pipe chain, except for the results of the last\nstatement.\nPositional bind variables arent supported."
      },
      {
        "heading": "Examples",
        "description": "\nThe following examples use the pipe operator:\nSelect a list of columns for the output of a SHOW command\nExecute queries that take input from queries on multiple tables\nReturn the row counts for DML operations in a transaction\nReturn the results for inserts into a table that is later dropped\nSelect a list of columns for the output of a SHOW command\nExecute queries that take input from queries on multiple tables\nReturn the row counts for DML operations in a transaction\nReturn the results for inserts into a table that is later dropped\nRun a SHOW TABLES command, and use the pipe operator to limit the output to the created_on, name, and\nowner columns for tables created after April 15, 2025.\nFirst, create a dept_pipe_demo table and an emp_pipe_demo table, and insert data into each one:\nThe following example uses the pipe operator for a chain of SQL statements that perform the following operations:\nQuery the dept_pipe_demo table to return rows where dname equals SALES.\nQuery the emp_pipe_demo table for employees with a salary greater than 1500 in the SALES department,\nusing the results of the previous query as input by specifying $1 in the WHERE condition of a FROM clause.\nRun a query that returns the ename and sal values using the results of the previous query as input\nby specifying $1 in the FROM clause.\nQuery the dept_pipe_demo table to return rows where dname equals SALES.\nQuery the emp_pipe_demo table for employees with a salary greater than 1500 in the SALES department,\nusing the results of the previous query as input by specifying $1 in the WHERE condition of a FROM clause.\nRun a query that returns the ename and sal values using the results of the previous query as input\nby specifying $1 in the FROM clause.\nNote\nThe purpose of this example is to show how to combine a series of queries with the pipe operator. However, the\nsame output can be achieved with a join query, and join queries typically perform better than queries combined\nwith the pipe operator.\nCreate a table and insert rows one by one. Chaining all the statements lets you use the\npipe operator to examine the result of each INSERT statement, which represents the total number of\nrows inserted.\nIn each of the SELECT statements in the example, the $1 in the SELECT list is a shorthand reference for\nthe first column, not a previous result in the pipe. The $n parameter for a pipe number is only\nvalid in the FROM clause.\nThe following example uses the pipe operator for a chain of SQL statements that perform the following operations:\nBegin a transaction.\nInsert a row into the previously created table.\nDelete rows from the table.\nUpdate rows in the table.\nCommit the transaction.\nQuery the number of rows that were affected by each DML operation.\nBegin a transaction.\nInsert a row into the previously created table.\nDelete rows from the table.\nUpdate rows in the table.\nCommit the transaction.\nQuery the number of rows that were affected by each DML operation.\nThis example uses the pipe operator for a chain of SQL statements that performs the following operations:\nCreate a table with an IDENTITY column.\nInsert rows into the table.\nQuery the table.\nDrop the table.\nQuery the results of pipe number $2 (the SELECT statement).\nCreate a table with an IDENTITY column.\nInsert rows into the table.\nQuery the table.\nDrop the table.\nQuery the results of pipe number $2 (the SELECT statement).\nThe result set consumed in the last SELECT statement is equivalent to the result set returned by the\nRESULT_SCAN function for the query ID of the previous SELECT statement.\nOn this page\nPipe\nSyntax\nUsage notes\nLimitations\nExamples\nSelect a list of columns for the output of a SHOW command\nExecute queries that take input from queries on multiple tables\nReturn the row counts for DML operations in a transaction\nReturn the results for inserts into a table that is later dropped\nWe use cookies to improve your experience on our site. By accepting, you agree to our privacy policy.\nEnglish\nFranais\nDeutsch\n\n\nPortugus\n",
        "syntax": [
          "SHOW TABLES\n  ->> SELECT \"created_on\" AS creation_date,\n             \"name\" AS table_name,\n             \"owner\" AS table_owner\n        FROM $1\n        WHERE creation_date > '2025-04-15'::DATE;",
          "+-------------------------------+-------------+--------------+\n| CREATION_DATE                 | TABLE_NAME  | TABLE_OWNER  |\n|-------------------------------+-------------+--------------|\n| 2025-04-16 08:46:16.130 -0700 | TEST_TABLE1 | ACCOUNTADMIN |\n| 2025-04-16 09:44:13.701 -0700 | MYTABLE1    | USER_ROLE    |\n| 2025-04-16 08:46:32.092 -0700 | MYTABLE2    | USER_ROLE    |\n+-------------------------------+-------------+--------------+",
          "CREATE OR REPLACE TABLE dept_pipe_demo (\n  deptno NUMBER(2),\n  dname VARCHAR(14),\n  loc VARCHAR(13)\n  ) AS SELECT * FROM VALUES\n     (10, 'ACCOUNTING', 'NEW YORK'),\n     (20, 'RESEARCH', 'DALLAS'),\n     (30, 'SALES', 'CHICAGO'),\n     (40, 'OPERATIONS', 'BOSTON');\n\nCREATE OR REPLACE TABLE emp_pipe_demo (\n  empno NUMBER(4),\n  ename VARCHAR(10),\n  sal NUMBER(7,2),\n  deptno NUMBER(2)\n  ) AS SELECT * FROM VALUES\n    (7369, 'SMITH', 800, 20),\n    (7499, 'ALLEN', 1600, 30),\n    (7521, 'WARD', 1250, 30),\n    (7698, 'BLAKE', 2850, 30),\n    (7782, 'CLARK', 2450, 10);",
          "SELECT * FROM dept_pipe_demo WHERE dname = 'SALES'\n  ->> SELECT * FROM emp_pipe_demo WHERE sal > 1500 AND deptno IN (SELECT deptno FROM $1)\n  ->> SELECT ename, sal FROM $1 ORDER BY 2 DESC;",
          "+-------+---------+\n| ENAME |     SAL |\n|-------+---------|\n| BLAKE | 2850.00 |\n| ALLEN | 1600.00 |\n+-------+---------+",
          "CREATE OR REPLACE TABLE test_sql_pipe_dml (a INT, b INT)\n  ->> INSERT INTO test_sql_pipe_dml VALUES (1, 2)\n  ->> INSERT INTO test_sql_pipe_dml VALUES (3, 4)\n  ->> INSERT INTO test_sql_pipe_dml VALUES (5, 6)\n  ->> INSERT INTO test_sql_pipe_dml VALUES (7, 8)\n  ->> SELECT (SELECT $1 FROM $4) +\n             (SELECT $1 FROM $3) +\n             (SELECT $1 FROM $2) +\n             (SELECT $1 FROM $1)\n        AS \"Number of rows\";",
          "+----------------+\n| Number of rows |\n|----------------|\n|              4 |\n+----------------+",
          "EXECUTE IMMEDIATE $$\nBEGIN TRANSACTION\n  ->> INSERT INTO test_sql_pipe_dml VALUES (1, 2)\n  ->> DELETE FROM test_sql_pipe_dml WHERE a = 1\n  ->> UPDATE test_sql_pipe_dml SET b = 2\n  ->> COMMIT\n  ->> SELECT\n        (SELECT $1 FROM $4) AS \"Inserted rows\",\n        (SELECT $1 FROM $3) AS \"Deleted rows\",\n        (SELECT $1 FROM $2) AS \"Updated rows\";\n$$;",
          "+---------------+--------------+--------------+\n| Inserted rows | Deleted rows | Updated rows |\n|---------------+--------------+--------------|\n|             1 |            2 |            3 |\n+---------------+--------------+--------------+",
          "CREATE OR REPLACE TABLE test_sql_pipe_drop (\n    id INT IDENTITY START 10 INCREMENT 1,\n    data VARCHAR)\n  ->> INSERT INTO test_sql_pipe_drop (data) VALUES ('row1'), ('row2'), ('row3')\n  ->> SELECT * FROM test_sql_pipe_drop\n  ->> DROP TABLE test_sql_pipe_drop\n  ->> SELECT COUNT(*) \"Number of rows\", MAX(id) AS \"Last ID\" FROM $2;",
          "+----------------+---------+\n| Number of rows | Last ID |\n|----------------+---------|\n|              3 |      12 |\n+----------------+---------+"
        ],
        "examples": [
          "first_st -- Referenced as $4 in last_st, $3 in fourth_st, $2 in third_st, and $1 in second_st\n  ->> second_st -- Referenced as $3 in last_st, $2 in fourth_st, and $1 in third_st\n  ->> third_st  -- Referenced as $2 in last_st and $1 in fourth_st\n  ->> fourth_st -- Referenced as $1 in last_st\n  ->> last_st;",
          "SELECT ...\n  ->> SELECT ... FROM $1\n  ->> SELECT ... FROM $2\n  ->> SELECT ... FROM $3;",
          "SHOW WAREHOUSES;\n\nSELECT \"name\", \"state\", \"type\", \"size\"\n  FROM TABLE(RESULT_SCAN(LAST_QUERY_ID(-1)));",
          "SHOW WAREHOUSES\n  ->> SELECT \"name\", \"state\", \"type\", \"size\" FROM $1;",
          "SHOW TABLES\n  ->> SELECT \"created_on\" AS creation_date,\n             \"name\" AS table_name,\n             \"owner\" AS table_owner\n        FROM $1\n        WHERE creation_date > '2025-04-15'::DATE;",
          "+-------------------------------+-------------+--------------+\n| CREATION_DATE                 | TABLE_NAME  | TABLE_OWNER  |\n|-------------------------------+-------------+--------------|\n| 2025-04-16 08:46:16.130 -0700 | TEST_TABLE1 | ACCOUNTADMIN |\n| 2025-04-16 09:44:13.701 -0700 | MYTABLE1    | USER_ROLE    |\n| 2025-04-16 08:46:32.092 -0700 | MYTABLE2    | USER_ROLE    |\n+-------------------------------+-------------+--------------+",
          "CREATE OR REPLACE TABLE dept_pipe_demo (\n  deptno NUMBER(2),\n  dname VARCHAR(14),\n  loc VARCHAR(13)\n  ) AS SELECT * FROM VALUES\n     (10, 'ACCOUNTING', 'NEW YORK'),\n     (20, 'RESEARCH', 'DALLAS'),\n     (30, 'SALES', 'CHICAGO'),\n     (40, 'OPERATIONS', 'BOSTON');\n\nCREATE OR REPLACE TABLE emp_pipe_demo (\n  empno NUMBER(4),\n  ename VARCHAR(10),\n  sal NUMBER(7,2),\n  deptno NUMBER(2)\n  ) AS SELECT * FROM VALUES\n    (7369, 'SMITH', 800, 20),\n    (7499, 'ALLEN', 1600, 30),\n    (7521, 'WARD', 1250, 30),\n    (7698, 'BLAKE', 2850, 30),\n    (7782, 'CLARK', 2450, 10);",
          "SELECT * FROM dept_pipe_demo WHERE dname = 'SALES'\n  ->> SELECT * FROM emp_pipe_demo WHERE sal > 1500 AND deptno IN (SELECT deptno FROM $1)\n  ->> SELECT ename, sal FROM $1 ORDER BY 2 DESC;",
          "+-------+---------+\n| ENAME |     SAL |\n|-------+---------|\n| BLAKE | 2850.00 |\n| ALLEN | 1600.00 |\n+-------+---------+",
          "CREATE OR REPLACE TABLE test_sql_pipe_dml (a INT, b INT)\n  ->> INSERT INTO test_sql_pipe_dml VALUES (1, 2)\n  ->> INSERT INTO test_sql_pipe_dml VALUES (3, 4)\n  ->> INSERT INTO test_sql_pipe_dml VALUES (5, 6)\n  ->> INSERT INTO test_sql_pipe_dml VALUES (7, 8)\n  ->> SELECT (SELECT $1 FROM $4) +\n             (SELECT $1 FROM $3) +\n             (SELECT $1 FROM $2) +\n             (SELECT $1 FROM $1)\n        AS \"Number of rows\";",
          "+----------------+\n| Number of rows |\n|----------------|\n|              4 |\n+----------------+",
          "EXECUTE IMMEDIATE $$\nBEGIN TRANSACTION\n  ->> INSERT INTO test_sql_pipe_dml VALUES (1, 2)\n  ->> DELETE FROM test_sql_pipe_dml WHERE a = 1\n  ->> UPDATE test_sql_pipe_dml SET b = 2\n  ->> COMMIT\n  ->> SELECT\n        (SELECT $1 FROM $4) AS \"Inserted rows\",\n        (SELECT $1 FROM $3) AS \"Deleted rows\",\n        (SELECT $1 FROM $2) AS \"Updated rows\";\n$$;",
          "+---------------+--------------+--------------+\n| Inserted rows | Deleted rows | Updated rows |\n|---------------+--------------+--------------|\n|             1 |            2 |            3 |\n+---------------+--------------+--------------+",
          "CREATE OR REPLACE TABLE test_sql_pipe_drop (\n    id INT IDENTITY START 10 INCREMENT 1,\n    data VARCHAR)\n  ->> INSERT INTO test_sql_pipe_drop (data) VALUES ('row1'), ('row2'), ('row3')\n  ->> SELECT * FROM test_sql_pipe_drop\n  ->> DROP TABLE test_sql_pipe_drop\n  ->> SELECT COUNT(*) \"Number of rows\", MAX(id) AS \"Last ID\" FROM $2;",
          "+----------------+---------+\n| Number of rows | Last ID |\n|----------------+---------|\n|              3 |      12 |\n+----------------+---------+"
        ]
      }
    ]
  },
  {
    "category": "Logical operators",
    "url": "https://docs.snowflake.com/en/sql-reference/operators-logical",
    "operators": [
      "AND",
      "NOT",
      "OR"
    ],
    "details": [
      {
        "heading": "Logical operators",
        "description": "\nLogical operators return the result of a particular Boolean operation on one or two input expressions. Logical operators are also\nreferred to as Boolean operators.\nLogical operators can only be used as a predicate (for example, in the WHERE clause). Input expressions must be predicates.",
        "definitions": [
          {
            "term": "See also:",
            "definition": "BOOLAND , BOOLNOT , BOOLOR , BOOLXOR"
          }
        ]
      },
      {
        "heading": "List of logical operators",
        "tables": [
          {
            "headers": [
              "Operator",
              "Syntax example",
              "Description"
            ],
            "rows": [
              [
                "AND",
                "a AND b",
                "Matches both expressions (a and b)."
              ],
              [
                "NOT",
                "NOT a",
                "Doesn’t match the expression."
              ],
              [
                "OR",
                "a OR b",
                "Matches either expression."
              ]
            ]
          }
        ]
      },
      {
        "heading": "Examples",
        "description": "\nThe following examples use logical operators:\nUse logical operators in queries on table data\nUse logical operators in queries on Boolean values\nShow truth tables for the logical operators\nUse logical operators in queries on table data\nUse logical operators in queries on Boolean values\nShow truth tables for the logical operators"
      },
      {
        "heading": "Use logical operators in queries on table data",
        "description": "\nCreate a table and insert data:\nUse a single logical operator in the WHERE clause of various queries:\nThe following examples show the precedence of the logical operators.\nThe first example shows that the precedence of AND is higher than the\nprecedence of OR. The query returns the rows that match these conditions:\nb equals Down.\nb equals Down.\nOR\na equals 8 AND b equals Up.\na equals 8 AND b equals Up.\nYou can use parentheses in the WHERE clause to change the precedence. For example,\nthe following query returns the rows that match these conditions:\nb equals Down OR a equals 8.\nb equals Down OR a equals 8.\nAND\nb equals Up.\nb equals Up.\nThe next example shows that the precedence of NOT is higher than the precedence of AND. For example,\nthe following query returns the rows that match these conditions:\na does NOT equal 15.\na does NOT equal 15.\nAND\nb equals Down.\nb equals Down.\nYou can use parentheses in the WHERE clause to change the precedence. For example,\nthe following query returns the rows that do NOT match both of these conditions:\na equals 15.\na equals 15.\nAND\nb equals Down.\nb equals Down.",
        "syntax": [
          "CREATE OR REPLACE TABLE logical_test1 (id INT, a INT, b VARCHAR);\n\nINSERT INTO logical_test1 (id, a, b) VALUES (1, 8, 'Up');\nINSERT INTO logical_test1 (id, a, b) VALUES (2, 25, 'Down');\nINSERT INTO logical_test1 (id, a, b) VALUES (3, 15, 'Down');\nINSERT INTO logical_test1 (id, a, b) VALUES (4, 47, 'Up');\n\nSELECT * FROM logical_test1;",
          "+----+----+------+\n| ID |  A | B    |\n|----+----+------|\n|  1 |  8 | Up   |\n|  2 | 25 | Down |\n|  3 | 15 | Down |\n|  4 | 47 | Up   |\n+----+----+------+",
          "SELECT *\n  FROM logical_test1\n  WHERE a > 20 AND\n        b = 'Down';",
          "+----+----+------+\n| ID |  A | B    |\n|----+----+------|\n|  2 | 25 | Down |\n+----+----+------+",
          "SELECT *\n  FROM logical_test1\n  WHERE a > 20 OR\n        b = 'Down';",
          "+----+----+------+\n| ID |  A | B    |\n|----+----+------|\n|  2 | 25 | Down |\n|  3 | 15 | Down |\n|  4 | 47 | Up   |\n+----+----+------+",
          "SELECT *\n  FROM logical_test1\n  WHERE a > 20 OR\n        b = 'Up';",
          "+----+----+------+\n| ID |  A | B    |\n|----+----+------|\n|  1 |  8 | Up   |\n|  2 | 25 | Down |\n|  4 | 47 | Up   |\n+----+----+------+",
          "SELECT *\n  FROM logical_test1\n  WHERE NOT a > 20;",
          "+----+----+------+\n| ID |  A | B    |\n|----+----+------|\n|  1 |  8 | Up   |\n|  3 | 15 | Down |\n+----+----+------+",
          "SELECT *\n  FROM logical_test1\n  WHERE b = 'Down' OR\n        a = 8 AND b = 'Up';",
          "+----+----+------+\n| ID |  A | B    |\n|----+----+------|\n|  1 |  8 | Up   |\n|  2 | 25 | Down |\n|  3 | 15 | Down |\n+----+----+------+",
          "SELECT *\n  FROM logical_test1\n  WHERE (b = 'Down' OR a = 8) AND b = 'Up';",
          "+----+---+----+\n| ID | A | B  |\n|----+---+----|\n|  1 | 8 | Up |\n+----+---+----+",
          "SELECT *\n  FROM logical_test1\n  WHERE NOT a = 15 AND b = 'Down';",
          "+----+----+------+\n| ID |  A | B    |\n|----+----+------|\n|  2 | 25 | Down |\n+----+----+------+",
          "SELECT *\n  FROM logical_test1\n  WHERE NOT (a = 15 AND b = 'Down');",
          "+----+----+------+\n| ID |  A | B    |\n|----+----+------|\n|  1 |  8 | Up   |\n|  2 | 25 | Down |\n|  4 | 47 | Up   |\n+----+----+------+"
        ]
      },
      {
        "heading": "Use logical operators in queries on Boolean values",
        "description": "\nCreate a table and insert data:\nThe following query uses the OR operator to return rows where either a or b\nis TRUE:\nThe following query uses the AND operator to return rows where both a and b\nare both TRUE:\nThe following query uses the AND operator and the NOT operator to return rows where\nb is TRUE and a is FALSE:\nThe following query uses the AND operator and the NOT operator to return rows where\na is TRUE and b is FALSE:",
        "syntax": [
          "CREATE OR REPLACE TABLE logical_test2 (a BOOLEAN, b BOOLEAN);\n\nINSERT INTO logical_test2 VALUES (0, 1);\n\nSELECT * FROM logical_test2;",
          "+-------+------+\n| A     | B    |\n|-------+------|\n| False | True |\n+-------+------+",
          "SELECT a, b FROM logical_test2 WHERE a OR b;",
          "+-------+------+\n| A     | B    |\n|-------+------|\n| False | True |\n+-------+------+",
          "SELECT a, b FROM logical_test2 WHERE a AND b;",
          "+---+---+\n| A | B |\n|---+---|\n+---+---+",
          "SELECT a, b FROM logical_test2 WHERE b AND NOT a;",
          "+-------+------+\n| A     | B    |\n|-------+------|\n| False | True |\n+-------+------+",
          "SELECT a, b FROM logical_test2 WHERE a AND NOT b;",
          "+---+---+\n| A | B |\n|---+---|\n+---+---+"
        ]
      },
      {
        "heading": "Show truth tables for the logical operators",
        "description": "\nThe next few examples show truth tables for the logical operators on a Boolean column. For more information about the\nbehavior of Boolean values in Snowflake, see Ternary logic.\nCreate a new table and data:\nThis shows the truth table for the OR operator:\nThis shows the truth table for the AND operator:\nOn this page\nList of logical operators\nExamples\nUse logical operators in queries on table data\nUse logical operators in queries on Boolean values\nShow truth tables for the logical operators\nWe use cookies to improve your experience on our site. By accepting, you agree to our privacy policy.\nEnglish\nFranais\nDeutsch\n\n\nPortugus\n",
        "syntax": [
          "CREATE OR REPLACE TABLE logical_test3 (x BOOLEAN);\n\nINSERT INTO logical_test3 (x) VALUES\n  (False),\n  (True),\n  (NULL);",
          "SELECT x AS \"OR\",\n       x OR False AS \"FALSE\",\n       x OR True AS \"TRUE\",\n       x OR NULL AS \"NULL\"\n  FROM logical_test3;",
          "+-------+-------+------+------+\n| OR    | FALSE | TRUE | NULL |\n|-------+-------+------+------|\n| False | False | True | NULL |\n| True  | True  | True | True |\n| NULL  | NULL  | True | NULL |\n+-------+-------+------+------+",
          "SELECT x AS \"AND\",\n       x AND False AS \"FALSE\",\n       x AND True AS \"TRUE\",\n       x AND NULL AS \"NULL\"\n  FROM logical_test3;",
          "+-------+-------+-------+-------+\n| AND   | FALSE | TRUE  | NULL  |\n|-------+-------+-------+-------|\n| False | False | False | False |\n| True  | False | True  | NULL  |\n| NULL  | False | NULL  | NULL  |\n+-------+-------+-------+-------+"
        ],
        "examples": [
          "CREATE OR REPLACE TABLE logical_test1 (id INT, a INT, b VARCHAR);\n\nINSERT INTO logical_test1 (id, a, b) VALUES (1, 8, 'Up');\nINSERT INTO logical_test1 (id, a, b) VALUES (2, 25, 'Down');\nINSERT INTO logical_test1 (id, a, b) VALUES (3, 15, 'Down');\nINSERT INTO logical_test1 (id, a, b) VALUES (4, 47, 'Up');\n\nSELECT * FROM logical_test1;",
          "+----+----+------+\n| ID |  A | B    |\n|----+----+------|\n|  1 |  8 | Up   |\n|  2 | 25 | Down |\n|  3 | 15 | Down |\n|  4 | 47 | Up   |\n+----+----+------+",
          "SELECT *\n  FROM logical_test1\n  WHERE a > 20 AND\n        b = 'Down';",
          "+----+----+------+\n| ID |  A | B    |\n|----+----+------|\n|  2 | 25 | Down |\n+----+----+------+",
          "SELECT *\n  FROM logical_test1\n  WHERE a > 20 OR\n        b = 'Down';",
          "+----+----+------+\n| ID |  A | B    |\n|----+----+------|\n|  2 | 25 | Down |\n|  3 | 15 | Down |\n|  4 | 47 | Up   |\n+----+----+------+",
          "SELECT *\n  FROM logical_test1\n  WHERE a > 20 OR\n        b = 'Up';",
          "+----+----+------+\n| ID |  A | B    |\n|----+----+------|\n|  1 |  8 | Up   |\n|  2 | 25 | Down |\n|  4 | 47 | Up   |\n+----+----+------+",
          "SELECT *\n  FROM logical_test1\n  WHERE NOT a > 20;",
          "+----+----+------+\n| ID |  A | B    |\n|----+----+------|\n|  1 |  8 | Up   |\n|  3 | 15 | Down |\n+----+----+------+",
          "SELECT *\n  FROM logical_test1\n  WHERE b = 'Down' OR\n        a = 8 AND b = 'Up';",
          "+----+----+------+\n| ID |  A | B    |\n|----+----+------|\n|  1 |  8 | Up   |\n|  2 | 25 | Down |\n|  3 | 15 | Down |\n+----+----+------+",
          "SELECT *\n  FROM logical_test1\n  WHERE (b = 'Down' OR a = 8) AND b = 'Up';",
          "+----+---+----+\n| ID | A | B  |\n|----+---+----|\n|  1 | 8 | Up |\n+----+---+----+",
          "SELECT *\n  FROM logical_test1\n  WHERE NOT a = 15 AND b = 'Down';",
          "+----+----+------+\n| ID |  A | B    |\n|----+----+------|\n|  2 | 25 | Down |\n+----+----+------+",
          "SELECT *\n  FROM logical_test1\n  WHERE NOT (a = 15 AND b = 'Down');",
          "+----+----+------+\n| ID |  A | B    |\n|----+----+------|\n|  1 |  8 | Up   |\n|  2 | 25 | Down |\n|  4 | 47 | Up   |\n+----+----+------+",
          "CREATE OR REPLACE TABLE logical_test2 (a BOOLEAN, b BOOLEAN);\n\nINSERT INTO logical_test2 VALUES (0, 1);\n\nSELECT * FROM logical_test2;",
          "+-------+------+\n| A     | B    |\n|-------+------|\n| False | True |\n+-------+------+",
          "SELECT a, b FROM logical_test2 WHERE a OR b;",
          "+-------+------+\n| A     | B    |\n|-------+------|\n| False | True |\n+-------+------+",
          "SELECT a, b FROM logical_test2 WHERE a AND b;",
          "+---+---+\n| A | B |\n|---+---|\n+---+---+",
          "SELECT a, b FROM logical_test2 WHERE b AND NOT a;",
          "+-------+------+\n| A     | B    |\n|-------+------|\n| False | True |\n+-------+------+",
          "SELECT a, b FROM logical_test2 WHERE a AND NOT b;",
          "+---+---+\n| A | B |\n|---+---|\n+---+---+",
          "CREATE OR REPLACE TABLE logical_test3 (x BOOLEAN);\n\nINSERT INTO logical_test3 (x) VALUES\n  (False),\n  (True),\n  (NULL);",
          "SELECT x AS \"OR\",\n       x OR False AS \"FALSE\",\n       x OR True AS \"TRUE\",\n       x OR NULL AS \"NULL\"\n  FROM logical_test3;",
          "+-------+-------+------+------+\n| OR    | FALSE | TRUE | NULL |\n|-------+-------+------+------|\n| False | False | True | NULL |\n| True  | True  | True | True |\n| NULL  | NULL  | True | NULL |\n+-------+-------+------+------+",
          "SELECT x AS \"AND\",\n       x AND False AS \"FALSE\",\n       x AND True AS \"TRUE\",\n       x AND NULL AS \"NULL\"\n  FROM logical_test3;",
          "+-------+-------+-------+-------+\n| AND   | FALSE | TRUE  | NULL  |\n|-------+-------+-------+-------|\n| False | False | False | False |\n| True  | False | True  | NULL  |\n| NULL  | False | NULL  | NULL  |\n+-------+-------+-------+-------+"
        ]
      }
    ]
  },
  {
    "category": "Set operators",
    "url": "https://docs.snowflake.com/en/sql-reference/operators-query",
    "operators": [
      "INTERSECT",
      "MINUS",
      "EXCEPT",
      "UNION"
    ],
    "details": [
      {
        "heading": "Set operators",
        "description": "\nSet operators combine the intermediate results of multiple query blocks into a single result set."
      },
      {
        "heading": "General syntax",
        "syntax": [
          "[ ( ] <query> [ ) ]\n{\n  INTERSECT |\n  { MINUS | EXCEPT } |\n  UNION [ { DISTINCT | ALL } ] [ BY NAME ]\n}\n[ ( ] <query> [ ) ]\n[ ORDER BY ... ]\n[ LIMIT ... ]"
        ]
      },
      {
        "heading": "General usage notes",
        "description": "\nEach query can itself contain query operators, so that you can combine multiple query expressions with set operators.\nYou can apply the ORDER BY and LIMIT / FETCH clauses to the result\nof the set operator.\nWhen using these operators:\n\nMake sure that each query selects the same number of columns, with the exception of queries that include UNION BY NAME\nor UNION ALL BY NAME.\nMake sure that the data type of each column is consistent across the rows from different sources.\nOne of the examples in the Use the UNION operator and cast mismatched data types section\nillustrates the potential problem and solution when data types dont match.\nIn general, make sure the meanings, as well as the data types, of the columns match. The following query with the\nUNION ALL operator wont produce the desired results:\nSELECT LastName, FirstName FROM employees\nUNION ALL\nSELECT FirstName, LastName FROM contractors;\n\nCopy\nThe risk of error increases when you use an asterisk to specify all columns of a table, for example:\nSELECT * FROM table1\nUNION ALL\nSELECT * FROM table2;\n\nCopy\nIf the tables have the same number of columns, but the columns arent in the same order, the query results will\nprobably be incorrect when you use these operators.\nThe UNION BY NAME and UNION ALL BY NAME operators are exceptions for this scenario. For example, the following\nquery returns the correct results:\nSELECT LastName, FirstName FROM employees\nUNION ALL BY NAME\nSELECT FirstName, LastName FROM contractors;\n\nCopy\n\nThe names of the output columns are based on the names of the columns of the first query. For example,\nconsider the following query:\nSELECT LastName, FirstName FROM employees\nUNION ALL\nSELECT FirstName, LastName FROM contractors;\n\nCopy\nThis query behaves as though the query were the following:\nSELECT LastName, FirstName FROM employees\nUNION ALL\nSELECT FirstName AS LastName, LastName AS FirstName FROM contractors;\n\nCopy\nMake sure that each query selects the same number of columns, with the exception of queries that include UNION BY NAME\nor UNION ALL BY NAME.\nMake sure that the data type of each column is consistent across the rows from different sources.\nOne of the examples in the Use the UNION operator and cast mismatched data types section\nillustrates the potential problem and solution when data types dont match.\nIn general, make sure the meanings, as well as the data types, of the columns match. The following query with the\nUNION ALL operator wont produce the desired results:\nSELECT LastName, FirstName FROM employees\nUNION ALL\nSELECT FirstName, LastName FROM contractors;\n\nCopy\nThe risk of error increases when you use an asterisk to specify all columns of a table, for example:\nSELECT * FROM table1\nUNION ALL\nSELECT * FROM table2;\n\nCopy\nIf the tables have the same number of columns, but the columns arent in the same order, the query results will\nprobably be incorrect when you use these operators.\nThe UNION BY NAME and UNION ALL BY NAME operators are exceptions for this scenario. For example, the following\nquery returns the correct results:\nSELECT LastName, FirstName FROM employees\nUNION ALL BY NAME\nSELECT FirstName, LastName FROM contractors;\n\nCopy\nThe names of the output columns are based on the names of the columns of the first query. For example,\nconsider the following query:\nSELECT LastName, FirstName FROM employees\nUNION ALL\nSELECT FirstName, LastName FROM contractors;\n\nCopy\nThis query behaves as though the query were the following:\nSELECT LastName, FirstName FROM employees\nUNION ALL\nSELECT FirstName AS LastName, LastName AS FirstName FROM contractors;\n\nCopy\nThe precedence of the set operators matches the ANSI and ISO SQL standards:\n\nThe UNION [ALL] and MINUS (EXCEPT) operators have equal precedence.\nThe INTERSECT operator has higher precedence than UNION [ALL] and MINUS (EXCEPT).\n\nSnowflake processes operators of equal precedence from left to right.\nYou can use parentheses to force the expressions to be evaluated in a different order.\nNot all database vendors follow the ANSI/ISO standard for precedence of set operators. Snowflake recommends using parentheses to\nspecify the order of evaluation, especially if you are porting code from another vendor to Snowflake, or writing code that you\nmight execute on other databases as well as on Snowflake.\nThe UNION [ALL] and MINUS (EXCEPT) operators have equal precedence.\nThe INTERSECT operator has higher precedence than UNION [ALL] and MINUS (EXCEPT).\nEach query can itself contain query operators, so that you can combine multiple query expressions with set operators.\nYou can apply the ORDER BY and LIMIT / FETCH clauses to the result\nof the set operator.\nWhen using these operators:\nMake sure that each query selects the same number of columns, with the exception of queries that include UNION BY NAME\nor UNION ALL BY NAME.\nMake sure that the data type of each column is consistent across the rows from different sources.\nOne of the examples in the Use the UNION operator and cast mismatched data types section\nillustrates the potential problem and solution when data types dont match.\nIn general, make sure the meanings, as well as the data types, of the columns match. The following query with the\nUNION ALL operator wont produce the desired results:\nSELECT LastName, FirstName FROM employees\nUNION ALL\nSELECT FirstName, LastName FROM contractors;\n\nCopy\nThe risk of error increases when you use an asterisk to specify all columns of a table, for example:\nSELECT * FROM table1\nUNION ALL\nSELECT * FROM table2;\n\nCopy\nIf the tables have the same number of columns, but the columns arent in the same order, the query results will\nprobably be incorrect when you use these operators.\nThe UNION BY NAME and UNION ALL BY NAME operators are exceptions for this scenario. For example, the following\nquery returns the correct results:\nSELECT LastName, FirstName FROM employees\nUNION ALL BY NAME\nSELECT FirstName, LastName FROM contractors;\n\nCopy\nThe names of the output columns are based on the names of the columns of the first query. For example,\nconsider the following query:\nSELECT LastName, FirstName FROM employees\nUNION ALL\nSELECT FirstName, LastName FROM contractors;\n\nCopy\nThis query behaves as though the query were the following:\nSELECT LastName, FirstName FROM employees\nUNION ALL\nSELECT FirstName AS LastName, LastName AS FirstName FROM contractors;\n\nCopy\nMake sure that each query selects the same number of columns, with the exception of queries that include UNION BY NAME\nor UNION ALL BY NAME.\nMake sure that the data type of each column is consistent across the rows from different sources.\nOne of the examples in the Use the UNION operator and cast mismatched data types section\nillustrates the potential problem and solution when data types dont match.\nIn general, make sure the meanings, as well as the data types, of the columns match. The following query with the\nUNION ALL operator wont produce the desired results:\nThe risk of error increases when you use an asterisk to specify all columns of a table, for example:\nIf the tables have the same number of columns, but the columns arent in the same order, the query results will\nprobably be incorrect when you use these operators.\nThe UNION BY NAME and UNION ALL BY NAME operators are exceptions for this scenario. For example, the following\nquery returns the correct results:\nThe names of the output columns are based on the names of the columns of the first query. For example,\nconsider the following query:\nThis query behaves as though the query were the following:\nThe precedence of the set operators matches the ANSI and ISO SQL standards:\nThe UNION [ALL] and MINUS (EXCEPT) operators have equal precedence.\nThe INTERSECT operator has higher precedence than UNION [ALL] and MINUS (EXCEPT).\nThe UNION [ALL] and MINUS (EXCEPT) operators have equal precedence.\nThe INTERSECT operator has higher precedence than UNION [ALL] and MINUS (EXCEPT).\nSnowflake processes operators of equal precedence from left to right.\nYou can use parentheses to force the expressions to be evaluated in a different order.\nNot all database vendors follow the ANSI/ISO standard for precedence of set operators. Snowflake recommends using parentheses to\nspecify the order of evaluation, especially if you are porting code from another vendor to Snowflake, or writing code that you\nmight execute on other databases as well as on Snowflake.",
        "syntax": [
          "SELECT LastName, FirstName FROM employees\nUNION ALL\nSELECT FirstName, LastName FROM contractors;",
          "SELECT * FROM table1\nUNION ALL\nSELECT * FROM table2;",
          "SELECT LastName, FirstName FROM employees\nUNION ALL BY NAME\nSELECT FirstName, LastName FROM contractors;",
          "SELECT LastName, FirstName FROM employees\nUNION ALL\nSELECT FirstName, LastName FROM contractors;",
          "SELECT LastName, FirstName FROM employees\nUNION ALL\nSELECT FirstName AS LastName, LastName AS FirstName FROM contractors;"
        ]
      },
      {
        "heading": "Sample tables for examples",
        "description": "\nSome of the examples in this topic use the following sample tables. Both tables have a postal code column. One table records the postal code of\neach sales office, and the other records the postal code of each customer.",
        "syntax": [
          "CREATE OR REPLACE TABLE sales_office_postal_example(\n  office_name VARCHAR,\n  postal_code VARCHAR);\n\nINSERT INTO sales_office_postal_example VALUES ('sales1', '94061');\nINSERT INTO sales_office_postal_example VALUES ('sales2', '94070');\nINSERT INTO sales_office_postal_example VALUES ('sales3', '98116');\nINSERT INTO sales_office_postal_example VALUES ('sales4', '98005');\n\nCREATE OR REPLACE TABLE customer_postal_example(\n  customer VARCHAR,\n  postal_code VARCHAR);\n\nINSERT INTO customer_postal_example VALUES ('customer1', '94066');\nINSERT INTO customer_postal_example VALUES ('customer2', '94061');\nINSERT INTO customer_postal_example VALUES ('customer3', '98444');\nINSERT INTO customer_postal_example VALUES ('customer4', '98005');"
        ]
      },
      {
        "heading": "INTERSECT",
        "description": "\nReturns rows from one querys result set which also appear in another querys result set, with duplicate elimination."
      },
      {
        "heading": "Syntax",
        "syntax": [
          "[ ( ] <query> [ ) ]\nINTERSECT\n[ ( ] <query> [ ) ]"
        ]
      },
      {
        "heading": "INTERSECT operator examples",
        "description": "\nTo find the postal codes that are in both the sales_office_postal_example table and the customer_postal_example\ntable, query the sample tables:",
        "syntax": [
          "SELECT postal_code FROM sales_office_postal_example\nINTERSECT\nSELECT postal_code FROM customer_postal_example\nORDER BY postal_code;",
          "+-------------+\n| POSTAL_CODE |\n|-------------|\n| 94061       |\n| 98005       |\n+-------------+"
        ]
      },
      {
        "heading": "MINUS , EXCEPT",
        "description": "\nReturns the rows returned by the first query that arent also returned by the second query.\nThe MINUS and EXCEPT keywords have the same meaning and can be used interchangeably."
      },
      {
        "heading": "Syntax",
        "syntax": [
          "[ ( ] <query> [ ) ]\nMINUS\n[ ( ] <query> [ ) ]\n\n[ ( ] <query> [ ) ]\nEXCEPT\n[ ( ] <query> [ ) ]"
        ]
      },
      {
        "heading": "MINUS operator examples",
        "description": "\nQuery the sample tables to find the postal codes in the\nsales_office_postal_example table that arent also in the customer_postal_example table:\nQuery the sample tables to find the postal codes in the\ncustomer_postal_example table that arent also in the sales_office_postal_example table:",
        "syntax": [
          "SELECT postal_code FROM sales_office_postal_example\nMINUS\nSELECT postal_code FROM customer_postal_example\nORDER BY postal_code;",
          "+-------------+\n| POSTAL_CODE |\n|-------------|\n| 94070       |\n| 98116       |\n+-------------+",
          "SELECT postal_code FROM customer_postal_example\nMINUS\nSELECT postal_code FROM sales_office_postal_example\nORDER BY postal_code;",
          "+-------------+\n| POSTAL_CODE |\n|-------------|\n| 94066       |\n| 98444       |\n+-------------+"
        ]
      },
      {
        "heading": "UNION [ { DISTINCT | ALL } ] [ BY NAME ]",
        "description": "\nCombines the result sets from two queries:\nUNION [ DISTINCT ] combines rows by column position with duplicate elimination.\nUNION ALL combines rows by column position without duplicate elimination.\nUNION [ DISTINCT ] BY NAME combines rows by column name with duplicate elimination.\nUNION ALL BY NAME combines rows by column name without duplicate elimination.\nUNION [ DISTINCT ] combines rows by column position with duplicate elimination.\nUNION ALL combines rows by column position without duplicate elimination.\nUNION [ DISTINCT ] BY NAME combines rows by column name with duplicate elimination.\nUNION ALL BY NAME combines rows by column name without duplicate elimination.\nThe default is UNION DISTINCT (that is, combine rows by column position with duplicate elimination).\nThe DISTINCT keyword is optional. The DISTINCT keyword and the ALL keyword are mutually\nexclusive.\nUse UNION or UNION ALL when the column positions match in the tables that you are combining. Use\nUNION BY NAME or UNION ALL BY NAME for the following use cases:\nThe tables that you are combining have varying column orders.\nThe tables that you are combining have evolving schemas, where columns are added or reordered.\nYou want to combine subsets of columns that have different positions in the tables.\nThe tables that you are combining have varying column orders.\nThe tables that you are combining have evolving schemas, where columns are added or reordered.\nYou want to combine subsets of columns that have different positions in the tables."
      },
      {
        "heading": "Syntax",
        "syntax": [
          "[ ( ] <query> [ ) ]\nUNION [ { DISTINCT | ALL } ] [ BY NAME ]\n[ ( ] <query> [ ) ]"
        ]
      },
      {
        "heading": "Usage notes for the BY NAME clause",
        "description": "\nIn addition to the general usage notes, the following usage notes apply to\nUNION BY NAME and UNION ALL BY NAME:\nColumns with the same identifiers are matched and combined. Matching of unquoted identifiers is case-insensitive,\nand matching of quoted identifiers is case-sensitive.\nThe inputs arent required to have the same number of columns. If a column exists in one input but not the other, it\nis filled with NULL values in the combined result set for each row where its missing.\nThe order of columns in the combined result set is determined by the order of unique columns from\nleft to right, as they are first encountered.\nColumns with the same identifiers are matched and combined. Matching of unquoted identifiers is case-insensitive,\nand matching of quoted identifiers is case-sensitive.\nThe inputs arent required to have the same number of columns. If a column exists in one input but not the other, it\nis filled with NULL values in the combined result set for each row where its missing.\nThe order of columns in the combined result set is determined by the order of unique columns from\nleft to right, as they are first encountered."
      },
      {
        "heading": "UNION operator examples",
        "description": "\nThe following examples use the UNION operator:\nCombine the results from two queries by column position\nCombine the results from two queries by column name\nUse an alias to combine the results from two queries with different column names\nUse the UNION operator and cast mismatched data types\nCombine the results from two queries by column position\nCombine the results from two queries by column name\nUse an alias to combine the results from two queries with different column names\nUse the UNION operator and cast mismatched data types\nTo combine the result sets by column position from two queries on the\nsample tables, use the UNION operator:\nCreate two tables with differing column order and insert data:\nTo combine the result sets by column name from two queries, use the UNION BY NAME operator:\nThe output shows that the query eliminated the duplicate row (with 3 in column A and three\nin column B).\nTo combine the tables without duplicate elimination, use the UNION ALL BY NAME operator:\nNotice that the cases of the column names dont match in the two tables. The column names are lowercase in\nthe union_demo_column_order1 table and uppercase in the union_demo_column_order2 table. If you run\na query with quotation marks around the column names, an error is returned because the matching of quoted\nidentifiers is case-sensitive. For example, the following query places quotation marks around the column names:\nWhen you use the UNION BY NAME operator to combine the result sets by column name from two queries on the\nsample tables, the rows in the result set have NULL values because\nthe column names dont match:\nThe output shows that columns with different identifiers arent combined and that rows have NULL\nvalues for columns that are in one table but not the other. The postal_code column is in both tables,\nso there are no NULL values in the output for the postal_code column.\nThe following query uses the alias office_or_customer so that columns with different names\nhave the same name for the duration of the query:\nThis example demonstrates a potential issue with using the UNION operator when data types dont match,\nthen provides the solution.\nStart by creating the tables and inserting some data:\nExecute a UNION by column position operation with different data types (a VARCHAR value in union_test1 and an\nINTEGER value in union_test2):\nThis query returns an error:\nNow use explicit casting to convert the inputs to a compatible type:\nOn this page\nGeneral syntax\nGeneral usage notes\nSample tables for examples\nINTERSECT\nMINUS , EXCEPT\nUNION [ { DISTINCT | ALL } ] [ BY NAME ]\nWe use cookies to improve your experience on our site. By accepting, you agree to our privacy policy.\nEnglish\nFranais\nDeutsch\n\n\nPortugus\n",
        "syntax": [
          "SELECT office_name office_or_customer, postal_code FROM sales_office_postal_example\nUNION\nSELECT customer, postal_code FROM customer_postal_example\nORDER BY postal_code;",
          "+--------------------+-------------+\n| OFFICE_OR_CUSTOMER | POSTAL_CODE |\n|--------------------+-------------|\n| sales1             | 94061       |\n| customer2          | 94061       |\n| customer1          | 94066       |\n| sales2             | 94070       |\n| sales4             | 98005       |\n| customer4          | 98005       |\n| sales3             | 98116       |\n| customer3          | 98444       |\n+--------------------+-------------+",
          "CREATE OR REPLACE TABLE union_demo_column_order1 (\n  a INTEGER,\n  b VARCHAR);\n\nINSERT INTO union_demo_column_order1 VALUES\n  (1, 'one'),\n  (2, 'two'),\n  (3, 'three');\n\nCREATE OR REPLACE TABLE union_demo_column_order2 (\n  B VARCHAR,\n  A INTEGER);\n\nINSERT INTO union_demo_column_order2 VALUES\n  ('three', 3),\n  ('four', 4);",
          "SELECT * FROM union_demo_column_order1\nUNION BY NAME\nSELECT * FROM union_demo_column_order2\nORDER BY a;",
          "+---+-------+\n| A | B     |\n|---+-------|\n| 1 | one   |\n| 2 | two   |\n| 3 | three |\n| 4 | four  |\n+---+-------+",
          "SELECT * FROM union_demo_column_order1\nUNION ALL BY NAME\nSELECT * FROM union_demo_column_order2\nORDER BY a;",
          "+---+-------+\n| A | B     |\n|---+-------|\n| 1 | one   |\n| 2 | two   |\n| 3 | three |\n| 3 | three |\n| 4 | four  |\n+---+-------+",
          "SELECT 'a', 'b' FROM union_demo_column_order1\nUNION ALL BY NAME\nSELECT 'B', 'A' FROM union_demo_column_order2\nORDER BY a;",
          "000904 (42000): SQL compilation error: error line 4 at position 9\ninvalid identifier 'A'",
          "SELECT office_name, postal_code FROM sales_office_postal_example\nUNION BY NAME\nSELECT customer, postal_code FROM customer_postal_example\nORDER BY postal_code;",
          "+-------------+-------------+-----------+\n| OFFICE_NAME | POSTAL_CODE | CUSTOMER  |\n|-------------+-------------+-----------|\n| sales1      | 94061       | NULL      |\n| NULL        | 94061       | customer2 |\n| NULL        | 94066       | customer1 |\n| sales2      | 94070       | NULL      |\n| sales4      | 98005       | NULL      |\n| NULL        | 98005       | customer4 |\n| sales3      | 98116       | NULL      |\n| NULL        | 98444       | customer3 |\n+-------------+-------------+-----------+",
          "SELECT office_name AS office_or_customer, postal_code FROM sales_office_postal_example\nUNION BY NAME\nSELECT customer AS office_or_customer, postal_code FROM customer_postal_example\nORDER BY postal_code;",
          "+--------------------+-------------+\n| OFFICE_OR_CUSTOMER | POSTAL_CODE |\n|--------------------+-------------|\n| sales1             | 94061       |\n| customer2          | 94061       |\n| customer1          | 94066       |\n| sales2             | 94070       |\n| sales4             | 98005       |\n| customer4          | 98005       |\n| sales3             | 98116       |\n| customer3          | 98444       |\n+--------------------+-------------+",
          "CREATE OR REPLACE TABLE union_test1 (v VARCHAR);\nCREATE OR REPLACE TABLE union_test2 (i INTEGER);\n\nINSERT INTO union_test1 (v) VALUES ('Smith, Jane');\nINSERT INTO union_test2 (i) VALUES (42);",
          "SELECT v FROM union_test1\nUNION\nSELECT i FROM union_test2;",
          "100038 (22018): Numeric value 'Smith, Jane' is not recognized",
          "SELECT v::VARCHAR FROM union_test1\nUNION\nSELECT i::VARCHAR FROM union_test2;",
          "+-------------+\n| V::VARCHAR  |\n|-------------|\n| Smith, Jane |\n| 42          |\n+-------------+"
        ],
        "examples": [
          "SELECT LastName, FirstName FROM employees\nUNION ALL\nSELECT FirstName, LastName FROM contractors;",
          "SELECT * FROM table1\nUNION ALL\nSELECT * FROM table2;",
          "SELECT LastName, FirstName FROM employees\nUNION ALL BY NAME\nSELECT FirstName, LastName FROM contractors;",
          "SELECT LastName, FirstName FROM employees\nUNION ALL\nSELECT FirstName, LastName FROM contractors;",
          "SELECT LastName, FirstName FROM employees\nUNION ALL\nSELECT FirstName AS LastName, LastName AS FirstName FROM contractors;",
          "CREATE OR REPLACE TABLE sales_office_postal_example(\n  office_name VARCHAR,\n  postal_code VARCHAR);\n\nINSERT INTO sales_office_postal_example VALUES ('sales1', '94061');\nINSERT INTO sales_office_postal_example VALUES ('sales2', '94070');\nINSERT INTO sales_office_postal_example VALUES ('sales3', '98116');\nINSERT INTO sales_office_postal_example VALUES ('sales4', '98005');\n\nCREATE OR REPLACE TABLE customer_postal_example(\n  customer VARCHAR,\n  postal_code VARCHAR);\n\nINSERT INTO customer_postal_example VALUES ('customer1', '94066');\nINSERT INTO customer_postal_example VALUES ('customer2', '94061');\nINSERT INTO customer_postal_example VALUES ('customer3', '98444');\nINSERT INTO customer_postal_example VALUES ('customer4', '98005');",
          "SELECT postal_code FROM sales_office_postal_example\nINTERSECT\nSELECT postal_code FROM customer_postal_example\nORDER BY postal_code;",
          "+-------------+\n| POSTAL_CODE |\n|-------------|\n| 94061       |\n| 98005       |\n+-------------+",
          "SELECT postal_code FROM sales_office_postal_example\nMINUS\nSELECT postal_code FROM customer_postal_example\nORDER BY postal_code;",
          "+-------------+\n| POSTAL_CODE |\n|-------------|\n| 94070       |\n| 98116       |\n+-------------+",
          "SELECT postal_code FROM customer_postal_example\nMINUS\nSELECT postal_code FROM sales_office_postal_example\nORDER BY postal_code;",
          "+-------------+\n| POSTAL_CODE |\n|-------------|\n| 94066       |\n| 98444       |\n+-------------+",
          "SELECT office_name office_or_customer, postal_code FROM sales_office_postal_example\nUNION\nSELECT customer, postal_code FROM customer_postal_example\nORDER BY postal_code;",
          "+--------------------+-------------+\n| OFFICE_OR_CUSTOMER | POSTAL_CODE |\n|--------------------+-------------|\n| sales1             | 94061       |\n| customer2          | 94061       |\n| customer1          | 94066       |\n| sales2             | 94070       |\n| sales4             | 98005       |\n| customer4          | 98005       |\n| sales3             | 98116       |\n| customer3          | 98444       |\n+--------------------+-------------+",
          "CREATE OR REPLACE TABLE union_demo_column_order1 (\n  a INTEGER,\n  b VARCHAR);\n\nINSERT INTO union_demo_column_order1 VALUES\n  (1, 'one'),\n  (2, 'two'),\n  (3, 'three');\n\nCREATE OR REPLACE TABLE union_demo_column_order2 (\n  B VARCHAR,\n  A INTEGER);\n\nINSERT INTO union_demo_column_order2 VALUES\n  ('three', 3),\n  ('four', 4);",
          "SELECT * FROM union_demo_column_order1\nUNION BY NAME\nSELECT * FROM union_demo_column_order2\nORDER BY a;",
          "+---+-------+\n| A | B     |\n|---+-------|\n| 1 | one   |\n| 2 | two   |\n| 3 | three |\n| 4 | four  |\n+---+-------+",
          "SELECT * FROM union_demo_column_order1\nUNION ALL BY NAME\nSELECT * FROM union_demo_column_order2\nORDER BY a;",
          "+---+-------+\n| A | B     |\n|---+-------|\n| 1 | one   |\n| 2 | two   |\n| 3 | three |\n| 3 | three |\n| 4 | four  |\n+---+-------+",
          "SELECT 'a', 'b' FROM union_demo_column_order1\nUNION ALL BY NAME\nSELECT 'B', 'A' FROM union_demo_column_order2\nORDER BY a;",
          "000904 (42000): SQL compilation error: error line 4 at position 9\ninvalid identifier 'A'",
          "SELECT office_name, postal_code FROM sales_office_postal_example\nUNION BY NAME\nSELECT customer, postal_code FROM customer_postal_example\nORDER BY postal_code;",
          "+-------------+-------------+-----------+\n| OFFICE_NAME | POSTAL_CODE | CUSTOMER  |\n|-------------+-------------+-----------|\n| sales1      | 94061       | NULL      |\n| NULL        | 94061       | customer2 |\n| NULL        | 94066       | customer1 |\n| sales2      | 94070       | NULL      |\n| sales4      | 98005       | NULL      |\n| NULL        | 98005       | customer4 |\n| sales3      | 98116       | NULL      |\n| NULL        | 98444       | customer3 |\n+-------------+-------------+-----------+",
          "SELECT office_name AS office_or_customer, postal_code FROM sales_office_postal_example\nUNION BY NAME\nSELECT customer AS office_or_customer, postal_code FROM customer_postal_example\nORDER BY postal_code;",
          "+--------------------+-------------+\n| OFFICE_OR_CUSTOMER | POSTAL_CODE |\n|--------------------+-------------|\n| sales1             | 94061       |\n| customer2          | 94061       |\n| customer1          | 94066       |\n| sales2             | 94070       |\n| sales4             | 98005       |\n| customer4          | 98005       |\n| sales3             | 98116       |\n| customer3          | 98444       |\n+--------------------+-------------+",
          "CREATE OR REPLACE TABLE union_test1 (v VARCHAR);\nCREATE OR REPLACE TABLE union_test2 (i INTEGER);\n\nINSERT INTO union_test1 (v) VALUES ('Smith, Jane');\nINSERT INTO union_test2 (i) VALUES (42);",
          "SELECT v FROM union_test1\nUNION\nSELECT i FROM union_test2;",
          "100038 (22018): Numeric value 'Smith, Jane' is not recognized",
          "SELECT v::VARCHAR FROM union_test1\nUNION\nSELECT i::VARCHAR FROM union_test2;",
          "+-------------+\n| V::VARCHAR  |\n|-------------|\n| Smith, Jane |\n| 42          |\n+-------------+"
        ]
      }
    ]
  },
  {
    "category": "Subquery operators",
    "url": "https://docs.snowflake.com/en/sql-reference/operators-subquery",
    "operators": [
      "[NOT] EXISTS",
      "ANY / ALL",
      "[NOT] IN"
    ],
    "details": [
      {
        "heading": "Subquery operators",
        "description": "\nA subquery is a query within another query. Subquery operators\nperform operations on the values produced by subqueries.\nSnowflake supports the following subquery operators:\nALL / ANY\n[ NOT ] EXISTS\n[ NOT ] IN\nALL / ANY\n[ NOT ] EXISTS\n[ NOT ] IN"
      },
      {
        "heading": "ALL / ANY",
        "description": "\nThe ALL and ANY keywords can be used to apply a comparison operator to the values produced by a subquery (which can return more than one row)."
      },
      {
        "heading": "Syntax",
        "description": "\nWhere:",
        "syntax": [
          "<expr> comparisonOperator { ALL | ANY } ( <query> )",
          "comparisonOperator ::=\n  { = | != | > | >= | < | <= }"
        ]
      },
      {
        "heading": "Usage notes",
        "description": "\nThe expression is compared with the operator for each value that the subquery returns:\n\nIf ALL is specified, then the result is TRUE if every row of the subquery satisfies the condition; otherwise, it returns FALSE.\nIf ANY is specified, then the result is TRUE if any row of the subquery satisfies the condition; otherwise, it returns FALSE.\nIf ALL is specified, then the result is TRUE if every row of the subquery satisfies the condition; otherwise, it returns FALSE.\nIf ANY is specified, then the result is TRUE if any row of the subquery satisfies the condition; otherwise, it returns FALSE.\nANY/ALL subqueries are currently supported only in a WHERE clause.\nANY/ALL subqueries cant appear as an argument to an OR operator.\nThe subquery must contain only one item in its SELECT list.\nThe expression is compared with the operator for each value that the subquery returns:\nIf ALL is specified, then the result is TRUE if every row of the subquery satisfies the condition; otherwise, it returns FALSE.\nIf ANY is specified, then the result is TRUE if any row of the subquery satisfies the condition; otherwise, it returns FALSE.\nIf ALL is specified, then the result is TRUE if every row of the subquery satisfies the condition; otherwise, it returns FALSE.\nIf ANY is specified, then the result is TRUE if any row of the subquery satisfies the condition; otherwise, it returns FALSE.\nANY/ALL subqueries are currently supported only in a WHERE clause.\nANY/ALL subqueries cant appear as an argument to an OR operator.\nThe subquery must contain only one item in its SELECT list."
      },
      {
        "heading": "Examples",
        "description": "\nUse a != ALL subquery to find the departments that have no employees:",
        "syntax": [
          "SELECT department_id\n  FROM departments d\n  WHERE d.department_id != ALL (\n    SELECT e.department_id\n      FROM employees e);"
        ]
      },
      {
        "heading": "[ NOT ] EXISTS",
        "description": "\nAn EXISTS subquery is a Boolean expression that can appear in a WHERE or HAVING clause,\nor in any function that operates on a Boolean expression:\nAn EXISTS expression evaluates to TRUE if any rows are produced by the subquery.\nA NOT EXISTS expression evaluates to TRUE if no rows are produced by the subquery.\nAn EXISTS expression evaluates to TRUE if any rows are produced by the subquery.\nA NOT EXISTS expression evaluates to TRUE if no rows are produced by the subquery."
      },
      {
        "heading": "Syntax",
        "syntax": [
          "[ NOT ] EXISTS ( <query> )"
        ]
      },
      {
        "heading": "Usage notes",
        "description": "\nCorrelated EXISTS subqueries are currently supported only in a\nWHERE clause.\nCorrelated EXISTS subqueries cannot appear as an argument to an OR operator.\nUncorrelated EXISTS subqueries are supported anywhere that a Boolean expression is allowed.\nCorrelated EXISTS subqueries are currently supported only in a\nWHERE clause.\nCorrelated EXISTS subqueries cannot appear as an argument to an OR operator.\nUncorrelated EXISTS subqueries are supported anywhere that a Boolean expression is allowed."
      },
      {
        "heading": "Examples",
        "description": "\nUse a correlated NOT EXISTS subquery to find the departments that have no employees:",
        "syntax": [
          "SELECT department_id\n  FROM departments d\n  WHERE NOT EXISTS (\n    SELECT 1\n      FROM employees e\n      WHERE e.department_id = d.department_id);"
        ]
      },
      {
        "heading": "[ NOT ] IN",
        "description": "\nThe IN and NOT IN operators check whether an expression is included in the values produced by a subquery."
      },
      {
        "heading": "Syntax",
        "syntax": [
          "<expr> [ NOT ] IN ( <query> )"
        ]
      },
      {
        "heading": "Usage notes",
        "description": "\nIN is shorthand for = ANY, and is subject to the same restrictions as ANY subqueries.\nNOT IN is shorthand for != ALL, and is subject to the same restrictions as ALL subqueries.\n[NOT] IN can also be used as an operator in expressions that dont involve a subquery. For details, see\n[ NOT ] IN.\nIN is shorthand for = ANY, and is subject to the same restrictions as ANY subqueries.\nNOT IN is shorthand for != ALL, and is subject to the same restrictions as ALL subqueries.\n[NOT] IN can also be used as an operator in expressions that dont involve a subquery. For details, see\n[ NOT ] IN."
      },
      {
        "heading": "Examples",
        "description": "\nUse a NOT IN subquery that is equivalent to the != ALL subquery example (earlier in this topic)\nto find the departments that have no employees:\nOn this page\nALL / ANY\n[ NOT ] EXISTS\n[ NOT ] IN\nRelated content\nWorking with Subqueries\nWe use cookies to improve your experience on our site. By accepting, you agree to our privacy policy.\nEnglish\nFranais\nDeutsch\n\n\nPortugus\n",
        "syntax": [
          "SELECT department_id\n  FROM departments d\n  WHERE d.department_id NOT IN (\n    SELECT e.department_id\n      FROM employees e);"
        ],
        "examples": [
          "SELECT department_id\n  FROM departments d\n  WHERE d.department_id != ALL (\n    SELECT e.department_id\n      FROM employees e);",
          "SELECT department_id\n  FROM departments d\n  WHERE NOT EXISTS (\n    SELECT 1\n      FROM employees e\n      WHERE e.department_id = d.department_id);",
          "SELECT department_id\n  FROM departments d\n  WHERE d.department_id NOT IN (\n    SELECT e.department_id\n      FROM employees e);"
        ]
      }
    ]
  }
]