[
{
    "function_name": "ABS",
    "summary": "Returns the absolute value of a numeric expression.",
    "category": "Numeric functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/abs",
    "title": "ABS",
    "description": "Returns the absolute value of a numeric expression.",
    "syntax": "ABS( <num_expr> )",
    "example": "SELECT column1, abs(column1)\n    FROM (values (0), (1), (-2), (3.5), (-4.5), (null));\n+---------+--------------+\n| COLUMN1 | ABS(COLUMN1) |\n|---------+--------------|\n|     0.0 |          0.0 |\n|     1.0 |          1.0 |\n|    -2.0 |          2.0 |\n|     3.5 |          3.5 |\n|    -4.5 |          4.5 |\n|    NULL |         NULL |\n+---------+--------------+"
},
{
    "function_name": "APPROX_TOP_K_COMBINE",
    "summary": "Combines (merges) input states into a single output state.",
    "category": "Aggregate functions , Window function syntax and usage",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/approx_top_k_combine",
    "title": "APPROX_TOP_K_COMBINE",
    "description": "Combines (merges) input states into a single output state.",
    "syntax": "APPROX_TOP_K_COMBINE( <state> [ , <counters> ] )",
    "example": "-- Create a sequence to use to generate values for the table.\nCREATE OR REPLACE SEQUENCE seq91;\nCREATE OR REPLACE TABLE sequence_demo (c1 INTEGER DEFAULT seq91.nextval, dummy SMALLINT);\nINSERT INTO sequence_demo (dummy) VALUES (0);\n\n-- Double the number of rows a few times, until there are 8 rows:\nINSERT INTO sequence_demo (dummy) SELECT dummy FROM sequence_demo;\nINSERT INTO sequence_demo (dummy) SELECT dummy FROM sequence_demo;\nINSERT INTO sequence_demo (dummy) SELECT dummy FROM sequence_demo;\n\nCREATE OR REPLACE TABLE resultstate1 AS (\n     SELECT approx_top_k_accumulate(c1, 50) AS rs1\n        FROM sequence_demo);\n\nCREATE OR REPLACE TABLE test_table2 (c1 INTEGER);\n-- Insert data.\nINSERT INTO test_table2 (c1) SELECT c1 + 4 FROM sequence_demo;\n\nCREATE OR REPLACE TABLE resultstate2 AS \n  (SELECT approx_top_k_accumulate(c1, 50) AS rs1 \n     FROM test_table2);\n\nCREATE OR REPLACE TABLE combined_resultstate (c1) AS \n  SELECT approx_top_k_combine(rs1) AS apc1\n    FROM (\n        SELECT rs1 FROM resultstate1\n        UNION ALL\n        SELECT rs1 FROM resultstate2\n      )\n      ;\n\nSELECT approx_top_k_estimate(c1, 4) FROM combined_resultstate;\n\n+------------------------------+\n| APPROX_TOP_K_ESTIMATE(C1, 4) |\n|------------------------------|\n| [                            |\n|   [                          |\n|     5,                       |\n|     2                        |\n|   ],                         |\n|   [                          |\n|     6,                       |\n|     2                        |\n|   ],                         |\n|   [                          |\n|     7,                       |\n|     2                        |\n|   ],                         |\n|   [                          |\n|     8,                       |\n|     2                        |\n|   ]                          |\n| ]                            |\n+------------------------------+",
    "arguments": [
        {
            "name": "state",
            "description": "An expression that contains state information generated\nby a call to APPROX_TOP_K_ACCUMULATE ."
        },
        {
            "name": "counters",
            "description": "This is the maximum number of distinct values that\ncan be tracked at a time during the estimation process. For example, if counters is set to 100000, then the algorithm tracks 100,000\ndistinct values, attempting to keep the 100,000 most frequent values. The maximum number of counters is 100000 (100,000)."
        }
    ],
    "returns": "This returns information about the “state” of the top K calculation."
},
{
    "function_name": "APPROX_TOP_K_ACCUMULATE",
    "summary": "Returns the Space-Saving summary at the end of aggregation.",
    "category": "Aggregate functions , Window function syntax and usage",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/approx_top_k_accumulate",
    "title": "APPROX_TOP_K_ACCUMULATE",
    "description": "Returns the Space-Saving summary at the end of aggregation. (For more\ninformation about the Space-Saving summary, see",
    "syntax": "APPROX_TOP_K_ACCUMULATE( <expr> , <counters> )",
    "example": "-- Create a sequence to use to generate values for the table.\nCREATE OR REPLACE SEQUENCE seq91;\nCREATE OR REPLACE TABLE sequence_demo (c1 INTEGER DEFAULT seq91.nextval, dummy SMALLINT);\nINSERT INTO sequence_demo (dummy) VALUES (0);\n\n-- Double the number of rows a few times, until there are 8 rows:\nINSERT INTO sequence_demo (dummy) SELECT dummy FROM sequence_demo;\nINSERT INTO sequence_demo (dummy) SELECT dummy FROM sequence_demo;\nINSERT INTO sequence_demo (dummy) SELECT dummy FROM sequence_demo;\n\nCREATE OR REPLACE TABLE resultstate1 AS (\n     SELECT approx_top_k_accumulate(c1, 50) AS rs1\n        FROM sequence_demo);\n\nCREATE OR REPLACE TABLE test_table2 (c1 INTEGER);\n-- Insert data.\nINSERT INTO test_table2 (c1) SELECT c1 + 4 FROM sequence_demo;\n\nCREATE OR REPLACE TABLE resultstate2 AS \n  (SELECT approx_top_k_accumulate(c1, 50) AS rs1 \n     FROM test_table2);\n\nCREATE OR REPLACE TABLE combined_resultstate (c1) AS \n  SELECT approx_top_k_combine(rs1) AS apc1\n    FROM (\n        SELECT rs1 FROM resultstate1\n        UNION ALL\n        SELECT rs1 FROM resultstate2\n      )\n      ;\n\nSELECT approx_top_k_estimate(c1, 4) FROM combined_resultstate;\n\n+------------------------------+\n| APPROX_TOP_K_ESTIMATE(C1, 4) |\n|------------------------------|\n| [                            |\n|   [                          |\n|     5,                       |\n|     2                        |\n|   ],                         |\n|   [                          |\n|     6,                       |\n|     2                        |\n|   ],                         |\n|   [                          |\n|     7,                       |\n|     2                        |\n|   ],                         |\n|   [                          |\n|     8,                       |\n|     2                        |\n|   ]                          |\n| ]                            |\n+------------------------------+",
    "arguments": [
        {
            "name": "expr",
            "description": "The expression (e.g. column name) for which you want to find the most common values."
        },
        {
            "name": "counters",
            "description": "This is the maximum number of distinct values that can be tracked at a time during the estimation process. For example, if counters is set to 100000, then the algorithm tracks 100,000 distinct values, attempting to keep the\n100,000 most frequent values. The maximum number of counters is 100000 (100,000)."
        }
    ]
},
{
    "function_name": "APPROX_TOP_K",
    "summary": "Uses Space-Saving to return an approximation of the most frequent values in the input, along with their approximate frequencies.",
    "category": "Aggregate functions , Window functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/approx_top_k",
    "title": "APPROX_TOP_K",
    "description": "Uses Space-Saving to return an approximation of the most frequent values in the input, along with their approximate frequencies.",
    "syntax": "APPROX_TOP_K( <expr> [ , <k> [ , <counters> ] ] )",
    "example": "SELECT APPROX_TOP_K(C4) FROM lineitem;\n\n+--------------------+\n| APPROX_TOP_K(C4,3) |\n+--------------------+\n| [                  |\n|   [                |\n|     1,             |\n|     124923         |\n|   ],               |\n|   [                |\n|     2,             |\n|     107093         |\n|   ],               |\n|   [                |\n|     3,             |\n|    89315           |\n|   ]                |\n| ]                  |\n+--------------------+\n\nWITH states AS (\n  SELECT approx_top_k(C4, 3, 5) AS state\n  FROM lineitem)\nSELECT value[0]::INT AS value, value[1]::INT AS frequency\n  FROM states, LATERAL FLATTEN(state);\n\n+-------+-----------+\n| VALUE | FREQUENCY |\n+-------+-----------+\n|     1 |    124923 |\n|     2 |    107093 |\n|     3 |     89438 |\n+-------+-----------+",
    "arguments": [
        {
            "name": "expr4",
            "description": "This is the optional expression used to group rows into partitions."
        }
    ]
},
{
    "function_name": "APPROX_PERCENTILE_ESTIMATE",
    "summary": "Returns the desired approximated percentile value for the specified t-Digest state.",
    "category": "Aggregate functions , Window function syntax and usage",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/approx_percentile_estimate",
    "title": "APPROX_PERCENTILE_ESTIMATE",
    "description": "Returns the desired approximated percentile value for the specified t-Digest state.",
    "syntax": "APPROX_PERCENTILE_ESTIMATE( <state> , <percentile> )",
    "arguments": [
        {
            "name": "state",
            "description": "An expression that contains state information generated\nby a call to APPROX_PERCENTILE_ACCUMULATE or APPROX_PERCENTILE_COMBINE ."
        },
        {
            "name": "percentile",
            "description": "A constant real value greater than or equal to 0.0 and less than 1.0 .\nThis indicates the percentile from 0 to 99.999… (e.g. the value 0.65 indicates the 65th percentile)."
        }
    ]
},
{
    "function_name": "APPROX_PERCENTILE_COMBINE",
    "summary": "Combines (merges) percentile input states into a single output state.",
    "category": "Aggregate functions , Window function syntax and usage",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/approx_percentile_combine",
    "title": "APPROX_PERCENTILE_COMBINE",
    "description": "Combines (merges) percentile input states into a single output state.",
    "syntax": "APPROX_PERCENTILE_COMBINE( <state> )",
    "arguments": [
        {
            "name": "state",
            "description": "An expression that contains state information generated\nby a call to APPROX_PERCENTILE_ACCUMULATE ."
        }
    ]
},
{
    "function_name": "APPROX_PERCENTILE_ACCUMULATE",
    "summary": "Returns the internal representation of the t-Digest state (as a JSON object) at the end of aggregation.",
    "category": "Aggregate functions , Window function syntax and usage",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/approx_percentile_accumulate",
    "title": "APPROX_PERCENTILE_ACCUMULATE",
    "description": "Returns the internal representation of the t-Digest state (as a JSON object) at the end of aggregation. (For more information about t-Digest, see:",
    "syntax": "APPROX_PERCENTILE_ACCUMULATE( <expr> )",
    "arguments": [
        {
            "name": "expr",
            "description": "A valid expression, such as a column name, that evaluates to a numeric\nvalue."
        }
    ]
},
{
    "function_name": "APPROX_PERCENTILE",
    "summary": "Returns an approximated value for the desired percentile (that is, if column c has n numbers, APPROX_PERCENTILE(c, p) returns a number such that approximately n * p of the numbers in c are smaller than the returned number).",
    "category": "Aggregate functions , Window functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/approx_percentile",
    "title": "APPROX_PERCENTILE",
    "description": "Returns an approximated value for the desired percentile (that is, if column",
    "syntax": "APPROX_PERCENTILE( <expr> , <percentile> )",
    "example": "CREATE TABLE testtable (c1 INTEGER);\nINSERT INTO testtable (c1) VALUES \n    (0),\n    (1),\n    (2),\n    (3),\n    (4),\n    (5),\n    (6),\n    (7),\n    (8),\n    (9),\n    (10);\n\nSELECT APPROX_PERCENTILE(c1, 0.1) FROM testtable;\n+----------------------------+\n| APPROX_PERCENTILE(C1, 0.1) |\n|----------------------------|\n|                        1.5 |\n+----------------------------+\n\nSELECT APPROX_PERCENTILE(c1, 0.5) FROM testtable;\n+----------------------------+\n| APPROX_PERCENTILE(C1, 0.5) |\n|----------------------------|\n|                        5.5 |\n+----------------------------+\n\nSELECT APPROX_PERCENTILE(c1, 0.999) FROM testtable;\n+------------------------------+\n| APPROX_PERCENTILE(C1, 0.999) |\n|------------------------------|\n|                         10.5 |\n+------------------------------+",
    "arguments": [
        {
            "name": "expr",
            "description": "A valid expression, such as a column name, that evaluates to a numeric value."
        },
        {
            "name": "percentile",
            "description": "A constant real value greater than or equal to 0.0 and less than 1.0 .\nThis indicates the percentile (from 0 to 99.999…).\nE.g. The value 0.65 indicates the 65th percentile."
        },
        {
            "name": "expr3",
            "description": "This is the optional expression used to group rows into partitions."
        }
    ],
    "returns": "The output is returned as a DOUBLE value."
},
{
    "function_name": "APPROX_COUNT_DISTINCT",
    "summary": "Uses HyperLogLog to return an approximation of the distinct cardinality of the input (i.e. HLL(col1, col2, ... ) returns an approximation of COUNT(DISTINCT col1, col2, ... )).",
    "category": "Aggregate functions , Window functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/approx_count_distinct",
    "title": "APPROX_COUNT_DISTINCT",
    "description": "Uses HyperLogLog to return an approximation of the distinct cardinality of the input (i.e.",
    "syntax": "APPROX_COUNT_DISTINCT( [ DISTINCT ] <expr1>  [ , ... ] )\n\nAPPROX_COUNT_DISTINCT(*)",
    "example": "SELECT COUNT(i), COUNT(DISTINCT i), APPROX_COUNT_DISTINCT(i), HLL(i)\n  FROM sequence_demo;\n\n+----------+-------------------+--------------------------+--------+\n| COUNT(I) | COUNT(DISTINCT I) | APPROX_COUNT_DISTINCT(I) | HLL(I) |\n|----------+-------------------+--------------------------+--------|\n|     1024 |              1024 |                     1007 |   1007 |\n+----------+-------------------+--------------------------+--------+",
    "arguments": [
        {
            "name": "expr1",
            "description": "This is the expression for which you want to know the number of distinct values."
        },
        {
            "name": "expr2",
            "description": "This is the optional expression used to group rows into partitions."
        },
        {
            "name": "*",
            "description": "Returns an approximation of the total number of records, excluding records with NULL values. When you pass a wildcard to the function, you can qualify the wildcard with the name or alias for the table.\nFor example, to pass in all of the columns from the table named mytable , specify the following: You can also use the ILIKE and EXCLUDE keywords for filtering: ILIKE filters for column names that match the specified pattern. Only one\npattern is allowed. For example: EXCLUDE filters out column names that don’t match the specified column or columns. For example: Qualifiers are valid when you use these keywords. The following example uses the ILIKE keyword to\nfilter for all of the columns that match the pattern col1% in the table mytable : The ILIKE and EXCLUDE keywords can’t be combined in a single function call. For this function, the ILIKE and EXCLUDE keywords are valid only in a SELECT list or GROUP BY clause. For more information about the ILIKE and EXCLUDE keywords, see the “Parameters” section in SELECT ."
        }
    ],
    "returns": "The data type of the returned value is INTEGER."
},
{
    "function_name": "APPLICATION_JSON",
    "summary": "Returns a JSON object that specifies the JSON message to use for a notification.",
    "category": "Notification functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/application_json",
    "title": "APPLICATION_JSON",
    "description": "Returns a JSON object that specifies the JSON message to use for a notification. This is a helper function that you use to\nconstruct a message object for the",
    "syntax": "SNOWFLAKE.NOTIFICATION.APPLICATION_JSON( '<message>' )",
    "arguments": [
        {
            "name": "'",
            "description": "Content of the message to send. You do not need to escape the double quotes around strings within the message (for example, double quotes around the keys\nand values). The function escapes these double quotes for you."
        }
    ],
    "returns": "A JSON-formatted string that specifies a message for the\nSYSTEM$SEND_SNOWFLAKE_NOTIFICATION stored procedure to send."
},
{
    "function_name": "ANY_VALUE",
    "summary": "Returns some value of the expression from the group.",
    "category": "Aggregate functions , Window functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/any_value",
    "title": "ANY_VALUE",
    "description": "Returns some value of the expression from the group. The result is non-deterministic.",
    "syntax": "ANY_VALUE( [ DISTINCT ] <expr1> )",
    "arguments": [
        {
            "name": "expr1",
            "description": "The input expression."
        },
        {
            "name": "expr2",
            "description": "The column to partition on, if you want the result to be split into multiple\npartitions."
        }
    ],
    "returns": "This function can return a value of any data type."
},
{
    "function_name": "ALL_USER_NAMES",
    "summary": "Returns all user names in the current account.",
    "category": "Context functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/all_user_names",
    "title": "ALL_USER_NAMES",
    "description": "Returns all user names in the current account.",
    "syntax": "ALL_USER_NAMES()",
    "example": "select all_user_names();\n\n+---------------------------+\n| ALL_USER_NAMES()          |\n+---------------------------+\n| [ \"user1\", \"user2\", ... ] |\n+---------------------------+",
    "returns": "The data type of the returned value is ARRAY."
},
{
    "function_name": "ALERT_HISTORY",
    "summary": "This INFORMATION_SCHEMA table function can be used to query the history of alerts within a specified date range.",
    "category": "Information Schema , Table functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/alert_history",
    "title": "ALERT_HISTORY",
    "description": "This INFORMATION_SCHEMA table function can be used to query the history of",
    "syntax": "ALERT_HISTORY(\n      [ SCHEDULED_TIME_RANGE_START => <constant_expr> ]\n      [, SCHEDULED_TIME_RANGE_END => <constant_expr> ]\n      [, RESULT_LIMIT => <integer> ]\n      [, ALERT_NAME => '<string>' ] )",
    "arguments": [
        {
            "name": "SCHEDULED_TIME_RANGE_START",
            "description": "Time range (in TIMESTAMP_LTZ format), within the last 7 days, in which the evaluation of the condition for the alert was\nscheduled. If SCHEDULED_TIME_RANGE_END is not specified, the function returns those alerts that have already completed, are\ncurrently running, or are scheduled in the future. If SCHEDULED_TIME_RANGE_END is CURRENT_TIMESTAMP , the function returns those alerts\nthat have already completed or are currently running. Note that an alert that is executed immediately prior to the current\ntime may still be identified as scheduled. Note If no start or end time is specified, the most recent alerts are returned, up to the specified RESULT_LIMIT value. If the time range does not fall within the last 7 days, an error is returned."
        },
        {
            "name": "RESULT_LIMIT",
            "description": "A number specifying the maximum number of rows returned by the function. If the number of matching rows is greater than this limit, the alert executions with the most recent timestamp are returned, up\nto the specified limit. Range: 1 to 10000 Default: 100 ."
        },
        {
            "name": "ALERT_NAME",
            "description": "A case-insensitive string specifying an alert. Only non-qualified alert names are supported. Only executions of the specified\nalert are returned. Note that if multiple alerts have the same name, the function returns the history for each of these alerts."
        }
    ]
},
{
    "function_name": "AI_SUMMARIZE_AGG",
    "summary": "Summarizes a column of text data.",
    "category": "Aggregate functions , String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/ai_summarize_agg",
    "title": "AI_SUMMARIZE_AGG",
    "syntax": "AI_SUMMARIZE_AGG( <expr> )",
    "example": "SELECT AI_SUMMARIZE_AGG('[Excellent, Great, Mediocre]');\n\nThe text discusses rating options, specifically mentioning three categories: Excellent, Great, and Mediocre.\n\nWITH reviews AS (\n            SELECT 'Excellent' AS review\n  UNION ALL SELECT 'Excellent'\n  UNION ALL SELECT 'Great'\n  UNION ALL SELECT 'Mediocre'\n)\nSELECT AI_SUMMARIZE_AGG(review)\n  FROM reviews;\n\nA product or service received a total of 4 ratings, with 2 being \"Excellent\", 1 being \"Great\", and 1 being \"Mediocre\".\n\nWITH reviews AS (\n            SELECT 1 AS product_id, 'Excellent' AS review\n  UNION ALL SELECT 1, 'Excellent'\n  UNION ALL SELECT 1, 'Great'\n  UNION ALL SELECT 1, 'Mediocre'\n  UNION ALL SELECT 2, 'Terrible'\n  UNION ALL SELECT 2, 'Bad'\n)\nSELECT product_id,\n       AI_SUMMARIZE_AGG(review) AS summarized_review\n  FROM reviews\n GROUP BY 1;\n\n+------------+------------------------------------------------------------------------------------------------------------------------+\n| PRODUCT_ID | SUMMARIZED_REVIEW                                                                                                      |\n|------------+------------------------------------------------------------------------------------------------------------------------+\n| 1          | A product or service received a total of 4 ratings, with 2 being \"Excellent\", 1 being \"Great\", and 1 being \"Mediocre\". |\n+------------+------------------------------------------------------------------------------------------------------------------------+\n| 2          | The text expresses a strong negative sentiment, conveying a terrible and bad experience or opinion.                    |\n+------------+------------------------------------------------------------------------------------------------------------------------+",
    "arguments": [
        {
            "name": "expr",
            "description": "This is an expression that contains text for summarization, such as restaurant reviews or phone transcripts."
        }
    ],
    "returns": "Returns a string summary of the expression."
},
{
    "function_name": "AI_SIMILARITY",
    "summary": "Computes a similarity score based on the vector cosine similarity value of the inputs’ embedding vectors.",
    "category": "",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/ai_similarity",
    "title": "AI_SIMILARITY",
    "syntax": "AI_SIMILARITY( <input1>, <input2> )",
    "example": "SELECT AI_SIMILARITY('I like this dish', 'This dish is very good');\n\nSELECT\n    review\nFROM restaurant_reviews\nORDER BY AI_SIMILARITY(review, 'I love the food here!');\n\nSELECT AI_SIMILARITY(TO_FILE('@file_stage', 'cat.jpg'), TO_FILE('@file_stage', '2cats.jpg'));\n\nSELECT\n    to_file('@file_stage', relative_path)\nFROM directory(@file_stage)\nWHERE AI_SIMILARITY(f, to_file(@file_stage, 'cat.jpg')) >= 0.5;",
    "arguments": [
        {
            "name": "input1",
            "description": "The strings with the text that you’re comparing and using to compute the similarity score."
        },
        {
            "name": "input1",
            "description": "FILE data type referencing the images to be compared."
        },
        {
            "name": "config_object",
            "description": "An OBJECT containing key-value pairs used to configure the model."
        }
    ],
    "returns": "Returns a float value of range -1 to 1 that represents the similarity score computed using vector similarity between two embedding vectors for the inputs."
},
{
    "function_name": "AI_FILTER",
    "summary": "Classifies free-form prompt inputs into a boolean.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/ai_filter",
    "title": "AI_FILTER",
    "syntax": "AI_FILTER( <input> )",
    "example": "SELECT AI_FILTER('Is Canada in North America?');\n\nTRUE\n\nWITH reviews AS (\n            SELECT 'Wow... Loved this place.' AS review\n  UNION ALL SELECT 'The pizza is not good.'\n)\nSELECT * FROM reviews\nWHERE AI_FILTER(CONCAT('The reviewer enjoyed the restaurant: ', review));\n\nWITH reviews AS (\n\nSELECT 'Wow... Loved this place.' AS review\nUNION ALL SELECT 'The pizza is not good.'\n)\nSELECT * FROM reviews\nWHERE AI_FILTER(PROMPT('The reviewer enjoyed the restaurant: {0}', review));\n\n+--------------------------+\n| REVIEW                   |\n|--------------------------+\n| Wow... Loved this place. |\n+--------------------------+\n\nWITH country AS (\n          SELECT 'Switzerland' AS country,\nUNION ALL SELECT 'Korea'\n),\nregion AS (\n            SELECT 'Asia' AS region,\n  UNION ALL SELECT 'Europe'\n)\nSELECT country,\n      region,\n      AI_FILTER(PROMPT('{0} is in {1}', country, region)) AS result\nFROM country CROSS JOIN region ;\n\n+-------------+-------+--------+\n| COUNTRY     |REGION | RESULT |\n|-------------+-------+--------+\n| Switzerland |Europe | TRUE   |\n|-------------+-------+--------+\n| Switzerland | Asia  | FALSE  |\n|-------------+-------+--------+\n| Korea       |Europe | FALSE  |\n+-------------+-------+--------+\n| Korea       | Asia  | TRUE   |\n+-------------+-------+--------+\n\nSELECT *\nFROM RESUMES\nJOIN JOBS\nON AI_FILTER(PROMPT('Evaluate if this resume {0} fits this job description {1}', RESUME.contents, JOBS.jd));\n\nWITH pictures AS (\n  SELECT\n      TO_FILE(file_url) AS img\n  FROM DIRECTORY(@file_stage)\n)\nSELECT\nFL_GET_RELATIVE_PATH(img) AS file_path FROM pictures\nWHERE AI_FILTER('Is this a picture of a cat?', img);\n\nWITH pictures AS (\n  SELECT\n      TO_FILE(file_url) AS img\n  FROM DIRECTORY(@file_stage)\n)\nSELECT\n    FL_GET_RELATIVE_PATH(img) AS file_path FROM pictures\nWHERE AI_FILTER(PROMPT('{0} is a cat picture', img));\n\n+--------------------------+\n|        FILE_PATH         |\n|--------------------------+\n|        2cats.jpg         |\n+--------------------------+\n|        cat1.png          |\n+--------------------------+\n|      orange_cat.jpg      |\n+--------------------------+",
    "arguments": [
        {
            "name": "input",
            "description": "A string containing the text to be classified."
        },
        {
            "name": "predicate",
            "description": "A string containing the instructions to classify the file input as either TRUE or FALSE ."
        },
        {
            "name": "file",
            "description": "The column that the file is classified by based on the instructions specified in predicate .\nYou can use IMAGE FILE as an input to the AI_FILTER function."
        }
    ],
    "returns": "Returns a Boolean value that indicates whether the statement evaluates to TRUE or FALSE for the specified text."
},
{
    "function_name": "ZIPF",
    "summary": "Returns a Zipf-distributed integer, for N elements and characteristic exponent s.",
    "category": "Data generation functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/zipf",
    "title": "ZIPF",
    "description": "Returns a Zipf-distributed integer, for",
    "syntax": "ZIPF( <s> , <N> , <gen> )",
    "example": "SELECT zipf(1, 10, random()) FROM table(generator(rowCount => 10));\n\n+-----------------------+\n| ZIPF(1, 10, RANDOM()) |\n|-----------------------|\n|                     9 |\n|                     7 |\n|                     1 |\n|                     8 |\n|                     8 |\n|                     2 |\n|                     3 |\n|                     8 |\n|                     2 |\n|                     5 |\n+-----------------------+\n\nSELECT zipf(1, 10, 1234) FROM table(generator(rowCount => 10));\n\n+-------------------+\n| ZIPF(1, 10, 1234) |\n|-------------------|\n|                 4 |\n|                 4 |\n|                 4 |\n|                 4 |\n|                 4 |\n|                 4 |\n|                 4 |\n|                 4 |\n|                 4 |\n|                 4 |\n+-------------------+"
},
{
    "function_name": "ZEROIFNULL",
    "summary": "Returns 0 if its argument is null; otherwise, returns its argument.",
    "category": "Conditional expression functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/zeroifnull",
    "title": "ZEROIFNULL",
    "description": "Returns 0 if its argument is null; otherwise, returns its argument.",
    "syntax": "ZEROIFNULL( <expr> )",
    "example": "SELECT column1, ZEROIFNULL(column1) \n    FROM VALUES (1), (null), (5), (0), (3.14159);\n+---------+---------------------+\n| COLUMN1 | ZEROIFNULL(COLUMN1) |\n|---------+---------------------|\n| 1.00000 |             1.00000 |\n|    NULL |             0.00000 |\n| 5.00000 |             5.00000 |\n| 0.00000 |             0.00000 |\n| 3.14159 |             3.14159 |\n+---------+---------------------+",
    "arguments": [
        {
            "name": "expr",
            "description": "The input should be an expression that evaluates to a numeric value (or NULL)."
        }
    ],
    "returns": "If the value of the input expressions is NULL, this returns 0.\nOtherwise, this returns the value of the input expression."
},
{
    "function_name": "YEAR* / DAY* / WEEK* / MONTH / QUARTER",
    "summary": "Extracts the corresponding date part from a date or timestamp.",
    "category": "Date & time functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/year",
    "title": "YEAR* / DAY* / WEEK* / MONTH / QUARTER",
    "description": "Extracts the corresponding date part from a date or timestamp.",
    "syntax": "YEAR( <date_or_timestamp_expr> )\n\nYEAROFWEEK( <date_or_timestamp_expr> )\nYEAROFWEEKISO( <date_or_timestamp_expr> )\n\nDAY( <date_or_timestamp_expr> )\n\nDAYOFMONTH( <date_or_timestamp_expr> )\nDAYOFWEEK( <date_or_timestamp_expr> )\nDAYOFWEEKISO( <date_or_timestamp_expr> )\nDAYOFYEAR( <date_or_timestamp_expr> )\n\nWEEK( <date_or_timestamp_expr> )\n\nWEEKOFYEAR( <date_or_timestamp_expr> )\nWEEKISO( <date_or_timestamp_expr> )\n\nMONTH( <date_or_timestamp_expr> )\n\nQUARTER( <date_or_timestamp_expr> )",
    "example": "SELECT '2025-04-11T23:39:20.123-07:00'::TIMESTAMP AS tstamp,\n       YEAR(tstamp) AS \"YEAR\",\n       QUARTER(tstamp) AS \"QUARTER OF YEAR\",\n       MONTH(tstamp) AS \"MONTH\",\n       DAY(tstamp) AS \"DAY\",\n       DAYOFMONTH(tstamp) AS \"DAY OF MONTH\",\n       DAYOFYEAR(tstamp) AS \"DAY OF YEAR\";\n\n+-------------------------+------+-----------------+-------+-----+--------------+-------------+\n| TSTAMP                  | YEAR | QUARTER OF YEAR | MONTH | DAY | DAY OF MONTH | DAY OF YEAR |\n|-------------------------+------+-----------------+-------+-----+--------------+-------------|\n| 2025-04-11 23:39:20.123 | 2025 |               2 |     4 |  11 |           11 |         101 |\n+-------------------------+------+-----------------+-------+-----+--------------+-------------+\n\nALTER SESSION SET WEEK_OF_YEAR_POLICY = 1;\n\nSELECT '2016-01-02T23:39:20.123-07:00'::TIMESTAMP AS tstamp,\n       WEEK(tstamp) AS \"WEEK\",\n       WEEKISO(tstamp) AS \"WEEK ISO\",\n       WEEKOFYEAR(tstamp) AS \"WEEK OF YEAR\",\n       YEAROFWEEK(tstamp) AS \"YEAR OF WEEK\",\n       YEAROFWEEKISO(tstamp) AS \"YEAR OF WEEK ISO\";\n\n+-------------------------+------+----------+--------------+--------------+------------------+\n| TSTAMP                  | WEEK | WEEK ISO | WEEK OF YEAR | YEAR OF WEEK | YEAR OF WEEK ISO |\n|-------------------------+------+----------+--------------+--------------+------------------|\n| 2016-01-02 23:39:20.123 |    1 |       53 |            1 |         2016 |             2015 |\n+-------------------------+------+----------+--------------+--------------+------------------+\n\nALTER SESSION SET WEEK_OF_YEAR_POLICY = 0;\n\nSELECT '2016-01-02T23:39:20.123-07:00'::TIMESTAMP AS tstamp,\n       WEEK(tstamp) AS \"WEEK\",\n       WEEKISO(tstamp) AS \"WEEK ISO\",\n       WEEKOFYEAR(tstamp) AS \"WEEK OF YEAR\",\n       YEAROFWEEK(tstamp) AS \"YEAR OF WEEK\",\n       YEAROFWEEKISO(tstamp) AS \"YEAR OF WEEK ISO\";\n\n+-------------------------+------+----------+--------------+--------------+------------------+\n| TSTAMP                  | WEEK | WEEK ISO | WEEK OF YEAR | YEAR OF WEEK | YEAR OF WEEK ISO |\n|-------------------------+------+----------+--------------+--------------+------------------|\n| 2016-01-02 23:39:20.123 |   53 |       53 |           53 |         2015 |             2015 |\n+-------------------------+------+----------+--------------+--------------+------------------+\n\nALTER SESSION SET WEEK_START = 7;\n\nSELECT '2025-04-05T23:39:20.123-07:00'::TIMESTAMP AS tstamp,\n       DAYOFWEEK(tstamp) AS \"DAY OF WEEK\",\n       DAYOFWEEKISO(tstamp) AS \"DAY OF WEEK ISO\";\n\n+-------------------------+-------------+-----------------+\n| TSTAMP                  | DAY OF WEEK | DAY OF WEEK ISO |\n|-------------------------+-------------+-----------------|\n| 2025-04-05 23:39:20.123 |           7 |               6 |\n+-------------------------+-------------+-----------------+\n\nALTER SESSION SET WEEK_START = 1;\n\nSELECT '2025-04-05T23:39:20.123-07:00'::TIMESTAMP AS tstamp,\n       DAYOFWEEK(tstamp) AS \"DAY OF WEEK\",\n       DAYOFWEEKISO(tstamp) AS \"DAY OF WEEK ISO\";\n\n+-------------------------+-------------+-----------------+\n| TSTAMP                  | DAY OF WEEK | DAY OF WEEK ISO |\n|-------------------------+-------------+-----------------|\n| 2025-04-05 23:39:20.123 |           6 |               6 |\n+-------------------------+-------------+-----------------+",
    "arguments": [
        {
            "name": "date_or_timestamp_expr",
            "description": "A date or a timestamp, or an expression that can be evaluated to a date or a timestamp."
        }
    ],
    "returns": "This function returns a value of type NUMBER."
},
{
    "function_name": "XMLGET",
    "summary": "Extracts an XML element object (often referred to as simply a tag) from the content of the outer XML element based on the name and instance number of the specified tag.",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/xmlget",
    "title": "XMLGET",
    "description": "Extracts an",
    "syntax": "XMLGET( <expression> , <tag_name> [ , <instance_number> ] )",
    "example": "CREATE OR REPLACE TABLE xml_demo (id INTEGER, object_col OBJECT);\n\nINSERT INTO xml_demo (id, object_col)\n  SELECT 1001,\n    PARSE_XML('<level1> 1 <level2> 2 <level3> 3A </level3> <level3> 3B </level3> </level2> </level1>');\n\nSELECT object_col,\n       XMLGET(object_col, 'level2'),\n       XMLGET(XMLGET(object_col, 'level2'), 'level3', 1)\n  FROM xml_demo;\n\n+-------------------------+------------------------------+---------------------------------------------------+\n| OBJECT_COL              | XMLGET(OBJECT_COL, 'LEVEL2') | XMLGET(XMLGET(OBJECT_COL, 'LEVEL2'), 'LEVEL3', 1) |\n|-------------------------+------------------------------+---------------------------------------------------|\n| <level1>                | <level2>                     | <level3>3B</level3>                               |\n|   1                     |   2                          |                                                   |\n|   <level2>              |   <level3>3A</level3>        |                                                   |\n|     2                   |   <level3>3B</level3>        |                                                   |\n|     <level3>3A</level3> | </level2>                    |                                                   |\n|     <level3>3B</level3> |                              |                                                   |\n|   </level2>             |                              |                                                   |\n| </level1>               |                              |                                                   |\n+-------------------------+------------------------------+---------------------------------------------------+\n\nSELECT object_col,\n       GET(XMLGET(object_col, 'level2'), '$') AS content_of_element\n  FROM xml_demo;\n\n+-------------------------+--------------------+\n| OBJECT_COL              | CONTENT_OF_ELEMENT |\n|-------------------------+--------------------|\n| <level1>                | [                  |\n|   1                     |   2,               |\n|   <level2>              |   {                |\n|     2                   |     \"$\": \"3A\",     |\n|     <level3>3A</level3> |     \"@\": \"level3\"  |\n|     <level3>3B</level3> |   },               |\n|   </level2>             |   {                |\n| </level1>               |     \"$\": \"3B\",     |\n|                         |     \"@\": \"level3\"  |\n|                         |   }                |\n|                         | ]                  |\n+-------------------------+--------------------+\n\nINSERT INTO xml_demo (id, object_col)\n  SELECT 1002,\n      PARSE_XML('<level1> 1 <level2 an_attribute=\"my attribute\"> 2 </level2> </level1>');\n\nSELECT object_col,\n       GET(XMLGET(object_col, 'level2'), '@an_attribute') AS attribute\n  FROM xml_demo\n  WHERE ID = 1002;\n\n+--------------------------------------------------+----------------+\n| OBJECT_COL                                       | ATTRIBUTE      |\n|--------------------------------------------------+----------------|\n| <level1>                                         | \"my attribute\" |\n|   1                                              |                |\n|   <level2 an_attribute=\"my attribute\">2</level2> |                |\n| </level1>                                        |                |\n+--------------------------------------------------+----------------+",
    "arguments": [
        {
            "name": "expression",
            "description": "The expression from which to extract the element. The expression must evaluate to an OBJECT (or a VARIANT containing an OBJECT). The OBJECT must contain\nvalid XML in the internal format that Snowflake supports. Typically, that means that the OBJECT was produced by one of the\nfollowing: Calling the PARSE_XML function. Loading the data (e.g. via the COPY INTO <table> command) and specifying that the data is in XML\nformat. The XMLGET function does not operate directly on a VARCHAR expression even if that VARCHAR contains valid XML text."
        },
        {
            "name": "tag_name",
            "description": "The name of an XML tag stored in the expression ."
        },
        {
            "name": "instance_number",
            "description": "If the XML contains multiple instances of tag_name , then use instance_number to specify which instance to\nretrieve. Like an array index, the instance_number is 0-based, not 1-based. instance_number can be omitted, in which case the default value 0 is used."
        }
    ],
    "returns": "The data type of the returned value is OBJECT."
},
{
    "function_name": "WIDTH_BUCKET",
    "summary": "Constructs equi-width histograms, in which the histogram range is divided into intervals of identical size, and returns the bucket number into which the value of an expression falls, after it has been evaluated.",
    "category": "Numeric functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/width_bucket",
    "title": "WIDTH_BUCKET",
    "description": "Constructs equi-width histograms, in which the histogram range is divided into intervals of identical size, and returns the bucket number into which the value of an expression falls, after\nit has been evaluated. The function returns an integer value or null (if any input is null).",
    "syntax": "WIDTH_BUCKET( <expr> , <min_value> , <max_value> , <num_buckets> )",
    "arguments": [
        {
            "name": "expr",
            "description": "The expression for which the histogram is created. This expression must evaluate to a numeric value or to a value that can be implicitly converted to a numeric value. The value must be within the range of -(2^53 - 1) to 2^53 - 1 (inclusive)."
        },
        {
            "name": "min_value",
            "description": "The low and high end points of the acceptable range for the expression. The end points must also evaluate to numeric values and not be equal. The low and high end points must be within the range of -(2^53 - 1) to 2^53 - 1 (inclusive). In addition, the difference\nbetween these points must be less than 2^53 (i.e. abs( max_value - min_value ) < 2^53 )."
        },
        {
            "name": "num_buckets",
            "description": "The desired number of buckets; must be a positive integer value. A value from the expression is assigned to each bucket, and the function then returns the corresponding bucket number. When an expression falls outside the range, the function returns: 0 if the expression is less than min_value . num_buckets + 1 if the expression is greater than or equal to max_value ."
        }
    ]
},
{
    "function_name": "WAREHOUSE_METERING_HISTORY",
    "summary": "This table function can be used in queries to return the hourly credit usage for a single warehouse (or all the warehouses in your account) within a specified date range.",
    "category": "Information Schema , Table functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/warehouse_metering_history",
    "title": "WAREHOUSE_METERING_HISTORY",
    "description": "This table function can be used in queries to return the hourly credit usage for a single warehouse (or all the warehouses in your account) within a specified date range.",
    "syntax": "WAREHOUSE_METERING_HISTORY(\n      DATE_RANGE_START => <constant_expr>\n      [ , DATE_RANGE_END => <constant_expr> ]\n      [ , WAREHOUSE_NAME => '<string>' ] )",
    "example": "select *\nfrom table(information_schema.warehouse_metering_history(dateadd('days',-10,current_date())));\n\nselect *\nfrom table(information_schema.warehouse_metering_history('2017-10-23', '2017-10-23', 'testingwh'));",
    "arguments": [
        {
            "name": "DATE_RANGE_START",
            "description": "The starting date, within the last 6 months, for which warehouse usage is returned."
        },
        {
            "name": "DATE_RANGE_END",
            "description": "The ending date, within the last 6 months, for which warehouse usage is returned. Default: CURRENT_DATE is used."
        },
        {
            "name": "WAREHOUSE_NAME",
            "description": "The name of the warehouse to retrieve credit usage for. Note that the warehouse name must be enclosed in single quotes. Also, if the warehouse name any spaces, mixed-case characters,\nor special characters, the name must be double-quoted within the single quotes (e.g. '\"My Warehouse\"' vs 'mywarehouse' ). Default: All warehouses that ran during the specified date range."
        }
    ]
},
{
    "function_name": "WAREHOUSE_LOAD_HISTORY",
    "summary": "This table function can be used to query the activity history (defined as the “query load”) for a single warehouse within a specified date range.",
    "category": "Information Schema , Table functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/warehouse_load_history",
    "title": "WAREHOUSE_LOAD_HISTORY",
    "description": "This table function can be used to query the activity history (defined as the “query load”) for a single warehouse within a specified date range.",
    "syntax": "WAREHOUSE_LOAD_HISTORY(\n      [ DATE_RANGE_START => <constant_expr> ]\n      [, DATE_RANGE_END => <constant_expr> ]\n      [, WAREHOUSE_NAME => '<string>' ] )",
    "example": "use warehouse mywarehouse;\n\nselect *\nfrom table(information_schema.warehouse_load_history(date_range_start=>dateadd('hour',-1,current_timestamp())));\n\nuse warehouse mywarehouse;\n\nselect *\nfrom table(information_schema.warehouse_load_history(date_range_start=>dateadd('day',-14,current_date()), date_range_end=>current_date()));",
    "arguments": [
        {
            "name": "DATE_RANGE_START",
            "description": "The date range, within the last 14 days, for which to retrieve warehouse load history data: If an end date is not specified, then CURRENT_DATE is used as the end of the range. If a start date is not specified, then the range starts 10 minutes prior to the start of DATE_RANGE_END (i.e. the default is to show the previous 10 minutes of load history). For example,\nif DATE_RANGE_END is CURRENT_DATE , then the default DATE_RANGE_START is 11:50 PM on the previous day. If the range falls outside the last 15 days, an error is returned. Note If the selected period is less than 8 hours, load is shown in 5-second intervals; otherwise, 5-minute intervals are used."
        },
        {
            "name": "WAREHOUSE_NAME",
            "description": "The name of the warehouse to retrieve usage load history for. Note that the warehouse name must be enclosed in single quotes. Also, if the warehouse name contains any spaces, mixed-case characters,\nor special characters, the name must be double-quoted within the single quotes (e.g. '\"My Warehouse\"' vs 'mywarehouse' ). Default: CURRENT_WAREHOUSE"
        }
    ]
},
{
    "function_name": "VECTOR_L2_DISTANCE",
    "summary": "Computes the L2 distance between two vectors.",
    "category": "Vector similarity functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/vector_l2_distance",
    "title": "VECTOR_L2_DISTANCE",
    "description": "Computes the L2 distance between two",
    "syntax": "VECTOR_L2_DISTANCE( <vector>, <vector> )",
    "example": "CREATE TABLE vectors (a VECTOR(FLOAT, 3), b VECTOR(FLOAT, 3));\nINSERT INTO vectors SELECT [1.1,2.2,3]::VECTOR(FLOAT,3), [1,1,1]::VECTOR(FLOAT,3);\nINSERT INTO vectors SELECT [1,2.2,3]::VECTOR(FLOAT,3), [4,6,8]::VECTOR(FLOAT,3);\n\n-- Compute the pairwise inner product between columns a and b\nSELECT VECTOR_L2_DISTANCE(a, b) FROM vectors;\n\n+------+\n| 2.3  |\n|------|\n| 6.95 |\n+------+",
    "arguments": [
        {
            "name": "vector",
            "description": "The VECTOR value to calculate the distance from."
        },
        {
            "name": "vector",
            "description": "The VECTOR value to calculate the distance to."
        }
    ],
    "returns": "Returns the distance between the two input vectors as a FLOAT value."
},
{
    "function_name": "VECTOR_L1_DISTANCE",
    "summary": "Computes the L1 distance between two vectors.",
    "category": "Vector similarity functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/vector_l1_distance",
    "title": "VECTOR_L1_DISTANCE",
    "description": "Computes the L1 distance between two",
    "syntax": "VECTOR_L1_DISTANCE( <vector>, <vector> )",
    "example": "CREATE TABLE vectors (a VECTOR(FLOAT, 3), b VECTOR(FLOAT, 3));\nINSERT INTO vectors SELECT [1.1,2.2,3]::VECTOR(FLOAT,3), [1,1,1]::VECTOR(FLOAT,3);\nINSERT INTO vectors SELECT [1,2.2,3]::VECTOR(FLOAT,3), [4,6,8]::VECTOR(FLOAT,3);\n\nSELECT VECTOR_L1_DISTANCE(a, b) FROM vectors;\n\n+--------------+\n| 3.300000191  |\n|--------------|\n| 11.800000191 |\n+--------------+",
    "arguments": [
        {
            "name": "vector",
            "description": "The VECTOR value to calculate the distance from."
        },
        {
            "name": "vector",
            "description": "The VECTOR value to calculate the distance to."
        }
    ],
    "returns": "Returns the L1 distance between the two input vectors as a FLOAT value."
},
{
    "function_name": "VECTOR_INNER_PRODUCT",
    "summary": "Computes the inner product of two vectors.",
    "category": "Vector similarity functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/vector_inner_product",
    "title": "VECTOR_INNER_PRODUCT",
    "description": "Computes the inner product of two",
    "syntax": "VECTOR_INNER_PRODUCT( <vector>, <vector> )",
    "example": "CREATE TABLE vectors (a VECTOR(FLOAT, 3), b VECTOR(FLOAT, 3));\nINSERT INTO vectors SELECT [1.1,2.2,3]::VECTOR(FLOAT,3), [1,1,1]::VECTOR(FLOAT,3);\nINSERT INTO vectors SELECT [1,2.2,3]::VECTOR(FLOAT,3), [4,6,8]::VECTOR(FLOAT,3);\n\n-- Compute the pairwise inner product between columns a and b\nSELECT VECTOR_INNER_PRODUCT(a, b) FROM vectors;\n\n+------+\n| 6.3  |\n|------|\n| 41.2 |\n+------+",
    "arguments": [
        {
            "name": "vector",
            "description": "First VECTOR value."
        },
        {
            "name": "vector",
            "description": "Second VECTOR value."
        }
    ],
    "returns": "Returns a VECTOR that is the inner product of the two vectors given as inputs."
},
{
    "function_name": "VECTOR_COSINE_SIMILARITY",
    "summary": "Computes the cosine similarity between two vectors.",
    "category": "Vector similarity functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/vector_cosine_similarity",
    "title": "VECTOR_COSINE_SIMILARITY",
    "description": "Computes the cosine similarity between two",
    "syntax": "VECTOR_COSINE_SIMILARITY( <vector>, <vector> )",
    "example": "SELECT a, VECTOR_COSINE_SIMILARITY(a, [1,2,3]::VECTOR(FLOAT, 3)) AS similarity\n  FROM vectors\n  ORDER BY similarity DESC\n  LIMIT 1;\n\n+-------------------------+\n| [1, 2.2, 3] | 0.9990... |\n+-------------------------+",
    "arguments": [
        {
            "name": "vector",
            "description": "The VECTOR value to calculate the angle from."
        },
        {
            "name": "vector",
            "description": "The VECTOR value to calculate the angle to."
        }
    ],
    "returns": "Returns a FLOAT value in the interval [-1, 1], which indicates the\ncosine similarity between the two input vectors."
},
{
    "function_name": "VARIANCE_POP",
    "summary": "Returns the population variance of non-NULL records in a group.",
    "category": "Aggregate functions , Window function syntax and usage",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/variance_pop",
    "title": "VARIANCE_POP",
    "description": "Returns the population variance of non-NULL records in a group. If all records inside a group are NULL, a NULL is returned.",
    "syntax": "VARIANCE_POP( [ DISTINCT ] <expr1> )",
    "arguments": [
        {
            "name": "expr1",
            "description": "The expr1 should evaluate to one of the numeric data types."
        },
        {
            "name": "expr2",
            "description": "This is the optional expression to partition by."
        },
        {
            "name": "expr3",
            "description": "This is the optional expression to order by within each partition."
        }
    ],
    "returns": "The data type of the returned value is NUMBER(<precision>, <scale>). The scale depends upon the values being processed."
},
{
    "function_name": "VARIANCE , VARIANCE_SAMP",
    "summary": "Returns the sample variance of non-NULL records in a group.",
    "category": "Aggregate functions , Window function syntax and usage",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/variance",
    "title": "VARIANCE , VARIANCE_SAMP",
    "description": "Returns the sample variance of non-NULL records in a group. If all records inside a group are NULL, a NULL is returned.",
    "syntax": "VARIANCE( [ DISTINCT ] <expr1> )",
    "arguments": [
        {
            "name": "expr1",
            "description": "The expr1 should evaluate to one of the numeric data types."
        },
        {
            "name": "expr2",
            "description": "This is the expression to partition by."
        },
        {
            "name": "expr3",
            "description": "This is the expression to order by within each partition."
        }
    ],
    "returns": "The data type of the returned value is NUMBER(<precision>, <scale>). The scale depends upon the values being processed."
},
{
    "function_name": "VAR_SAMP",
    "summary": "Returns the sample variance of non-NULL records in a group.",
    "category": "Aggregate functions , Window function syntax and usage",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/var_samp",
    "title": "VAR_SAMP",
    "description": "Returns the sample variance of non-NULL records in a group. If all records inside a group are NULL, a NULL is returned.",
    "syntax": "VAR_SAMP( [DISTINCT] <expr1> )",
    "example": "create table aggr(k int, v decimal(10,2), v2 decimal(10, 2));\ninsert into aggr values \n   (1, 10, null),\n   (2, 10, 11), \n   (2, 20, 22), \n   (2, 25, null), \n   (2, 30, 35);\n\nSELECT k, var_samp(v), var_samp(v2) \n    FROM aggr \n    GROUP BY k\n    ORDER BY k;\n+---+---------------+----------------+\n| K |   VAR_SAMP(V) |   VAR_SAMP(V2) |\n|---+---------------+----------------|\n| 1 |          NULL |           NULL |\n| 2 | 72.9166666667 | 144.3333333333 |\n+---+---------------+----------------+",
    "arguments": [
        {
            "name": "expr1",
            "description": "The expr1 should evaluate to one of the numeric data types."
        },
        {
            "name": "expr2",
            "description": "This is the expression to partition by."
        },
        {
            "name": "expr3",
            "description": "This is the expression to order by within each partition."
        }
    ],
    "returns": "The data type of the returned value is NUMBER(<precision>, <scale>). The scale depends upon the values being processed."
},
{
    "function_name": "VAR_POP",
    "summary": "Returns the population variance of non-NULL records in a group.",
    "category": "Aggregate functions , Window function syntax and usage",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/var_pop",
    "title": "VAR_POP",
    "description": "Returns the population variance of non-NULL records in a group. If all records inside a group are NULL, a NULL is returned.",
    "syntax": "VAR_POP( [ DISTINCT ] <expr1> )",
    "example": "create table aggr(k int, v decimal(10,2), v2 decimal(10, 2));\ninsert into aggr values \n   (1, 10, null),\n   (2, 10, 11), \n   (2, 20, 22), \n   (2, 25, null), \n   (2, 30, 35);\n\nSELECT k, var_pop(v), var_pop(v2) \n    FROM aggr \n    GROUP BY k\n    ORDER BY k;\n+---+---------------+---------------+\n| K |    VAR_POP(V) |   VAR_POP(V2) |\n|---+---------------+---------------|\n| 1 |  0.0000000000 |          NULL |\n| 2 | 54.6875000000 | 96.2222222222 |\n+---+---------------+---------------+",
    "arguments": [
        {
            "name": "expr1",
            "description": "The expr1 should evaluate to one of the numeric data types."
        },
        {
            "name": "expr2",
            "description": "This is the optional expression to partition by."
        },
        {
            "name": "expr3",
            "description": "This is the optional expression to order by within each partition."
        }
    ],
    "returns": "The data type of the returned value is NUMBER(<precision>, <scale>). The scale depends upon the values being processed."
},
{
    "function_name": "VALIDATE_PIPE_LOAD",
    "summary": "This table function can be used to validate data files processed by Snowpipe within a specified time range.",
    "category": "Information Schema , Table functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/validate_pipe_load",
    "title": "VALIDATE_PIPE_LOAD",
    "description": "This table function can be used to validate data files processed by",
    "syntax": "VALIDATE_PIPE_LOAD(\n      PIPE_NAME => '<string>'\n       , START_TIME => <constant_expr>\n      [, END_TIME => <constant_expr> ] )",
    "example": "select * from table(validate_pipe_load(\n  pipe_name=>'MY_DB.PUBLIC.MYPIPE',\n  start_time=>dateadd(hour, -1, current_timestamp())));",
    "arguments": [
        {
            "name": "PIPE_NAME",
            "description": "A string specifying a pipe. The function returns results for the specified pipe only."
        },
        {
            "name": "START_TIME",
            "description": "Timestamp (in TIMESTAMP_LTZ format), within the last 14 days, marking the start of the time range for retrieving error events."
        },
        {
            "name": "END_TIME",
            "description": "Timestamp (in TIMESTAMP_LTZ format), within the last 14 days, marking the end of the time range for retrieving error events."
        }
    ]
},
{
    "function_name": "VALIDATE",
    "summary": "Validates the files loaded in a past execution of the COPY INTO <table> command and returns all the errors encountered during the load, rather than just the first error.",
    "category": "Table functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/validate",
    "title": "VALIDATE",
    "description": "Validates the files loaded in a past execution of the",
    "syntax": "VALIDATE( [<namespace>.]<table_name> , JOB_ID => { '<query_id>' | '_last' } )",
    "example": "SELECT * FROM TABLE(VALIDATE(t1, JOB_ID => '_last'));\n\nSELECT * FROM TABLE(VALIDATE(t1, JOB_ID=>'5415fa1e-59c9-4dda-b652-533de02fdcf1'));\n\nCREATE OR REPLACE TABLE save_copy_errors AS SELECT * FROM TABLE(VALIDATE(t1, JOB_ID=>'5415fa1e-59c9-4dda-b652-533de02fdcf1'));",
    "arguments": [
        {
            "name": "[",
            "description": "Specifies the fully-qualified name of the table that was the target of the load. Namespace is the database and/or schema in which the table resides, in the form of database_name . schema_name or schema_name . It is optional if a database and schema\nare currently in use within the user session; otherwise, it is required."
        },
        {
            "name": "JOB_ID",
            "description": "The ID for the COPY INTO <table> command to be validated: The ID can be obtained from the Query ID column in the History page in the Classic Console. The specified query ID must have been for the specified target table. If _last is specified instead of query_id , the function validates the last load executed during the current session, regardless of the specified target table."
        }
    ]
},
{
    "function_name": "UUID_STRING",
    "summary": "Generates either a version 4 (random) or version 5 (named) RFC 4122-compliant universally unique identifier (UUID) as a formatted string.",
    "category": "String & binary functions , Data generation functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/uuid_string",
    "title": "UUID_STRING",
    "description": "Generates either a version 4 (random) or version 5 (named) RFC 4122-compliant universally unique identifier (UUID)\nas a formatted string.",
    "syntax": "UUID_STRING()\n\nUUID_STRING( '<uuid>' , '<name>' )",
    "example": "SELECT UUID_STRING();\n\n+--------------------------------------+\n| UUID_STRING()                        |\n|--------------------------------------|\n| d47f4e30-306f-4940-8921-c154094df1a1 |\n+--------------------------------------+\n\nSELECT UUID_STRING('fe971b24-9572-4005-b22f-351e9c09274d','foo');\n\n+-----------------------------------------------------------+\n| UUID_STRING('FE971B24-9572-4005-B22F-351E9C09274D','FOO') |\n|-----------------------------------------------------------|\n| dc0b6f65-fca6-5b4b-9d37-ccc3fde1f3e2                      |\n+-----------------------------------------------------------+\n\nCREATE OR REPLACE TABLE uuid_insert_test(random_uuid VARCHAR(36), test VARCHAR(10));\n\nINSERT INTO uuid_insert_test (random_uuid, test) SELECT UUID_STRING(), 'test1';\nINSERT INTO uuid_insert_test (random_uuid, test) SELECT UUID_STRING(), 'test2';\nINSERT INTO uuid_insert_test (random_uuid, test) SELECT UUID_STRING(), 'test3';\nINSERT INTO uuid_insert_test (random_uuid, test) SELECT UUID_STRING(), 'test4';\nINSERT INTO uuid_insert_test (random_uuid, test) SELECT UUID_STRING(), 'test5';\n\nSELECT * FROM uuid_insert_test;\n\n+--------------------------------------+-------+\n| RANDOM_UUID                          | TEST  |\n|--------------------------------------+-------|\n| 7745a0cf-d136-406b-9289-38072d242871 | test1 |\n| 8c31e031-a6bf-479d-9abb-b7909f298ba1 | test2 |\n| e65d5641-01c0-4126-b80d-c5ae6d4848be | test3 |\n| bd02bf4e-fa5d-498d-8a9a-d38200f1ca30 | test4 |\n| 4df2a34e-ad65-46b4-a51a-3eb9394aeb83 | test5 |\n+--------------------------------------+-------+",
    "arguments": [
        {
            "name": "'",
            "description": "A valid UUID string. This value is the namespace used to generate the returned UUID."
        },
        {
            "name": "'",
            "description": "The name used to generate the returned UUID."
        }
    ],
    "returns": "This function returns a 128-bit value, formatted as a string (VARCHAR data type)."
},
{
    "function_name": "UPPER",
    "summary": "Returns the input string with all characters converted to uppercase.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/upper",
    "title": "UPPER",
    "description": "Returns the input string with all characters converted to uppercase.",
    "syntax": "UPPER( <expr> )",
    "example": "SELECT v, UPPER(v) FROM lu;\n\n+----------------------------------+----------------------------------+\n|                v                 |             upper(v)             |\n+----------------------------------+----------------------------------+\n|                                  |                                  |\n| 1č2Щ3ß4Ę!-?abc@                  | 1Č2Щ3SS4Ę!-?ABC@                 |\n| AaBbCcDdEeFfGgHhIiJj             | AABBCCDDEEFFGGHHIIJJ             |\n| KkLlMmNnOoPpQqRrSsTt             | KKLLMMNNOOPPQQRRSSTT             |\n| UuVvWwXxYyZz                     | UUVVWWXXYYZZ                     |\n| ÁáÄäÉéÍíÓóÔôÚúÝý                 | ÁÁÄÄÉÉÍÍÓÓÔÔÚÚÝÝ                 |\n| ÄäÖößÜü                          | ÄÄÖÖSSÜÜ                         |\n| ÉéÀàÈèÙùÂâÊêÎîÔôÛûËëÏïÜüŸÿÇçŒœÆæ | ÉÉÀÀÈÈÙÙÂÂÊÊÎÎÔÔÛÛËËÏÏÜÜŸŸÇÇŒŒÆÆ |\n| ĄąĆćĘęŁłŃńÓóŚśŹźŻż               | ĄĄĆĆĘĘŁŁŃŃÓÓŚŚŹŹŻŻ               |\n| ČčĎďĹĺĽľŇňŔŕŠšŤťŽž               | ČČĎĎĹĹĽĽŇŇŔŔŠŠŤŤŽŽ               |\n| АаБбВвГгДдЕеЁёЖжЗзИиЙй           | ААББВВГГДДЕЕЁЁЖЖЗЗИИЙЙ           |\n| КкЛлМмНнОоПпРрСсТтУуФф           | ККЛЛММННООППРРССТТУУФФ           |\n| ХхЦцЧчШшЩщЪъЫыЬьЭэЮюЯя           | ХХЦЦЧЧШШЩЩЪЪЫЫЬЬЭЭЮЮЯЯ           |\n| [NULL]                           | [NULL]                           |\n+----------------------------------+----------------------------------+\n\nSELECT UPPER('i' COLLATE 'tr');\n\n+-------------------------+\n| UPPER('I' COLLATE 'TR') |\n|-------------------------|\n| İ                       |\n+-------------------------+",
    "arguments": [
        {
            "name": "expr",
            "description": "The string expression."
        }
    ],
    "returns": "This function returns a value of type VARCHAR."
},
{
    "function_name": "UNIFORM",
    "summary": "Generates a uniformly-distributed pseudo-random number in the inclusive range [min, max].",
    "category": "Data generation functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/uniform",
    "title": "UNIFORM",
    "description": "Generates a uniformly-distributed pseudo-random number in the inclusive\nrange [",
    "syntax": "UNIFORM( <min> , <max> , <gen> )",
    "example": "SELECT UNIFORM(1, 10, RANDOM()) FROM TABLE(GENERATOR(ROWCOUNT => 5));\n\n+--------------------------+\n| UNIFORM(1, 10, RANDOM()) |\n|--------------------------|\n|                        6 |\n|                        1 |\n|                        8 |\n|                        5 |\n|                        6 |\n+--------------------------+\n\nSELECT UNIFORM(0::FLOAT, 1::FLOAT, RANDOM()) FROM TABLE(GENERATOR(ROWCOUNT => 5));\n\n+---------------------------------------+\n| UNIFORM(0::FLOAT, 1::FLOAT, RANDOM()) |\n|---------------------------------------|\n|                         0.1180758313  |\n|                         0.4945805484  |\n|                         0.7113092833  |\n|                         0.06170806767 |\n|                         0.01635235156 |\n+---------------------------------------+\n\nSELECT UNIFORM(1, 10, 1234) FROM TABLE(GENERATOR(ROWCOUNT => 5));\n\n+----------------------+\n| UNIFORM(1, 10, 1234) |\n|----------------------|\n|                    7 |\n|                    7 |\n|                    7 |\n|                    7 |\n|                    7 |\n+----------------------+",
    "arguments": [
        {
            "name": "min",
            "description": "A constant specifying the minimum value (inclusive) of the generated number."
        },
        {
            "name": "max",
            "description": "A constant specifying the maximum value (inclusive) of the generated number."
        },
        {
            "name": "gen",
            "description": "An expression that serves as a raw source of uniform random numbers,\ntypically the RANDOM function. For more information, see the Data\nGeneration Functions Usage notes ."
        }
    ],
    "returns": "If either or both of min or max is a floating-point number,\nUNIFORM returns a floating-point number. If both min and\nmax are integers, UNIFORM returns an integer."
},
{
    "function_name": "UNICODE",
    "summary": "Returns the Unicode code point for the first Unicode character in a string.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/unicode",
    "title": "UNICODE",
    "description": "Returns the Unicode code point for the first Unicode character in a string. If the string is empty, a value of",
    "syntax": "UNICODE( <input> )",
    "example": "SELECT column1, UNICODE(column1), CHAR(UNICODE(column1))\nFROM values('a'), ('\\u2744'), ('cde'), (''), (null);\n\n+---------+------------------+------------------------+\n| COLUMN1 | UNICODE(COLUMN1) | CHAR(UNICODE(COLUMN1)) |\n|---------+------------------+------------------------|\n| a       |               97 | a                      |\n| ❄       |            10052 | ❄                      |\n| cde     |               99 | c                      |\n|         |                0 |                        |\n| NULL    |             NULL | NULL                   |\n+---------+------------------+------------------------+",
    "arguments": [
        {
            "name": "input",
            "description": "The string for which the Unicode code point for the first character in the string is returned."
        }
    ]
},
{
    "function_name": "TYPEOF",
    "summary": "Returns the type of a value stored in a VARIANT column.",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/typeof",
    "title": "TYPEOF",
    "description": "Returns the type of a value stored in a",
    "syntax": "TYPEOF( <expr> )",
    "example": "CREATE OR REPLACE TABLE vartab (n NUMBER(2), v VARIANT);\n\nINSERT INTO vartab\n  SELECT column1 AS n, PARSE_JSON(column2) AS v\n    FROM VALUES (1, 'null'), \n                (2, null), \n                (3, 'true'),\n                (4, '-17'), \n                (5, '123.12'), \n                (6, '1.912e2'),\n                (7, '\"Om ara pa ca na dhih\"  '), \n                (8, '[-1, 12, 289, 2188, false,]'), \n                (9, '{ \"x\" : \"abc\", \"y\" : false, \"z\": 10} ') \n       AS vals;\n\nSELECT n, v, TYPEOF(v)\n  FROM vartab\n  ORDER BY n;\n\n+---+------------------------+------------+\n| N | V                      | TYPEOF(V)  |\n|---+------------------------+------------|\n| 1 | null                   | NULL_VALUE |\n| 2 | NULL                   | NULL       |\n| 3 | true                   | BOOLEAN    |\n| 4 | -17                    | INTEGER    |\n| 5 | 123.12                 | DECIMAL    |\n| 6 | 1.912000000000000e+02  | DOUBLE     |\n| 7 | \"Om ara pa ca na dhih\" | VARCHAR    |\n| 8 | [                      | ARRAY      |\n|   |   -1,                  |            |\n|   |   12,                  |            |\n|   |   289,                 |            |\n|   |   2188,                |            |\n|   |   false,               |            |\n|   |   undefined            |            |\n|   | ]                      |            |\n| 9 | {                      | OBJECT     |\n|   |   \"x\": \"abc\",          |            |\n|   |   \"y\": false,          |            |\n|   |   \"z\": 10              |            |\n|   | }                      |            |\n+---+------------------------+------------+\n\nCREATE OR REPLACE TABLE typeof_cast(status VARCHAR, time TIMESTAMP);\n\nINSERT INTO typeof_cast VALUES('check in', '2024-01-17 19:00:00.000 -0800');\n\nSELECT status,\n       TYPEOF(status::VARIANT) AS \"TYPE OF STATUS\",\n       time,\n       TYPEOF(time::VARIANT) AS \"TYPE OF TIME\"\n  FROM typeof_cast;\n\n+----------+----------------+-------------------------+---------------+\n| STATUS   | TYPE OF STATUS | TIME                    | TYPE OF TIME  |\n|----------+----------------+-------------------------+---------------|\n| check in | VARCHAR        | 2024-01-17 19:00:00.000 | TIMESTAMP_NTZ |\n+----------+----------------+-------------------------+---------------+",
    "arguments": [
        {
            "name": "expr",
            "description": "The argument can be a column name or a general expression of type VARIANT. If necessary, you can cast the expr to a VARIANT."
        }
    ],
    "returns": "Returns a VARCHAR value that contains the data type of the input expression, such as BOOLEAN, DECIMAL, ARRAY,\nOBJECT, and so on."
},
{
    "function_name": "TRY_TO_TIMESTAMP / TRY_TO_TIMESTAMP_*",
    "summary": "A special version of TO_TIMESTAMP / TO_TIMESTAMP_* that performs the same operation (i.e. converts an input expression into a timestamp), but with error-handling support (i.e. if the conversion cannot be performed, it returns a NULL value instead of raising an error).",
    "category": "Conversion functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/try_to_timestamp",
    "title": "TRY_TO_TIMESTAMP / TRY_TO_TIMESTAMP_*",
    "description": "A special version of",
    "syntax": "timestampFunction ( <string_expr> [, <format> ] )\ntimestampFunction ( '<integer>' )",
    "example": "SELECT TRY_TO_TIMESTAMP('2024-01-15 12:30:00'), TRY_TO_TIMESTAMP('Invalid');\n\n+-----------------------------------------+-----------------------------+\n| TRY_TO_TIMESTAMP('2024-01-15 12:30:00') | TRY_TO_TIMESTAMP('INVALID') |\n|-----------------------------------------+-----------------------------|\n| 2024-01-15 12:30:00.000                 | NULL                        |\n+-----------------------------------------+-----------------------------+",
    "arguments": [
        {
            "name": "string_expr",
            "description": "A string that can be evaluated to a TIMESTAMP (TIMESTAMP_NTZ, TIMESTAMP_LTZ, or TIMESTAMP_TZ)."
        },
        {
            "name": "'",
            "description": "An expression that evaluates to a string containing an integer, for example '15000000' . Depending\non the magnitude of the string, it can be interpreted as seconds, milliseconds, microseconds, or\nnanoseconds. For details, see the Usage Notes ."
        },
        {
            "name": "format",
            "description": "Format specifier for string_expr or AUTO .\nFor more information, see Date and time formats in conversion functions . The default is the current value of the TIMESTAMP_INPUT_FORMAT session parameter (default AUTO)."
        }
    ],
    "returns": "The data type of the returned value is one of the TIMESTAMP data\ntypes. By default, the data type is TIMESTAMP_NTZ. You can change\nthis by setting the session parameter TIMESTAMP_TYPE_MAPPING."
},
{
    "function_name": "TRY_TO_TIME",
    "summary": "A special version of TO_TIME , TIME that performs the same operation (i.e. converts an input expression into a time), but with error-handling support (i.e. if the conversion cannot be performed, it returns a NULL value instead of raising an error).",
    "category": "Conversion functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/try_to_time",
    "title": "TRY_TO_TIME",
    "description": "A special version of",
    "syntax": "TRY_TO_TIME( <string_expr> [, <format> ] )\nTRY_TO_TIME( '<integer>' )",
    "example": "SELECT TRY_TO_TIME('12:30:00'), TRY_TO_TIME('Invalid');\n\n+-------------------------+------------------------+\n| TRY_TO_TIME('12:30:00') | TRY_TO_TIME('INVALID') |\n|-------------------------+------------------------|\n| 12:30:00                | NULL                   |\n+-------------------------+------------------------+",
    "arguments": [
        {
            "name": "string_expr",
            "description": "A string that can be converted to a valid time."
        },
        {
            "name": "'",
            "description": "An expression that evaluates to a string containing an integer, for example '15000000' . Depending\non the magnitude of the string, it can be interpreted as seconds, milliseconds, microseconds, or\nnanoseconds. For details, see the Usage Notes ."
        },
        {
            "name": "format",
            "description": "Format specifier for string_expr or AUTO .\nFor more information, see Date and time formats in conversion functions . The default is the current value of the TIME_INPUT_FORMAT session parameter (default AUTO)."
        }
    ],
    "returns": "The data type of the returned value is TIME."
},
{
    "function_name": "TRY_TO_GEOMETRY",
    "summary": "Parses an input and returns a value of type GEOMETRY.",
    "category": "Geospatial functions , Conversion functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/try_to_geometry",
    "title": "TRY_TO_GEOMETRY",
    "description": "Parses an input and returns a value of type",
    "syntax": "TRY_TO_GEOMETRY( <varchar_expression> [ , <srid> ] [ , <allow_invalid> ] )\n\nTRY_TO_GEOMETRY( <binary_expression> [ , <srid> ] [ , <allow_invalid> ] )\n\nTRY_TO_GEOMETRY( <variant_expression> [ , <srid> ] [ , <allow_invalid> ] )",
    "example": "select try_to_geometry('INVALID INPUT');\n\n+--------------------------------------+\n| try_to_geometry('INVALID INPUT')     |\n|--------------------------------------|\n| NULL                                 |\n+--------------------------------------+",
    "arguments": [
        {
            "name": "varchar_expression",
            "description": "The argument must be a string expression that represents a valid geometric object in one of the following formats: WKT (well-known text). WKB (well-known binary) in hexadecimal format (without a leading 0x ). EWKT (extended well-known text). EWKB (extended well-known binary) in hexadecimal format (without a leading 0x ). GeoJSON."
        },
        {
            "name": "binary_expression",
            "description": "The argument must be a binary expression in WKB or EWKB format."
        },
        {
            "name": "variant_expression",
            "description": "The argument must be an OBJECT in GeoJSON format."
        },
        {
            "name": "srid",
            "description": "The integer value of the SRID to use."
        },
        {
            "name": "allow_invalid",
            "description": "If TRUE, specifies that the function should return a GEOGRAPHY or GEOMETRY object, even when the input shape is invalid and\ncannot be repaired. For details, refer to Specifying how invalid geospatial shapes are handled ."
        }
    ],
    "returns": "The function returns a value of type GEOMETRY."
},
{
    "function_name": "TRY_TO_GEOGRAPHY",
    "summary": "Parses an input and returns a value of type GEOGRAPHY.",
    "category": "Geospatial functions , Conversion functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/try_to_geography",
    "title": "TRY_TO_GEOGRAPHY",
    "description": "Parses an input and returns a value of type",
    "syntax": "TRY_TO_GEOGRAPHY( <varchar_expression> [ , <allow_invalid> ] )\n\nTRY_TO_GEOGRAPHY( <binary_expression> [ , <allow_invalid> ] )\n\nTRY_TO_GEOGRAPHY( <variant_expression> [ , <allow_invalid> ] )",
    "example": "select TRY_TO_GEOGRAPHY('Not a valid input for this data type.');\n+-----------------------------------------------------------+\n| TRY_TO_GEOGRAPHY('NOT A VALID INPUT FOR THIS DATA TYPE.') |\n|-----------------------------------------------------------|\n| NULL                                                      |\n+-----------------------------------------------------------+",
    "arguments": [
        {
            "name": "varchar_expression",
            "description": "The argument must be a string expression that represents a valid geometric object in one of the following formats: WKT (well-known text). WKB (well-known binary) in hexadecimal format (without a leading 0x ). EWKT (extended well-known text). EWKB (extended well-known binary) in hexadecimal format (without a leading 0x ). GeoJSON."
        },
        {
            "name": "binary_expression",
            "description": "The argument must be a binary expression in WKB or EWKB format."
        },
        {
            "name": "variant_expression",
            "description": "The argument must be an OBJECT in GeoJSON format."
        },
        {
            "name": "allow_invalid",
            "description": "If TRUE, specifies that the function should return a GEOGRAPHY or GEOMETRY object, even when the input shape is invalid and\ncannot be repaired. For details, refer to Specifying how invalid geospatial shapes are handled ."
        }
    ],
    "returns": "The function returns a value of type GEOGRAPHY."
},
{
    "function_name": "TRY_TO_FILE",
    "summary": "A version of TO_FILE that returns NULL instead of raising an error.",
    "category": "",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/try_to_file",
    "title": "TRY_TO_FILE",
    "description": "A version of",
    "syntax": "TRY_TO_FILE( <stage_name>, <relative_path> )\n\nTRY_TO_FILE( <file_url> )\n\nTRY_TO_FILE( <metadata> )",
    "arguments": [
        {
            "name": "stage_name",
            "description": "The name of the stage where the file is located, as a string, in the form '@stage_name' ."
        },
        {
            "name": "relative_path",
            "description": "The path to the file on the stage specified by stage_name as a string."
        },
        {
            "name": "file_url",
            "description": "A valid stage or scoped file URL as a string."
        },
        {
            "name": "metadata",
            "description": "An OBJECT containing the required FILE metadata. A FILE must have CONTENT_TYPE, SIZE, ETAG, and LAST_MODIFIED fields.\nIt must also specify the file’s location in one of the following ways: Both STAGE and RELATIVE_PATH STAGE_FILE_URL SCOPED_FILE_URL"
        }
    ],
    "returns": "A FILE, or NULL."
},
{
    "function_name": "TRY_TO_DOUBLE",
    "summary": "A special version of TO_DOUBLE that performs the same operation (that is, converts an input expression to a double-precision floating-point number), but with error-handling support (that is, if the conversion can’t be performed, it returns a NULL value instead of raising an error).",
    "category": "Conversion functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/try_to_double",
    "title": "TRY_TO_DOUBLE",
    "description": "A special version of",
    "syntax": "TRY_TO_DOUBLE( <string_expr> [, '<format>' ] )",
    "example": "SELECT TRY_TO_DOUBLE('3.1415926'), TRY_TO_DOUBLE('Invalid');\n\n+----------------------------+--------------------------+\n| TRY_TO_DOUBLE('3.1415926') | TRY_TO_DOUBLE('INVALID') |\n|----------------------------+--------------------------|\n|                  3.1415926 |                     NULL |\n+----------------------------+--------------------------+",
    "arguments": [
        {
            "name": "expr",
            "description": "An expression of a character type."
        },
        {
            "name": "format",
            "description": "If the expression evaluates to a string, then the function accepts\nan optional format model. Format models are described at SQL format models . The format model\nspecifies the format of the input string, not the format of the\noutput value."
        }
    ],
    "returns": "This function returns a value of FLOAT data type."
},
{
    "function_name": "TRY_TO_DECIMAL, TRY_TO_NUMBER, TRY_TO_NUMERIC",
    "summary": "A special version of TO_DECIMAL , TO_NUMBER , TO_NUMERIC that performs the same operation (i.e. converts an input expression to a fixed-point number), but with error-handling support (i.e. if the conversion cannot be performed, it returns a NULL value instead of raising an error).",
    "category": "Conversion functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/try_to_decimal",
    "title": "TRY_TO_DECIMAL, TRY_TO_NUMBER, TRY_TO_NUMERIC",
    "description": "A special version of",
    "syntax": "TRY_TO_DECIMAL( <string_expr> [, '<format>' ] [, <precision> [, <scale> ] ] )\n\nTRY_TO_NUMBER( <string_expr> [, '<format>' ] [, <precision> [, <scale> ] ] )\n\nTRY_TO_NUMERIC( <string_expr> [, '<format>' ] [, <precision> [, <scale> ] ] )",
    "example": "SELECT column1 AS orig_string,\n       TO_DECIMAL(column1) AS dec,\n       TO_DECIMAL(column1, 10, 2) AS dec_with_scale,\n       TO_DECIMAL(column1, 4, 2) AS dec_with_range_err\n  FROM VALUES ('345.123');\n\n100039 (22003): Numeric value '345.123' is out of range\n\nSELECT column1 AS orig_string,\n       TRY_TO_DECIMAL(column1) AS dec,\n       TRY_TO_DECIMAL(column1, 10, 2) AS dec_with_scale,\n       TRY_TO_DECIMAL(column1, 4, 2) AS dec_with_range_err\n  FROM VALUES ('345.123');\n\n+-------------+-----+----------------+--------------------+\n| ORIG_STRING | DEC | DEC_WITH_SCALE | DEC_WITH_RANGE_ERR |\n|-------------+-----+----------------+--------------------|\n| 345.123     | 345 |         345.12 |               NULL |\n+-------------+-----+----------------+--------------------+\n\nSELECT column1 AS orig_string,\n       TO_DECIMAL(column1, '$9,999.00') AS num,\n       TO_DECIMAL(column1, '$9,999.00', 6, 2) AS num_with_scale,\n       TO_DECIMAL(column1, 6, 2) AS num_with_format_err\n  FROM VALUES ('$7,543.21');\n\n100038 (22018): Numeric value '$7,543.21' is not recognized\n\nSELECT column1 AS orig_string,\n       TRY_TO_DECIMAL(column1, '$9,999.00') AS num,\n       TRY_TO_DECIMAL(column1, '$9,999.00', 6, 2) AS num_with_scale,\n       TRY_TO_DECIMAL(column1, 6, 2) AS num_with_format_err\n  FROM VALUES ('$7,543.21');\n\n+-------------+------+----------------+---------------------+\n| ORIG_STRING |  NUM | NUM_WITH_SCALE | NUM_WITH_FORMAT_ERR |\n|-------------+------+----------------+---------------------|\n| $7,543.21   | 7543 |        7543.21 |                NULL |\n+-------------+------+----------------+---------------------+",
    "arguments": [
        {
            "name": "string_expr",
            "description": "An expression of type VARCHAR."
        },
        {
            "name": "format",
            "description": "The SQL format model used to parse the input expr and return. For more\ninformation, see SQL format models ."
        },
        {
            "name": "precision",
            "description": "The maximal number of decimal digits in the resulting number; from 1\nto 38. In Snowflake, precision is not used for determination of the\nnumber of bytes needed to store the number and does not have any effect\non efficiency, so the default is the maximum (38)."
        },
        {
            "name": "scale",
            "description": "The number of fractional decimal digits (from 0 to precision - 1).\n0 indicates no fractional digits (i.e. an integer number). The default scale\nis 0."
        }
    ],
    "returns": "The function returns NUMBER(p,s), where p is the precision and\ns is the scale."
},
{
    "function_name": "TRY_TO_DATE",
    "summary": "A special version of the TO_DATE function that performs the same operation (i.e. converts an input expression to a date), but with error-handling support (i.e. if the conversion cannot be performed, it returns a NULL value instead of raising an error).",
    "category": "Conversion functions , Date & time functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/try_to_date",
    "title": "TRY_TO_DATE",
    "description": "A special version of the",
    "syntax": "TRY_TO_DATE( <string_expr> [, <format> ] )\nTRY_TO_DATE( '<integer>' )",
    "example": "SELECT \n  TRY_TO_DATE('2024-05-10') AS valid_date, \n  TRY_TO_DATE('Invalid') AS invalid_date;\n\n+------------+--------------+\n| VALID_DATE | INVALID_DATE |\n|------------+--------------|\n| 2024-05-10 | NULL         |\n+------------+--------------+",
    "arguments": [
        {
            "name": "string_expr",
            "description": "String from which to extract a date. For example: '2024-01-31' ."
        },
        {
            "name": "'",
            "description": "An expression that evaluates to a string containing an integer. For example: '15000000' . Depending\non the magnitude of the string, it can be interpreted as seconds, milliseconds, microseconds, or\nnanoseconds. For details, see the Usage notes for this function."
        },
        {
            "name": "format",
            "description": "Date format specifier for string_expr or AUTO ,\nwhich specifies that Snowflake should automatically detect the format to use. For more information,\nsee Date and time formats in conversion functions . The default is the current value of the DATE_INPUT_FORMAT session parameter (default AUTO )."
        }
    ],
    "returns": "The data type of the returned value is DATE."
},
{
    "function_name": "TRY_TO_BOOLEAN",
    "summary": "A special version of TO_BOOLEAN that performs the same operation (that is, converts an input expression to a Boolean value), but with error-handling support.",
    "category": "Conversion functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/try_to_boolean",
    "title": "TRY_TO_BOOLEAN",
    "description": "A special version of",
    "syntax": "TRY_TO_BOOLEAN( <string_expr> )",
    "example": "SELECT TRY_TO_BOOLEAN('True')  AS \"T\",\n       TRY_TO_BOOLEAN('False') AS \"F\",\n       TRY_TO_BOOLEAN('Not valid')  AS \"N\";\n\n+------+-------+------+\n| T    | F     | N    |\n|------+-------+------|\n| True | False | NULL |\n+------+-------+------+",
    "arguments": [
        {
            "name": "string_expr",
            "description": "A string expression that can be evaluated to a BOOLEAN value."
        }
    ],
    "returns": "This function returns a value of type BOOLEAN."
},
{
    "function_name": "TRY_TO_BINARY",
    "summary": "A special version of TO_BINARY that performs the same operation (i.e. converts an input expression to a binary value), but with error handling support (i.e. if the conversion cannot be performed, it returns a NULL value instead of raising an error).",
    "category": "Conversion functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/try_to_binary",
    "title": "TRY_TO_BINARY",
    "description": "A special version of",
    "syntax": "TRY_TO_BINARY( <string_expr> [, '<format>'] )",
    "example": "CREATE TABLE strings (v VARCHAR, hex_encoded_string VARCHAR, b BINARY);\nINSERT INTO strings (v) VALUES\n    ('01'),\n    ('A B'),\n    ('Hello'),\n    (NULL);\nUPDATE strings SET hex_encoded_string = HEX_ENCODE(v);\nUPDATE strings SET b = TRY_TO_BINARY(hex_encoded_string, 'HEX');\n\nSELECT v, hex_encoded_string, TO_VARCHAR(b, 'UTF-8')\n  FROM strings\n  ORDER BY v\n  ;\n+-------+--------------------+------------------------+\n| V     | HEX_ENCODED_STRING | TO_VARCHAR(B, 'UTF-8') |\n|-------+--------------------+------------------------|\n| 01    | 3031               | 01                     |\n| A B   | 412042             | A B                    |\n| Hello | 48656C6C6F         | Hello                  |\n| NULL  | NULL               | NULL                   |\n+-------+--------------------+------------------------+",
    "arguments": [
        {
            "name": "string_expr",
            "description": "A string expression."
        },
        {
            "name": "format",
            "description": "The binary format for conversion: HEX, BASE64, or UTF-8 (see Binary input and output ). The default is the value of the\nBINARY_INPUT_FORMAT session parameter. If this parameter is not set, the\ndefault is HEX."
        }
    ],
    "returns": "Returns a value of type BINARY."
},
{
    "function_name": "TRY_PARSE_JSON",
    "summary": "A special version of PARSE_JSON that returns a NULL value if an error occurs during parsing.",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/try_parse_json",
    "title": "TRY_PARSE_JSON",
    "description": "A special version of",
    "syntax": "TRY_PARSE_JSON( <expr> [ , '<parameter>' ] )",
    "example": "CREATE OR REPLACE TEMPORARY TABLE vartab (ID INTEGER, v VARCHAR);\n\nINSERT INTO vartab (id, v) VALUES\n  (1, '[-1, 12, 289, 2188, FALSE,]'),\n  (2, '{ \"x\" : \"abc\", \"y\" : FALSE, \"z\": 10} '),\n  (3, '{ \"bad\" : \"json\", \"missing\" : TRUE, \"close_brace\": 10 ');\n\nSELECT ID, TRY_PARSE_JSON(v)\n  FROM vartab\n  ORDER BY ID;\n\n+----+-------------------+\n| ID | TRY_PARSE_JSON(V) |\n|----+-------------------|\n|  1 | [                 |\n|    |   -1,             |\n|    |   12,             |\n|    |   289,            |\n|    |   2188,           |\n|    |   false,          |\n|    |   undefined       |\n|    | ]                 |\n|  2 | {                 |\n|    |   \"x\": \"abc\",     |\n|    |   \"y\": false,     |\n|    |   \"z\": 10         |\n|    | }                 |\n|  3 | NULL              |\n+----+-------------------+",
    "arguments": [
        {
            "name": "expr",
            "description": "An expression of string type (for example, VARCHAR) that holds valid JSON information."
        },
        {
            "name": "'",
            "description": "String constant that specifies the parameter used to search for matches. Supported values: Parameter Description d Allow duplicate keys in JSON objects. If a JSON object contains a duplicate key, the returned object has a single instance\nof that key with the last value specified for that key. s Don’t allow duplicate keys in JSON objects (strict). This value is the default."
        }
    ],
    "returns": "Returns a value of type VARIANT that contains a JSON document."
},
{
    "function_name": "TRY_HEX_DECODE_STRING",
    "summary": "A special version of HEX_DECODE_STRING that returns a NULL value if an error occurs during decoding.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/try_hex_decode_string",
    "title": "TRY_HEX_DECODE_STRING",
    "description": "A special version of",
    "syntax": "TRY_HEX_DECODE_STRING(<input>)",
    "example": "CREATE TABLE hex (v VARCHAR, hex_string VARCHAR, garbage VARCHAR);\nINSERT INTO hex (v, hex_string, garbage) \n  SELECT 'AaBb', HEX_ENCODE('AaBb'), '127';\n\nSELECT v, hex_string, TRY_HEX_DECODE_STRING(hex_string), TRY_HEX_DECODE_STRING(garbage) FROM hex;\n\n+------+------------+-----------------------------------+--------------------------------+\n| V    | HEX_STRING | TRY_HEX_DECODE_STRING(HEX_STRING) | TRY_HEX_DECODE_STRING(GARBAGE) |\n|------+------------+-----------------------------------+--------------------------------|\n| AaBb | 41614262   | AaBb                              | NULL                           |\n+------+------------+-----------------------------------+--------------------------------+",
    "arguments": [
        {
            "name": "input",
            "description": "A hex-encoded string expression. Typically the input was created by a\ncall to HEX_ENCODE ."
        }
    ],
    "returns": "The returned value is a string (VARCHAR)."
},
{
    "function_name": "TRY_HEX_DECODE_BINARY",
    "summary": "A special version of HEX_DECODE_BINARY that returns a NULL value if an error occurs during decoding.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/try_hex_decode_binary",
    "title": "TRY_HEX_DECODE_BINARY",
    "description": "A special version of",
    "syntax": "TRY_HEX_DECODE_BINARY(<input>)",
    "example": "CREATE TABLE hex (v VARCHAR, b BINARY);\nINSERT INTO hex (v, b)\n   SELECT 'ABab', \n     -- Convert string -> hex-encoded string -> binary.\n     TRY_HEX_DECODE_BINARY(HEX_ENCODE('ABab'));\n\nSELECT v, b, \n    -- Convert binary -> hex-encoded-string -> string.\n    TRY_HEX_DECODE_STRING(TO_VARCHAR(b)) \n  FROM hex;\n\n+------+----------+--------------------------------------+\n| V    | B        | TRY_HEX_DECODE_STRING(TO_VARCHAR(B)) |\n|------+----------+--------------------------------------|\n| ABab | 41426162 | ABab                                 |\n+------+----------+--------------------------------------+",
    "arguments": [
        {
            "name": "input",
            "description": "A string expression containing only hexadecimal digits. Typically, this\ninput string is generated by calling the function HEX_ENCODE ."
        }
    ],
    "returns": "A BINARY value that can, for example, be inserted into a column of type\nBINARY."
},
{
    "function_name": "TRY_DECRYPT_RAW",
    "summary": "A special version of DECRYPT_RAW that returns a NULL value if an error occurs during decryption.",
    "category": "Encryption functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/try_decrypt_raw",
    "title": "TRY_DECRYPT_RAW",
    "description": "A special version of",
    "syntax": "TRY_DECRYPT_RAW( <value_to_decrypt> , <key> , <iv> ,\n         [ [ [ <additional_authenticated_data> , ] <encryption_method> , ] <aead_tag> ]\n       )",
    "arguments": [
        {
            "name": "value_to_decrypt",
            "description": "The binary value to decrypt."
        },
        {
            "name": "key",
            "description": "The key to use to encrypt/decrypt the data. The key must be a BINARY value. The key can be any value as long as the\nlength is correct. For example, for AES128, the key must be 128 bits (16 bytes), and for AES256, the key must be\n256 bits (32 bytes). The key used to encrypt the value must be used to decrypt the value."
        },
        {
            "name": "iv",
            "description": "This parameter contains the Initialization Vector (IV) to use to encrypt and decrypt this piece of\ndata. The IV must be a BINARY value of a specific length: For GCM, this field must be 96 bits (12 bytes). While the GCM encryption method allows this field to be a different\nsize, Snowflake currently only supports 96 bits. For CCM, this should be 56 bits (7 bytes). For ECB, this parameter is unneeded. For all other supported encryption modes, this should be 128 bits (16 bytes). This value is used to initialize the first encryption round. You should never use the same IV and key combination\nmore than once, especially for encryption modes like GCM. If this parameter is set to NULL, the implementation will choose a new pseudo-random IV during each call."
        },
        {
            "name": "additional_authenticated_data",
            "description": "Additional authenticated data (AAD) is additional data whose confidentiality and authenticity is assured during the\ndecryption process. However, this AAD is not encrypted and is not included as a field in the returned value from the\nENCRYPT or ENCRYPT_RAW function. If AAD is passed to the encryption function (ENCRYPT or ENCRYPT_RAW), then the same AAD must be passed to the\ndecryption function (DECRYPT or DECRYPT_RAW). If the AAD passed to the decryption function does not match the\nAAD passed to the encryption function, then decryption fails. The difference between the AAD and the passphrase is that the passphrase is intended to be kept\nsecret (otherwise, the encryption is essentially worthless) while the AAD can be left public. The AAD helps\nauthenticate that a public piece of information and an encrypted value are associated with each other. The\nexamples section in the ENCRYPT function includes an example showing the behavior\nwhen the AAD matches and the behavior when it doesn’t match. For ENCRYPT_RAW and DECRYPT_RAW, the data type of the AAD should be BINARY.\nFor ENCRYPT and DECRYPT, the data type of the AAD can be either VARCHAR or BINARY, and does not need to match\nthe data type of the value that was encrypted. AAD is supported only by AEAD-enabled encryption modes like GCM (default)."
        },
        {
            "name": "encryption_method",
            "description": "This string specifies the method to use for encrypting/decrypting the data. This string contains subfields: The algorithm is currently limited to: 'AES' : When a passphrase is passed (e.g. to ENCRYPT), the function uses AES-256 encryption (256 bits). When a key\nis passed (e.g. to ENCRYPT_RAW), the function uses 128, 192, or 256-bit encryption, depending upon the key\nlength. The algorithm is case-insensitive. The mode specifies which block cipher mode should be used to encrypt messages.\nThe following table shows which modes are supported, and which of those modes support padding: Mode Padding Description 'ECB' Yes Encrypt every block individually with the key. This mode is generally discouraged and is included only for compatibility with external implementations. 'CBC' Yes The encrypted block is XORed with the previous block. 'GCM' No Galois/Counter Mode is a high-performance encryption mode that is AEAD-enabled. AEAD additionally assures the authenticity and confidentiality of the encrypted data by generating an AEAD tag. Moreover, AEAD supports AAD (additional authenticated data). 'CTR' No Counter mode. 'OFB' No Output feedback. The ciphertext is XORed with the plaintext of a block. 'CFB' No Cipher feedback is a combination of OFB and CBC. The mode is case-insensitive. The padding specifies how to pad messages whose length is not a multiple of the block size. Padding is\napplicable only for ECB and CBC modes; padding is ignored for other modes. The possible values for padding are: 'PKCS' : Uses PKCS5 for block padding. 'NONE' : No padding. The user needs to take care of the padding when using ECB or CBC mode. The padding is case-insensitive. Default setting: 'AES-GCM' . If the mode is not specified, GCM is used. If the padding is not specified, PKCS is used."
        },
        {
            "name": "aead_tag",
            "description": "This BINARY value is needed for AEAD-enabled decryption modes to check the authenticity and confidentiality of the\nencrypted data. Use the AEAD tag that was returned by the ENCRYPT_RAW function. An example below shows how to\naccess and use this value."
        }
    ],
    "returns": "The function returns the decrypted value or a NULL value if any runtime error occurs during decryption. The data type of the\nreturned value is BINARY."
},
{
    "function_name": "TRY_DECRYPT",
    "summary": "A special version of DECRYPT that returns a NULL value if an error occurs during decryption.",
    "category": "Encryption functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/try_decrypt",
    "title": "TRY_DECRYPT",
    "description": "A special version of",
    "syntax": "TRY_DECRYPT( <value_to_decrypt> , <passphrase> ,\n         [ [ <additional_authenticated_data> , ] <encryption_method> ]\n       )",
    "arguments": [
        {
            "name": "value_to_decrypt",
            "description": "The BINARY value to decrypt."
        },
        {
            "name": "passphrase",
            "description": "The passphrase to use to encrypt/decrypt the data. The passphrase is a VARCHAR."
        },
        {
            "name": "additional_authenticated_data",
            "description": "Additional authenticated data (AAD) is additional data whose confidentiality and authenticity is assured during the\ndecryption process. However, this AAD is not encrypted and is not included as a field in the returned value from the\nENCRYPT or ENCRYPT_RAW function. If AAD is passed to the encryption function (ENCRYPT or ENCRYPT_RAW), then the same AAD must be passed to the\ndecryption function (DECRYPT or DECRYPT_RAW). If the AAD passed to the decryption function does not match the\nAAD passed to the encryption function, then decryption fails. The difference between the AAD and the passphrase is that the passphrase is intended to be kept\nsecret (otherwise, the encryption is essentially worthless) while the AAD can be left public. The AAD helps\nauthenticate that a public piece of information and an encrypted value are associated with each other. The\nexamples section in the ENCRYPT function includes an example showing the behavior\nwhen the AAD matches and the behavior when it doesn’t match. For ENCRYPT_RAW and DECRYPT_RAW, the data type of the AAD should be BINARY.\nFor ENCRYPT and DECRYPT, the data type of the AAD can be either VARCHAR or BINARY, and does not need to match\nthe data type of the value that was encrypted. AAD is supported only by AEAD-enabled encryption modes like GCM (default)."
        },
        {
            "name": "encryption_method",
            "description": "This string specifies the method to use for encrypting/decrypting the data. This string contains subfields: The algorithm is currently limited to: 'AES' : When a passphrase is passed (e.g. to ENCRYPT), the function uses AES-256 encryption (256 bits). When a key\nis passed (e.g. to ENCRYPT_RAW), the function uses 128, 192, or 256-bit encryption, depending upon the key\nlength. The algorithm is case-insensitive. The mode specifies which block cipher mode should be used to encrypt messages.\nThe following table shows which modes are supported, and which of those modes support padding: Mode Padding Description 'ECB' Yes Encrypt every block individually with the key. This mode is generally discouraged and is included only for compatibility with external implementations. 'CBC' Yes The encrypted block is XORed with the previous block. 'GCM' No Galois/Counter Mode is a high-performance encryption mode that is AEAD-enabled. AEAD additionally assures the authenticity and confidentiality of the encrypted data by generating an AEAD tag. Moreover, AEAD supports AAD (additional authenticated data). 'CTR' No Counter mode. 'OFB' No Output feedback. The ciphertext is XORed with the plaintext of a block. 'CFB' No Cipher feedback is a combination of OFB and CBC. The mode is case-insensitive. The padding specifies how to pad messages whose length is not a multiple of the block size. Padding is\napplicable only for ECB and CBC modes; padding is ignored for other modes. The possible values for padding are: 'PKCS' : Uses PKCS5 for block padding. 'NONE' : No padding. The user needs to take care of the padding when using ECB or CBC mode. The padding is case-insensitive. Default setting: 'AES-GCM' . If the mode is not specified, GCM is used. If the padding is not specified, PKCS is used."
        }
    ],
    "returns": "Returns the decrypted value as a BINARY value or a NULL value if any runtime\nerror occurs during decryption."
},
{
    "function_name": "TRY_COMPLETE (SNOWFLAKE.CORTEX)",
    "summary": "Performs the same operation as the COMPLETE function but returns NULL instead of raising an error when the operation cannot be performed.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/try_complete-snowflake-cortex",
    "title": "TRY_COMPLETE (SNOWFLAKE.CORTEX)",
    "description": "Performs the same operation as the",
    "syntax": "SNOWFLAKE.CORTEX.TRY_COMPLETE( <model>, <prompt_or_history> [ , <options> ] )",
    "example": "SELECT SNOWFLAKE.CORTEX.TRY_COMPLETE('snowflake-arctic', 'What are large language models?');\n\nSELECT SNOWFLAKE.CORTEX.TRY_COMPLETE(\n    'llama2-70b-chat',\n    [\n        {\n            'role': 'user',\n            'content': 'how does a snowflake get its unique pattern?'\n        }\n    ],\n    {\n        'temperature': 0.7,\n        'max_tokens': 10\n    }\n);\n\n{\n    \"choices\": [\n        {\n            \"messages\": \" The unique pattern on a snowflake is\"\n        }\n    ],\n    \"created\": 1708536426,\n    \"model\": \"llama2-70b-chat\",\n    \"usage\": {\n        \"completion_tokens\": 10,\n        \"prompt_tokens\": 22,\n        \"total_tokens\": 32\n    }\n}",
    "arguments": [
        {
            "name": "model",
            "description": "A string specifying the model to be used. Specify one of the following values. claude-4-opus claude-4-sonnet claude-3-7-sonnet claude-3-5-sonnet deepseek-r1 gemma-7b jamba-1.5-mini jamba-1.5-large jamba-instruct llama2-70b-chat llama3-8b llama3-70b llama3.1-8b llama3.1-70b llama3.1-405b llama3.2-1b llama3.2-3b llama3.3-70b llama4-maverick llama4-scout mistral-large mistral-large2 mistral-7b mixtral-8x7b openai-gpt-4.1 openai-o4-mini reka-core reka-flash snowflake-arctic snowflake-llama-3.1-405b snowflake-llama-3.3-70b Supported models might have different costs ."
        },
        {
            "name": "prompt_or_history",
            "description": "The prompt or conversation history to be used to generate a completion. If options is not present, the prompt given must be a string. If options is present, the argument must be an array of objects representing a\nconversation in chronological order. Each object must contain a role key and a content key. The content value is a prompt or a response, depending on the role. The role must be one of the\nfollowing."
        },
        {
            "name": "options",
            "description": "An object containing zero or more of the following options that affect the model’s\nhyperparameters. See LLM Settings . temperature : A value from 0 to 1 (inclusive) that controls the randomness of the output of the language model. A\nhigher temperature (for example, 0.7) results in more diverse and random output, while a lower temperature (such as\n0.2) makes the output more deterministic and focused. Default: 0 top_p : A value from 0 to 1 (inclusive) that controls the randomness and diversity of the language model,\ngenerally used as an alternative to temperature . The difference is that top_p restricts the set of possible tokens\nthat the model outputs, while temperature influences which tokens are chosen at each step. Default: 0 max_tokens : Sets the maximum number of output tokens in the response. Small values can result in truncated responses. Default: 4096\nMaximum allowed value: 8192 guardrails : Filters potentially unsafe and harmful responses from a language model using Cortex Guard .\nEither TRUE or FALSE. Default: FALSE response_format : A JSON schema that the response should follow. This is a SQL\nsub-object, not a string. If response_format is not specified, the response is a string containing either the\nresponse or a serialized JSON object containing the response and information about it. For more information, see AI_COMPLETE Structured Outputs . Specifying the options argument, even if it is an empty object ( {} ), affects how the prompt argument is\ninterpreted and how the response is formatted."
        }
    ],
    "returns": "When the options argument is not specified, returns a string containing the response."
},
{
    "function_name": "TRY_CAST",
    "summary": "A special version of CAST , :: that is available for a subset of data type conversions.",
    "category": "Conversion functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/try_cast",
    "title": "TRY_CAST",
    "description": "A special version of",
    "syntax": "TRY_CAST( <source_string_expr> AS <target_data_type> )",
    "example": "SELECT TRY_CAST('05-Mar-2016' AS TIMESTAMP);\n+--------------------------------------+\n| TRY_CAST('05-MAR-2016' AS TIMESTAMP) |\n|--------------------------------------|\n| 2016-03-05 00:00:00.000              |\n+--------------------------------------+\n\nSELECT TRY_CAST('05/16' AS TIMESTAMP);\n+--------------------------------+\n| TRY_CAST('05/16' AS TIMESTAMP) |\n|--------------------------------|\n| NULL                           |\n+--------------------------------+\n\nSELECT TRY_CAST('ABCD' AS CHAR(2));\n+-----------------------------+\n| TRY_CAST('ABCD' AS CHAR(2)) |\n|-----------------------------|\n| NULL                        |\n+-----------------------------+\n\nSELECT TRY_CAST('ABCD' AS VARCHAR(10));\n+---------------------------------+\n| TRY_CAST('ABCD' AS VARCHAR(10)) |\n|---------------------------------|\n| ABCD                            |\n+---------------------------------+"
},
{
    "function_name": "TRY_BASE64_DECODE_STRING",
    "summary": "A special version of BASE64_DECODE_STRING that returns a NULL value if an error occurs during decoding.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/try_base64_decode_string",
    "title": "TRY_BASE64_DECODE_STRING",
    "description": "A special version of",
    "syntax": "TRY_BASE64_DECODE_STRING(<input> [, <alphabet>])",
    "example": "SELECT TRY_BASE64_DECODE_STRING(BASE64_ENCODE('HELLO'));\n+--------------------------------------------------+\n| TRY_BASE64_DECODE_STRING(BASE64_ENCODE('HELLO')) |\n|--------------------------------------------------|\n| HELLO                                            |\n+--------------------------------------------------+\n\nCREATE TABLE base64 (v VARCHAR, base64_string VARCHAR, garbage VARCHAR);\nINSERT INTO base64 (v, base64_string, garbage) \n  SELECT 'HELLO', BASE64_ENCODE('HELLO'), '127';\n\nSELECT v, base64_string, TRY_BASE64_DECODE_STRING(base64_string), TRY_BASE64_DECODE_STRING(garbage) FROM base64;\n+-------+---------------+-----------------------------------------+-----------------------------------+\n| V     | BASE64_STRING | TRY_BASE64_DECODE_STRING(BASE64_STRING) | TRY_BASE64_DECODE_STRING(GARBAGE) |\n|-------+---------------+-----------------------------------------+-----------------------------------|\n| HELLO | SEVMTE8=      | HELLO                                   | NULL                              |\n+-------+---------------+-----------------------------------------+-----------------------------------+",
    "arguments": [
        {
            "name": "input",
            "description": "The base64-encoded string to decode to a normal string."
        },
        {
            "name": "alphabet",
            "description": "A string consisting of up to three ASCII characters: The first two characters in the string specify the last two characters (indexes 62 and 63) in the alphabet used to encode the input: A to Z (indexes 0-25). a to z (indexes 26-51). 0 to 9 (indexes 52-61). + and / (indexes 62, 63). Defaults: + and / The third character in the string specifies the character used for padding. Default: ="
        }
    ],
    "returns": "A string."
},
{
    "function_name": "TRY_BASE64_DECODE_BINARY",
    "summary": "A special version of BASE64_DECODE_BINARY that returns a NULL value if an error occurs during decoding.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/try_base64_decode_binary",
    "title": "TRY_BASE64_DECODE_BINARY",
    "description": "A special version of",
    "syntax": "TRY_BASE64_DECODE_BINARY(<input> [, <alphabet>])",
    "example": "CREATE TABLE base64 (v VARCHAR, base64_encoded_varchar VARCHAR, b BINARY);\nINSERT INTO base64 (v, base64_encoded_varchar, b)\n   SELECT 'HELP', BASE64_ENCODE('HELP'),\n      TRY_BASE64_DECODE_BINARY(BASE64_ENCODE('HELP'));\n\nSELECT v, base64_encoded_varchar, \n    -- Convert binary -> base64-encoded-string\n    TO_VARCHAR(b, 'BASE64'),\n    -- Convert binary back to original value\n    TO_VARCHAR(b, 'UTF-8')\n  FROM base64;\n+------+------------------------+-------------------------+------------------------+\n| V    | BASE64_ENCODED_VARCHAR | TO_VARCHAR(B, 'BASE64') | TO_VARCHAR(B, 'UTF-8') |\n|------+------------------------+-------------------------+------------------------|\n| HELP | SEVMUA==               | SEVMUA==                | HELP                   |\n+------+------------------------+-------------------------+------------------------+",
    "arguments": [
        {
            "name": "input",
            "description": "The base64-encoded string to convert to BINARY data type."
        },
        {
            "name": "alphabet",
            "description": "A string consisting of up to three ASCII characters: The first two characters in the string specify the last two characters (indexes 62 and 63) in the alphabet used to encode the input: A to Z (indexes 0-25). a to z (indexes 26-51). 0 to 9 (indexes 52-61). + and / (indexes 62, 63). Defaults: + and / The third character in the string specifies the character used for padding. Default: ="
        }
    ],
    "returns": "This returns a BINARY value. The value can be inserted into a column of\ntype BINARY, for example."
},
{
    "function_name": "TRUNCATE, TRUNC",
    "summary": "Truncates a DATE, TIME, or TIMESTAMP value to the specified precision.",
    "category": "Date & time functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/trunc2",
    "title": "TRUNCATE, TRUNC",
    "description": "Truncates a DATE, TIME, or TIMESTAMP value to the specified precision. For example,\ntruncating a timestamp down to the quarter returns the timestamp corresponding\nto midnight of the first day of the original timestamp’s quarter.",
    "syntax": "TRUNC( <date_or_time_expr>, <date_or_time_part> )",
    "example": "CREATE OR REPLACE TABLE test_date_trunc (\n mydate DATE,\n mytime TIME,\n mytimestamp TIMESTAMP);\n\nINSERT INTO test_date_trunc VALUES (\n  '2024-05-09',\n  '08:50:48',\n  '2024-05-09 08:50:57.891 -0700');\n\nSELECT * FROM test_date_trunc;\n\n+------------+----------+-------------------------+\n| MYDATE     | MYTIME   | MYTIMESTAMP             |\n|------------+----------+-------------------------|\n| 2024-05-09 | 08:50:48 | 2024-05-09 08:50:57.891 |\n+------------+----------+-------------------------+\n\nSELECT mydate AS \"DATE\",\n       TRUNC(mydate, 'year') AS \"TRUNCATED TO YEAR\",\n       TRUNC(mydate, 'month') AS \"TRUNCATED TO MONTH\",\n       TRUNC(mydate, 'day') AS \"TRUNCATED TO DAY\"\n  FROM test_date_trunc;\n\n+------------+-------------------+--------------------+------------------+\n| DATE       | TRUNCATED TO YEAR | TRUNCATED TO MONTH | TRUNCATED TO DAY |\n|------------+-------------------+--------------------+------------------|\n| 2024-05-09 | 2024-01-01        | 2024-05-01         | 2024-05-09       |\n+------------+-------------------+--------------------+------------------+\n\nSELECT mytime AS \"TIME\",\n       TRUNCATE(mytime, 'minute') AS \"TRUNCATED TO MINUTE\"\n  FROM test_date_trunc;\n\n+----------+---------------------+\n| TIME     | TRUNCATED TO MINUTE |\n|----------+---------------------|\n| 08:50:48 | 08:50:00            |\n+----------+---------------------+\n\nSELECT mytimestamp AS \"TIMESTAMP\",\n       TRUNCATE(mytimestamp, 'hour') AS \"TRUNCATED TO HOUR\",\n       TRUNCATE(mytimestamp, 'minute') AS \"TRUNCATED TO MINUTE\",\n       TRUNCATE(mytimestamp, 'second') AS \"TRUNCATED TO SECOND\"\n  FROM test_date_trunc;\n\n+-------------------------+-------------------------+-------------------------+-------------------------+\n| TIMESTAMP               | TRUNCATED TO HOUR       | TRUNCATED TO MINUTE     | TRUNCATED TO SECOND     |\n|-------------------------+-------------------------+-------------------------+-------------------------|\n| 2024-05-09 08:50:57.891 | 2024-05-09 08:00:00.000 | 2024-05-09 08:50:00.000 | 2024-05-09 08:50:57.000 |\n+-------------------------+-------------------------+-------------------------+-------------------------+\n\nSELECT TRUNC(mytimestamp, 'quarter') AS \"TRUNCATED\",\n       EXTRACT('quarter', mytimestamp) AS \"EXTRACTED\"\n  FROM test_date_trunc;\n\n+-------------------------+-----------+\n| TRUNCATED               | EXTRACTED |\n|-------------------------+-----------|\n| 2024-04-01 00:00:00.000 |         2 |\n+-------------------------+-----------+",
    "arguments": [
        {
            "name": "date_or_time_expr",
            "description": "This argument must evaluate to a date, time, or timestamp."
        },
        {
            "name": "date_or_time_part",
            "description": "This argument must be one of the values listed in Supported date and time parts ."
        }
    ],
    "returns": "The returned value is the same type as the input value."
},
{
    "function_name": "TRUNCATE , TRUNC",
    "summary": "Rounds the input expression down to the nearest (or equal) value closer to zero.",
    "category": "Numeric functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/trunc",
    "title": "TRUNCATE , TRUNC",
    "description": "Rounds the input expression down to the nearest (or equal) value closer to zero.\nDepending on the value you specify as the scale parameter, the transformation can remove:",
    "syntax": "TRUNCATE( <input_expr> [ , <scale_expr> ] )\n\nTRUNC( <input_expr> [ , <scale_expr> ] )",
    "example": "CREATE TABLE numeric_trunc_demo (n FLOAT, scale INTEGER);\nINSERT INTO numeric_trunc_demo (n, scale) VALUES\n   (-975.975, -1), (-975.975,  0), (-975.975,  2),\n   ( 135.135, -2), ( 135.135,  0), ( 135.135,  1),\n   ( 135.135,  3), ( 135.135, 50), ( 135.135, NULL);\n\nSELECT DISTINCT n, TRUNCATE(n)\n  FROM numeric_trunc_demo ORDER BY n;\n\n+----------+-------------+\n|        N | TRUNCATE(N) |\n|----------+-------------|\n| -975.975 |        -975 |\n|  135.135 |         135 |\n+----------+-------------+\n\nSELECT n, scale, TRUNC(n, scale)\n  FROM numeric_trunc_demo ORDER BY n, scale;\n\n+----------+-------+-----------------+\n|        N | SCALE | TRUNC(N, SCALE) |\n|----------+-------+-----------------|\n| -975.975 |    -1 |        -970     |\n| -975.975 |     0 |        -975     |\n| -975.975 |     2 |        -975.97  |\n|  135.135 |    -2 |         100     |\n|  135.135 |     0 |         135     |\n|  135.135 |     1 |         135.1   |\n|  135.135 |     3 |         135.135 |\n|  135.135 |    50 |         135.135 |\n|  135.135 |  NULL |            NULL |\n+----------+-------+-----------------+",
    "arguments": [
        {
            "name": "input_expr",
            "description": "The value or expression to operate on. The data type must be one of the numeric data types, such as FLOAT or NUMBER."
        },
        {
            "name": "scale_expr",
            "description": "The number of digits to include after the decimal point. Use an expression that evaluates to an\ninteger from -38 to +38. The default scale_expr is zero, meaning that the function removes all digits after the decimal point. For information about negative scales, see the Usage notes below."
        }
    ],
    "returns": "The data type of the returned value is NUMBER(precision, scale)."
},
{
    "function_name": "TRIM",
    "summary": "Removes leading and trailing characters from a string.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/trim",
    "title": "TRIM",
    "description": "Removes leading and trailing characters from a string.",
    "syntax": "TRIM( <expr> [, <characters> ] )",
    "example": "SELECT '*-*ABC-*-' AS original,\n       TRIM('*-*ABC-*-', '*-') AS trimmed;\n\n+-----------+---------+\n| ORIGINAL  | TRIMMED |\n|-----------+---------|\n| *-*ABC-*- | ABC     |\n+-----------+---------+\n\nSELECT CONCAT('>', CONCAT('ABC\\n', '<')) AS original,\n       CONCAT('>', CONCAT(TRIM('ABC\\n', '\\n'), '<')) AS trimmed;\n\n+----------+---------+\n| ORIGINAL | TRIMMED |\n|----------+---------|\n| >ABC     | >ABC<   |\n| <        |         |\n+----------+---------+\n\nCREATE OR REPLACE TABLE test_trim_function(column1 VARCHAR);\n\nINSERT INTO test_trim_function VALUES ('  Leading Spaces'), ('Trailing Spaces  '), (NULL);\n\nSELECT CONCAT('>', CONCAT(column1, '<')) AS original_values,\n       CONCAT('>', CONCAT(TRIM(column1), '<')) AS trimmed_values\n  FROM test_trim_function;\n\n+---------------------+-------------------+\n| ORIGINAL_VALUES     | TRIMMED_VALUES    |\n|---------------------+-------------------|\n| >  Leading Spaces<  | >Leading Spaces<  |\n| >Trailing Spaces  < | >Trailing Spaces< |\n| NULL                | NULL              |\n+---------------------+-------------------+",
    "arguments": [
        {
            "name": "expr",
            "description": "A string expression to be trimmed."
        },
        {
            "name": "characters",
            "description": "One or more characters to remove from the left and right side of expr . The default value is ' ' (a single blank space character).\nIf no characters are specified, only blank spaces are removed."
        }
    ],
    "returns": "This function returns a value of VARCHAR data type or NULL. If either argument is NULL, returns NULL."
},
{
    "function_name": "TRANSLATE",
    "summary": "Replaces characters in a string.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/translate",
    "title": "TRANSLATE",
    "description": "Replaces characters in a string. Specifically, given a string, a set of characters to replace, and\nthe characters to substitute for the original characters, TRANSLATE makes the specified substitutions.",
    "syntax": "TRANSLATE( <subject>, <sourceAlphabet>, <targetAlphabet> )",
    "example": "SELECT TRANSLATE('peña','ñ','n') AS translation;\n\n+-------------+\n| TRANSLATION |\n|-------------|\n| pena        |\n+-------------+\n\nSELECT TRANSLATE('❄a❄bX❄dYZ❄','XYZ❄','cef') AS translation;\n\n+-------------+\n| TRANSLATION |\n|-------------|\n| abcdef      |\n+-------------+",
    "arguments": [
        {
            "name": "subject",
            "description": "A string expression that is translated. If a character in subject isn’t\nin sourceAlphabet , the character is added to the result without any translation."
        },
        {
            "name": "sourceAlphabet",
            "description": "A string with all characters that are modified by\nthis function. Each character is either translated to the corresponding\ncharacter in the targetAlphabet or omitted in the result. A character is\nomitted in the result if the targetAlphabet has no corresponding character\n(that is, has fewer characters than the sourceAlphabet )."
        },
        {
            "name": "targetAlphabet",
            "description": "A string with all characters that are used to replace characters from the sourceAlphabet . If targetAlphabet is longer than sourceAlphabet , Snowflake reports the\nfollowing error:"
        }
    ],
    "returns": "This function returns a value of type VARCHAR."
},
{
    "function_name": "TRANSLATE (SNOWFLAKE.CORTEX)",
    "summary": "Translates the given input text from one supported language to another.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/translate-snowflake-cortex",
    "title": "TRANSLATE (SNOWFLAKE.CORTEX)",
    "description": "Translates the given input text from one supported language to another.",
    "syntax": "SNOWFLAKE.CORTEX.TRANSLATE(\n    <text>, <source_language>, <target_language>)",
    "example": "SELECT SNOWFLAKE.CORTEX.TRANSLATE(review_content, 'en', 'de') FROM reviews LIMIT 10;\n\nSELECT SNOWFLAKE.CORTEX.TRANSLATE(\n  'Hit the slopes with Snowflake\\'s latest innovation - \"Skii Headphones\" designed to keep your ears warm and your soul ablaze. Engineered specifically for snow weather, these rugged headphones combine crystal-clear sound with thermally-insulated ear cups to keep the chill out and the beats in. Whether you\\'re carving through powder or cruising down groomers, Skii Headphones will fuel your mountain adventures with vibrant sound and unrelenting passion. Stay warm, stay fired up, and shred the mountain with Snowflake Skii Headphones',\n'en','es');\n\nSube a las pistas con la última innovación de Snowflake: \"Skii Headphones\", diseñados para mantener tus oídos calientes y tu alma encendida. Diseñados específicamente para el clima de nieve, estos audífonos resistentes combinan un sonido cristalino con copas de oído aisladas térmicamente para mantener el frío fuera y los ritmos dentro. Ya sea que estés esculpiendo en polvo o deslizándote por pistas preparadas, los Skii Headphones alimentarán tus aventuras en la montaña con un sonido vibrante y una pasión incesante. Mantente caliente, mantente encendido y arrasa la montaña con los Skii Headphones de Snowflake.\n\nSELECT SNOWFLAKE.CORTEX.TRANSLATE\n  ('Kunde: Hallo\n    Agent: Hallo, ich hoffe, es geht Ihnen gut. Um Ihnen am besten helfen zu können, teilen Sie bitte Ihren Vor- und Nachnamen und den Namen der Firma, von der aus Sie anrufen.\n    Kunde: Ja, hier ist Thomas Müller von SkiPisteExpress.\n    Agent: Danke Thomas, womit kann ich Ihnen heute helfen?\n    Kunde: Also wir haben die XtremeX Helme in Größe M bestellt, die wir speziell für die kommende Wintersaison benötigen. Jedoch sind alle Schnallen der Helme defekt, und keiner schließt richtig.\n    Agent: Ich verstehe, dass das ein Problem für Ihr Geschäft sein kann. Lassen Sie mich überprüfen, was mit Ihrer Bestellung passiert ist. Um zu bestätigen: Ihre Bestellung endet mit der Nummer 56682?\n    Kunde: Ja, das ist meine Bestellung.\n    Agent: Ich sehe das Problem. Entschuldigen Sie die Unannehmlichkeiten. Ich werde sofort eine neue Lieferung mit reparierten Schnallen für Sie vorbereiten, die in drei Tagen bei Ihnen eintreffen sollte. Ist das in Ordnung für Sie?\n    Kunde: Drei Tage sind ziemlich lang, ich hatte gehofft, diese Helme früher zu erhalten. Gibt es irgendeine Möglichkeit, die Lieferung zu beschleunigen?\n    Agent: Ich verstehe Ihre Dringlichkeit. Ich werde mein Bestes tun, um die Lieferung auf zwei Tage zu beschleunigen. Wie kommst du damit zurecht?\n    Kunde: Das wäre großartig, ich wäre Ihnen sehr dankbar.\n    Agent: Kein Problem, Thomas. Ich kümmere mich um die eilige Lieferung. Danke für Ihr Verständnis und Ihre Geduld.\n    Kunde: Vielen Dank für Ihre Hilfe. Auf Wiedersehen!\n    Agent: Bitte, gerne geschehen. Auf Wiedersehen und einen schönen Tag noch!'\n,'de','en');\n\nCustomer: Hello\nAgent: Hello, I hope you are well. To best assist you, please share your first and last name and the name of the company you are calling from.\nCustomer: Yes, this is Thomas Müller from SkiPisteExpress.\nAgent: Thank you, Thomas, what can I help you with today?\nCustomer: So, we ordered the XtremeX helmets in size M, which we specifically need for the upcoming winter season. However, all the buckles on the helmets are defective and none of them close properly.\nAgent: I understand that this can be a problem for your business. Let me check what happened with your order. To confirm: your order ends with the number 56682?\nCustomer: Yes, that's my order.\nAgent: I see the issue. I apologize for the inconvenience. I will prepare a new delivery with repaired buckles for you immediately, which should arrive in three days. Is that okay for you?\nCustomer: Three days is quite a long time; I was hoping to receive these helmets sooner. Is there any way to expedite the delivery?\nAgent: I understand your urgency. I will do my best to expedite the delivery to two days. How does that sound?\nCustomer: That would be great, I would be very grateful.\nAgent: No problem, Thomas. I will take care of the urgent delivery. Thank you for your understanding and patience.\nCustomer: Thank you very much for your help. Goodbye!\nAgent: You're welcome. Goodbye and have a nice day!\n\nSELECT SNOWFLAKE.CORTEX.TRANSLATE ('Voy a likear tus fotos en Insta.', '', 'en')\n\nI'm going to like your photos on Insta.",
    "arguments": [
        {
            "name": "text",
            "description": "A string containing the text to be translated."
        },
        {
            "name": "source_language",
            "description": "A string specifying the language code for the language the text is currently in. See Usage notes for a list of\nsupported language codes. If the source language code is an empty string, '' , the source language is\nautomatically detected."
        },
        {
            "name": "target_language",
            "description": "A string specifying the language code into which the text should be translated. See Usage notes for a list of\nsupported language codes."
        }
    ],
    "returns": "A string containing a translation of the original text into the target language."
},
{
    "function_name": "TRANSFORM",
    "summary": "Transforms an array based on the logic in a lambda expression.",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/transform",
    "title": "TRANSFORM",
    "description": "Transforms an",
    "syntax": "TRANSFORM( <array> , <lambda_expression> )",
    "example": "SELECT TRANSFORM([1, 2, 3], a INT -> a * 2) AS \"Multiply by Two\";\n\n+-----------------+\n| Multiply by Two |\n|-----------------|\n| [               |\n|   2,            |\n|   4,            |\n|   6             |\n| ]               |\n+-----------------+\n\nSELECT TRANSFORM([1, 2, 3]::ARRAY(INT), a INT -> a * 2) AS \"Multiply by Two (Structured)\";\n\n+------------------------------+\n| Multiply by Two (Structured) |\n|------------------------------|\n| [                            |\n|   2,                         |\n|   4,                         |\n|   6                          |\n| ]                            |\n+------------------------------+\n\nSELECT TRANSFORM(\n  [\n    {'name':'Pat', 'value': 50},\n    {'name':'Terry', 'value': 75},\n    {'name':'Dana', 'value': 25}\n  ],\n  c -> c:value || ' is the number') AS \"Return Values\";\n\n+-----------------------+\n| Return Values         |\n|-----------------------|\n| [                     |\n|   \"50 is the number\", |\n|   \"75 is the number\", |\n|   \"25 is the number\"  |\n| ]                     |\n+-----------------------+\n\nCREATE OR REPLACE TABLE orders AS\n  SELECT 1 AS order_id, '2024-01-01' AS order_date, [\n    {'item':'UHD Monitor', 'quantity':3, 'subtotal':1500},\n    {'item':'Business Printer', 'quantity':1, 'subtotal':1200}\n  ] AS order_detail\n  UNION SELECT 2 AS order_id, '2024-01-02' AS order_date, [\n    {'item':'Laptop', 'quantity':5, 'subtotal':7500},\n    {'item':'Noise-canceling Headphones', 'quantity':5, 'subtotal':1000}\n  ] AS order_detail;\n\nSELECT * FROM orders;\n\n+----------+------------+-------------------------------------------+\n| ORDER_ID | ORDER_DATE | ORDER_DETAIL                              |\n|----------+------------+-------------------------------------------|\n|        1 | 2024-01-01 | [                                         |\n|          |            |   {                                       |\n|          |            |     \"item\": \"UHD Monitor\",                |\n|          |            |     \"quantity\": 3,                        |\n|          |            |     \"subtotal\": 1500                      |\n|          |            |   },                                      |\n|          |            |   {                                       |\n|          |            |     \"item\": \"Business Printer\",           |\n|          |            |     \"quantity\": 1,                        |\n|          |            |     \"subtotal\": 1200                      |\n|          |            |   }                                       |\n|          |            | ]                                         |\n|        2 | 2024-01-02 | [                                         |\n|          |            |   {                                       |\n|          |            |     \"item\": \"Laptop\",                     |\n|          |            |     \"quantity\": 5,                        |\n|          |            |     \"subtotal\": 7500                      |\n|          |            |   },                                      |\n|          |            |   {                                       |\n|          |            |     \"item\": \"Noise-canceling Headphones\", |\n|          |            |     \"quantity\": 5,                        |\n|          |            |     \"subtotal\": 1000                      |\n|          |            |   }                                       |\n|          |            | ]                                         |\n+----------+------------+-------------------------------------------+\n\nSELECT order_id,\n       order_date,\n       TRANSFORM(o.order_detail, i -> OBJECT_INSERT(\n         i,\n         'unit_price',\n         (i:subtotal / i:quantity)::NUMERIC(10,2))) ORDER_DETAIL_WITH_UNIT_PRICE\n  FROM orders o;\n\n+----------+------------+-------------------------------------------+\n| ORDER_ID | ORDER_DATE | ORDER_DETAIL_WITH_UNIT_PRICE              |\n|----------+------------+-------------------------------------------|\n|        1 | 2024-01-01 | [                                         |\n|          |            |   {                                       |\n|          |            |     \"item\": \"UHD Monitor\",                |\n|          |            |     \"quantity\": 3,                        |\n|          |            |     \"subtotal\": 1500,                     |\n|          |            |     \"unit_price\": 500                     |\n|          |            |   },                                      |\n|          |            |   {                                       |\n|          |            |     \"item\": \"Business Printer\",           |\n|          |            |     \"quantity\": 1,                        |\n|          |            |     \"subtotal\": 1200,                     |\n|          |            |     \"unit_price\": 1200                    |\n|          |            |   }                                       |\n|          |            | ]                                         |\n|        2 | 2024-01-02 | [                                         |\n|          |            |   {                                       |\n|          |            |     \"item\": \"Laptop\",                     |\n|          |            |     \"quantity\": 5,                        |\n|          |            |     \"subtotal\": 7500,                     |\n|          |            |     \"unit_price\": 1500                    |\n|          |            |   },                                      |\n|          |            |   {                                       |\n|          |            |     \"item\": \"Noise-canceling Headphones\", |\n|          |            |     \"quantity\": 5,                        |\n|          |            |     \"subtotal\": 1000,                     |\n|          |            |     \"unit_price\": 200                     |\n|          |            |   }                                       |\n|          |            | ]                                         |\n+----------+------------+-------------------------------------------+\n\nSELECT order_id,\n       order_date,\n       TRANSFORM(o.order_detail, i -> OBJECT_DELETE(\n         i,\n         'quantity')) ORDER_DETAIL_WITHOUT_QUANTITY\n  FROM orders o;\n\n+----------+------------+-------------------------------------------+\n| ORDER_ID | ORDER_DATE | ORDER_DETAIL_WITHOUT_QUANTITY             |\n|----------+------------+-------------------------------------------|\n|        1 | 2024-01-01 | [                                         |\n|          |            |   {                                       |\n|          |            |     \"item\": \"UHD Monitor\",                |\n|          |            |     \"subtotal\": 1500                      |\n|          |            |   },                                      |\n|          |            |   {                                       |\n|          |            |     \"item\": \"Business Printer\",           |\n|          |            |     \"subtotal\": 1200                      |\n|          |            |   }                                       |\n|          |            | ]                                         |\n|        2 | 2024-01-02 | [                                         |\n|          |            |   {                                       |\n|          |            |     \"item\": \"Laptop\",                     |\n|          |            |     \"subtotal\": 7500                      |\n|          |            |   },                                      |\n|          |            |   {                                       |\n|          |            |     \"item\": \"Noise-canceling Headphones\", |\n|          |            |     \"subtotal\": 1000                      |\n|          |            |   }                                       |\n|          |            | ]                                         |\n+----------+------------+-------------------------------------------+",
    "arguments": [
        {
            "name": "array",
            "description": "The array that contains the elements to be transformed. The array can be semi-structured or structured."
        },
        {
            "name": "lambda_expression",
            "description": "A lambda expression that defines the transformation\nlogic on each array element. The lambda expression must have only one argument specified in the following syntax:"
        }
    ],
    "returns": "The return type of this function is a semi-structured or structured array of the lambda expression result."
},
{
    "function_name": "TO_XML",
    "summary": "Converts a VARIANT to a VARCHAR that contains an XML representation of the value.",
    "category": "Conversion functions , Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/to_xml",
    "title": "TO_XML",
    "description": "Converts a",
    "syntax": "TO_XML( <expression> )",
    "example": "CREATE OR REPLACE TABLE xml_02 (x OBJECT);\n\nINSERT INTO xml_02 (x)\n  SELECT PARSE_XML('<note> <body>Sample XML</body> </note>');\n\nSELECT x, TO_VARCHAR(x), TO_XML(x) FROM xml_02;\n\n+---------------------------+--------------------------------------+--------------------------------------+\n| X                         | TO_VARCHAR(X)                        | TO_XML(X)                            |\n|---------------------------+--------------------------------------+--------------------------------------|\n| <note>                    | <note><body>Sample XML</body></note> | <note><body>Sample XML</body></note> |\n|   <body>Sample XML</body> |                                      |                                      |\n| </note>                   |                                      |                                      |\n+---------------------------+--------------------------------------+--------------------------------------+\n\nCREATE OR REPLACE TABLE xml_03 (object_col_1 OBJECT);\n\nINSERT INTO xml_03 (object_col_1)\n  SELECT OBJECT_CONSTRUCT('key1', 'value1', 'key2', 'value2');\n\nSELECT object_col_1, TO_XML(object_col_1)\n  FROM xml_03;\n\n+---------------------+-------------------------------------------------------------------------------------------------------------------+\n| OBJECT_COL_1        | TO_XML(OBJECT_COL_1)                                                                                              |\n|---------------------+-------------------------------------------------------------------------------------------------------------------|\n| {                   | <SnowflakeData type=\"OBJECT\"><key1 type=\"VARCHAR\">value1</key1><key2 type=\"VARCHAR\">value2</key2></SnowflakeData> |\n|   \"key1\": \"value1\", |                                                                                                                   |\n|   \"key2\": \"value2\"  |                                                                                                                   |\n| }                   |                                                                                                                   |\n+---------------------+-------------------------------------------------------------------------------------------------------------------+\n\nCREATE OR REPLACE TABLE xml_04 (array_col_1 ARRAY);\n\nINSERT INTO xml_04 (array_col_1)\n  SELECT ARRAY_CONSTRUCT('v1', 'v2');\n\nSELECT array_col_1, TO_XML(array_col_1)\n  FROM xml_04;\n\n+-------------+----------------------------------------------------------------------------------------------+\n| ARRAY_COL_1 | TO_XML(ARRAY_COL_1)                                                                          |\n|-------------+----------------------------------------------------------------------------------------------|\n| [           | <SnowflakeData type=\"ARRAY\"><e type=\"VARCHAR\">v1</e><e type=\"VARCHAR\">v2</e></SnowflakeData> |\n|   \"v1\",     |                                                                                              |\n|   \"v2\"      |                                                                                              |\n| ]           |                                                                                              |\n+-------------+----------------------------------------------------------------------------------------------+\n\nCREATE OR REPLACE TABLE xml_05 (json_col_1 VARIANT);\n\nINSERT INTO xml_05 (json_col_1)\n  SELECT PARSE_JSON(' { \"key1\": [\"a1\", \"a2\"] } ');\n\nSELECT json_col_1,\n       TO_JSON(json_col_1),\n       TO_XML(json_col_1)\n  FROM xml_05;\n\n+-------------+----------------------+-------------------------------------------------------------------------------------------------------------------------+\n| JSON_COL_1  | TO_JSON(JSON_COL_1)  | TO_XML(JSON_COL_1)                                                                                                      |\n|-------------+----------------------+-------------------------------------------------------------------------------------------------------------------------|\n| {           | {\"key1\":[\"a1\",\"a2\"]} | <SnowflakeData type=\"OBJECT\"><key1 type=\"ARRAY\"><e type=\"VARCHAR\">a1</e><e type=\"VARCHAR\">a2</e></key1></SnowflakeData> |\n|   \"key1\": [ |                      |                                                                                                                         |\n|     \"a1\",   |                      |                                                                                                                         |\n|     \"a2\"    |                      |                                                                                                                         |\n|   ]         |                      |                                                                                                                         |\n| }           |                      |                                                                                                                         |\n+-------------+----------------------+-------------------------------------------------------------------------------------------------------------------------+",
    "arguments": [
        {
            "name": "expression",
            "description": "An expression that evaluates to a VARIANT or that can be cast to a VARIANT."
        }
    ],
    "returns": "The data type of the returned value is VARCHAR."
},
{
    "function_name": "TO_VARIANT",
    "summary": "Converts any value to a VARIANT value or NULL (if input is NULL).",
    "category": "Conversion functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/to_variant",
    "title": "TO_VARIANT",
    "description": "Converts any value to a",
    "syntax": "TO_VARIANT( <expr> )",
    "example": "CREATE OR REPLACE TABLE to_variant_example (\n  v_varchar   VARIANT,\n  v_number    VARIANT,\n  v_timestamp VARIANT,\n  v_array     VARIANT,\n  v_object    VARIANT);\n\nINSERT INTO to_variant_example (v_varchar, v_number, v_timestamp, v_array, v_object)\n  SELECT\n    TO_VARIANT('Skiing is fun!'),\n    TO_VARIANT(3.14),\n    TO_VARIANT('2024-01-25 01:02:03'),\n    TO_VARIANT(ARRAY_CONSTRUCT('San Mateo', 'Seattle', 'Berlin')),\n    PARSE_JSON(' { \"key1\": \"value1\", \"key2\": \"value2\" } ');\n\nSELECT * FROM to_variant_example;\n\n+------------------+----------+-----------------------+----------------+---------------------+\n| V_VARCHAR        | V_NUMBER | V_TIMESTAMP           | V_ARRAY        | V_OBJECT            |\n|------------------+----------+-----------------------+----------------+---------------------|\n| \"Skiing is fun!\" | 3.14     | \"2024-01-25 01:02:03\" | [              | {                   |\n|                  |          |                       |   \"San Mateo\", |   \"key1\": \"value1\", |\n|                  |          |                       |   \"Seattle\",   |   \"key2\": \"value2\"  |\n|                  |          |                       |   \"Berlin\"     | }                   |\n|                  |          |                       | ]              |                     |\n+------------------+----------+-----------------------+----------------+---------------------+",
    "arguments": [
        {
            "name": "expr",
            "description": "An expression of any data type."
        }
    ]
},
{
    "function_name": "TO_TIMESTAMP / TO_TIMESTAMP_*",
    "summary": "Converts an input expression into the corresponding timestamp.",
    "category": "Conversion functions , Date & time functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/to_timestamp",
    "title": "TO_TIMESTAMP / TO_TIMESTAMP_*",
    "description": "Converts an input expression into the corresponding timestamp:",
    "syntax": "timestampFunction ( <numeric_expr> [ , <scale> ] )\n\ntimestampFunction ( <date_expr> )\n\ntimestampFunction ( <timestamp_expr> )\n\ntimestampFunction ( <string_expr> [ , <format> ] )\n\ntimestampFunction ( '<integer>' )\n\ntimestampFunction ( <variant_expr> )",
    "example": "ALTER SESSION SET TIMEZONE = 'America/Los_Angeles';\n\nSELECT TO_TIMESTAMP_TZ('2024-04-05 01:02:03');\n\n+----------------------------------------+\n| TO_TIMESTAMP_TZ('2024-04-05 01:02:03') |\n|----------------------------------------|\n| 2024-04-05 01:02:03.000 -0700          |\n+----------------------------------------+\n\nSELECT TO_TIMESTAMP_NTZ('2024-04-05 01:02:03');\n\n+-----------------------------------------+\n| TO_TIMESTAMP_NTZ('2024-04-05 01:02:03') |\n|-----------------------------------------|\n| 2024-04-05 01:02:03.000                 |\n+-----------------------------------------+\n\nSELECT TO_TIMESTAMP_TZ('04/05/2024 01:02:03', 'mm/dd/yyyy hh24:mi:ss');\n\n+-----------------------------------------------------------------+\n| TO_TIMESTAMP_TZ('04/05/2024 01:02:03', 'MM/DD/YYYY HH24:MI:SS') |\n|-----------------------------------------------------------------|\n| 2024-04-05 01:02:03.000 -0700                                   |\n+-----------------------------------------------------------------+\n\nSELECT TO_TIMESTAMP_TZ('04/05/2024 01:02:03', 'dd/mm/yyyy hh24:mi:ss');\n\n+-----------------------------------------------------------------+\n| TO_TIMESTAMP_TZ('04/05/2024 01:02:03', 'DD/MM/YYYY HH24:MI:SS') |\n|-----------------------------------------------------------------|\n| 2024-05-04 01:02:03.000 -0700                                   |\n+-----------------------------------------------------------------+\n\nALTER SESSION SET TIMESTAMP_OUTPUT_FORMAT = 'YYYY-MM-DD HH24:MI:SS.FF9 TZH:TZM';\n\nSELECT TO_TIMESTAMP_NTZ(40 * 365.25 * 86400);\n\n+---------------------------------------+\n| TO_TIMESTAMP_NTZ(40 * 365.25 * 86400) |\n|---------------------------------------|\n| 2010-01-01 00:00:00.000               |\n+---------------------------------------+\n\nSELECT TO_TIMESTAMP_NTZ(40 * 365.25 * 86400 * 1000 + 456, 3);\n\n+-------------------------------------------------------+\n| TO_TIMESTAMP_NTZ(40 * 365.25 * 86400 * 1000 + 456, 3) |\n|-------------------------------------------------------|\n| 2010-01-01 00:00:00.456                               |\n+-------------------------------------------------------+\n\nSELECT TO_TIMESTAMP(1000000000, 0) AS \"Scale in seconds\",\n       TO_TIMESTAMP(1000000000, 3) AS \"Scale in milliseconds\",\n       TO_TIMESTAMP(1000000000, 6) AS \"Scale in microseconds\",\n       TO_TIMESTAMP(1000000000, 9) AS \"Scale in nanoseconds\";\n\n+-------------------------+-------------------------+-------------------------+-------------------------+\n| Scale in seconds        | Scale in milliseconds   | Scale in microseconds   | Scale in nanoseconds    |\n|-------------------------+-------------------------+-------------------------+-------------------------|\n| 2001-09-09 01:46:40.000 | 1970-01-12 13:46:40.000 | 1970-01-01 00:16:40.000 | 1970-01-01 00:00:01.000 |\n+-------------------------+-------------------------+-------------------------+-------------------------+\n\nCREATE OR REPLACE TABLE demo1 (\n  description VARCHAR,\n  value VARCHAR -- string rather than bigint\n);\n\nINSERT INTO demo1 (description, value) VALUES\n  ('Seconds',      '31536000'),\n  ('Milliseconds', '31536000000'),\n  ('Microseconds', '31536000000000'),\n  ('Nanoseconds',  '31536000000000000');\n\nSELECT description,\n       value,\n       TO_TIMESTAMP(value),\n       TO_DATE(value)\n  FROM demo1\n  ORDER BY value;\n\n+--------------+-------------------+-------------------------+----------------+\n| DESCRIPTION  | VALUE             | TO_TIMESTAMP(VALUE)     | TO_DATE(VALUE) |\n|--------------+-------------------+-------------------------+----------------|\n| Seconds      | 31536000          | 1971-01-01 00:00:00.000 | 1971-01-01     |\n| Milliseconds | 31536000000       | 1971-01-01 00:00:00.000 | 1971-01-01     |\n| Microseconds | 31536000000000    | 1971-01-01 00:00:00.000 | 1971-01-01     |\n| Nanoseconds  | 31536000000000000 | 1971-01-01 00:00:00.000 | 1971-01-01     |\n+--------------+-------------------+-------------------------+----------------+\n\nSELECT 0::TIMESTAMP_NTZ, PARSE_JSON(0)::TIMESTAMP_NTZ, PARSE_JSON(0)::INT::TIMESTAMP_NTZ;\n\n+-------------------------+------------------------------+-----------------------------------+\n| 0::TIMESTAMP_NTZ        | PARSE_JSON(0)::TIMESTAMP_NTZ | PARSE_JSON(0)::INT::TIMESTAMP_NTZ |\n|-------------------------+------------------------------+-----------------------------------|\n| 1970-01-01 00:00:00.000 | 1969-12-31 16:00:00.000      | 1970-01-01 00:00:00.000           |\n+-------------------------+------------------------------+-----------------------------------+\n\nSELECT TO_TIMESTAMP_NTZ(0), TO_TIMESTAMP_NTZ(PARSE_JSON(0)), TO_TIMESTAMP_NTZ(PARSE_JSON(0)::INT);\n\n+-------------------------+---------------------------------+--------------------------------------+\n| TO_TIMESTAMP_NTZ(0)     | TO_TIMESTAMP_NTZ(PARSE_JSON(0)) | TO_TIMESTAMP_NTZ(PARSE_JSON(0)::INT) |\n|-------------------------+---------------------------------+--------------------------------------|\n| 1970-01-01 00:00:00.000 | 1969-12-31 16:00:00.000         | 1970-01-01 00:00:00.000              |\n+-------------------------+---------------------------------+--------------------------------------+",
    "arguments": [
        {
            "name": "numeric_expr",
            "description": "A number of seconds (if scale = 0 or is absent) or fractions of a second (e.g. milliseconds or nanoseconds)\nsince the start of the Unix epoch (1970-01-01 00:00:00 UTC). If a non-integer decimal expression is input, the\nscale of the result is inherited."
        },
        {
            "name": "date_expr",
            "description": "A date to be converted into a timestamp."
        },
        {
            "name": "timestamp_expr",
            "description": "A timestamp to be converted into another timestamp (e.g. convert TIMESTAMP_LTZ to TIMESTAMP_NTZ)."
        },
        {
            "name": "string_expr",
            "description": "A string from which to extract a timestamp, for example '2019-01-31 01:02:03.004' ."
        },
        {
            "name": "'",
            "description": "An expression that evaluates to a string containing an integer, for example '15000000' . Depending\non the magnitude of the string, it can be interpreted as seconds, milliseconds, microseconds, or\nnanoseconds. For details, see the Usage Notes ."
        },
        {
            "name": "variant_expr",
            "description": "An expression of type VARIANT. The VARIANT must contain one of the following: A string from which to extract a timestamp. A timestamp. An integer that represents the number of seconds, milliseconds, microseconds, or nanoseconds. A string containing an integer that represents the number of seconds, milliseconds, microseconds, or nanoseconds. Although TO_TIMESTAMP accepts a DATE value, it does not accept a DATE inside a VARIANT."
        },
        {
            "name": "format",
            "description": "Format specifier (only for string_expr ). For more information, see Date and time formats in conversion functions . The default value is the current value of the TIMESTAMP_INPUT_FORMAT parameter (default AUTO )."
        },
        {
            "name": "scale",
            "description": "Scale specifier (only for numeric_expr ). If specified, defines the scale of the numbers provided. For example: For seconds, scale = 0 . For milliseconds, scale = 3 . For microseconds, scale = 6 . For nanoseconds, scale = 9 . Default: 0"
        }
    ],
    "returns": "The data type of the returned value is one of the TIMESTAMP data\ntypes. By default, the data type is TIMESTAMP_NTZ. You can change\nthis by setting the session parameter TIMESTAMP_TYPE_MAPPING."
},
{
    "function_name": "TO_TIME , TIME",
    "summary": "Converts an input expression into a time.",
    "category": "Conversion functions , Date & time functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/to_time",
    "title": "TO_TIME , TIME",
    "description": "Converts an input expression into a time.",
    "syntax": "TO_TIME( <string_expr> [, <format> ] )\nTO_TIME( <timestamp_expr> )\nTO_TIME( '<integer>' )\nTO_TIME( <variant_expr> )\n\nTIME( <string_expr> )\nTIME( <timestamp_expr> )\nTIME( '<integer>' )\nTIME( <variant_expr> )",
    "example": "SELECT TO_TIME('13:30:00'), TIME('13:30:00');\n\n+---------------------+------------------+\n| TO_TIME('13:30:00') | TIME('13:30:00') |\n|---------------------+------------------|\n| 13:30:00            | 13:30:00         |\n+---------------------+------------------+\n\nSELECT TO_TIME('13:30:00.000'), TIME('13:30:00.000');\n\n+-------------------------+----------------------+\n| TO_TIME('13:30:00.000') | TIME('13:30:00.000') |\n|-------------------------+----------------------|\n| 13:30:00                | 13:30:00             |\n+-------------------------+----------------------+\n\nSELECT TO_TIME('11.15.00', 'HH24.MI.SS');\n\n+-----------------------------------+\n| TO_TIME('11.15.00', 'HH24.MI.SS') |\n|-----------------------------------|\n| 11:15:00                          |\n+-----------------------------------+\n\nCREATE OR REPLACE TABLE demo1_time (\n  description VARCHAR,\n  value VARCHAR -- string rather than bigint\n);\n\nINSERT INTO demo1_time (description, value) VALUES\n  ('Seconds',      '31536001'),\n  ('Milliseconds', '31536002400'),\n  ('Microseconds', '31536003600000'),\n  ('Nanoseconds',  '31536004900000000');\n\nSELECT description,\n       value,\n       TO_TIMESTAMP(value),\n       TO_TIME(value)\n  FROM demo1_time\n  ORDER BY value;\n\n+--------------+-------------------+-------------------------+----------------+\n| DESCRIPTION  | VALUE             | TO_TIMESTAMP(VALUE)     | TO_TIME(VALUE) |\n|--------------+-------------------+-------------------------+----------------|\n| Seconds      | 31536001          | 1971-01-01 00:00:01.000 | 00:00:01       |\n| Milliseconds | 31536002400       | 1971-01-01 00:00:02.400 | 00:00:02       |\n| Microseconds | 31536003600000    | 1971-01-01 00:00:03.600 | 00:00:03       |\n| Nanoseconds  | 31536004900000000 | 1971-01-01 00:00:04.900 | 00:00:04       |\n+--------------+-------------------+-------------------------+----------------+",
    "arguments": [
        {
            "name": "string_expr",
            "description": "Expression to be converted into a time: For string_expr , the string to convert to a time. For timestamp_expr , the timestamp to convert to a time. The function returns the time portion of the input value. For ' integer ' , a string containing an integer to convert to a time. The integer is treated as a number of seconds, milliseconds,\nmicroseconds, or nanoseconds after the start of the Unix epoch. See the Usage Notes . For this timestamp, the function gets the number of seconds after the start of the Unix epoch. The function performs a modulo operation to get the remainder from dividing this number by the\nnumber of seconds in a day ( 86400 ): number_of_seconds % 86400 The function interprets this remainder as the number of seconds after midnight. For example, suppose that the value is '31536002789' . Based on the magnitude of this value, the function uses milliseconds as the unit of time and determines that the value\nrepresents 1971-01-01 00:00:02.789 . The function gets the number of seconds after the Unix epoch for this value ( 31536002 ). The function gets the remainder from dividing that number by the number of seconds in a day ( 31536002 % 86400 ). The function uses the remainder ( 2 ) as the number of seconds after midnight. The resulting time is 00:00:02 . For variant_expr : If the VARIANT contains a string in TIME format (such as HH:MI:SS ), a string conversion is performed. If the VARIANT contains a string in INTEGER format, a string conversion is performed and the value is\ntreated as the number of seconds since midnight (modulus 86400 if necessary). If the VARIANT contains a JSON null value, the output is NULL. For all other values, a conversion error is generated."
        },
        {
            "name": "format",
            "description": "Time format specifier for string_expr or AUTO ,\nwhich specifies that Snowflake automatically detects the format to use. For more information,\nsee Date and time formats in conversion functions . Default: The current value of the TIME_INPUT_FORMAT session parameter (default AUTO)"
        }
    ],
    "returns": "The data type of the returned value is TIME. If the input is NULL, returns NULL."
},
{
    "function_name": "TO_QUERY",
    "summary": "Returns a result set based on SQL text and an optional set of arguments that are passed to the SQL text if it is parameterized.",
    "category": "Table functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/to_query",
    "title": "TO_QUERY",
    "description": "Returns a result set based on SQL text and an optional set of arguments that are passed to the SQL text if\nit is parameterized. The function compiles the SQL text as the definition of a subquery in the FROM clause.\nWhen writing an application or a stored procedure, you can call this function to construct a SQL statement.",
    "syntax": "TO_QUERY( SQL => '<string>' [ , <arg> => '<value>' [, <arg> => '<value>' ...] ] )",
    "example": "CREATE OR REPLACE TABLE to_query_example (\n  deptno NUMBER(2),\n  dname  VARCHAR(14),\n  loc    VARCHAR(13))\nAS SELECT\n  column1,\n  column2,\n  column3\nFROM\n  VALUES\n    (10, 'ACCOUNTING', 'NEW YORK'),\n    (20, 'RESEARCH',   'DALLAS'  ),\n    (30, 'SALES',      'CHICAGO' ),\n    (40, 'OPERATIONS', 'BOSTON'  );\n\nSET table_name = 'to_query_example';\n\nSELECT * FROM TABLE(TO_QUERY('SELECT * FROM IDENTIFIER($table_name)'));\n\n+--------+------------+----------+\n| DEPTNO | DNAME      | LOC      |\n|--------+------------+----------|\n|     10 | ACCOUNTING | NEW YORK |\n|     20 | RESEARCH   | DALLAS   |\n|     30 | SALES      | CHICAGO  |\n|     40 | OPERATIONS | BOSTON   |\n+--------+------------+----------+\n\nSELECT deptno FROM TABLE(TO_QUERY('SELECT * FROM IDENTIFIER($table_name)'));\n\n+--------+\n| DEPTNO |\n|--------|\n|     10 |\n|     20 |\n|     30 |\n|     40 |\n+--------+\n\nSELECT * FROM TABLE(\n  TO_QUERY(\n    'SELECT * FROM IDENTIFIER($table_name)\n    WHERE deptno = TO_NUMBER(:dno)', dno => '10'\n    )\n  );\n\n+--------+------------+----------+\n| DEPTNO | DNAME      | LOC      |\n|--------+------------+----------|\n|     10 | ACCOUNTING | NEW YORK |\n+--------+------------+----------+\n\nSET dept = '10';\n\nSELECT * FROM TABLE(\n  TO_QUERY(\n    'SELECT * FROM IDENTIFIER($table_name)\n    WHERE deptno = TO_NUMBER(:dno)', dno => $dept\n    )\n  );\n\n+--------+------------+----------+\n| DEPTNO | DNAME      | LOC      |\n|--------+------------+----------|\n|     10 | ACCOUNTING | NEW YORK |\n+--------+------------+----------+\n\nSELECT * FROM TABLE(\n  TO_QUERY(\n    'SELECT * FROM IDENTIFIER($table_name)\n    WHERE deptno = TO_NUMBER(:dno) OR dname = :dnm',\n    dno => '10', dnm => 'SALES'\n    )\n  );\n\n+--------+------------+----------+\n| DEPTNO | DNAME      | LOC      |\n|--------+------------+----------|\n|     10 | ACCOUNTING | NEW YORK |\n|     30 | SALES      | CHICAGO  |\n+--------+------------+----------+\n\nCREATE OR REPLACE PROCEDURE get_num_results_tq(query VARCHAR)\nRETURNS TABLE ()\nLANGUAGE SQL\nAS\nDECLARE\n  res RESULTSET DEFAULT (SELECT COUNT(*) FROM TABLE(TO_QUERY(:query)));\nBEGIN\n  RETURN TABLE(res);\nEND;\n\nCREATE OR REPLACE PROCEDURE get_num_results_tq(query VARCHAR)\nRETURNS TABLE ()\nLANGUAGE SQL\nAS\n$$\nDECLARE\n  res RESULTSET DEFAULT (SELECT COUNT(*) FROM TABLE(TO_QUERY(:query)));\nBEGIN\n  RETURN TABLE(res);\nEND;\n$$\n;\n\nCALL get_num_results_tq('SELECT * FROM to_query_example');\n\n+----------+\n| COUNT(*) |\n|----------|\n|        4 |\n+----------+\n\nCALL get_num_results_tq('SELECT * FROM to_query_example WHERE deptno = 20');\n\n+----------+\n| COUNT(*) |\n|----------|\n|        1 |\n+----------+\n\nCREATE OR REPLACE PROCEDURE get_results_tqbnd(dno VARCHAR)\nRETURNS TABLE ()\nLANGUAGE SQL\nAS\nDECLARE\n  res RESULTSET DEFAULT (SELECT * FROM TABLE(\n    TO_QUERY(\n      'SELECT * FROM to_query_example\n      WHERE deptno = TO_NUMBER(:dnoval)', dnoval => :dno\n    )\n  ));\nBEGIN\n  RETURN TABLE(res);\nEND;\n\nCREATE OR REPLACE PROCEDURE get_results_tqbnd(dno VARCHAR)\nRETURNS TABLE ()\nLANGUAGE SQL\nAS\n$$\nDECLARE\n  res RESULTSET DEFAULT (SELECT * FROM TABLE(\n    TO_QUERY(\n      'SELECT * FROM to_query_example\n      WHERE deptno = TO_NUMBER(:dnoval)', dnoval => :dno\n    )\n  ));\nBEGIN\n  RETURN TABLE(res);\nEND;\n$$\n;\n\nCALL get_results_tqbnd('40');\n\n+--------+------------+--------+\n| DEPTNO | DNAME      | LOC    |\n|--------+------------+--------|\n|     40 | OPERATIONS | BOSTON |\n+--------+------------+--------+\n\nSET dept = '20';\n\nCALL get_results_tqbnd($dept);\n\n+--------+----------+--------+\n| DEPTNO | DNAME    | LOC    |\n|--------+----------+--------|\n|     20 | RESEARCH | DALLAS |\n+--------+----------+--------+",
    "arguments": [
        {
            "name": "SQL",
            "description": "String representation of the subquery."
        },
        {
            "name": "arg",
            "description": "Bind variables passed to the SQL string ."
        }
    ],
    "returns": "Returns the result set produced by the execution of the specified SQL text or NULL. If any argument is NULL,\nthe function returns NULL without reporting any error."
},
{
    "function_name": "TO_OBJECT",
    "summary": "Converts the input value to an OBJECT.",
    "category": "Conversion functions , Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/to_object",
    "title": "TO_OBJECT",
    "description": "Converts the input value to an",
    "syntax": "TO_OBJECT( <expr> )",
    "example": "CREATE TABLE t1 (vo VARIANT);\nINSERT INTO t1 (vo) \n    SELECT PARSE_JSON('{\"a\":1}');\n\nSELECT TO_OBJECT(vo) from t1;\n+---------------+\n| TO_OBJECT(VO) |\n|---------------|\n| {             |\n|   \"a\": 1      |\n| }             |\n+---------------+",
    "arguments": [
        {
            "name": "expr",
            "description": "An expression that evaluates to a VARIANT that contains an OBJECT."
        }
    ],
    "returns": "The data type of the returned value is OBJECT."
},
{
    "function_name": "TO_JSON",
    "summary": "Converts a VARIANT value to a string containing the JSON representation of the value.",
    "category": "Conversion functions , Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/to_json",
    "title": "TO_JSON",
    "description": "Converts a",
    "syntax": "TO_JSON( <expr> )",
    "example": "CREATE OR REPLACE TABLE jdemo1 (v VARIANT);\nINSERT INTO jdemo1 SELECT PARSE_JSON('{\"food\":\"bard\"}');\n\nSELECT v, v:food, TO_JSON(v) FROM jdemo1;\n\n+------------------+--------+-----------------+\n| V                | V:FOOD | TO_JSON(V)      |\n|------------------+--------+-----------------|\n| {                | \"bard\" | {\"food\":\"bard\"} |\n|   \"food\": \"bard\" |        |                 |\n| }                |        |                 |\n+------------------+--------+-----------------+\n\nSELECT TO_JSON(NULL), TO_JSON('null'::VARIANT),\n       PARSE_JSON(NULL), PARSE_JSON('null');\n\n+---------------+--------------------------+------------------+--------------------+\n| TO_JSON(NULL) | TO_JSON('NULL'::VARIANT) | PARSE_JSON(NULL) | PARSE_JSON('NULL') |\n|---------------+--------------------------+------------------+--------------------|\n| NULL          | \"null\"                   | NULL             | null               |\n+---------------+--------------------------+------------------+--------------------+\n\nCREATE OR REPLACE TABLE jdemo2 (\n  varchar1 VARCHAR, \n  variant1 VARIANT);\n\nINSERT INTO jdemo2 (varchar1) VALUES ('{\"PI\":3.14}');\n\nUPDATE jdemo2 SET variant1 = PARSE_JSON(varchar1);\n\nSELECT varchar1, \n       PARSE_JSON(varchar1), \n       variant1, \n       TO_JSON(variant1),\n       PARSE_JSON(varchar1) = variant1, \n       TO_JSON(variant1) = varchar1\n  FROM jdemo2;\n\n+-------------+----------------------+--------------+-------------------+---------------------------------+------------------------------+\n| VARCHAR1    | PARSE_JSON(VARCHAR1) | VARIANT1     | TO_JSON(VARIANT1) | PARSE_JSON(VARCHAR1) = VARIANT1 | TO_JSON(VARIANT1) = VARCHAR1 |\n|-------------+----------------------+--------------+-------------------+---------------------------------+------------------------------|\n| {\"PI\":3.14} | {                    | {            | {\"PI\":3.14}       | True                            | True                         |\n|             |   \"PI\": 3.14         |   \"PI\": 3.14 |                   |                                 |                              |\n|             | }                    | }            |                   |                                 |                              |\n+-------------+----------------------+--------------+-------------------+---------------------------------+------------------------------+\n\nSELECT TO_JSON(PARSE_JSON('{\"b\":1,\"a\":2}')),\n       TO_JSON(PARSE_JSON('{\"b\":1,\"a\":2}')) = '{\"b\":1,\"a\":2}',\n       TO_JSON(PARSE_JSON('{\"b\":1,\"a\":2}')) = '{\"a\":2,\"b\":1}';\n\n+--------------------------------------+--------------------------------------------------------+--------------------------------------------------------+\n| TO_JSON(PARSE_JSON('{\"B\":1,\"A\":2}')) | TO_JSON(PARSE_JSON('{\"B\":1,\"A\":2}')) = '{\"B\":1,\"A\":2}' | TO_JSON(PARSE_JSON('{\"B\":1,\"A\":2}')) = '{\"A\":2,\"B\":1}' |\n|--------------------------------------+--------------------------------------------------------+--------------------------------------------------------|\n| {\"a\":2,\"b\":1}                        | False                                                  | True                                                   |\n+--------------------------------------+--------------------------------------------------------+--------------------------------------------------------+",
    "arguments": [
        {
            "name": "expr",
            "description": "An expression of type VARIANT that holds valid JSON information."
        }
    ],
    "returns": "Returns a value of type VARCHAR."
},
{
    "function_name": "TO_GEOMETRY",
    "summary": "Parses an input and returns a value of type GEOMETRY.",
    "category": "Geospatial functions , Conversion functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/to_geometry",
    "title": "TO_GEOMETRY",
    "description": "Parses an input and returns a value of type",
    "syntax": "TO_GEOMETRY( <varchar_expression> [ , <srid> ] [ , <allow_invalid> ] )\n\nTO_GEOMETRY( <binary_expression> [ , <srid> ] [ , <allow_invalid> ] )\n\nTO_GEOMETRY( <variant_expression> [ , <srid> ] [ , <allow_invalid> ] )\n\nTO_GEOMETRY( <geography_expression> [ , <srid> ] [ , <allow_invalid> ] )",
    "example": "ALTER SESSION SET GEOMETRY_OUTPUT_FORMAT='EWKT';\n\nSELECT TO_GEOMETRY('POINT(1820.12 890.56)');\n\n+--------------------------------------+\n| TO_GEOMETRY('POINT(1820.12 890.56)') |\n|--------------------------------------|\n| SRID=0;POINT(1820.12 890.56)         |\n+--------------------------------------+\n\nALTER SESSION SET GEOMETRY_OUTPUT_FORMAT='EWKT';\n\nSELECT TO_GEOMETRY('SRID=4326;POINT(1820.12 890.56)');\n\n+------------------------------------------------+\n| TO_GEOMETRY('SRID=4326;POINT(1820.12 890.56)') |\n|------------------------------------------------|\n| SRID=4326;POINT(1820.12 890.56)                |\n+------------------------------------------------+\n\nALTER SESSION SET GEOMETRY_OUTPUT_FORMAT='EWKT';\n\nSELECT TO_GEOMETRY('POINT(1820.12 890.56)', 4326);\n\n+--------------------------------------------+\n| TO_GEOMETRY('POINT(1820.12 890.56)', 4326) |\n|--------------------------------------------|\n| SRID=4326;POINT(1820.12 890.56)            |\n+--------------------------------------------+\n\nALTER SESSION SET GEOMETRY_OUTPUT_FORMAT='EWKT';\n\nSELECT TO_GEOMETRY('SRID=32633;POINTZ(389866.35 5819003.03 30)');\n\n+-----------------------------------------------------------+\n| TO_GEOMETRY('SRID=32633;POINTZ(389866.35 5819003.03 30)') |\n|-----------------------------------------------------------|\n| SRID=32633;POINTZ(389866.35 5819003.03 30)                |\n+-----------------------------------------------------------+",
    "arguments": [
        {
            "name": "varchar_expression",
            "description": "The argument must be a string expression that represents a valid geometric object in one of the following formats: WKT (well-known text). WKB (well-known binary) in hexadecimal format (without a leading 0x ). EWKT (extended well-known text). EWKB (extended well-known binary) in hexadecimal format (without a leading 0x ). GeoJSON."
        },
        {
            "name": "binary_expression",
            "description": "The argument must be a binary expression in WKB or EWKB format."
        },
        {
            "name": "variant_expression",
            "description": "The argument must be an OBJECT in GeoJSON format."
        },
        {
            "name": "geography_expression",
            "description": "The argument must be an expression of type GEOGRAPHY."
        },
        {
            "name": "srid",
            "description": "The integer value of the SRID to use."
        },
        {
            "name": "allow_invalid",
            "description": "If TRUE, specifies that the function should return a GEOGRAPHY or GEOMETRY object, even when the input shape is invalid and\ncannot be repaired. For details, refer to Specifying how invalid geospatial shapes are handled ."
        }
    ],
    "returns": "The function returns a value of type GEOMETRY."
},
{
    "function_name": "TO_GEOGRAPHY",
    "summary": "Parses an input and returns a value of type GEOGRAPHY.",
    "category": "Geospatial functions , Conversion functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/to_geography",
    "title": "TO_GEOGRAPHY",
    "description": "Parses an input and returns a value of type",
    "syntax": "TO_GEOGRAPHY( <varchar_expression> [ , <allow_invalid> ] )\n\nTO_GEOGRAPHY( <binary_expression> [ , <allow_invalid> ] )\n\nTO_GEOGRAPHY( <variant_expression> [ , <allow_invalid> ] )\n\nTO_GEOGRAPHY( <geometry_expression> [ , <allow_invalid> ] )",
    "example": "select TO_GEOGRAPHY('POINT(-122.35 37.55)');\n\n+--------------------------------------+\n| TO_GEOGRAPHY('POINT(-122.35 37.55)') |\n|--------------------------------------|\n| POINT(-122.35 37.55)                 |\n+--------------------------------------+\n\nselect TO_GEOGRAPHY('POINTZ(-122.35 37.55 30)');\n\n+------------------------------------------+\n| TO_GEOGRAPHY('POINTZ(-122.35 37.55 30)') |\n|------------------------------------------|\n| POINTZ(-122.35 37.55 30)                 |\n+------------------------------------------+",
    "arguments": [
        {
            "name": "varchar_expression",
            "description": "The argument must be a string expression that represents a valid geometric object in one of the following formats: WKT (well-known text). WKB (well-known binary) in hexadecimal format (without a leading 0x ). EWKT (extended well-known text). EWKB (extended well-known binary) in hexadecimal format (without a leading 0x ). GeoJSON."
        },
        {
            "name": "binary_expression",
            "description": "The argument must be a binary expression in WKB or EWKB format."
        },
        {
            "name": "variant_expression",
            "description": "The argument must be an OBJECT in GeoJSON format."
        },
        {
            "name": "geometry_expression",
            "description": "The argument must be an expression of type GEOMETRY with the SRID 4326."
        },
        {
            "name": "allow_invalid",
            "description": "If TRUE, specifies that the function should return a GEOGRAPHY or GEOMETRY object, even when the input shape is invalid and\ncannot be repaired. For details, refer to Specifying how invalid geospatial shapes are handled ."
        }
    ],
    "returns": "The function returns a value of type GEOGRAPHY."
},
{
    "function_name": "TO_FILE",
    "summary": "Constructs a value of type FILE from a file location or from metadata.",
    "category": "",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/to_file",
    "title": "TO_FILE",
    "syntax": "TO_FILE( <stage_name>, <relative_path> )\n\nTO_FILE( <file_url> )\n\nTO_FILE( <metadata> )",
    "example": "SELECT TO_FILE(BUILD_STAGE_FILE_URL('@mystage', 'image.png'));\n\n+--------------------------------------------------------------------------------------------------------------------+\n| TO_FILE(BUILD_STAGE_FILE_URL('@MYSTAGE', 'IMAGE.PNG'))                                                             |\n|--------------------------------------------------------------------------------------------------------------------|\n| {                                                                                                                  |\n|   \"CONTENT_TYPE\": \"image/png\",                                                                                     |\n|   \"ETAG\": \"...\"                                                                                                    |\n|   \"LAST_MODIFIED\": \"Wed, 11 Dec 2024 20:24:00 GMT\",                                                                |\n|   \"RELATIVE_PATH\": \"image.png\",                                                                                    |\n|   \"SIZE\": 105859,                                                                                                  |\n|   \"STAGE\": \"@MYDB.MYSCHEMA.MYSTAGE\",                                                                               |\n|   \"STAGE_FILE_URL\": \"https://snowflake.account.snowflakecomputing.com/api/files/MYDB/MYSCHEMA/MYSTAGE/image.png\"   |\n| }                                                                                                                  |\n+--------------------------------------------------------------------------------------------------------------------+\n\nSELECT TO_FILE(file_url) FROM DIRECTORY(@mystage) LIMIT 1;\n\n+--------------------------------------------------------------------------------------------------------------------+\n| TO_FILE(FILE_URL)                                                                                                  |\n|--------------------------------------------------------------------------------------------------------------------|\n| {                                                                                                                  |\n|   \"CONTENT_TYPE\": \"image/png\",                                                                                     |\n|   \"ETAG\": \"...\"                                                                                                    |\n|   \"LAST_MODIFIED\": \"Wed, 11 Dec 2024 20:24:00 GMT\",                                                                |\n|   \"RELATIVE_PATH\": \"image.png\",                                                                                    |\n|   \"SIZE\": 105859,                                                                                                  |\n|   \"STAGE\": \"@MYDB.MYSCHEMA.MYSTAGE\",                                                                               |\n|   \"STAGE_FILE_URL\": \"https://snowflake.account.snowflakecomputing.com/api/files/MYDB/MYSCHEMA/MYSTAGE/image.png\"   |\n| }                                                                                                                  |\n+--------------------------------------------------------------------------------------------------------------------+\n\nSELECT TO_FILE(`https://snowflake.account.snowflakecomputing.com/api/files/01ba4df2-0100-0001-0000-00040002e2b6/299017/Y6JShH6KjV`);\n\n+------------------------------------------------------------------------------------------------------------------------------------------------+\n| TO_FILE(https://snowflake.account.snowflakecomputing.com/api/files/01ba4df2-0100-0001-0000-00040002e2b6/299017/Y6JShH6KjV                      |\n|------------------------------------------------------------------------------------------------------------------------------------------------|\n| {                                                                                                                                              |\n|   \"CONTENT_TYPE\": \"image/png\",                                                                                                                 |\n|   \"ETAG\": \"...\"                                                                                                                                |\n|   \"LAST_MODIFIED\": \"Wed, 11 Dec 2024 20:24:00 GMT\",                                                                                            |\n|   \"SCOPED_FILE_URL\": \"https://snowflake.account.snowflakecomputing.com/api/files/01ba4df2-0100-0001-0000-00040002e2b6/299017/Y6JShH6KjV\",      |\n|   \"SIZE\": 105859                                                                                                                               |\n| }                                                                                                                                              |\n+-----------------------------------------------------------------------------------------------------------------------------------------------+|\n\nSELECT TO_FILE(OBJECT_CONSTRUCT('STAGE', 'MYSTAGE', 'RELATIVE_PATH', 'image.png', 'ETAG', '<ETAG value>',\n  'LAST_MODIFIED', 'Wed, 11 Dec 2024 20:24:00 GMT', 'SIZE', 105859, 'CONTENT_TYPE', 'image/png'));\n\n+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| TO_FILE(OBJECT_CONSTRUCT('STAGE', 'MYSTAGE', 'RELATIVE_PATH', 'IMAGE.PNG', 'ETAG', '<ETAG value>', 'LAST_MODIFIED', 'WED, 11 DEC 2024 20:24:00 GMT', 'SIZE', 105859, 'CONTENT_TYPE', 'IMAGE/PNG')) |\n|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| {                                                                                                                                                                                                  |\n|   \"CONTENT_TYPE\": \"image/png\",                                                                                                                                                                     |\n|   \"ETAG\": \"<ETAG value>>\"                                                                                                                                                                          |\n|   \"LAST_MODIFIED\": \"Wed, 11 Dec 2024 20:24:00 GMT\",                                                                                                                                                |\n|   \"RELATIVE_PATH\": \"image.png\",                                                                                                                                                                    |\n|   \"SIZE\": 105859,                                                                                                                                                                                  |\n|   \"STAGE\": \"@MYDB.MYSCHEMA.MYSTAGE\"                                                                                                                                                                |\n| }                                                                                                                                                                                                  |\n+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+",
    "arguments": [
        {
            "name": "stage_name",
            "description": "The name of the stage where the file is located, as a string, in the form '@stage_name' ."
        },
        {
            "name": "relative_path",
            "description": "The path to the file on the stage specified by stage_name as a string."
        },
        {
            "name": "file_url",
            "description": "A valid stage or scoped file URL as a string."
        },
        {
            "name": "metadata",
            "description": "An OBJECT containing the required FILE metadata. A FILE must have CONTENT_TYPE, SIZE, ETAG, and LAST_MODIFIED fields.\nIt must also specify the file’s location in one of the following ways: Both STAGE and RELATIVE_PATH STAGE_FILE_URL SCOPED_FILE_URL"
        }
    ],
    "returns": "A FILE that represents the staged file."
},
{
    "function_name": "TO_DOUBLE",
    "summary": "Converts an expression to a double-precision floating-point number.",
    "category": "Conversion functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/to_double",
    "title": "TO_DOUBLE",
    "description": "Converts an expression to a double-precision floating-point number.",
    "syntax": "TO_DOUBLE( <expr> [, '<format>' ] )",
    "example": "CREATE OR REPLACE TABLE double_demo (d DECIMAL(7, 2), v VARCHAR, o VARIANT);\nINSERT INTO double_demo (d, v, o) SELECT 1.1, '2.2', TO_VARIANT(3.14);\nSELECT TO_DOUBLE(d), TO_DOUBLE(v), TO_DOUBLE(o) FROM double_demo;\n\n+--------------+--------------+--------------+\n| TO_DOUBLE(D) | TO_DOUBLE(V) | TO_DOUBLE(O) |\n|--------------+--------------+--------------|\n|          1.1 |          2.2 |         3.14 |\n+--------------+--------------+--------------+\n\nSELECT TO_DOUBLE(1.1)::NUMBER(38, 18);\n\n+--------------------------------+\n| TO_DOUBLE(1.1)::NUMBER(38, 18) |\n|--------------------------------|\n|           1.100000000000000089 |\n+--------------------------------+",
    "arguments": [
        {
            "name": "expr",
            "description": "An expression of a numeric, character, or variant type."
        },
        {
            "name": "format",
            "description": "If the expression evaluates to a string, then the function accepts\nan optional format model. Format models are described at SQL format models . The format model\nspecifies the format of the input string, not the format of the\noutput value."
        }
    ],
    "returns": "This function returns a value of FLOAT data type."
},
{
    "function_name": "TO_DECIMAL , TO_NUMBER , TO_NUMERIC",
    "summary": "Converts an input expression to a fixed-point number.",
    "category": "Conversion functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/to_decimal",
    "title": "TO_DECIMAL , TO_NUMBER , TO_NUMERIC",
    "description": "Converts an input expression to a fixed-point number. For NULL input, the\noutput is NULL.",
    "syntax": "TO_DECIMAL( <expr> [, '<format>' ] [, <precision> [, <scale> ] ] )\n\nTO_NUMBER( <expr> [, '<format>' ] [, <precision> [, <scale> ] ] )\n\nTO_NUMERIC( <expr> [, '<format>' ] [, <precision> [, <scale> ] ] )",
    "example": "CREATE OR REPLACE TABLE number_conv(expr VARCHAR);\nINSERT INTO number_conv VALUES ('12.3456'), ('98.76546');\n\nSELECT expr,\n       TO_NUMBER(expr),\n       TO_NUMBER(expr, 10, 1),\n       TO_NUMBER(expr, 10, 8)\n  FROM number_conv;\n\n+----------+-----------------+------------------------+------------------------+\n| EXPR     | TO_NUMBER(EXPR) | TO_NUMBER(EXPR, 10, 1) | TO_NUMBER(EXPR, 10, 8) |\n|----------+-----------------+------------------------+------------------------|\n| 12.3456  |              12 |                   12.3 |            12.34560000 |\n| 98.76546 |              99 |                   98.8 |            98.76546000 |\n+----------+-----------------+------------------------+------------------------+\n\nSELECT expr, TO_NUMBER(expr, 10, 9) FROM number_conv;\n\n100039 (22003): Numeric value '12.3456' is out of range\n\nSELECT column1,\n       TO_DECIMAL(column1, '99.9') as D0,\n       TO_DECIMAL(column1, '99.9', 9, 5) as D5,\n       TO_DECIMAL(column1, 'TM9', 9, 5) as TD5\n  FROM VALUES ('1.0'), ('-12.3'), ('0.0'), ('- 0.1');\n\n+---------+-----+-----------+-----------+\n| COLUMN1 |  D0 |        D5 |       TD5 |\n|---------+-----+-----------+-----------|\n| 1.0     |   1 |   1.00000 |   1.00000 |\n| -12.3   | -12 | -12.30000 | -12.30000 |\n| 0.0     |   0 |   0.00000 |   0.00000 |\n| - 0.1   |   0 |  -0.10000 |  -0.10000 |\n+---------+-----+-----------+-----------+\n\nSELECT column1,\n       TO_DECIMAL(column1, '9,999.99', 6, 2) as convert_number\n  FROM VALUES ('3,741.72');\n\n+----------+----------------+\n| COLUMN1  | CONVERT_NUMBER |\n|----------+----------------|\n| 3,741.72 |        3741.72 |\n+----------+----------------+\n\nSELECT column1,\n       TO_DECIMAL(column1, '$9,999.99', 6, 2) as convert_currency\n  FROM VALUES ('$3,741.72');\n\n+-----------+------------------+\n| COLUMN1   | CONVERT_CURRENCY |\n|-----------+------------------|\n| $3,741.72 |          3741.72 |\n+-----------+------------------+\n\nSELECT TO_DECIMAL('ae5', 'XXX');\n\n+--------------------------+\n| TO_DECIMAL('AE5', 'XXX') |\n|--------------------------|\n|                     2789 |\n+--------------------------+\n\nSELECT TO_DECIMAL('ae5', 'XX');\n\n100140 (22007): Can't parse 'ae5' as number with format 'XX'",
    "arguments": [
        {
            "name": "expr",
            "description": "An expression of a numeric, character, or variant type."
        },
        {
            "name": "format",
            "description": "The SQL format model used to parse the input expr and return. For more\ninformation, see SQL format models ."
        },
        {
            "name": "precision",
            "description": "The maximal number of decimal digits in the resulting number; from 1\nto 38. In Snowflake, precision is not used for determination of the\nnumber of bytes needed to store the number and does not have any effect\non efficiency, so the default is the maximum (38)."
        },
        {
            "name": "scale",
            "description": "The number of fractional decimal digits (from 0 to precision - 1).\n0 indicates no fractional digits (i.e. an integer number). The default scale\nis 0."
        }
    ],
    "returns": "The function returns NUMBER(precision, scale)."
},
{
    "function_name": "TO_DATE , DATE",
    "summary": "Converts an input expression to a date.",
    "category": "Conversion functions , Date & time functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/to_date",
    "title": "TO_DATE , DATE",
    "description": "Converts an input expression to a date:",
    "syntax": "TO_DATE( <string_expr> [, <format> ] )\nTO_DATE( <timestamp_expr> )\nTO_DATE( '<integer>' )\nTO_DATE( <variant_expr> )\n\nDATE( <string_expr> [, <format> ] )\nDATE( <timestamp_expr> )\nDATE( '<integer>' )\nDATE( <variant_expr> )",
    "example": "SELECT TO_DATE('2024-05-10'), DATE('2024-05-10');\n\n+-----------------------+--------------------+\n| TO_DATE('2024-05-10') | DATE('2024-05-10') |\n|-----------------------+--------------------|\n| 2024-05-10            | 2024-05-10         |\n+-----------------------+--------------------+\n\nCREATE OR REPLACE TABLE date_from_timestamp(ts TIMESTAMP);\n\nINSERT INTO date_from_timestamp(ts)\n  VALUES (TO_TIMESTAMP('2024.10.02 04:00:00', 'YYYY.MM.DD HH:MI:SS'));\n\nSELECT ts FROM date_from_timestamp;\n\n+-------------------------+\n| TS                      |\n|-------------------------|\n| 2024-10-02 04:00:00.000 |\n+-------------------------+\n\nSELECT TO_DATE(ts) FROM date_from_timestamp;\n\n+-------------+\n| TO_DATE(TS) |\n|-------------|\n| 2024-10-02  |\n+-------------+\n\nSELECT TO_DATE('2024.05.10', 'YYYY.MM.DD'), DATE('2024.05.10', 'YYYY.MM.DD');\n\n+-------------------------------------+----------------------------------+\n| TO_DATE('2024.05.10', 'YYYY.MM.DD') | DATE('2024.05.10', 'YYYY.MM.DD') |\n|-------------------------------------+----------------------------------|\n| 2024-05-10                          | 2024-05-10                       |\n+-------------------------------------+----------------------------------+\n\nSELECT TO_DATE('2024-05-10', 'AUTO'), DATE('2024-05-10', 'AUTO');\n\n+-------------------------------+----------------------------+\n| TO_DATE('2024-05-10', 'AUTO') | DATE('2024-05-10', 'AUTO') |\n|-------------------------------+----------------------------|\n| 2024-05-10                    | 2024-05-10                 |\n+-------------------------------+----------------------------+\n\nSELECT TO_DATE('05/10/2024', 'MM/DD/YYYY'), DATE('05/10/2024', 'MM/DD/YYYY');\n\n+-------------------------------------+----------------------------------+\n| TO_DATE('05/10/2024', 'MM/DD/YYYY') | DATE('05/20/2024', 'MM/DD/YYYY') |\n|-------------------------------------+----------------------------------|\n| 2024-05-10                          | 2024-05-20                       |\n+-------------------------------------+----------------------------------+\n\nALTER SESSION SET DATE_OUTPUT_FORMAT = 'DD-MON-YYYY';\n\nSELECT TO_DATE('2024-05-10', 'YYYY-MM-DD'), DATE('2024-05-10', 'YYYY-MM-DD');\n\n+-------------------------------------+----------------------------------+\n| TO_DATE('2024-05-10', 'YYYY-MM-DD') | DATE('2024-05-10', 'YYYY-MM-DD') |\n|-------------------------------------+----------------------------------|\n| 10-May-2024                         | 10-May-2024                      |\n+-------------------------------------+----------------------------------+\n\nSELECT TO_DATE('05/10/2024', 'MM/DD/YYYY'), DATE('05/10/2024', 'MM/DD/YYYY');\n\n+-------------------------------------+----------------------------------+\n| TO_DATE('05/10/2024', 'MM/DD/YYYY') | DATE('05/10/2024', 'MM/DD/YYYY') |\n|-------------------------------------+----------------------------------|\n| 10-May-2024                         | 10-May-2024                      |\n+-------------------------------------+----------------------------------+\n\nCREATE OR REPLACE TABLE demo1 (\n  description VARCHAR,\n  value VARCHAR -- string rather than bigint\n);\n\nINSERT INTO demo1 (description, value) VALUES\n  ('Seconds',      '31536000'),\n  ('Milliseconds', '31536000000'),\n  ('Microseconds', '31536000000000'),\n  ('Nanoseconds',  '31536000000000000');\n\nSELECT description,\n       value,\n       TO_TIMESTAMP(value),\n       TO_DATE(value)\n  FROM demo1\n  ORDER BY value;\n\n+--------------+-------------------+-------------------------+----------------+\n| DESCRIPTION  | VALUE             | TO_TIMESTAMP(VALUE)     | TO_DATE(VALUE) |\n|--------------+-------------------+-------------------------+----------------|\n| Seconds      | 31536000          | 1971-01-01 00:00:00.000 | 1971-01-01     |\n| Milliseconds | 31536000000       | 1971-01-01 00:00:00.000 | 1971-01-01     |\n| Microseconds | 31536000000000    | 1971-01-01 00:00:00.000 | 1971-01-01     |\n| Nanoseconds  | 31536000000000000 | 1971-01-01 00:00:00.000 | 1971-01-01     |\n+--------------+-------------------+-------------------------+----------------+",
    "arguments": [
        {
            "name": "string_expr",
            "description": "String from which to extract a date. For example: '2024-01-31' ."
        },
        {
            "name": "timestamp_expr",
            "description": "A TIMESTAMP expression. The DATE portion of the TIMESTAMP value is extracted."
        },
        {
            "name": "'",
            "description": "An expression that evaluates to a string containing an integer. For example: '15000000' . Depending\non the magnitude of the string, it can be interpreted as seconds, milliseconds, microseconds, or\nnanoseconds. For details, see the Usage notes for this function."
        },
        {
            "name": "variant_expr",
            "description": "An expression of type VARIANT. The VARIANT must contain one of the following: A string from which to extract a date. A date. A string containing an integer that represents the number of seconds or milliseconds. Although TO_DATE accepts a TIMESTAMP value, it does not accept a TIMESTAMP value inside a VARIANT."
        },
        {
            "name": "format",
            "description": "Date format specifier for string_expr or AUTO ,\nwhich specifies that Snowflake automatically detects the format to use. For more information,\nsee Date and time formats in conversion functions . The default is the current value of the DATE_INPUT_FORMAT session parameter (default AUTO )."
        }
    ],
    "returns": "The data type of the returned value is DATE. If the input is NULL, returns NULL."
},
{
    "function_name": "TO_CHAR , TO_VARCHAR",
    "summary": "Converts the input expression to a string.",
    "category": "Conversion functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/to_char",
    "title": "TO_CHAR , TO_VARCHAR",
    "description": "Converts the input expression to a string. For NULL input, the output is NULL.",
    "syntax": "TO_CHAR( <expr> )\nTO_CHAR( <numeric_expr> [, '<format>' ] )\nTO_CHAR( <date_or_time_expr> [, '<format>' ] )\nTO_CHAR( <binary_expr> [, '<format>' ] )\n\nTO_VARCHAR( <expr> )\nTO_VARCHAR( <numeric_expr> [, '<format>' ] )\nTO_VARCHAR( <date_or_time_expr> [, '<format>' ] )\nTO_VARCHAR( <binary_expr> [, '<format>' ] )",
    "example": "CREATE OR REPLACE TABLE convert_numbers_to_strings(column1 NUMBER);\n\nINSERT INTO convert_numbers_to_strings VALUES\n  (-12.391),\n  (0),\n  (-1),\n  (0.10),\n  (0.01),\n  (3987),\n  (1.111);\n\nSELECT column1 AS orig_value,\n       TO_CHAR(column1, '\">\"$99.0\"<\"') AS D2_1,\n       TO_CHAR(column1, '\">\"B9,999.0\"<\"') AS D4_1,\n       TO_CHAR(column1, '\">\"TME\"<\"') AS TME,\n       TO_CHAR(column1, '\">\"TM9\"<\"') AS TM9,\n       TO_CHAR(column1, '\">\"0XXX\"<\"') AS X4,\n       TO_CHAR(column1, '\">\"S0XXX\"<\"') AS SX4\n  FROM convert_numbers_to_strings;\n\n+------------+----------+------------+-------------+------------+--------+---------+\n| ORIG_VALUE | D2_1     | D4_1       | TME         | TM9        | X4     | SX4     |\n|------------+----------+------------+-------------+------------+--------+---------|\n|    -12.391 | >-$12.4< | >   -12.4< | >-1.2391E1< | >-12.391<  | >FFF4< | >-000C< |\n|      0.000 | >  $0.0< | >      .0< | >0E0<       | >0.000<    | >0000< | >+0000< |\n|     -1.000 | > -$1.0< | >    -1.0< | >-1E0<      | >-1.000<   | >FFFF< | >-0001< |\n|      0.100 | >  $0.1< | >      .1< | >1E-1<      | >0.100<    | >0000< | >+0000< |\n|      0.010 | >  $0.0< | >      .0< | >1E-2<      | >0.010<    | >0000< | >+0000< |\n|   3987.000 | > $##.#< | > 3,987.0< | >3.987E3<   | >3987.000< | >0F93< | >+0F93< |\n|      1.111 | >  $1.1< | >     1.1< | >1.111E0<   | >1.111<    | >0001< | >+0001< |\n+------------+----------+------------+-------------+------------+--------+---------+\n\nSELECT TO_VARCHAR(LOG(3,4));\n\n+----------------------+\n| TO_VARCHAR(LOG(3,4)) |\n|----------------------|\n| 1.261859507          |\n+----------------------+\n\nSELECT TO_VARCHAR('2024-04-05 01:02:03'::TIMESTAMP, 'mm/dd/yyyy, hh24:mi hours');\n\n+---------------------------------------------------------------------------+\n| TO_VARCHAR('2024-04-05 01:02:03'::TIMESTAMP, 'MM/DD/YYYY, HH24:MI HOURS') |\n|---------------------------------------------------------------------------|\n| 04/05/2024, 01:02 hours                                                   |\n+---------------------------------------------------------------------------+\n\nSELECT TO_VARCHAR('03-April-2024'::DATE);\n\n+-----------------------------------+\n| TO_VARCHAR('03-APRIL-2024'::DATE) |\n|-----------------------------------|\n| 2024-04-03                        |\n+-----------------------------------+\n\nSELECT TO_VARCHAR('03-April-2024'::DATE, 'yyyy.mm.dd');\n\n+-------------------------------------------------+\n| TO_VARCHAR('03-APRIL-2024'::DATE, 'YYYY.MM.DD') |\n|-------------------------------------------------|\n| 2024.04.03                                      |\n+-------------------------------------------------+",
    "arguments": [
        {
            "name": "expr",
            "description": "An expression of any data type."
        },
        {
            "name": "numeric_expr",
            "description": "A numeric expression."
        },
        {
            "name": "date_or_time_expr",
            "description": "An expression of type DATE, TIME, or TIMESTAMP."
        },
        {
            "name": "binary_expr",
            "description": "An expression of type BINARY or VARBINARY."
        },
        {
            "name": "format",
            "description": "The format of the output string: For numeric_expr , specifies the SQL format model used to\ninterpret the numeric expression. For more information, see SQL format models . For date_or_time_expr , specifies the expected format to parse\nor produce a string. For more information, see Date and time formats in conversion functions . The default is the current value of the following session\nparameters: DATE_OUTPUT_FORMAT (for DATE inputs) TIME_OUTPUT_FORMAT (for TIME inputs) TIMESTAMP_OUTPUT_FORMAT (for TIMESTAMP inputs) For binary_expr , specifies the format in which to produce\nthe string (e.g. ‘HEX’, ‘BASE64’ or ‘UTF-8’). For more information, see Overview of supported binary formats ."
        }
    ],
    "returns": "This function returns a value of VARCHAR data type or NULL."
},
{
    "function_name": "TO_BOOLEAN",
    "summary": "Converts the input text or numeric expression to a BOOLEAN value.",
    "category": "Conversion functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/to_boolean",
    "title": "TO_BOOLEAN",
    "description": "Converts the input text or numeric expression to a",
    "syntax": "TO_BOOLEAN( <string_or_numeric_expr> )",
    "example": "CREATE OR REPLACE TABLE test_boolean(\n  b BOOLEAN,\n  n NUMBER,\n  s STRING);\n\nINSERT INTO test_boolean VALUES\n  (true, 1, 'yes'),\n  (false, 0, 'no'),\n  (null, null, null);\n\nSELECT * FROM test_boolean;\n\n+-------+------+------+\n| B     |    N | S    |\n|-------+------+------|\n| True  |    1 | yes  |\n| False |    0 | no   |\n| NULL  | NULL | NULL |\n+-------+------+------+\n\nSELECT s, TO_BOOLEAN(s) FROM test_boolean;\n\n+------+---------------+\n| S    | TO_BOOLEAN(S) |\n|------+---------------|\n| yes  | True          |\n| no   | False         |\n| NULL | NULL          |\n+------+---------------+\n\nSELECT n, TO_BOOLEAN(n) FROM test_boolean;\n\n+------+---------------+\n|    N | TO_BOOLEAN(N) |\n|------+---------------|\n|    1 | True          |\n|    0 | False         |\n| NULL | NULL          |\n+------+---------------+",
    "arguments": [
        {
            "name": "string_or_numeric_expr",
            "description": "A string expression or numeric expression that can be evaluated to a BOOLEAN value."
        }
    ],
    "returns": "Returns a BOOLEAN value or NULL."
},
{
    "function_name": "TO_BINARY",
    "summary": "Converts the input expression to a binary value.",
    "category": "Conversion functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/to_binary",
    "title": "TO_BINARY",
    "description": "Converts the input expression to a binary value. For NULL input, the output is NULL.",
    "syntax": "TO_BINARY( <string_expr> [, '<format>'] )\nTO_BINARY( <variant_expr> )",
    "example": "CREATE TABLE binary_test (v VARCHAR, b BINARY);\nINSERT INTO binary_test(v) VALUES ('SNOW');\n\nUPDATE binary_test SET b = TO_BINARY(HEX_ENCODE(v), 'HEX');\n\nSELECT v, HEX_DECODE_STRING(TO_VARCHAR(b, 'HEX')) FROM binary_test;\n+------+-----------------------------------------+\n| V    | HEX_DECODE_STRING(TO_VARCHAR(B, 'HEX')) |\n|------+-----------------------------------------|\n| SNOW | SNOW                                    |\n+------+-----------------------------------------+\n\nSELECT TO_BINARY('SNOW', 'utf-8');\n+----------------------------+\n| TO_BINARY('SNOW', 'UTF-8') |\n|----------------------------|\n| 534E4F57                   |\n+----------------------------+\n\nSELECT TO_VARCHAR(TO_BINARY('SNOW', 'utf-8'), 'HEX');\n+-----------------------------------------------+\n| TO_VARCHAR(TO_BINARY('SNOW', 'UTF-8'), 'HEX') |\n|-----------------------------------------------|\n| 534E4F57                                      |\n+-----------------------------------------------+",
    "arguments": [
        {
            "name": "string_expr",
            "description": "A string expression."
        },
        {
            "name": "format",
            "description": "The binary format for conversion: HEX, BASE64, or UTF-8 (see Binary input and output ). The default is the value of the\nBINARY_INPUT_FORMAT session parameter. If this parameter is not set, the\ndefault is HEX."
        }
    ],
    "returns": "The return type is BINARY."
},
{
    "function_name": "TO_ARRAY",
    "summary": "Converts the input expression to an ARRAY value.",
    "category": "Conversion functions , Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/to_array",
    "title": "TO_ARRAY",
    "description": "Converts the input expression to an",
    "syntax": "TO_ARRAY( <expr> )",
    "example": "CREATE OR REPLACE TABLE array_demo_2 (\n  ID INTEGER,\n  array1 ARRAY,\n  array2 ARRAY);\n\nINSERT INTO array_demo_2 (ID, array1, array2)\n  SELECT 1, TO_ARRAY(1), TO_ARRAY(3);\n\nSELECT * FROM array_demo_2;\n\n+----+--------+--------+\n| ID | ARRAY1 | ARRAY2 |\n|----+--------+--------|\n|  1 | [      | [      |\n|    |   1    |   3    |\n|    | ]      | ]      |\n+----+--------+--------+\n\nSELECT array1, array2, ARRAY_CAT(array1, array2)\n  FROM array_demo_2;\n\n+--------+--------+---------------------------+\n| ARRAY1 | ARRAY2 | ARRAY_CAT(ARRAY1, ARRAY2) |\n|--------+--------+---------------------------|\n| [      | [      | [                         |\n|   1    |   3    |   1,                      |\n| ]      | ]      |   3                       |\n|        |        | ]                         |\n+--------+--------+---------------------------+\n\nSELECT TO_ARRAY('snowman,snowball,snowcone') AS to_array_result;\n\n+-------------------------------+\n| TO_ARRAY_RESULT               |\n|-------------------------------|\n| [                             |\n|   \"snowman,snowball,snowcone\" |\n| ]                             |\n+-------------------------------+\n\nSELECT STRTOK_TO_ARRAY('snowman,snowball,snowcone', ',') AS strtok_to_array_result;\n\n+------------------------+\n| STRTOK_TO_ARRAY_RESULT |\n|------------------------|\n| [                      |\n|   \"snowman\",           |\n|   \"snowball\",          |\n|   \"snowcone\"           |\n| ]                      |\n+------------------------+",
    "arguments": [
        {
            "name": "expr",
            "description": "An expression of any data type."
        }
    ],
    "returns": "This function returns a value of type ARRAY or NULL:"
},
{
    "function_name": "TIMESTAMPDIFF",
    "summary": "Calculates the difference between two date, time, or timestamp expressions based on the specified date or time part.",
    "category": "Date & time functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/timestampdiff",
    "title": "TIMESTAMPDIFF",
    "description": "Calculates the difference between two date, time, or timestamp expressions based on the specified date or time part.\nThe function returns the result of subtracting the second argument from the third argument.",
    "syntax": "TIMESTAMPDIFF( <date_or_time_part> , <date_or_time_expr1> , <date_or_time_expr2> )",
    "arguments": [
        {
            "name": "date_or_time_part",
            "description": "The unit of time. Must be one of the values listed in Supported date and time parts (for example, month ).\nThe value can be a string literal or can be unquoted (for example, 'month' or month )."
        },
        {
            "name": "date_or_time_expr1",
            "description": "The values to compare. Must be a date, a time, a timestamp, or an expression that can be evaluated to\na date, a time, or a timestamp. The value date_or_time_expr1 is subtracted from date_or_time_expr2 ."
        }
    ],
    "returns": "Returns an integer representing the number of units (seconds, days, etc.) difference between date_or_time_expr2 and\ndate_or_time_expr1."
},
{
    "function_name": "TIMESTAMPADD",
    "summary": "Adds the specified value for the specified date or time part to a date, time, or timestamp.",
    "category": "Date & time functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/timestampadd",
    "title": "TIMESTAMPADD",
    "description": "Adds the specified value for the specified date or time part to a date, time, or timestamp.",
    "syntax": "TIMESTAMPADD( <date_or_time_part> , <time_value> , <date_or_time_expr> )",
    "example": "SELECT TO_DATE('2022-05-08') AS original_date,\n       DATEADD(year, 2, TO_DATE('2022-05-08')) AS date_plus_two_years;\n\n+---------------+---------------------+\n| ORIGINAL_DATE | DATE_PLUS_TWO_YEARS |\n|---------------+---------------------|\n| 2022-05-08    | 2024-05-08          |\n+---------------+---------------------+\n\nSELECT TO_DATE('2022-05-08') AS original_date,\n       DATEADD(year, -2, TO_DATE('2022-05-08')) AS date_minus_two_years;\n\n+---------------+----------------------+\n| ORIGINAL_DATE | DATE_MINUS_TWO_YEARS |\n|---------------+----------------------|\n| 2022-05-08    | 2020-05-08           |\n+---------------+----------------------+\n\nALTER SESSION SET TIMESTAMP_OUTPUT_FORMAT = 'YYYY-MM-DD HH24:MI:SS.FF9';\nCREATE TABLE datetest (d date);\nINSERT INTO datetest VALUES ('2022-04-05');\n\nSELECT d AS original_date,\n       DATEADD(year, 2, d) AS date_plus_two_years,\n       TO_TIMESTAMP(d) AS original_timestamp,\n       DATEADD(hour, 2, d) AS timestamp_plus_two_hours\n  FROM datetest;\n\n+---------------+---------------------+-------------------------+--------------------------+\n| ORIGINAL_DATE | DATE_PLUS_TWO_YEARS | ORIGINAL_TIMESTAMP      | TIMESTAMP_PLUS_TWO_HOURS |\n|---------------+---------------------+-------------------------+--------------------------|\n| 2022-04-05    | 2024-04-05          | 2022-04-05 00:00:00.000 | 2022-04-05 02:00:00.000  |\n+---------------+---------------------+-------------------------+--------------------------+\n\nSELECT DATEADD(month, 1, '2023-01-31'::DATE) AS date_plus_one_month;\n\n+---------------------+\n| DATE_PLUS_ONE_MONTH |\n|---------------------|\n| 2023-02-28          |\n+---------------------+\n\nSELECT DATEADD(month, 1, '2023-02-28'::DATE) AS date_plus_one_month;\n\n+---------------------+\n| DATE_PLUS_ONE_MONTH |\n|---------------------|\n| 2023-03-28          |\n+---------------------+\n\nSELECT TO_TIME('05:00:00') AS original_time,\n       DATEADD(hour, 3, TO_TIME('05:00:00')) AS time_plus_three_hours;\n\n+---------------+-----------------------+\n| ORIGINAL_TIME | TIME_PLUS_THREE_HOURS |\n|---------------+-----------------------|\n| 05:00:00      | 08:00:00              |\n+---------------+-----------------------+",
    "arguments": [
        {
            "name": "date_or_time_part",
            "description": "This indicates the units of time that you want to add. For example if you\nwant to add two days, then specify day . This unit of measure must\nbe one of the values listed in Supported date and time parts ."
        },
        {
            "name": "value",
            "description": "This is the number of units of time that you want to add. For example,\nif the units of time is day , and you want to add two days, specify 2 .\nIf you want to subtract two days, specify -2 ."
        },
        {
            "name": "date_or_time_expr",
            "description": "date_or_time_expr must evaluate to a date, time, or timestamp.\nThis is the date, time, or timestamp to which you want to add.\nFor example, if you want to add two days to August 1, 2024, then specify '2024-08-01'::DATE . If the data type is TIME, then the date_or_time_part must be in units of hours or smaller, not days or bigger. If the input data type is DATE, and the date_or_time_part is hours\nor smaller, the input value will not be rejected, but instead will be\ntreated as a TIMESTAMP with hours, minutes, seconds, and fractions of\na second all initially set to 0 (e.g. midnight on the specified date)."
        }
    ],
    "returns": "If date_or_time_expr is a time, then the return data type is a time."
},
{
    "function_name": "TIMESTAMP_FROM_PARTS",
    "summary": "Creates a timestamp from individual numeric components.",
    "category": "Date & time functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/timestamp_from_parts",
    "title": "TIMESTAMP_FROM_PARTS",
    "description": "Creates a timestamp from individual numeric components. If no time zone is in effect, the function can be used to create a timestamp from a date expression and a time expression.",
    "syntax": "TIMESTAMP_FROM_PARTS( <year>, <month>, <day>, <hour>, <minute>, <second> [, <nanosecond> ] [, <time_zone> ] )\n\nTIMESTAMP_FROM_PARTS( <date_expr>, <time_expr> )",
    "example": "ALTER SESSION SET TIMESTAMP_OUTPUT_FORMAT='YYYY-MM-DD HH24:MI:SS.FF9 TZH:TZM';\nALTER SESSION SET TIMESTAMP_NTZ_OUTPUT_FORMAT='YYYY-MM-DD HH24:MI:SS.FF9 TZH:TZM';\nALTER SESSION SET TIMEZONE='America/New_York';\n\nSELECT TIMESTAMP_LTZ_FROM_PARTS(2013, 4, 5, 12, 00, 00);\n+--------------------------------------------------+\n| TIMESTAMP_LTZ_FROM_PARTS(2013, 4, 5, 12, 00, 00) |\n|--------------------------------------------------|\n| 2013-04-05 12:00:00.000000000 -0400              |\n+--------------------------------------------------+\n\nselect timestamp_ntz_from_parts(2013, 4, 5, 12, 00, 00, 987654321);\n+-------------------------------------------------------------+\n| TIMESTAMP_NTZ_FROM_PARTS(2013, 4, 5, 12, 00, 00, 987654321) |\n|-------------------------------------------------------------|\n| 2013-04-05 12:00:00.987654321                               |\n+-------------------------------------------------------------+\n\nselect timestamp_ntz_from_parts(to_date('2013-04-05'), to_time('12:00:00'));\n+----------------------------------------------------------------------+\n| TIMESTAMP_NTZ_FROM_PARTS(TO_DATE('2013-04-05'), TO_TIME('12:00:00')) |\n|----------------------------------------------------------------------|\n| 2013-04-05 12:00:00.000000000                                        |\n+----------------------------------------------------------------------+\n\nselect timestamp_tz_from_parts(2013, 4, 5, 12, 00, 00);\n+-------------------------------------------------+\n| TIMESTAMP_TZ_FROM_PARTS(2013, 4, 5, 12, 00, 00) |\n|-------------------------------------------------|\n| 2013-04-05 12:00:00.000000000 -0400             |\n+-------------------------------------------------+\n\nselect timestamp_tz_from_parts(2013, 4, 5, 12, 00, 00, 0, 'America/Los_Angeles');\n+---------------------------------------------------------------------------+\n| TIMESTAMP_TZ_FROM_PARTS(2013, 4, 5, 12, 00, 00, 0, 'AMERICA/LOS_ANGELES') |\n|---------------------------------------------------------------------------|\n| 2013-04-05 12:00:00.000000000 -0700                                       |\n+---------------------------------------------------------------------------+\n\nselect timestamp_from_parts(2013, 4, 5, 12, 0, -3600);\n+------------------------------------------------+\n| TIMESTAMP_FROM_PARTS(2013, 4, 5, 12, 0, -3600) |\n|------------------------------------------------|\n| 2013-04-05 11:00:00.000000000                  |\n+------------------------------------------------+",
    "arguments": [
        {
            "name": "year",
            "description": "An integer expression to use as a year for building a timestamp."
        },
        {
            "name": "month",
            "description": "An integer expression to use as a month for building a timestamp, with January represented as 1 , and December as 12 ."
        },
        {
            "name": "day",
            "description": "An integer expression to use as a day for building a timestamp, usually in the 1 - 31 range."
        },
        {
            "name": "hour",
            "description": "An integer expression to use as an hour for building a timestamp, usually in the 0 - 23 range."
        },
        {
            "name": "minute",
            "description": "An integer expression to use as a minute for building a timestamp, usually in the 0 - 59 range."
        },
        {
            "name": "second",
            "description": "An integer expression to use as a second for building a timestamp, usually in the 0 - 59 range."
        },
        {
            "name": "date_expr",
            "description": "Specifies the date and time expressions to use for building a timestamp where date_expr provides the year, month, and day for the timestamp and time_expr provides the hour,\nminute, second, and nanoseconds within the day. Only valid for: TIMESTAMP_FROM_PARTS (when the TIMESTAMP_TYPE_MAPPING session parameter is set to TIMESTAMP_NTZ) TIMESTAMP_NTZ_FROM_PARTS"
        },
        {
            "name": "nanoseconds",
            "description": "An integer expression to use as a nanosecond for building a timestamp, usually in the 0 - 999999999 range."
        },
        {
            "name": "time_zone",
            "description": "A string expression to use as a time zone for building a timestamp (e.g. America/Los_Angeles ). Only valid for: TIMESTAMP_FROM_PARTS (when the TIMESTAMP_TYPE_MAPPING session parameter is set to TIMESTAMP_TZ) TIMESTAMP_TZ_FROM_PARTS"
        }
    ]
},
{
    "function_name": "TIMEDIFF",
    "summary": "Calculates the difference between two date, time, or timestamp expressions based on the specified date or time part.",
    "category": "Date & time functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/timediff",
    "title": "TIMEDIFF",
    "description": "Calculates the difference between two date, time, or timestamp expressions based on the specified date or time part.\nThe function returns the result of subtracting the second argument from the third argument.",
    "syntax": "TIMEDIFF( <date_or_time_part> , <date_or_time_expr1> , <date_or time_expr2> )",
    "example": "SELECT TIMEDIFF(YEAR, '2017-01-01', '2019-01-01') AS Years;\n+-------+\n| YEARS |\n|-------|\n|     2 |\n+-------+\n\nSELECT TIMEDIFF(MONTH, '2017-01-1', '2017-12-31') AS Months;\n+--------+\n| MONTHS |\n|--------|\n|     11 |\n+--------+",
    "arguments": [
        {
            "name": "date_or_time_part",
            "description": "The unit of time. Must be one of the values listed in Supported date and time parts (for example, month ).\nThe value can be a string literal or can be unquoted (for example, 'month' or month )."
        },
        {
            "name": "date_or_time_expr1",
            "description": "The values to compare. Must be a date, a time, a timestamp, or an expression that can be evaluated to\na date, a time, or a timestamp. The value date_or_time_expr1 is subtracted from date_or_time_expr2 ."
        }
    ],
    "returns": "Returns an integer representing the number of units (seconds, days, etc.) difference between date_or_time_expr2 and\ndate_or_time_expr1."
},
{
    "function_name": "TIMEADD",
    "summary": "Adds the specified value for the specified date or time part to a date, time, or timestamp.",
    "category": "Date & time functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/timeadd",
    "title": "TIMEADD",
    "description": "Adds the specified value for the specified date or time part to a date, time, or timestamp.",
    "syntax": "TIMEADD( <date_or_time_part> , <value> , <date_or_time_expr> )",
    "example": "SELECT TO_DATE('2022-05-08') AS original_date,\n       DATEADD(year, 2, TO_DATE('2022-05-08')) AS date_plus_two_years;\n\n+---------------+---------------------+\n| ORIGINAL_DATE | DATE_PLUS_TWO_YEARS |\n|---------------+---------------------|\n| 2022-05-08    | 2024-05-08          |\n+---------------+---------------------+\n\nSELECT TO_DATE('2022-05-08') AS original_date,\n       DATEADD(year, -2, TO_DATE('2022-05-08')) AS date_minus_two_years;\n\n+---------------+----------------------+\n| ORIGINAL_DATE | DATE_MINUS_TWO_YEARS |\n|---------------+----------------------|\n| 2022-05-08    | 2020-05-08           |\n+---------------+----------------------+\n\nALTER SESSION SET TIMESTAMP_OUTPUT_FORMAT = 'YYYY-MM-DD HH24:MI:SS.FF9';\nCREATE TABLE datetest (d date);\nINSERT INTO datetest VALUES ('2022-04-05');\n\nSELECT d AS original_date,\n       DATEADD(year, 2, d) AS date_plus_two_years,\n       TO_TIMESTAMP(d) AS original_timestamp,\n       DATEADD(hour, 2, d) AS timestamp_plus_two_hours\n  FROM datetest;\n\n+---------------+---------------------+-------------------------+--------------------------+\n| ORIGINAL_DATE | DATE_PLUS_TWO_YEARS | ORIGINAL_TIMESTAMP      | TIMESTAMP_PLUS_TWO_HOURS |\n|---------------+---------------------+-------------------------+--------------------------|\n| 2022-04-05    | 2024-04-05          | 2022-04-05 00:00:00.000 | 2022-04-05 02:00:00.000  |\n+---------------+---------------------+-------------------------+--------------------------+\n\nSELECT DATEADD(month, 1, '2023-01-31'::DATE) AS date_plus_one_month;\n\n+---------------------+\n| DATE_PLUS_ONE_MONTH |\n|---------------------|\n| 2023-02-28          |\n+---------------------+\n\nSELECT DATEADD(month, 1, '2023-02-28'::DATE) AS date_plus_one_month;\n\n+---------------------+\n| DATE_PLUS_ONE_MONTH |\n|---------------------|\n| 2023-03-28          |\n+---------------------+\n\nSELECT TO_TIME('05:00:00') AS original_time,\n       DATEADD(hour, 3, TO_TIME('05:00:00')) AS time_plus_three_hours;\n\n+---------------+-----------------------+\n| ORIGINAL_TIME | TIME_PLUS_THREE_HOURS |\n|---------------+-----------------------|\n| 05:00:00      | 08:00:00              |\n+---------------+-----------------------+",
    "arguments": [
        {
            "name": "date_or_time_part",
            "description": "This indicates the units of time that you want to add. For example if you\nwant to add two days, then specify day . This unit of measure must\nbe one of the values listed in Supported date and time parts ."
        },
        {
            "name": "value",
            "description": "This is the number of units of time that you want to add. For example,\nif the units of time is day , and you want to add two days, specify 2 .\nIf you want to subtract two days, specify -2 ."
        },
        {
            "name": "date_or_time_expr",
            "description": "date_or_time_expr must evaluate to a date, time, or timestamp.\nThis is the date, time, or timestamp to which you want to add.\nFor example, if you want to add two days to August 1, 2024, then specify '2024-08-01'::DATE . If the data type is TIME, then the date_or_time_part must be in units of hours or smaller, not days or bigger. If the input data type is DATE, and the date_or_time_part is hours\nor smaller, the input value will not be rejected, but instead will be\ntreated as a TIMESTAMP with hours, minutes, seconds, and fractions of\na second all initially set to 0 (e.g. midnight on the specified date)."
        }
    ],
    "returns": "If date_or_time_expr is a time, then the return data type is a time."
},
{
    "function_name": "TIME_SLICE",
    "summary": "Calculates the beginning or end of a “slice” of time, where the length of the slice is a multiple of a standard unit of time (minute, hour, day, etc.).",
    "category": "Date & time functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/time_slice",
    "title": "TIME_SLICE",
    "description": "Calculates the beginning or end of a “slice” of time, where the length of the slice is a multiple of a standard unit of time\n(minute, hour, day, etc.).",
    "syntax": "TIME_SLICE( <date_or_time_expr> , <slice_length> , <date_or_time_part> [ , <start_or_end> ] )",
    "example": "SELECT '2019-02-28'::DATE AS \"DATE\",\n       TIME_SLICE(\"DATE\", 4, 'MONTH', 'START') AS \"START OF SLICE\",\n       TIME_SLICE(\"DATE\", 4, 'MONTH', 'END') AS \"END OF SLICE\";\n+------------+----------------+--------------+\n| DATE       | START OF SLICE | END OF SLICE |\n|------------+----------------+--------------|\n| 2019-02-28 | 2019-01-01     | 2019-05-01   |\n+------------+----------------+--------------+\n\nSELECT '2019-02-28T01:23:45.678'::TIMESTAMP_NTZ AS \"TIMESTAMP 1\",\n       '2019-02-28T12:34:56.789'::TIMESTAMP_NTZ AS \"TIMESTAMP 2\",\n       TIME_SLICE(\"TIMESTAMP 1\", 8, 'HOUR') AS \"SLICE FOR TIMESTAMP 1\",\n       TIME_SLICE(\"TIMESTAMP 2\", 8, 'HOUR') AS \"SLICE FOR TIMESTAMP 2\";\n+-------------------------+-------------------------+-------------------------+-------------------------+\n| TIMESTAMP 1             | TIMESTAMP 2             | SLICE FOR TIMESTAMP 1   | SLICE FOR TIMESTAMP 2   |\n|-------------------------+-------------------------+-------------------------+-------------------------|\n| 2019-02-28 01:23:45.678 | 2019-02-28 12:34:56.789 | 2019-02-28 00:00:00.000 | 2019-02-28 08:00:00.000 |\n+-------------------------+-------------------------+-------------------------+-------------------------+\n\nCREATE TABLE accounts (ID INT, billing_date DATE, balance_due NUMBER(11, 2));\n\nINSERT INTO accounts (ID, billing_date, balance_due) VALUES\n    (1, '2018-07-31', 100.00),\n    (2, '2018-08-01', 200.00),\n    (3, '2018-08-25', 400.00);\n\nSELECT\n       TIME_SLICE(billing_date, 2, 'WEEK', 'START') AS \"START OF SLICE\",\n       TIME_SLICE(billing_date, 2, 'WEEK', 'END')   AS \"END OF SLICE\",\n       COUNT(*) AS \"NUMBER OF LATE BILLS\",\n       SUM(balance_due) AS \"SUM OF MONEY OWED\"\n    FROM accounts\n    WHERE balance_due > 0    -- bill hasn't yet been paid\n    GROUP BY \"START OF SLICE\", \"END OF SLICE\";\n+----------------+--------------+----------------------+-------------------+\n| START OF SLICE | END OF SLICE | NUMBER OF LATE BILLS | SUM OF MONEY OWED |\n|----------------+--------------+----------------------+-------------------|\n| 2018-07-23     | 2018-08-06   |                    2 |            300.00 |\n| 2018-08-20     | 2018-09-03   |                    1 |            400.00 |\n+----------------+--------------+----------------------+-------------------+",
    "arguments": [
        {
            "name": "date_or_time_expr",
            "description": "The function returns the start or end of the slice that contains this date or time. The expression must\nbe of type DATE or TIMESTAMP_NTZ."
        },
        {
            "name": "slice_length",
            "description": "This indicates the width of the slice (i.e. how many units of\ntime are contained in the slice). For example, if the unit is MONTH and the slice_length is 2, then each slice is 2 months wide. The slice_length must be an integer\ngreater than or equal to 1."
        },
        {
            "name": "date_or_time_part",
            "description": "Time unit for the slice length. The value must be a string containing one of the values listed\nbelow: If input expression is a DATE: YEAR, QUARTER, MONTH, WEEK, DAY. If input expression is a TIMESTAMP_NTZ: YEAR, QUARTER, MONTH, WEEK, DAY, HOUR, MINUTE, SECOND. The values are case-insensitive."
        },
        {
            "name": "start_or_end",
            "description": "This is an optional constant parameter that determines whether the start or end of the slice should be returned. Supported values are ‘START’ or ‘END’. The values are case-insensitive. The default value is ‘START’."
        }
    ],
    "returns": "The data type of the return value is identical to the data type of the input date_or_time_expr\n(i.e. either TIMESTAMP_NTZ or DATE)."
},
{
    "function_name": "TIME_FROM_PARTS",
    "summary": "Creates a time from individual numeric components.",
    "category": "Date & time functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/time_from_parts",
    "title": "TIME_FROM_PARTS",
    "description": "Creates a time from individual numeric components.",
    "syntax": "TIME_FROM_PARTS( <hour>, <minute>, <second> [, <nanoseconds>] )",
    "example": "ALTER SESSION SET TIME_OUTPUT_FORMAT='HH24:MI:SS.FF9';\n\nselect time_from_parts(12, 34, 56, 987654321);\n\n----------------------------------------+\n TIME_FROM_PARTS(12, 34, 56, 987654321) |\n----------------------------------------+\n 12:34:56.987654321                     |\n----------------------------------------+\n\nselect time_from_parts(0, 100, 0), time_from_parts(12, 0, 12345);\n\n----------------------------+-------------------------------+\n TIME_FROM_PARTS(0, 100, 0) | TIME_FROM_PARTS(12, 0, 12345) |\n----------------------------+-------------------------------+\n 01:40:00.000000000         | 15:25:45.000000000            |\n----------------------------+-------------------------------+",
    "arguments": [
        {
            "name": "hour",
            "description": "An integer expression to use as an hour for building a time,\nusually in the 0-23 range."
        },
        {
            "name": "minute",
            "description": "An integer expression to use as a minute for building a time,\nusually in the 0-59 range."
        },
        {
            "name": "second",
            "description": "An integer expression to use as a second for building a time,\nusually in the 0-59 range."
        },
        {
            "name": "nanoseconds",
            "description": "A 9-digit integer expression to use as a nanosecond for building\na time."
        }
    ]
},
{
    "function_name": "TEXT_PLAIN",
    "summary": "Returns a JSON object that specifies the plain text message to use for a notification.",
    "category": "Notification functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/text_plain",
    "title": "TEXT_PLAIN",
    "description": "Returns a JSON object that specifies the plain text message to use for a notification. This is a helper function that you use to\nconstruct a message object for the",
    "syntax": "SNOWFLAKE.NOTIFICATION.TEXT_PLAIN( '<message>' )",
    "arguments": [
        {
            "name": "'",
            "description": "Content of the message to send."
        }
    ],
    "returns": "A JSON-formatted string that specifies a message for the\nSYSTEM$SEND_SNOWFLAKE_NOTIFICATION stored procedure to send."
},
{
    "function_name": "TEXT_HTML",
    "summary": "Returns a JSON object that specifies the HTML message to use for a notification.",
    "category": "Notification functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/text_html",
    "title": "TEXT_HTML",
    "description": "Returns a JSON object that specifies the HTML message to use for a notification. This is a helper function that you use to\nconstruct a message object for the",
    "syntax": "SNOWFLAKE.NOTIFICATION.TEXT_HTML( '<message>' )",
    "arguments": [
        {
            "name": "'",
            "description": "Content of the message to send."
        }
    ],
    "returns": "A JSON-formatted string that specifies a message for the\nSYSTEM$SEND_SNOWFLAKE_NOTIFICATION stored procedure to send."
},
{
    "function_name": "TASK_HISTORY",
    "summary": "You can use this table function to query the history of task usage within a specified date range.",
    "category": "Information Schema , Table functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/task_history",
    "title": "TASK_HISTORY",
    "description": "You can use this table function to query the history of",
    "syntax": "TASK_HISTORY(\n      [ SCHEDULED_TIME_RANGE_START => <constant_expr> ]\n      [, SCHEDULED_TIME_RANGE_END => <constant_expr> ]\n      [, RESULT_LIMIT => <integer> ]\n      [, TASK_NAME => '<string>' ]\n      [, ERROR_ONLY => { TRUE | FALSE } ]\n      [, ROOT_TASK_ID => '<string>'] )",
    "example": "SELECT *\n  FROM TABLE(INFORMATION_SCHEMA.TASK_HISTORY())\n  ORDER BY SCHEDULED_TIME;\n\nSELECT *\n  FROM TABLE(INFORMATION_SCHEMA.TASK_HISTORY(\n    SCHEDULED_TIME_RANGE_START=>TO_TIMESTAMP_LTZ('2024-11-9 12:00:00.000 -0700'),\n    SCHEDULED_TIME_RANGE_END=>TO_TIMESTAMP_LTZ('2024-11-9 12:30:00.000 -0700')));\n\nSELECT *\n  FROM TABLE(INFORMATION_SCHEMA.TASK_HISTORY(\n    SCHEDULED_TIME_RANGE_START=>DATEADD('hour',-1,current_timestamp()),\n    RESULT_LIMIT => 10,\n    TASK_NAME=>'mytask'));\n\nSELECT *\n  FROM TABLE(INFORMATION_SCHEMA.TASK_HISTORY(ROOT_TASK_ID=>'d4b89013-c942-465c-bcb8-e7037a932b04'));\n\nDESC TASK my_task\nSET task_id=(SELECT \"id\" FROM TABLE(RESULT_SCAN(LAST_QUERY_ID())));\nSELECT *\n  FROM TABLE(INFORMATION_SCHEMA.TASK_HISTORY(ROOT_TASK_ID=>$task_id));",
    "arguments": [
        {
            "name": "SCHEDULED_TIME_RANGE_START",
            "description": "Time range (in TIMESTAMP_LTZ format ), within the last 7 days, in which the task execution was scheduled. If the time range does not fall\nwithin the last 7 days, an error is returned. If SCHEDULED_TIME_RANGE_END is not specified, the function returns those tasks that have already completed, are currently\nrunning, or are scheduled in the future. If SCHEDULED_TIME_RANGE_END is CURRENT_TIMESTAMP , the function returns those tasks that have\nalready completed or are currently running. Note that a task that is executed immediately before the current time might still be\nidentified as scheduled. To query only those tasks that have already completed or are currently running, include WHERE query_id IS NOT NULL as a filter.\nThe QUERY_ID column in the TASK_HISTORY output is populated only when a task has started running. Note If no start or end time is specified, the most recent tasks are returned, up to the specified RESULT_LIMIT value."
        },
        {
            "name": "RESULT_LIMIT",
            "description": "A number specifying the maximum number of rows returned by the function. If the number of matching rows is greater than this limit, the task executions with the most recent timestamp are returned, up to the specified limit. Range: 1 to 10000 Default: 100 ."
        },
        {
            "name": "TASK_NAME",
            "description": "A case-insensitive string specifying a task. Only non-qualified task names are supported. Only executions of the specified task are returned. Note that if multiple tasks have the same name, the function returns the history for each of these tasks."
        },
        {
            "name": "ERROR_ONLY",
            "description": "When set to TRUE, this function returns only task runs that failed or were cancelled. Default: FALSE ."
        },
        {
            "name": "ROOT_TASK_ID",
            "description": "Unique identifier for the root task in a task graph. This ID matches the ID column value in the SHOW TASKS output for the same task.\nSpecify the ROOT_TASK_ID to show the history of the root task and any child tasks that are part of the task graph."
        }
    ]
},
{
    "function_name": "TASK_DEPENDENTS",
    "summary": "This table function returns the list of child tasks for a given root task in a task graph.",
    "category": "Information Schema , Table functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/task_dependents",
    "title": "TASK_DEPENDENTS",
    "description": "This table function returns the list of child",
    "syntax": "TASK_DEPENDENTS(\n      TASK_NAME => '<string>'\n      [, RECURSIVE => <Boolean> ] )",
    "example": "select *\n  from table(information_schema.task_dependents(task_name => 'mydb.myschema.mytask', recursive => false));",
    "arguments": [
        {
            "name": "TASK_NAME",
            "description": "A string specifying a task. The function returns the specified root task as the first entry, followed by the list of child tasks. Note that the entire name must be enclosed in single quotes, including the database and schema (if the name is fully-qualified), i.e. '<db>.<schema>.<task_name>' . If the task name is case-sensitive or includes any special characters or spaces, double quotes are required to process the case/characters. The double quotes must be enclosed within the single quotes, i.e. '\"<task_name>\"' ."
        },
        {
            "name": "RECURSIVE",
            "description": "Specifies whether to limit the output to include only direct child tasks or to include all recursive child tasks. TRUE : Returns all recursive child tasks (children, grandchildren, etc.) in the output. FALSE : Returns only direct child tasks in the output. Default: TRUE ."
        }
    ]
},
{
    "function_name": "TANH",
    "summary": "Computes the hyperbolic tangent of its argument.",
    "category": "Numeric functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/tanh",
    "title": "TANH",
    "description": "Computes the hyperbolic tangent of its argument.",
    "syntax": "TANH( <real_expr> )",
    "example": "SELECT TANH(1.5);\n\n--------------+\n  TANH(1.5)   |\n--------------+\n 0.9051482536 |\n--------------+",
    "arguments": [
        {
            "name": "real_expr",
            "description": "This expression should evaluate to a real number."
        }
    ]
},
{
    "function_name": "TAN",
    "summary": "Computes the tangent of its argument; the argument should be expressed in radians.",
    "category": "Numeric functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/tan",
    "title": "TAN",
    "description": "Computes the tangent of its argument; the argument should be expressed in\nradians.",
    "syntax": "TAN( <real_expr> )",
    "example": "SELECT TAN(0), TAN(PI()/3), TAN(RADIANS(90));\n--------+-------------+----------------------+\n TAN(0) | TAN(PI()/3) |   TAN(RADIANS(90))   |\n--------+-------------+----------------------+\n 0      | 1.732050808 | 1.63312393531954e+16 |\n--------+-------------+----------------------+",
    "arguments": [
        {
            "name": "real_expr",
            "description": "This expression should evaluate to a real number. The value should be in\nradians, not degrees."
        }
    ]
},
{
    "function_name": "TAG_REFERENCES_WITH_LINEAGE",
    "summary": "Returns a table in which each row displays an association between the specified tag and the Snowflake object to which the tag is associated.",
    "category": "Account Usage table functions , Table functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/tag_references_with_lineage",
    "title": "TAG_REFERENCES_WITH_LINEAGE",
    "description": "Returns a table in which each row displays an association between the specified tag and the Snowflake object to which the tag is associated.",
    "syntax": "TAG_REFERENCES_WITH_LINEAGE( '<name>' )",
    "example": "select *\n  from table(snowflake.account_usage.tag_references_with_lineage('MY_DB.MY_SCHEMA.COST_CENTER'));",
    "arguments": [
        {
            "name": "'",
            "description": "The fully qualified name of the tag. The fully qualified name must specify the parent tag database and tag schema for the tag in the following format: <tag_database>.<tag_schema>.<tag_name>"
        }
    ]
},
{
    "function_name": "TAG_REFERENCES_ALL_COLUMNS",
    "summary": "Returns a table in which each row displays the tag name and tag value assigned to a specific column.",
    "category": "Information Schema , Table functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/tag_references_all_columns",
    "title": "TAG_REFERENCES_ALL_COLUMNS",
    "description": "Returns a table in which each row displays the tag name and tag value assigned to a specific column.",
    "syntax": "TAG_REFERENCES_ALL_COLUMNS( '<object_name>' , '<object_domain>' )",
    "example": "select *\n  from table(my_db.information_schema.tag_references_all_columns('my_table', 'table'));",
    "arguments": [
        {
            "name": "'",
            "description": "Name of the referenced object if the tag association is on the object. This argument supports the names for tables and views."
        },
        {
            "name": "'",
            "description": "Domain of the referenced object. Snowflake supports one domain for this function: TABLE . Note that the domain TABLE must be used for all objects that contain columns, even if the object name is a view\n(i.e. view, materialized view)."
        }
    ]
},
{
    "function_name": "TAG_REFERENCES",
    "summary": "Returns a table in which each row displays an association between a tag and value.",
    "category": "Information Schema , Table functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/tag_references",
    "title": "TAG_REFERENCES",
    "description": "Returns a table in which each row displays an association between a tag and value.",
    "syntax": "TAG_REFERENCES( '<object_name>' , '<object_domain>' )",
    "example": "select *\n  from table(my_db.information_schema.tag_references('my_table', 'table'));\n\nselect *\n  from table(my_db.information_schema.tag_references('my_table.result', 'COLUMN'));",
    "arguments": [
        {
            "name": "'",
            "description": "Name of the referenced object if the tag association is on the object."
        },
        {
            "name": "'",
            "description": "Domain of the reference object, such as a table or view, if the tag association is on the object. For columns, the domain is COLUMN if the tag association is on a column. Use one of the following values: 'ACCOUNT' 'ALERT' 'COLUMN' 'COMPUTE POOL' 'DATABASE' 'DATABASE ROLE' 'FAILOVER GROUP' 'FUNCTION' 'INTEGRATION' 'INSTANCE' 'NETWORK POLICY' 'PROCEDURE' 'REPLICATION GROUP' 'ROLE' 'SCHEMA' 'SHARE' 'STAGE' 'STREAM' 'TABLE' : Use this for all table-like objects such as views, materialized views, and external tables. 'TASK' 'USER' 'WAREHOUSE'"
        }
    ]
},
{
    "function_name": "SYSTIMESTAMP",
    "summary": "Returns the current timestamp for the system.",
    "category": "Context functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/systimestamp",
    "title": "SYSTIMESTAMP",
    "description": "Returns the current timestamp for the system.",
    "syntax": "SYSTIMESTAMP()",
    "example": "SELECT SYSTIMESTAMP();\n\n+--------------------------+\n| SYSTIMESTAMP()           |\n|--------------------------|\n| 2024-04-17 15:49:34.0800 |\n+--------------------------+",
    "returns": "Returns the current system time in the local time zone. The data type of the returned value is\nTIMESTAMP_LTZ."
},
{
    "function_name": "SYSTEM$WHITELIST_PRIVATELINK — Deprecated",
    "summary": "Returns hostnames and port numbers for AWS PrivateLink, Azure Private Link, and Google Cloud Private Service Connect deployments to add to your firewall’s allowed list so that you can access Snowflake from behind your firewall.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_whitelist_privatelink",
    "title": "SYSTEM$WHITELIST_PRIVATELINK —",
    "syntax": "SYSTEM$WHITELIST_PRIVATELINK()",
    "example": "SELECT SYSTEM$WHITELIST_PRIVATELINK();\n\n[\n  {\"type\":\"SNOWFLAKE_DEPLOYMENT\", \"host\":\"xy12345.us-west-2.privatelink.snowflakecomputing.com\",\"port\":443},\n  {\"type\":\"STAGE\",                \"host\":\"sfc-ss-ds2-customer-stage.s3.us-west-2.amazonaws.com\",\"port\":443},\n  ...\n  {\"type\":\"SNOWSQL_REPO\",         \"host\":\"sfc-repo.snowflakecomputing.com\",                     \"port\":443},\n  ...\n  {\"type\":\"OUT_OF_BAND_TELEMETRY\",\"host\":\"client-telemetry.snowflakecomputing.com\",\"port\":443},\n  {\"type\":\"OCSP_CACHE\",           \"host\":\"ocsp.station00752.us-west-2.privatelink.snowflakecomputing.com\",\"port\":80}\n]\n\nSELECT t.VALUE:type::VARCHAR as type,\n       t.VALUE:host::VARCHAR as host,\n       t.VALUE:port as port\nFROM TABLE(FLATTEN(input => PARSE_JSON(SYSTEM$WHITELIST_PRIVATELINK()))) AS t;\n\n+-----------------------+---------------------------------------------------+------+\n| TYPE                  | HOST                                              | PORT |\n+-----------------------+---------------------------------------------------+------+\n| SNOWFLAKE_DEPLOYMENT  | xy12345.snowflakecomputing.com                    | 443  |\n| STAGE                 | sfc-customer-stage.s3.us-west-2.amazonaws.com     | 443  |\n  ...\n| SNOWSQL_REPO          | sfc-repo.snowflakecomputing.com                   | 443  |\n  ...\n| OCSP_CACHE            | ocsp.snowflakecomputing.com                       | 80   |\n  ...\n+-----------------------+---------------------------------------------------+------+",
    "returns": "The data type of the returned value is VARIANT. The value is an array of JSON structures. Each JSON structure contains three key/value\npairs:"
},
{
    "function_name": "SYSTEM$WHITELIST — Deprecated",
    "summary": "Returns hostnames and port numbers to add to your firewall’s allowed list so that you can access Snowflake from behind your firewall.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_whitelist",
    "title": "SYSTEM$WHITELIST —",
    "syntax": "SYSTEM$WHITELIST()",
    "example": "SELECT SYSTEM$WHITELIST();\n\n[\n  {\"type\":\"SNOWFLAKE_DEPLOYMENT\", \"host\":\"xy12345.snowflakecomputing.com\",                 \"port\":443},\n  {\"type\":\"STAGE\",                \"host\":\"sfc-customer-stage.s3.us-west-2.amazonaws.com\",  \"port\":443},\n  ...\n  {\"type\":\"SNOWSQL_REPO\",         \"host\":\"sfc-repo.snowflakecomputing.com\",                \"port\":443},\n  ...\n  {\"type\":\"OCSP_CACHE\",           \"host\":\"ocsp.snowflakecomputing.com\",                    \"port\":80}\n  {\"type\":\"OCSP_RESPONDER\",       \"host\":\"o.ss2.us\",                                       \"port\":80},\n  ...\n]\n\nSELECT t.VALUE:type::VARCHAR as type,\n       t.VALUE:host::VARCHAR as host,\n       t.VALUE:port as port\nFROM TABLE(FLATTEN(input => PARSE_JSON(SYSTEM$WHITELIST()))) AS t;\n\n+-----------------------+---------------------------------------------------+------+\n| TYPE                  | HOST                                              | PORT |\n|-----------------------+---------------------------------------------------+------|\n| SNOWFLAKE_DEPLOYMENT  | xy12345.snowflakecomputing.com                    | 443  |\n| STAGE                 | sfc-customer-stage.s3.us-west-2.amazonaws.com     | 443  |\n  ...\n| SNOWSQL_REPO          | sfc-repo.snowflakecomputing.com                   | 443  |\n  ...\n| OCSP_CACHE            | ocsp.snowflakecomputing.com                       | 80   |\n| OCSP_RESPONDER        | ocsp.sca1b.amazontrust.com                        | 80   |\n  ...\n+-----------------------+---------------------------------------------------+------+",
    "returns": "The data type of the returned value is VARIANT. The value is an array of JSON structures. Each JSON structure contains three\nkey/value pairs:"
},
{
    "function_name": "SYSTEM$WAIT_FOR_SERVICES",
    "summary": "Waits for one or more Snowpark Container Services services to reach the READY state (or becomes upgraded) before returning.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_wait_for_services",
    "title": "SYSTEM$WAIT_FOR_SERVICES",
    "syntax": "SYSTEM$WAIT_FOR_SERVICES( <seconds_to_pause>, '<service_name>' [, ...] )",
    "example": "SELECT SYSTEM$WAIT_FOR_SERVICES(600, 'service-name-1', 'service-name-2', 'service-name-3');",
    "arguments": [
        {
            "name": "seconds_to_pause",
            "description": "Number of seconds to pause."
        },
        {
            "name": "service_name",
            "description": "Names of one or more services to wait for."
        }
    ],
    "returns": "‘OK’ or fails in case of timeout."
},
{
    "function_name": "SYSTEM$WAIT",
    "summary": "Waits for the specified amount of time before proceeding.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_wait",
    "title": "SYSTEM$WAIT",
    "description": "Waits for the specified amount of time before proceeding.",
    "syntax": "SYSTEM$WAIT( amount [ , time_unit ] )",
    "example": "CALL SYSTEM$WAIT(10);\n\n-------------------+\n    SYSTEM$WAIT    |\n-------------------+\n waited 10 seconds |\n-------------------+\n\nCALL SYSTEM$WAIT(2, 'MINUTES');\n\n-------------------+\n    SYSTEM$WAIT    |\n-------------------+\n waited 2 minutes  |\n-------------------+",
    "arguments": [
        {
            "name": "amount",
            "description": "Number specifying the amount of time to wait as determined by time_unit ."
        },
        {
            "name": "time_unit",
            "description": "Time unit for amount . Accepted values are DAYS, HOURS, MINUTES, SECONDS, MILLISECONDS, MICROSECONDS, NANOSECONDS.\nThe unit should be in single quotes (see Examples below). Default: SECONDS"
        }
    ]
},
{
    "function_name": "SYSTEM$VERIFY_EXTERNAL_VOLUME",
    "summary": "Verifies the configuration for a specified external volume.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_verify_external_volume",
    "title": "SYSTEM$VERIFY_EXTERNAL_VOLUME",
    "description": "Verifies the configuration for a specified",
    "syntax": "SYSTEM$VERIFY_EXTERNAL_VOLUME('<external_volume_name>')",
    "example": "SELECT SYSTEM$VERIFY_EXTERNAL_VOLUME('my_s3_external_volume');",
    "arguments": [
        {
            "name": "external_volume_name",
            "description": "Name of the external volume to verify. If the identifier contains spaces or special characters,\nthe entire string must be enclosed in double quotes. Identifiers enclosed in double quotes are also case sensitive."
        }
    ],
    "returns": "The function returns a JSON object with the properties described below:"
},
{
    "function_name": "SYSTEM$VERIFY_EXTERNAL_OAUTH_TOKEN",
    "summary": "Determines whether your External OAuth access token is valid or has expired and needs to be regenerated.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_verify_ext_oauth_token",
    "title": "SYSTEM$VERIFY_EXTERNAL_OAUTH_TOKEN",
    "description": "Determines whether your",
    "syntax": "SYSTEM$VERIFY_EXTERNAL_OAUTH_TOKEN( '<access_token>' )",
    "example": "SELECT SYSTEM$VERIFY_EXTERNAL_OAUTH_TOKEN('<access_token>');\n\n+-----------------------------------------------------------------------------------------------+\n| Token Validation finished.{\"Validation Result\":\"Passed\",\"Issuer\":\"<URL>\",\"User\":\"<username>\"} |\n+-----------------------------------------------------------------------------------------------+",
    "arguments": [
        {
            "name": "access_token",
            "description": "The External OAuth access token generated by your OAuth 2.0 server."
        }
    ]
},
{
    "function_name": "SYSTEM$VERIFY_CMK_INFO",
    "summary": "Verifies your customer-managed key (CMK) configuration and returns a message about the registered CMK.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_verify_cmk_info",
    "title": "SYSTEM$VERIFY_CMK_INFO",
    "description": "Verifies your customer-managed key (CMK) configuration and returns a message about the registered CMK.",
    "syntax": "SYSTEM$VERIFY_CMK_INFO()",
    "example": "SELECT SYSTEM$VERIFY_CMK_INFO();",
    "returns": "Returns a successful status message or information about the unsuccessful verification:"
},
{
    "function_name": "SYSTEM$VERIFY_CATALOG_INTEGRATION",
    "summary": "Verifies the configuration for a specified catalog integration for",
    "category": "iceberg-tm",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_verify_catalog_integration",
    "title": "SYSTEM$VERIFY_CATALOG_INTEGRATION",
    "description": "Verifies the configuration for a specified catalog integration for Apache Iceberg™ REST.",
    "syntax": "SYSTEM$VERIFY_CATALOG_INTEGRATION( '<rest_catalog_integration_name>' )",
    "example": "CREATE CATALOG INTEGRATION my_rest_cat_int\n  CATALOG_SOURCE = ICEBERG_REST\n  TABLE_FORMAT = ICEBERG\n  CATALOG_NAMESPACE = 'default'\n  REST_CONFIG = (\n    CATALOG_URI = 'https://abc123.us-west-2.aws.myapi.com/polaris/api/catalog'\n    CATALOG_NAME = 'my_catalog_name'\n  )\n  REST_AUTHENTICATION = (\n    TYPE = OAUTH\n    OAUTH_CLIENT_ID = '123AbC ...'\n    OAUTH_CLIENT_SECRET = '1365910abIncorrectSecret ...'\n    OAUTH_ALLOWED_SCOPES = ('all-apis', 'sql')\n  )\n  ENABLED = TRUE;\n\nSELECT SYSTEM$VERIFY_CATALOG_INTEGRATION('my_rest_cat_int');\n\n+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n|                                                                                                              SYSTEM$VERIFY_CATALOG_INTEGRATION('MY_REST_CAT_INT')                                                                                                               |\n+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| {                                                                                                                                                                                                                                                                               |\n|  \"success\" : false,                                                                                                                                                                                                                                                             |                                                                                                                                                                                                                                                                    |\n|   \"errorCode\" : \"004155\",                                                                                                                                                                                                                                                       |\n|   \"errorMessage\" : \"SQL Execution Error: Failed to perform OAuth client credential flow for the REST Catalog integration MY_REST_CAT_INT due to error: SQL execution error: OAuth2 Access token request failed with error 'unauthorized_client:The client is not authorized'..\" |\n| }                                                                                                                                                                                                                                                                               |\n+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+",
    "arguments": [
        {
            "name": "rest_catalog_integration_name",
            "description": "Name of the Iceberg REST catalog integration to test. Catalog integration names are case sensitive."
        }
    ],
    "returns": "The function returns a JSON object with the properties described below:"
},
{
    "function_name": "SYSTEM$VALIDATE_STORAGE_INTEGRATION",
    "summary": "Validates the configuration for a specified storage integration.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_validate_storage_integration",
    "title": "SYSTEM$VALIDATE_STORAGE_INTEGRATION",
    "description": "Validates the configuration for a specified storage integration.\nThe function attempts to use the storage integration to write, read, list, or delete a file for a storage location that you specify by path.",
    "syntax": "SYSTEM$VALIDATE_STORAGE_INTEGRATION( '<storage_integration_name>', '<storage_path>', '<test_file_name>', '<validate_action>' )",
    "example": "SELECT\n  SYSTEM$VALIDATE_STORAGE_INTEGRATION(\n    'example_integration',\n    's3://example_bucket/test_path/'',\n    'validate_all.txt', 'all');\n\n+----------------------------+\n|           RESULT           |\n+----------------------------+\n| {                          |\n|   \"status\" : \"success\",    |\n|   \"actions\" : {            |\n|     \"READ\" : {             |\n|       \"status\" : \"success\" |\n|     },                     |\n|     \"DELETE\" : {           |\n|       \"status\" : \"success\" |\n|     },                     |\n|     \"LIST\" : {             |\n|       \"status\" : \"success\" |\n|     },                     |\n|     \"WRITE\" : {            |\n|       \"status\" : \"success\" |\n|     }                      |\n|   }                        |\n| }                          |\n+----------------------------+\n\nSELECT\n  SYSTEM$VALIDATE_STORAGE_INTEGRATION(\n    'example_integration',\n    'gcs://example_bucket/test_path/'',\n    'read_fail.txt', 'all');\n\n+----------------------------------------------------------------------------------------------------------------+\n|                                                     RESULT                                                     |\n+----------------------------------------------------------------------------------------------------------------+\n| {                                                                                                              |\n|   \"status\" : \"failure\",                                                                                        |\n|   \"actions\" : {                                                                                                |\n|     \"READ\" : {                                                                                                 |\n|       \"message\" : \"Access Denied (Status Code: 403; Error Code: AccessDenied)\",                                |\n|       \"status\" : \"failure\"                                                                                     |\n|     },                                                                                                         |\n|     \"DELETE\" : {                                                                                               |\n|       \"status\" : \"success\"                                                                                     |\n|     },                                                                                                         |\n|     \"LIST\" : {                                                                                                 |\n|       \"status\" : \"success\"                                                                                     |\n|     },                                                                                                         |\n|     \"WRITE\" : {                                                                                                |\n|       \"status\" : \"success\"                                                                                     |\n|     }                                                                                                          |\n|   },                                                                                                           |\n|   \"message\" : \"Some of the integration checks failed. Check the Snowflake documentation for more information.\" |\n| }                                                                                                              |\n+----------------------------------------------------------------------------------------------------------------+",
    "arguments": [
        {
            "name": "storage_integration_name",
            "description": "Name of the storage integration to test. Storage integration names are case-sensitive."
        },
        {
            "name": "storage_path",
            "description": "The full path to a storage location that you want to validate.\nThe storage path must be a URL in the STORAGE_ALLOWED_LOCATIONS list for the storage integration. Amazon S3 's3:// bucket / path /' The s3 prefix refers to S3 storage in public AWS regions. The s3gov prefix refers to S3 storage in government regions . bucket is the name of an S3 bucket that stores your data files. path is an optional path or directory in the bucket. Google Cloud Storage 'gcs:// bucket / path /' bucket is the name of a GCS bucket that stores your data files. path is an optional path or directory in the bucket. Microsoft Azure 'azure:// account .blob.core.windows.net/ container / path /' account is the name of the Azure storage account. container is the name of an Azure blob storage container that stores your data files. path is an optional path or directory in the bucket."
        },
        {
            "name": "test_file_name",
            "description": "The name of the file to use in storage integration validation."
        },
        {
            "name": "validate_action",
            "description": "The validation action to perform. read - Validates that Snowflake can read from the storage location. This action fails if the file doesn’t exist. write - Validate that Snowflake can write to the storage location. This action fails if the file already exists. list - Validates that Snowflake can list the files in the storage location. delete - Validates that Snowflake can delete files in the storage location. all - Validates all possible actions in the storage location."
        }
    ],
    "returns": "The function returns a JSON object with the properties described below:"
},
{
    "function_name": "SYSTEM$USER_TASK_CANCEL_ONGOING_EXECUTIONS",
    "summary": "Cancels a run of the specified task that the system has already started to process (that is, a run with an EXECUTING state in the TASK_HISTORY output).",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_user_task_cancel_ongoing_executions",
    "title": "SYSTEM$USER_TASK_CANCEL_ONGOING_EXECUTIONS",
    "description": "Cancels a run of the specified task that the system has already started to process (that is, a run with an EXECUTING state in the",
    "syntax": "SYSTEM$USER_TASK_CANCEL_ONGOING_EXECUTIONS( '<task_name>' )",
    "example": "SELECT SYSTEM$USER_TASK_CANCEL_ONGOING_EXECUTIONS('mydb.myschema.mytask');\n\nSELECT SYSTEM$USER_TASK_CANCEL_ONGOING_EXECUTIONS('mydb.myschema.\"myTask\"');\n\nSELECT SYSTEM$USER_TASK_CANCEL_ONGOING_EXECUTIONS('my_task');\n\n+------------------------------------------------------------------------------------+\n| SYSTEM$USER_TASK_CANCEL_ONGOING_EXECUTIONS('my_task')                              |\n|------------------------------------------------------------------------------------|\n| Marked 1 task runs for cancellation. It may take a few seconds for cancellation to |\n| complete. Query ids canceled: [2036a04c-9c46-4c6b-b354-67a44b5e0b50]               |\n+------------------------------------------------------------------------------------+\n\nSELECT SYSTEM$USER_TASK_CANCEL_ONGOING_EXECUTIONS('my_task');\n\n+------------------------------------------------------------------------------------+\n| SYSTEM$USER_TASK_CANCEL_ONGOING_EXECUTIONS('my_task') |\n|------------------------------------------------------------------------------------|\n| Task MY_TASK has no currently running executions. If the task was dropped or       |\n| replaced after a previous execution started, use SYSTEM$CANCEL_QUERY along with    |\n| the query id to cancel the run.                                                    |\n|------------------------------------------------------------------------------------|",
    "arguments": [
        {
            "name": "task_name",
            "description": "Name of the task."
        }
    ]
},
{
    "function_name": "SYSTEM$UNSET_EVENT_SHARING_ACCOUNT_FOR_REGION",
    "summary": "Unsets the events account for a region.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_unset_event_sharing_account_for_region",
    "title": "SYSTEM$UNSET_EVENT_SHARING_ACCOUNT_FOR_REGION",
    "description": "Unsets the events account for a region.",
    "syntax": "SYSTEM$UNSET_EVENT_SHARING_ACCOUNT_FOR_REGION( '<snowflake_region>' , '<region_group>' , '<account_name>' )",
    "example": "SELECT SYSTEM$UNSET_EVENT_SHARING_ACCOUNT_FOR_REGION('aws_us_west_2', 'public', 'myaccount');",
    "arguments": [
        {
            "name": "snowflake_region",
            "description": "Specifies the region where the account is located, for example: AWS_US_WEST_2, AWS_US_EAST_1 ."
        },
        {
            "name": "region_group",
            "description": "Specifies the region group, for example: PUBLIC ."
        },
        {
            "name": "account_name",
            "description": "Specifies the account name."
        }
    ]
},
{
    "function_name": "SYSTEM$UNREGISTER_PRIVATELINK_ENDPOINT",
    "summary": "Unregisters a private connectivity endpoint to route your connection to the Snowflake service.",
    "category": "",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_unregister_privatelink_endpoint",
    "title": "SYSTEM$UNREGISTER_PRIVATELINK_ENDPOINT",
    "syntax": "SYSTEM$UNREGISTER_PRIVATELINK_ENDPOINT(\n  '<aws_private_endpoint_vpce_id>',\n  '<aws_account_id>',\n  '<token>'\n  )",
    "example": "SELECT SYSTEM$UNREGISTER_PRIVATELINK_ENDPOINT(\n  'vpce-0c1...',\n  '174...',\n  '{\n    \"Credentials\": {\n      \"AccessKeyId\": \"ASI...\",\n      \"SecretAccessKey\": \"aFP...\",\n      \"SessionToken\": \"Fwo...\",\n      \"Expiration\": \"2024-04-26 05:49:09+00:00\"\n    },\n    \"FederatedUser\": {\n      \"FederatedUserId\": \"0123...:snowflake\",\n      \"Arn\": \"arn:aws:sts::174...:federated-user/sam\"\n    },\n    \"PackedPolicySize\": 9\n  }'\n);\n\nSELECT SYSTEM$UNREGISTER_PRIVATELINK_ENDPOINT(\n  '123...',\n  '/subscriptions/0cc51670-.../resourceGroups/dbsec_test_rg/providers/Microsoft.Network/\n  privateEndpoints/...',\n  'eyJ...'\n  );",
    "arguments": [
        {
            "name": "aws_private_endpoint_vpce_id",
            "description": "Specifies the identifier for your Amazon Web Services (AWS) virtual private cloud endpoint (AWS VPCEID). To obtain the AWS VPCEID value, navigate through the AWS console or use the following command:"
        },
        {
            "name": "aws_account_id",
            "description": "The 12-digit identifier that uniquely identifies your Amazon Web Services (AWS) account, as a string. To obtain the AWS account ID value, navigate through the AWS console or use the following command:"
        },
        {
            "name": "azure_private_endpoint_link_id",
            "description": "Specifies the identifier for your Microsoft Azure (Azure) virtual private cloud endpoint link (Azure LinkID). To obtain the Azure LinkID value: Run the SYSTEM$GET_PRIVATELINK_AUTHORIZED_ENDPOINTS system function."
        },
        {
            "name": "azure_private_endpoint_resource_id",
            "description": "The identifier that uniquely identifies your Snowflake account in Microsoft Azure (Azure) as a string. To obtain the Azure private endpoint resource Id, use the following command:"
        },
        {
            "name": "token",
            "description": "Specifies an access token to verify ownership of the private connectivity endpoint. To obtain the token, you must have the corresponding read or describe privilege on the private connectivity endpoint at a minimum.\nFor more information, see: AWS endpoint policies Azure private endpoint privileges To obtain the token, use the following commands: For Snowflake on AWS: For Snowflake on Azure: For more information about limiting the scope of an access token, see: For Snowflake on AWS: Managing access token scope on Amazon Web Services For Snowflake on Azure: Managing access token scope on Microsoft Azure"
        }
    ],
    "returns": "Returns a status message about the registration of the private connectivity endpoint."
},
{
    "function_name": "SYSTEM$UNLINK_ORGANIZATION_USER_GROUP",
    "summary": "Unlinks an access control role from an organization user group so it can be managed as a local role going forward.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_unlink_organization_user_group",
    "title": "SYSTEM$UNLINK_ORGANIZATION_USER_GROUP",
    "syntax": "SYSTEM$UNLINK_ORGANIZATION_USER_GROUP( '<role>' )",
    "example": "SELECT SYSTEM$UNLINK_ORGANIZATION_USER_GROUP('marketing_team');",
    "arguments": [
        {
            "name": "'",
            "description": "Name of an access control role that is linked to an organization user group."
        }
    ]
},
{
    "function_name": "SYSTEM$UNLINK_ORGANIZATION_USER",
    "summary": "Unlinks a user object from an organization user so it can be managed as a local user going forward.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_unlink_organization_user",
    "title": "SYSTEM$UNLINK_ORGANIZATION_USER",
    "syntax": "SYSTEM$UNLINK_ORGANIZATION_USER( '<user_name>' )",
    "example": "SELECT SYSTEM$UNLINK_ORGANIZATION_USER('jloeb');",
    "arguments": [
        {
            "name": "'",
            "description": "Name of a user object that was imported from an organization user."
        }
    ]
},
{
    "function_name": "SYSTEM$UNBLOCK_INTERNAL_STAGES_PUBLIC_ACCESS",
    "summary": "Allows traffic from public IP addresses to access the internal stage of the current Snowflake account on Microsoft Azure.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_unblock_internal_stages_public_access",
    "title": "SYSTEM$UNBLOCK_INTERNAL_STAGES_PUBLIC_ACCESS",
    "syntax": "SYSTEM$UNBLOCK_INTERNAL_STAGES_PUBLIC_ACCESS()",
    "example": "USE ROLE accountadmin;\n\nSELECT SYSTEM$UNBLOCK_INTERNAL_STAGES_PUBLIC_ACCESS();",
    "returns": "This function returns the following status messages:"
},
{
    "function_name": "SYSTEM$TYPEOF",
    "summary": "Returns a string representing the SQL data type associated with an expression.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_typeof",
    "title": "SYSTEM$TYPEOF",
    "description": "Returns a string representing the SQL data type associated with an\nexpression.",
    "syntax": "SYSTEM$TYPEOF( <expr> )",
    "example": "SELECT SYSTEM$TYPEOF(NULL);\n\n+---------------------+\n| SYSTEM$TYPEOF(NULL) |\n|---------------------|\n| NULL[LOB]           |\n+---------------------+\n\nSELECT SYSTEM$TYPEOF(1);\n\n+------------------+\n| SYSTEM$TYPEOF(1) |\n|------------------|\n| NUMBER(1,0)[SB1] |\n+------------------+\n\nSELECT SYSTEM$TYPEOF(1e10);\n\n+---------------------+\n| SYSTEM$TYPEOF(1E10) |\n|---------------------|\n| NUMBER(11,0)[SB8]   |\n+---------------------+\n\nSELECT SYSTEM$TYPEOF(10000);\n\n+----------------------+\n| SYSTEM$TYPEOF(10000) |\n|----------------------|\n| NUMBER(5,0)[SB2]     |\n+----------------------+\n\nSELECT SYSTEM$TYPEOF('something');\n\n+----------------------------+\n| SYSTEM$TYPEOF('SOMETHING') |\n|----------------------------|\n| VARCHAR(9)[LOB]            |\n+----------------------------+\n\nSELECT SYSTEM$TYPEOF(CONCAT('every', 'body'));\n\n+----------------------------------------+\n| SYSTEM$TYPEOF(CONCAT('EVERY', 'BODY')) |\n|----------------------------------------|\n| VARCHAR(9)[LOB]                        |\n+----------------------------------------+",
    "arguments": [
        {
            "name": "expr",
            "description": "The argument can be a column name or a general expression."
        }
    ],
    "returns": "Returns a VARCHAR value that contains the data type of the input expression, for example, BOOLEAN, NUMBER, ARRAY, OBJECT, etc."
},
{
    "function_name": "SYSTEM$TRIGGER_LISTING_REFRESH",
    "summary": "Triggers a one-time, on-demand data refresh for a provider’s databases or listings, accessible to all consumers.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_trigger_listing_refresh",
    "title": "SYSTEM$TRIGGER_LISTING_REFRESH",
    "description": "Triggers a one-time, on-demand data refresh for a provider’s databases or listings, accessible to all consumers. The refresh job begins immediately upon triggering and can be tracked using the",
    "syntax": "SYSTEM$TRIGGER_LISTING_REFRESH( '<type>' , '<name>' )",
    "example": "SELECT SYSTEM$TRIGGER_LISTING_REFRESH('DATABASE', 'MY_DATABASE');",
    "arguments": [
        {
            "name": "'",
            "description": "Type of dataset to refresh ( LISTING or DATABASE ). Note that the dataset type must be enclosed in single quotes."
        },
        {
            "name": "'",
            "description": "Name of the listing or database. Note that the entire name must be enclosed in single quotes."
        }
    ]
},
{
    "function_name": "SYSTEM$TASK_RUNTIME_INFO",
    "summary": "Returns information about the current task run.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_task_runtime_info",
    "title": "SYSTEM$TASK_RUNTIME_INFO",
    "description": "Returns information about the current task run. If this function is called outside of a task run, it fails with an error.",
    "syntax": "SYSTEM$TASK_RUNTIME_INFO('<arg_name>')",
    "example": "CREATE OR REPLACE TASK my_task ...\n  AS\n  ...\n\n  -- Inside Python UDF\n\n  query_result = session.sql(\"\"\"select\n        SYSTEM$TASK_RUNTIME_INFO('CURRENT_ROOT_TASK_NAME')\n        root_name,\n        SYSTEM$TASK_RUNTIME_INFO('CURRENT_TASK_GRAPH_RUN_GROUP_ID')\n        run_id\"\"\").collect()\n  current_root_task_name, current_graph_run_id = result.ROOT_NAME, result.RUN_ID\n\n  -- Logging information here\n\n  logger.debug(f\"start training for {current_root_task_name} at run {current_graph_run_id}\")\n\n  -- Create a unique output directory to store intermediate information\n\n  output_dir_name = f\"{current_root_task_name}/{current_graph_run_id}/preprocessing.out\"\n  with open(output_dir_name, \"rw+\") as f:\n    ....\n...;\n\nCREATE OR REPLACE TASK my_task ...\n  AS\n  ...\n  INSERT INTO my_output_table\n    SELECT * FROM my_source_table\n      WHERE TRUE\n        ...\n        AND TIMESTAMP BETWEEN\n          COALESCE(\n            SYSTEM$TASK_RUNTIME_INFO(‘LAST_SUCCESSFUL_TASK_GRAPH_ORIGINAL_SCHEDULED_TIMESTAMP’)::timestamp_ltz,\n            '2023-07-01'\n          ) AND SYSTEM$TASK_RUNTIME_INFO(‘CURRENT_TASK_GRAPH_ORIGINAL_SCHEDULED_TIMESTAMP’)::timestamp_ltz\n   ...;\n\nCREATE OR REPLACE TASK my_task ...\n  AS\n  ...\n\n  -- Inside Python UDF\n\n  query_result = session.sql(\"select\n      SYSTEM$TASK_RUNTIME_INFO('CURRENT_ROOT_TASK_NAME') root_name, SYSTEM$TASK_RUNTIME_INFO('LAST_SUCCESSFUL_TASK_GRAPH_RUN_GROUP_ID') last_run_id\").collect()\n  current_root_task_name, last_graph_run_id = result.ROOT_NAME,result.LAST_RUN_ID\n  logger.log(f\"graph name: {current_root_task_name}, last successful run: {last_graph_run_id}\")\n  ...;",
    "arguments": [
        {
            "name": "'",
            "description": "Specifies the type of information to return. You can specify one of the following values: Value Description 'CURRENT_TASK_NAME' Returns the name of the current task. 'CURRENT_ROOT_TASK_NAME' Returns the name of the root task in the current task graph. 'CURRENT_ROOT_TASK_UUID' Returns a universally unique identifier (UUID) that represents the root task in the current task graph. 'CURRENT_TASK_GRAPH_RUN_GROUP_ID' Returns a universally unique identifier (UUID) that represents the current graph run group. 'CURRENT_TASK_GRAPH_ORIGINAL_SCHEDULED_TIMESTAMP' Returns the original scheduled timestamp of the root task in the current graph run group. For graphs that are retried, the returned value is the original scheduled timestamp of the initial graph run in the\ncurrent group. 'LAST_SUCCESSFUL_TASK_GRAPH_RUN_GROUP_ID' Returns a universally unique identifier (UUID) that represents the latest successful graph run group. The value is consistent throughout the graph run group and is determined when the root task of the initial graph run\nstarts. 'LAST_SUCCESSFUL_TASK_GRAPH_ORIGINAL_SCHEDULED_TIMESTAMP' Returns the original scheduled timestamp of the root task in the latest successful graph run group. The value is consistent throughout the graph run group and is determined when the root task of the initial graph run\nstarts."
        }
    ],
    "returns": "Returns a STRING or TEXT with requested information."
},
{
    "function_name": "SYSTEM$TASK_DEPENDENTS_ENABLE",
    "summary": "Recursively resumes a specified task and all its dependent tasks.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_task_dependents_enable",
    "title": "SYSTEM$TASK_DEPENDENTS_ENABLE",
    "description": "Recursively resumes a specified task and all its dependent tasks. This function allows the owner of a",
    "syntax": "SYSTEM$TASK_DEPENDENTS_ENABLE( '<task_name>' )",
    "example": "SELECT SYSTEM$TASK_DEPENDENTS_ENABLE('mydb.myschema.mytask');\n\nSELECT SYSTEM$TASK_DEPENDENTS_ENABLE('mydb.myschema.\"myTask\"');",
    "arguments": [
        {
            "name": "task_name",
            "description": "Name of a task in a simple task graph. It does not need to be a root task."
        }
    ]
},
{
    "function_name": "SYSTEM$STREAM_HAS_DATA",
    "summary": "Indicates whether a specified stream contains change data capture (CDC) records.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_stream_has_data",
    "title": "SYSTEM$STREAM_HAS_DATA",
    "description": "Indicates whether a specified stream contains change data capture (CDC) records.",
    "syntax": "SYSTEM$STREAM_HAS_DATA('<stream_name>')",
    "example": "create table MYTABLE1 (id int);\n\ncreate table MYTABLE2(id int);\n\ncreate stream MYSTREAM on table MYTABLE1;\n\ninsert into MYTABLE1 values (1);\n\n-- returns true because the stream contains change tracking information\nselect system$stream_has_data('MYSTREAM');\n\n+----------------------------------------+\n| SYSTEM$STREAM_HAS_DATA('MYSTREAM')     |\n|----------------------------------------|\n| True                                   |\n+----------------------------------------+\n\n -- consume the stream\nbegin;\ninsert into MYTABLE2 select id from MYSTREAM;\ncommit;\n\n-- returns false because the stream was consumed\nselect system$stream_has_data('MYSTREAM');\n\n+----------------------------------------+\n| SYSTEM$STREAM_HAS_DATA('MYSTREAM')     |\n|----------------------------------------|\n| False                                  |\n+----------------------------------------+",
    "arguments": [
        {
            "name": "stream_name",
            "description": "The name of the stream to query. Note that the entire name must be enclosed in single quotes, including the database and schema (if the name is fully-qualified), i.e. '<db>.<schema>.<stream_name>' . If the stream name is case-sensitive or includes any special characters or spaces, double quotes are required to process the case/characters. The double quotes must be enclosed within the single quotes, i.e. '\"<stream_name>\"' ."
        }
    ]
},
{
    "function_name": "SYSTEM$STREAM_GET_TABLE_TIMESTAMP",
    "summary": "Returns the timestamp in nanoseconds of the latest table version at or before the current offset for the specified stream.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_stream_get_table_timestamp",
    "title": "SYSTEM$STREAM_GET_TABLE_TIMESTAMP",
    "description": "Returns the timestamp in nanoseconds of the latest table version at or before the current offset for the specified stream. When the stream is\nqueried (or consumed), the records returned include all transactions committed after this table version and before the current time.",
    "syntax": "SYSTEM$STREAM_GET_TABLE_TIMESTAMP('<stream_name>')",
    "example": "create table MYTABLE1 (id int);\n\ncreate table MYTABLE2(id int);\n\ncreate or replace stream MYSTREAM on table MYTABLE1;\n\ninsert into MYTABLE1 values (1);\n\n-- consume the stream\nbegin;\ninsert into MYTABLE2 select id from MYSTREAM;\ncommit;\n\n-- return the current offset for the stream\nselect system$stream_get_table_timestamp('MYSTREAM');",
    "arguments": [
        {
            "name": "stream_name",
            "description": "The name of the stream to query. Note that the entire name must be enclosed in single quotes, including the database and schema (if the name is fully-qualified), i.e. '<db>.<schema>.<stream_name>' . If the stream name is case-sensitive or includes any special characters or spaces, double quotes are required to process the case/characters. The double quotes must be enclosed within the single quotes, i.e. '\"<stream_name>\"' ."
        }
    ]
},
{
    "function_name": "SYSTEM$STREAM_BACKLOG",
    "summary": "Returns the set of table versions between the current offset for a specified stream and the current timestamp.",
    "category": "Table functions , System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_stream_backlog",
    "title": "SYSTEM$STREAM_BACKLOG",
    "description": "Returns the set of table versions between the current",
    "syntax": "SYSTEM$STREAM_BACKLOG('<stream_name>')",
    "example": "SELECT * FROM TABLE(SYSTEM$STREAM_BACKLOG('db1.schema1.s1'));",
    "arguments": [
        {
            "name": "stream_name",
            "description": "The name of the stream to query. Note that the entire name must be enclosed in single quotes, including the database and schema, if the name is fully-qualified,\n(i.e. '<db>.<schema>.<stream_name>' ). If the stream name is case-sensitive or includes any special characters or spaces, double quotes are required to process the\ncase/characters. The double quotes must be enclosed within the single quotes, i.e. '\"<stream_name>\"' ."
        }
    ]
},
{
    "function_name": "SYSTEM$START_USER_EMAIL_VERIFICATION",
    "summary": "Starts the email verification process for a user.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_start_user_email_verification",
    "title": "SYSTEM$START_USER_EMAIL_VERIFICATION",
    "description": "Starts the",
    "syntax": "SYSTEM$START_USER_EMAIL_VERIFICATION( '<user_name>' )",
    "example": "SELECT SYSTEM$START_USER_EMAIL_VERIFICATION('user_name');\n\nSELECT SYSTEM$START_USER_EMAIL_VERIFICATION('\"UserName\"');",
    "arguments": [
        {
            "name": "'",
            "description": "Name of the user."
        }
    ]
},
{
    "function_name": "SYSTEM$START_OAUTH_FLOW",
    "summary": "Initiates the OAUTH client flow, returning a URL you use in a browser to complete the OAuth consent process.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_start_oauth_flow",
    "title": "SYSTEM$START_OAUTH_FLOW",
    "description": "Initiates the OAUTH client flow, returning a URL you use in a browser to complete the OAuth consent process.",
    "syntax": "SYSTEM$START_OAUTH_FLOW( '<database_name.schema_name.secret_name>' )",
    "arguments": [
        {
            "name": "'",
            "description": "The name of the OAuth2 secret specifying authentication information for the API to access with OAuth."
        }
    ]
},
{
    "function_name": "SYSTEM$SNOWPIPE_STREAMING_UPDATE_CHANNEL_OFFSET_TOKEN",
    "summary": "Updates the offset token for a particular channel used by Snowpipe Streaming with a new offset token.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_snowpipe_streaming_update_channel_offset_token",
    "title": "SYSTEM$SNOWPIPE_STREAMING_UPDATE_CHANNEL_OFFSET_TOKEN",
    "description": "Updates the offset token for a particular channel used by Snowpipe Streaming with a new offset token.",
    "syntax": "SYSTEM$SNOWPIPE_STREAMING_UPDATE_CHANNEL_OFFSET_TOKEN('<dbName>.<schemaName>.<tableName>', '<channelName>', '<new_offset_token>')",
    "example": "show channels;\nselect SYSTEM$SNOWPIPE_STREAMING_UPDATE_CHANNEL_OFFSET_TOKEN('mydb.myschema.mytable', 'mychannel', '<new_offset_token>');\nshow channels;",
    "arguments": [
        {
            "name": "dbName",
            "description": "Name of the database in which the channel is stored."
        },
        {
            "name": "schemaName",
            "description": "Name of the schema in which the channel is stored."
        },
        {
            "name": "tableName",
            "description": "Name of the table where the channel is mapped to."
        },
        {
            "name": "channelName",
            "description": "Name of the channel."
        },
        {
            "name": "new_offset_token",
            "description": "The new offset token."
        }
    ]
},
{
    "function_name": "SYSTEM$SHOW_OAUTH_CLIENT_SECRETS",
    "summary": "Returns the client secrets in a string.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_show_oauth_client_secrets",
    "title": "SYSTEM$SHOW_OAUTH_CLIENT_SECRETS",
    "description": "Returns the client secrets in a string. The client ID and a client secret must be included in the authorization header to the OAuth token endpoint.",
    "syntax": "SYSTEM$SHOW_OAUTH_CLIENT_SECRETS( '<integration_name>' )",
    "example": "select system$show_oauth_client_secrets('MYINT');",
    "arguments": [
        {
            "name": "integration_name",
            "description": "Name of the integration. Note that the integration name is case-sensitive and must be uppercase and enclosed in single quotes."
        }
    ]
},
{
    "function_name": "SYSTEM$SHOW_MOVE_ORGANIZATION_ACCOUNT_STATUS",
    "summary": "Returns the status of an attempt to move an organization account.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_show_move_organization_account_status",
    "title": "SYSTEM$SHOW_MOVE_ORGANIZATION_ACCOUNT_STATUS",
    "syntax": "SYSTEM$SHOW_MOVE_ORGANIZATION_ACCOUNT_STATUS( )",
    "returns": "The following are the possible statuses:"
},
{
    "function_name": "SYSTEM$SHOW_EVENT_SHARING_ACCOUNTS",
    "summary": "Shows event accounts in a provider organization.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_show_event_sharing_accounts",
    "title": "SYSTEM$SHOW_EVENT_SHARING_ACCOUNTS",
    "description": "Shows event accounts in a provider organization.",
    "syntax": "SYSTEM$SHOW_EVENT_SHARING_ACCOUNTS()",
    "example": "SELECT SYSTEM$SHOW_EVENT_SHARING_ACCOUNTS();"
},
{
    "function_name": "SYSTEM$SHOW_BUDGETS_IN_ACCOUNT",
    "summary": "Returns the budgets in the account for which you have access privileges.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_show_budgets_in_account",
    "title": "SYSTEM$SHOW_BUDGETS_IN_ACCOUNT",
    "description": "Returns the",
    "syntax": "SYSTEM$SHOW_BUDGETS_IN_ACCOUNT()",
    "example": "SELECT SYSTEM$SHOW_BUDGETS_IN_ACCOUNT();",
    "returns": "The function returns the following elements in a JSON object:"
},
{
    "function_name": "SYSTEM$SHOW_BUDGETS_FOR_RESOURCE",
    "summary": "Returns a string containing a list of the budgets that track a specified resource (for example, a table or a schema).",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_show_budgets_for_resource",
    "title": "SYSTEM$SHOW_BUDGETS_FOR_RESOURCE",
    "description": "Returns a string containing a list of the",
    "syntax": "SYSTEM$SHOW_BUDGETS_FOR_RESOURCE( '<resource_domain>' , '<resource_name>' )",
    "example": "SELECT SYSTEM$SHOW_BUDGETS_FOR_RESOURCE('SCHEMA', 'my_db.my_schema');\n\n+---------------------------------------------------------------+\n| SYSTEM$SHOW_BUDGETS_FOR_RESOURCE('SCHEMA', 'MY_DB.MY_SCHEMA') |\n|---------------------------------------------------------------|\n| [BUDGETS_DB.BUDGETS_SCHEMA.MY_BUDGET]                         |\n+---------------------------------------------------------------+\n\nSELECT SYSTEM$SHOW_BUDGETS_FOR_RESOURCE('TABLE', 'my_db.my_schema.my_table');\n\n+-----------------------------------------------------------------------+\n| SYSTEM$SHOW_BUDGETS_FOR_RESOURCE('TABLE', 'MY_DB.MY_SCHEMA.MY_TABLE') |\n|-----------------------------------------------------------------------|\n| []                                                                    |\n+-----------------------------------------------------------------------+",
    "arguments": [
        {
            "name": "'",
            "description": "Domain of the resource. You can specify one of the following values: compute_pool database materialized_view pipe schema table task warehouse"
        },
        {
            "name": "'",
            "description": "Name of the resource (for example, the name of the table)."
        }
    ],
    "returns": "Returns a VARCHAR value containing the comma-delimited list of the fully qualified names of the budgets for the resource.\nThe list is surrounded by square brackets."
},
{
    "function_name": "SYSTEM$SHOW_ACTIVE_BEHAVIOR_CHANGE_BUNDLES",
    "summary": "Returns an array of the currently available behavior change release bundles, the default state of each bundle, and the actual state of the bundle for the current account.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_show_active_behavior_change_bundles",
    "title": "SYSTEM$SHOW_ACTIVE_BEHAVIOR_CHANGE_BUNDLES",
    "description": "Returns an array of the currently available",
    "syntax": "SYSTEM$SHOW_ACTIVE_BEHAVIOR_CHANGE_BUNDLES()",
    "example": "SELECT SYSTEM$SHOW_ACTIVE_BEHAVIOR_CHANGE_BUNDLES();\n\n+--------------------------------------------------------------------------------------------------------------+\n| SYSTEM$SHOW_ACTIVE_BEHAVIOR_CHANGE_BUNDLES()                                                                 |\n|--------------------------------------------------------------------------------------------------------------|\n| [{\"name\":\"2023_08\",\"isDefault\":true,\"isEnabled\":true},{\"name\":\"2024_01\",\"isDefault\":false,\"isEnabled\":true}] |\n+--------------------------------------------------------------------------------------------------------------+\n\nSELECT\n    bundles.VALUE:name::VARCHAR AS bundle_name,\n    bundles.VALUE:isDefault::BOOLEAN AS is_enabled_by_default,\n    bundles.VALUE:isEnabled::BOOLEAN AS is_actually_enabled_in_account\n  FROM\n    TABLE(FLATTEN(input => PARSE_JSON(SYSTEM$SHOW_ACTIVE_BEHAVIOR_CHANGE_BUNDLES())))\n    AS bundles;\n\n+-------------+-----------------------+--------------------------------+\n| BUNDLE_NAME | IS_ENABLED_BY_DEFAULT | IS_ACTUALLY_ENABLED_IN_ACCOUNT |\n|-------------+-----------------------+--------------------------------|\n| 2023_08     | True                  | True                           |\n| 2024_01     | False                 | True                           |\n+-------------+-----------------------+--------------------------------+",
    "returns": "Returns a VARCHAR value that contains an array of objects that represent the currently available behavior change bundles.\nEach object contains the following keys, which describe the status of the bundle:"
},
{
    "function_name": "SYSTEM$SET_SPAN_ATTRIBUTES (for Snowflake Scripting)",
    "summary": "Sets attribute name and value associated with a span containing trace events.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_set_span_attributes",
    "title": "SYSTEM$SET_SPAN_ATTRIBUTES (for Snowflake Scripting)",
    "description": "Sets attribute name and value associated with a span containing trace events.",
    "syntax": "SYSTEM$SET_SPAN_ATTRIBUTES('<object>');",
    "example": "create procedure MYPROC()\nreturns double\nlanguage sql\nas\n$$\nbegin\n    -- Add an event without attributes\n    SYSTEM$ADD_EVENT('name_a');\n\n    -- Add an event with attributes\n    let attr := {'score':89, 'pass':true};\n    SYSTEM$ADD_EVENT('name_b', attr);\n\n    -- Set attributes for the span\n    SYSTEM$SET_SPAN_ATTRIBUTES('{'attr1':'value1', 'attr2':true}');\n\n    return 3.14;\nend;\n$$\n;",
    "arguments": [
        {
            "name": "'",
            "description": "An object containing name-value pairs representing the attributes to add."
        }
    ]
},
{
    "function_name": "SYSTEM$SET_RETURN_VALUE",
    "summary": "Explicitly sets the return value for a task.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_set_return_value",
    "title": "SYSTEM$SET_RETURN_VALUE",
    "description": "Explicitly sets the return value for a task.",
    "syntax": "SYSTEM$SET_RETURN_VALUE( '<string_expression>' )",
    "example": "-- Create a table to store the return values.\nCREATE OR REPLACE TABLE return_values (str VARCHAR);\n\n-- Create a task that sets the return value for the task.\nCREATE TASK set_return_value\n  WAREHOUSE=return_task_wh\n  SCHEDULE='1 MINUTE'\n  AS\n    CALL SYSTEM$SET_RETURN_VALUE('The quick brown fox jumps over the lazy dog');\n\n-- Create a task that identifies the first task as the predecessor task and retrieves the return value set for that task.\nCREATE TASK get_return_value\n  WAREHOUSE=return_task_wh\n  AFTER set_return_value\n  AS\n    INSERT INTO return_values VALUES(SYSTEM$GET_PREDECESSOR_RETURN_VALUE());\n\n\n-- Note that if there are multiple predecessor tasks that are enabled, you must specify the name of the task to retrieve the return value for that task.\nCREATE TASK get_return_value_by_pred\n  WAREHOUSE=return_task_wh\n  AFTER set_return_value\n  AS\n    INSERT INTO return_values VALUES(SYSTEM$GET_PREDECESSOR_RETURN_VALUE('SET_RETURN_VALUE'));\n\n-- Resume task (using ALTER TASK ... RESUME).\n-- Wait for task to run on schedule.\n\nSELECT DISTINCT(str) FROM return_values;\n+-----------------------------------------------+\n|                      STR                      |\n+-----------------------------------------------+\n|  The quick brown fox jumps over the lazy dog  |\n+-----------------------------------------------+\n\nSELECT DISTINCT(RETURN_VALUE)\n  FROM TABLE(information_schema.task_history())\n  WHERE RETURN_VALUE IS NOT NULL;\n\n\n+-----------------------------------------------+\n|                  RETURN_VALUE                 |\n+-----------------------------------------------+\n|  The quick brown fox jumps over the lazy dog  |\n+-----------------------------------------------+\n\n-- Create a table to store the return values.\nCREATE OR REPLACE TABLE return_values_sp (str VARCHAR);\n\n-- Create a stored procedure that sets the return value for the task.\nCREATE OR REPLACE PROCEDURE set_return_value_sp()\nRETURNS STRING\nLANGUAGE JAVASCRIPT\nEXECUTE AS CALLER\nAS $$\nvar stmt = snowflake.createStatement({sqlText:`CALL SYSTEM$SET_RETURN_VALUE('The quick brown fox jumps over the lazy dog');`});\n  var res = stmt.execute();\n$$;\n\n-- Create a stored procedure that inserts the return value for the predecessor task into the 'return_values_sp' table.\nCREATE OR REPLACE PROCEDURE get_return_value_sp()\nRETURNS STRING\nLANGUAGE JAVASCRIPT\nEXECUTE AS CALLER\nAS $$\nvar stmt = snowflake.createStatement({sqlText:`INSERT INTO return_values_sp VALUES(SYSTEM$GET_PREDECESSOR_RETURN_VALUE());`});\nvar res = stmt.execute();\n$$;\n\n-- Create a task that calls the set_return_value stored procedure.\nCREATE TASK set_return_value_t\nWAREHOUSE=warehouse1\nSCHEDULE='1 MINUTE'\nAS\n  CALL set_return_value_sp();\n\n-- Create a task that calls the get_return_value stored procedure.\nCREATE TASK get_return_value_t\nWAREHOUSE=warehouse1\nAFTER set_return_value_t\nAS\n  CALL get_return_value_sp();\n\n-- Resume task.\n-- Wait for task to run on schedule.\n\nSELECT DISTINCT(str) FROM return_values_sp;\n+-----------------------------------------------+\n|                      STR                      |\n+-----------------------------------------------+\n|  The quick brown fox jumps over the lazy dog  |\n+-----------------------------------------------+\n\nSELECT DISTINCT(RETURN_VALUE)\n  FROM TABLE(information_schema.task_history())\n  WHERE RETURN_VALUE IS NOT NULL;\n\n+-----------------------------------------------+\n|                  RETURN_VALUE                 |\n+-----------------------------------------------+\n|  The quick brown fox jumps over the lazy dog  |\n+-----------------------------------------------+\n\nCREATE OR REPLACE TASK load_raw_data\nWAREHOUSE = 'WH'\nWHEN\n    SYSTEM$STREAM_HAS_DATA('NEW_WEATHER_DATA')\nAS\n    DECLARE\n        rows_loaded NUMBER;\n        result_string VARCHAR;\n    BEGIN\n        INSERT INTO raw_weather_data ( -- our landing table\n            row_id)\n        SELECT\n            row_id\n        FROM\n            new_weather_data  -- our source stream\n        ;\n\n        -- to see the number of rows loaded in the UI\n        rows_loaded := (SELECT $1 FROM TABLE(RESULT_SCAN(LAST_QUERY_ID())));\n        result_string := :rows_loaded || ' rows loaded into RAW_WEATHER_DATA';\n        -- show result string as task return value\n        CALL SYSTEM$SET_RETURN_VALUE(:result_string);\n    END;",
    "arguments": [
        {
            "name": "string_expression",
            "description": "The string to set as the return value. The string size must be <= 10 kB (when encoded in UTF8)."
        }
    ]
},
{
    "function_name": "SYSTEM$SET_REFERENCE",
    "summary": "Called by a",
    "category": "native-app",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_set_reference",
    "title": "SYSTEM$SET_REFERENCE",
    "description": "Called by a Snowflake Native App to associate a consumer reference string to a reference definition.\nThe app can use this association to access the consumer object. The reference string passed to this system function is the value returned by the",
    "syntax": "SYSTEM$SET_REFERENCE('<reference_name>', '<reference_string>')",
    "arguments": [
        {
            "name": "'",
            "description": "The name of the reference as specified in the manifest.yml file of the app."
        },
        {
            "name": "'",
            "description": "The system-generated ID of the reference to the object in the consumer account."
        }
    ]
},
{
    "function_name": "SYSTEM$SET_EVENT_SHARING_ACCOUNT_FOR_REGION",
    "summary": "Sets the event account for a region.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_set_event_sharing_account_for_region",
    "title": "SYSTEM$SET_EVENT_SHARING_ACCOUNT_FOR_REGION",
    "description": "Sets the event account for a region.",
    "syntax": "SYSTEM$SET_EVENT_SHARING_ACCOUNT_FOR_REGION( '<snowflake_region>' , '<region_group>' , '<account_name>' )",
    "example": "SELECT SYSTEM$SET_EVENT_SHARING_ACCOUNT_FOR_REGION('aws_us_west_2', 'public', 'myaccount');",
    "arguments": [
        {
            "name": "snowflake_region",
            "description": "Specifies the region where the account is located, for example: AWS_US_WEST_2, AWS_US_EAST_1 ."
        },
        {
            "name": "region_group",
            "description": "Specifies the region group, for example: PUBLIC . Refer to Region groups for details."
        },
        {
            "name": "account_name",
            "description": "Specifies the account name. If another account is already set as the events account in the\nspecified region, calling this function changes the events account to be the account\nspecified here."
        }
    ]
},
{
    "function_name": "SYSTEM$SET_APPLICATION_RESTRICTED_FEATURE_ACCESS",
    "summary": "Enables a restricted feature for a",
    "category": "native-app",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_set_application_restricted_feature_access",
    "title": "SYSTEM$SET_APPLICATION_RESTRICTED_FEATURE_ACCESS",
    "description": "Enables a restricted feature for a Snowflake Native App. Currently, only external and Apache Iceberg™ tables are\nsupported.",
    "syntax": "SYSTEM$SET_APPLICATION_RESTRICTED_FEATURE_ACCESS(\n  '<app_name>',\n  '<type>',\n  '<parameters>'\n)",
    "example": "SELECT SYSTEM$SET_APPLICATION_RESTRICTED_FEATURE_ACCESS('hello_snowflake_app', 'external_data', '{\"allowed_cloud_providers\" : \"none\"}');\n\n\"SYSTEM$SET_APPLICATION_RESTRICTED_FEATURE_ACCESS('EXTERNAL_DATA_DEMO_APP', 'EXTERNAL_DATA', '{\"\"ALLOWED_CLOUD_PROVIDERS\"\" : \"\"NONE\"\"}')\"\n\"{\"\"external_data\"\":{\"\"allowed_cloud_providers\"\":\"\"none\"\"}}\"",
    "arguments": [
        {
            "name": "app_name",
            "description": "Name of the Snowflake Native App."
        },
        {
            "name": "type",
            "description": "The type of restricted feature. Currently only EXTERNAL_DATA is supported."
        },
        {
            "name": "parameters",
            "description": "A JSON object that contains configuration parameters for the restricted feature. Currently,\nonly JSON objects of the following format are supported: The supported values for allowed_cloud_providers are all and none ."
        }
    ],
    "returns": "A JSON object containing a list of external features whose value the consumer has set. The JSON\nobject has the following structure:"
},
{
    "function_name": "SYSTEM$SEND_NOTIFICATIONS_TO_CATALOG",
    "summary": "Sends a notification to Snowflake Open Catalog to update Snowflake-managed Apache Iceberg™ tables in",
    "category": "opencatalog",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_send_notifications_to_catalog",
    "title": "SYSTEM$SEND_NOTIFICATIONS_TO_CATALOG",
    "description": "Sends a notification to",
    "syntax": "SYSTEM$SEND_NOTIFICATIONS_TO_CATALOG( '<domain>' , '<entity_name>' [ , '<notification_type>'] [ , '<catalog_sync_integration_name>'] )",
    "example": "SELECT VALUE[0]::STRING AS tableName,\n       VALUE[1]::BOOLEAN notificationStatus,\n       VALUE[2]::STRING errorCode,\n       VALUE[3]::STRING errorMessage\n  FROM TABLE(FLATTEN(PARSE_JSON(\n    SELECT SYSTEM$SEND_NOTIFICATIONS_TO_CATALOG(\n      'SCHEMA',\n      'testSchema'))));\n\nSELECT VALUE[0]::STRING AS tableName,\n       VALUE[1]::BOOLEAN notificationStatus,\n       VALUE[2]::STRING errorCode,\n       VALUE[3]::STRING errorMessage\n   FROM TABLE(FLATTEN(PARSE_JSON(\n     SELECT SYSTEM$SEND_NOTIFICATIONS_TO_CATALOG(\n       'TABLE',\n       'icebergTable',\n       'DROP',\n       'my_catalog_sync_integration'))));",
    "arguments": [
        {
            "name": "domain",
            "description": "The domain at which to send the notification. You can specify one of the following domains: DATABASE SCHEMA TABLE For example, if you want to send a notification to tables under a certain schema, specify SCHEMA ."
        },
        {
            "name": "entity_name",
            "description": "The name of an entity for the given domain . Depending on the given domain, entity_name specifies the name of a\ndatabase, schema, or table."
        },
        {
            "name": "notification_type",
            "description": "The type of notification to send to Open Catalog. You can specify one of the following types of notifications: UPDATE : Updates the state of the table in Open Catalog. If the table doesn’t yet exist, Open Catalog, creates the table. DROP : Drops the table from Open Catalog if it exists. Default: UPDATE"
        },
        {
            "name": "catalog_sync_integration_name",
            "description": "The name of a catalog integration for Open Catalog to which you want to scope the notifications. The notifications are only sent to a given\ntable if the CATALOG_SYNC parameter for the table is set to this catalog integration. Important If you need to specify a value for catalog_sync_integration_name , you can’t leave notification_type empty to use\nits default value. In other words, if you need to specify a value for catalog_sync_integration_name instead of using the\ndefault, you must first specify UPDATE or DROP for notification_type . Default: If the argument is not specified, notifications are sent to all the tables in the domain specified by the required arguments,\nregardless of their catalog sync integration. For example, if you specify SCHEMA for domain and schema1 for entity_name and use the default for catalog_sync_integration_name , all tables under schema1 are notified. This argument is used to limit\nthe scope of notifications to a single catalog sync integration."
        }
    ],
    "returns": "The function returns a JSON object with the properties described below:"
},
{
    "function_name": "SYSTEM$SCHEDULE_ASYNC_REPLICATION_GROUP_REFRESH",
    "summary": "Starts a refresh operation for a replication group or a failover group, in the background.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_schedule_async_replication_group_refresh",
    "title": "SYSTEM$SCHEDULE_ASYNC_REPLICATION_GROUP_REFRESH",
    "description": "Starts a refresh operation for a replication group or a failover group, in the background.\nYou can call this function in a stored procedure to begin one or more refresh operations\nand continue doing work while the refreshes are in progress.",
    "syntax": "SYSTEM$SCHEDULE_ASYNC_REPLICATION_GROUP_REFRESH(<replication_group_name>)\nSYSTEM$SCHEDULE_ASYNC_REPLICATION_GROUP_REFRESH(<failover_group_name>)",
    "example": "USE ROLE ACCOUNTADMIN;\n\nSELECT SYSTEM$SCHEDULE_ASYNC_REPLICATION_GROUP_REFRESH('failover_group_1');\nSELECT SYSTEM$SCHEDULE_ASYNC_REPLICATION_GROUP_REFRESH('failover_group_2');",
    "arguments": [
        {
            "name": "'",
            "description": "The name of the replication group or failover group to refresh."
        }
    ]
},
{
    "function_name": "SYSTEM$REVOKE_STAGE_PRIVATELINK_ACCESS",
    "summary": "Revokes the authorization for Snowflake to access the Microsoft Azure Private Endpoint for Azure private endpoints for internal stages for the current account.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_revoke_stage_privatelink_access",
    "title": "SYSTEM$REVOKE_STAGE_PRIVATELINK_ACCESS",
    "description": "Revokes the authorization for Snowflake to access the Microsoft Azure Private Endpoint for",
    "syntax": "-- Azure\nSYSTEM$REVOKE_STAGE_PRIVATELINK_ACCESS( '<privateEndpointResourceID>' )",
    "example": "use role accountadmin;\n\nselect SYSTEM$REVOKE_STAGE_PRIVATELINK_ACCESS('/subscriptions/subId/resourceGroups/rg1/providers/Microsoft.Network/privateEndpoints/pe1');",
    "arguments": [
        {
            "name": "'",
            "description": "The unique identifier for the Private Endpoint in Azure. Snowflake uses this endpoint value to access the internal stage through the Azure internal network to avoid the public Internet. For instructions on how to obtain this value, see Configuring private endpoints to access Snowflake internal stages ."
        }
    ]
},
{
    "function_name": "SYSTEM$REVOKE_PRIVATELINK",
    "summary": "Disables private connectivity to the Snowflake service for the current account.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_revoke_privatelink",
    "title": "SYSTEM$REVOKE_PRIVATELINK",
    "description": "Disables private connectivity to the Snowflake service for the current account.",
    "syntax": "SYSTEM$REVOKE_PRIVATELINK( '<aws_id>' , '<federated_token>' )",
    "example": "USE ROLE ACCOUNTADMIN;\n\nselect SYSTEM$REVOKE_PRIVATELINK(\n    '185...',\n    '{\n      \"Credentials\": {\n          \"AccessKeyId\": \"ASI...\",\n          \"SecretAccessKey\": \"enw...\",\n          \"SessionToken\": \"Fwo...\",\n          \"Expiration\": \"2021-01-07T19:06:23+00:00\"\n      },\n      \"FederatedUser\": {\n          \"FederatedUserId\": \"185...:sam\",\n          \"Arn\": \"arn:aws:sts::185...:federated-user/sam\"\n      },\n      \"PackedPolicySize\": 0\n  }'\n  );\n\nUSE ROLE ACCOUNTADMIN;\n\nselect SYSTEM$REVOKE_PRIVATELINK(\n  '/subscriptions/26d.../resourcegroups/sf-1/providers/microsoft.network/privateendpoints/test-self-service',\n  'eyJ...');\n\nUSE ROLE ACCOUNTADMIN;\n\nselect SYSTEM$REVOKE_PRIVATELINK(\n  'my-gcp-project-id',\n  'ya29.a0AcM612zT4pJaXdYfwgY8aiMoDE9W_xkqQ20coFTB1TJcImKDPo...'\n  );",
    "arguments": [
        {
            "name": "'",
            "description": "The 12-digit identifier that uniquely identifies your Amazon Web Services (AWS) account, as a string."
        },
        {
            "name": "'",
            "description": "The identifier that uniquely identifies the private endpoint in Microsoft Azure (Azure) as a string."
        },
        {
            "name": "'",
            "description": "The federated token value that contains access credentials for a federated user as a string. To obtain this value, execute the appropriate command for the cloud platform that hosts your Snowflake account. Use the command-line tool\nprovided by the platform: For Snowflake on AWS: For Snowflake on Azure: Where: The unique identifier for your subscription. For example: 13c... To obtain this value, execute the following Azure CLI command in your command line environment: Note the output value in the SubscriptionID column, which is truncated in this example:"
        },
        {
            "name": "SubscriptionID",
            "description": "The unique identifier for your subscription. For example: 13c... To obtain this value, execute the following Azure CLI command in your command line environment: Note the output value in the SubscriptionID column, which is truncated in this example:"
        },
        {
            "name": "'",
            "description": "The identifier that uniquely identifies your Google Cloud (GCP) project, as a string."
        },
        {
            "name": "'",
            "description": "The access token value that contains access credentials for a Google Cloud user as a string."
        }
    ]
},
{
    "function_name": "SYSTEM$RESTORE_PRIVATELINK_ENDPOINT",
    "summary": "Restores a private connectivity endpoint in the Snowflake VPC or VNet to enable Snowflake to connect to an external service using private connectivity.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_restore_privatelink_endpoint",
    "title": "SYSTEM$RESTORE_PRIVATELINK_ENDPOINT",
    "syntax": "SYSTEM$RESTORE_PRIVATELINK_ENDPOINT( '<provider_service_name>' )",
    "example": "SELECT SYSTEM$RESTORE_PRIVATELINK_ENDPOINT('com.amazonaws.us-west-2.s3');\n\nSELECT SYSTEM$RESTORE_PRIVATELINK_ENDPOINT(\n  '/subscriptions/11111111-2222-3333-4444-5555555555/resourceGroups/my_rg/providers/Microsoft.Sql/servers/my_db_server',\n  'sqlServer'\n);\n\nPrivate endpoint with id ''/subscriptions/66666666-7777-8888-9999-0000000000/resourcegroups/rg/providers/microsoft.network/privateendpoints/00000000-1111-2222-3333-4444444444'' restored successfully.",
    "arguments": [
        {
            "name": "provider_service_name",
            "description": "Specifies the external service or resource endpoint to restore. For example, com.amazonaws.us-west-2.execute-api for the Amazon API\nGateway or com.amazonaws.us-west-2.s3 for Amazon S3."
        },
        {
            "name": "'",
            "description": "Specifies the fully-qualified identifier for the resource in your VPC or VNet."
        },
        {
            "name": "'",
            "description": "Specifies the name of the subresource of the Azure resource. This argument is not required for Azure Private Link Service and Azure API Management Service. For all supported values, see the Sub-resource table ."
        }
    ],
    "returns": "Returns a status message stating that the endpoint, with its identifier, is restored successfully."
},
{
    "function_name": "SYSTEM$REMOVE_REFERENCE",
    "summary": "Remove an association from the reference to an object in the consumer account and returns a unique system-generated alias for the reference.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_remove_reference",
    "title": "SYSTEM$REMOVE_REFERENCE",
    "description": "Remove an association from the reference to an object in the consumer account and returns\na unique system-generated alias for the reference.",
    "syntax": "SYSTEM$REMOVE_REFERENCE('<reference_name>'[, '<alias>'])",
    "arguments": [
        {
            "name": "'",
            "description": "The name of the reference as specified in the manifest.yml file of the app."
        },
        {
            "name": "'",
            "description": "The system-generated ID of the reference to the object in the consumer account."
        }
    ]
},
{
    "function_name": "SYSTEM$REMOVE_ALL_REFERENCES",
    "summary": "Deletes all associations to the reference.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_remove_all_references",
    "title": "SYSTEM$REMOVE_ALL_REFERENCES",
    "description": "Deletes all associations to the reference.",
    "syntax": "SYSTEM$REMOVE_ALL_REFERENCES('<reference_name>')",
    "arguments": [
        {
            "name": "'",
            "description": "The name of the reference as specified in the manifest.yml file of the app."
        }
    ]
},
{
    "function_name": "SYSTEM$REGISTRY_LIST_IMAGES — Deprecated",
    "summary": "Lists images in an image repository.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_registry_list_images",
    "title": "SYSTEM$REGISTRY_LIST_IMAGES —",
    "syntax": "SYSTEM$REGISTRY_LIST_IMAGES( '/<dbName>/<schemaName>/<repositoryName>' )",
    "example": "SELECT SYSTEM$REGISTRY_LIST_IMAGES('/tutorial_db/data_schema/tutorial_repository');\n\n+-----------------------------------------------------------------------------+\n| SYSTEM$REGISTRY_LIST_IMAGES('/TUTORIAL_DB/DATA_SCHEMA/TUTORIAL_REPOSITORY') |\n|-----------------------------------------------------------------------------|\n| {\"images\":[\"my_echo_service_image\",\"my_job_image\"]}                         |\n+-----------------------------------------------------------------------------+",
    "arguments": [
        {
            "name": "dbName",
            "description": "Name of the database in which the repository is created."
        },
        {
            "name": "schemaName",
            "description": "Name of the database in which the repository is created."
        },
        {
            "name": "repositoryName",
            "description": "Name of the image repository."
        }
    ],
    "returns": "Returns a JSON object listing all the images."
},
{
    "function_name": "SYSTEM$REGISTER_PRIVATELINK_ENDPOINT",
    "summary": "Registers a private connectivity endpoint to route your connection to the Snowflake service.",
    "category": "",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_register_privatelink_endpoint",
    "title": "SYSTEM$REGISTER_PRIVATELINK_ENDPOINT",
    "syntax": "SYSTEM$REGISTER_PRIVATELINK_ENDPOINT(\n  '<aws_private_endpoint_vpce_id>',\n  '<aws_account_id>',\n  '<token>',\n  [ <delay_time> ]\n  )",
    "example": "SELECT SYSTEM$REGISTER_PRIVATELINK_ENDPOINT(\n  'vpce-0c1...',\n  '123.....',\n  '{\n    \"Credentials\": {\n      \"AccessKeyId\": \"ASI...\",\n      \"SecretAccessKey\": \"alD...\",\n      \"SessionToken\": \"IQo...\",\n      \"Expiration\": \"2024-12-10T08:20:20+00:00\"\n    },\n    \"FederatedUser\": {\n      \"FederatedUserId\": \"0123...:snowflake\",\n      \"Arn\": \"arn:aws:sts::174...:federated-user/snowflake\"\n    },\n    \"PackedPolicySize\": 9,\n    }',\n  120\n  );\n\nSELECT SYSTEM$REGISTER_PRIVATELINK_ENDPOINT(\n  '123....',\n  '/subscriptions/0cc51670-.../resourceGroups/dbsec_test_rg/providers/Microsoft.Network/\n  privateEndpoints/...',\n  'eyJ...',\n  120\n);",
    "returns": "Returns a status message about the registration of the private connectivity endpoint."
},
{
    "function_name": "SYSTEM$REGISTER_CMK_INFO",
    "summary": "Registers your customer-managed key (CMK) for use with Tri-Secret Secure.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_register_cmk_info",
    "title": "SYSTEM$REGISTER_CMK_INFO",
    "description": "Registers your customer-managed key (CMK) for use with Tri-Secret Secure.",
    "syntax": "SYSTEM$REGISTER_CMK_INFO( '<cmk-arn>' )",
    "example": "SELECT SYSTEM$REGISTER_CMK_INFO('arn:aws:kms:us-west-2:736112632310:key/ceab36e4-f0e5-4b46-9a78-86e8f17a0f59');\n\nSELECT SYSTEM$REGISTER_CMK_INFO('https://trisecretsite.vault.azure.net/', 'trisecretazkey');\n\nSELECT SYSTEM$REGISTER_CMK_INFO('my-env', 'us-west1', 'trisecrettest', 'trisecretgcpkey');",
    "arguments": [
        {
            "name": "cmk-arn",
            "description": "Specifies the Amazon Web Services resource number (ARN) that specifies the customer-managed key (CMK) for use with Tri-Secret Secure."
        },
        {
            "name": "vault-uri",
            "description": "Specifies the Microsoft Azure unique endpoint identifier for your Azure Key Vault."
        },
        {
            "name": "key-name",
            "description": "Specifies the name for your CMK in Microsoft Azure."
        },
        {
            "name": "project-id",
            "description": "Specifies the unique identifier for your project in Google Cloud Platform."
        },
        {
            "name": "location",
            "description": "Specifies the Google Cloud Platform region that hosts your Snowflake account."
        },
        {
            "name": "key-ring",
            "description": "Specifies the key ring for your CMK in Google Cloud Platform."
        },
        {
            "name": "key-name",
            "description": "Specifies the name of your CMK."
        }
    ],
    "returns": "Returns a status message stating the registration is complete."
},
{
    "function_name": "SYSTEM$REFERENCE",
    "summary": "Returns a reference to an object (a table, view, or function).",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_reference",
    "title": "SYSTEM$REFERENCE",
    "description": "Returns a",
    "syntax": "SYSTEM$REFERENCE('<object_type>', '<object_identifier>',\n  [ , '<reference_scope>' [ , '<privilege>' [ , '<privilege>' ... ] ] ] )",
    "arguments": [
        {
            "name": "'",
            "description": "Type of the object. You can specify one of the following values: api_integration compute_pool database external_access_integration external_table external_volume function materialized_view policy pipe procedure row_access_policy secret schema table tag task view warehouse"
        },
        {
            "name": "'",
            "description": "Identifier for the object. If the identifier contains spaces or special characters, the entire string must be enclosed in\ndouble quotes. Identifiers enclosed in double quotes are also case-sensitive. For more details about identifiers, see Identifier requirements ."
        },
        {
            "name": "'",
            "description": "Specifies the scope of the reference. If 'CALL' or omitted, specifies that the reference is valid within the context in which it was created.\nSee Specifying the scope of the reference . If 'SESSION' , specifies that the reference should be valid for the duration for the session. If 'PERSISTENT' , specifies that the reference should be valid until the object is dropped. See persistent references . Note: If you need to specify the ' privilege ' argument, the ' reference_scope ' argument is required. Valid values: 'CALL' 'SESSION' 'PERSISTENT' Default value: 'CALL'"
        },
        {
            "name": "'",
            "description": "Additional privilege that is needed to perform an SQL action on the\nobject. For example, suppose that you are passing the reference for a table to a stored procedure that inserts rows into that table.\nSpecify 'INSERT' to confer the INSERT privilege on that table to the stored procedure. For a list of supported objects and privileges, see Supported object types and privileges for references . To specify more than one additional privilege, pass each privilege name as an additional argument to the function. For example,\nto confer the INSERT, UPDATE, and TRUNCATE privileges: Note that you cannot specify OWNERSHIP or ALL as privileges."
        }
    ],
    "returns": "A serialized string representation of the reference that can be used as an identifier."
},
{
    "function_name": "SYSTEM$QUERY_REFERENCE",
    "summary": "Returns a query reference that you can pass to a stored procedure.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_query_reference",
    "title": "SYSTEM$QUERY_REFERENCE",
    "description": "Returns a",
    "syntax": "SYSTEM$QUERY_REFERENCE('<select_statement>', [ , <use_session_scope> ] )",
    "arguments": [
        {
            "name": "select_statement",
            "description": "The SELECT statement to pass to the stored procedure. This must be a statement that serves as an inline view. Note that if the SELECT statement contains any single quotes or other special characters (e.g. newlines), you must escape those characters with backslashes ."
        },
        {
            "name": "use_session_scope",
            "description": "If TRUE , specifies that the query reference should be valid for the duration for the session. If this is FALSE or omitted, the query reference is valid within the context in which it was created. See Specifying the scope of the reference . Default value: FALSE"
        }
    ],
    "returns": "A query reference that represents the specified SELECT statement."
},
{
    "function_name": "SYSTEM$PROVISION_PRIVATELINK_ENDPOINT",
    "summary": "Provisions a private connectivity endpoint in the Snowflake VPC or VNet to enable Snowflake to connect to an external service using private connectivity.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_provision_privatelink_endpoint",
    "title": "SYSTEM$PROVISION_PRIVATELINK_ENDPOINT",
    "syntax": "SYSTEM$PROVISION_PRIVATELINK_ENDPOINT(\n  '<provider_service_name>',\n  '<host_name>'\n)",
    "example": "SELECT SYSTEM$PROVISION_PRIVATELINK_ENDPOINT(\n  'com.amazonaws.us-west-2.s3',\n  '*.s3.us-west-2.amazonaws.com'\n);\n\nSELECT SYSTEM$PROVISION_PRIVATELINK_ENDPOINT(\n  '/subscriptions/f4b00c5f-f6bf-41d6-806b-e1cac4f1f36f/resourceGroups/aztest1-external-function-rg/providers/Microsoft.ApiManagement/service/aztest1-external-function-api',\n  'aztest1-external-function-api.azure.net',\n  'Gateway'\n  );\n\nPrivate endpoint with ID \"/subscriptions/e48379a7-2fc4-473e-b071-f94858cc83f5/resourcegroups/test_rg/providers/microsoft.network/privateendpoints/32bd3122-bfbd-417d-8620-1a02fd68fcf8\" to resource \"/subscriptions/f4b00c5f-f6bf-41d6-806b-e1cac4f1f36f/resourceGroups/aztest1-external-function-rg/providers/Microsoft.ApiManagement/service/aztest1-external-function-api\" has been provisioned successfully. Please note down the endpoint ID and approve the connection from it on the Azure portal.\n\nSELECT SYSTEM$PROVISION_PRIVATELINK_ENDPOINT(\n  '/subscriptions/11111111-2222-3333-4444-5555555555/resourceGroups/leorg1/providers/Microsoft.Sql/servers/myserver',\n  'testdb.database.windows.net',\n  'sqlServer'\n  );\n\n\"Resource Endpoint with id \"/subscriptions/f0abb333-1b05-47c6-8c31-dd36d2512fd1/resourceGroups/privatelink-test/providers/Microsoft.Network/privateEndpoints/external-network-access-pe\" provisioned successfully\"\n\nSELECT SYSTEM$PROVISION_PRIVATELINK_ENDPOINT(\n  '/subscriptions/cc2909f2-ed22-4c89-8e5d-bdc40e5eac26/resourceGroups/mystorage/providers/Microsoft.Storage/storageAccounts/storagedemo',\n  'storagedemo.blob.core.windows.net',\n  'blob'\n);\n\n\"Resource Endpoint with id \"/subscriptions/57faea9a-20c2-4d35-b283-9c0c1e9593d8/resourceGroups/privatelink-test/providers/Microsoft.Network/privateEndpoints/external-network-access-pe\" provisioned successfully\"",
    "arguments": [
        {
            "name": "'",
            "description": "Specifies the external service or resource to connect to. For example, com.amazonaws.us-west-2.execute-api for the Amazon API\nGateway or com.amazonaws.us-west-2.s3 for Amazon S3. For information about retrieving this value from AWS, see Provision private connectivity endpoints ."
        },
        {
            "name": "'",
            "description": "Specifies the fully-qualified hostname to access the resource in your VPC or VNet. This value does not contain any port numbers and must match what you specified in the Snowflake object that enables you to connect to the\nexternal service. AWS: Examples include bedrock-runtime.us-west-2.amazonaws.com and *.s3.us-west-2.amazonaws.com . When using private connectivity for external stages and external volumes, the host_name must use a wildcard instead of\nspecifying a specific AWS S3 bucket. For information about retrieving this value from AWS, see Provision private connectivity endpoints . Azure: For Microsoft Azure API Management, the value must match the API_ALLOWED_PREFIXES property of the API integration. Do not include https:// . For examples of the hostname for outbound private connectivity for external functions, see the following: Azure Portal Azure ARM template ."
        },
        {
            "name": "'",
            "description": "Specifies the fully-qualified identifier for the resource in your VPC or VNet."
        },
        {
            "name": "'",
            "description": "Specifies the name of the subresource of the Azure resource. This argument is not required for Azure Private Link Service and Azure API Management Service. For all supported values, see the Sub-resource table ."
        }
    ],
    "returns": "Returns a status message that the endpoint was provisioned successfully or details and instructions about why the endpoint was not\nprovisioned successfully."
},
{
    "function_name": "SYSTEM$PIPE_STATUS",
    "summary": "Retrieves a JSON representation of the current status of a pipe.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_pipe_status",
    "title": "SYSTEM$PIPE_STATUS",
    "description": "Retrieves a JSON representation of the current status of a pipe.",
    "syntax": "SYSTEM$PIPE_STATUS( '<pipe_name>' )",
    "example": "SELECT SYSTEM$PIPE_STATUS('mydb.myschema.mypipe');\n\n+---------------------------------------------------+\n| SYSTEM$PIPE_STATUS('MYDB.MYSCHEMA.MYPIPE')        |\n|---------------------------------------------------|\n| {\"executionState\":\"RUNNING\",\"pendingFileCount\":0} |\n+---------------------------------------------------+\n\nSELECT SYSTEM$PIPE_STATUS('mydb.myschema.\"myPipe\"');\n\n+---------------------------------------------------+\n| SYSTEM$PIPE_STATUS('MYDB.MYSCHEMA.\"MYPIPE\"')      |\n|---------------------------------------------------|\n| {\"executionState\":\"RUNNING\",\"pendingFileCount\":0} |\n+---------------------------------------------------+",
    "arguments": [
        {
            "name": "pipe_name",
            "description": "Pipe for which you want to retrieve the current status."
        }
    ]
},
{
    "function_name": "SYSTEM$PIPE_REBINDING_WITH_NOTIFICATION_CHANNEL",
    "summary": "Retries the notification channel binding process when a replicated pipe has not been successfully bound to a notification channel during replication time.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_pipe_rebinding_with_notification_channel",
    "title": "SYSTEM$PIPE_REBINDING_WITH_NOTIFICATION_CHANNEL",
    "description": "Retries the notification channel binding process when a replicated pipe has not been successfully bound to a notification channel during replication time. Binding can be unsuccessful for one of the following reasons:",
    "syntax": "SYSTEM$PIPE_REBINDING_WITH_NOTIFICATION( '<pipe_name>')",
    "example": "SELECT SYSTEM$PIPE_REBINDING_WITH_NOTIFICATION_CHANNEL('mydb.myschema.mypipe');",
    "arguments": [
        {
            "name": "'",
            "description": "The name of the pipe that needs to go through the rebind notification process."
        }
    ]
},
{
    "function_name": "SYSTEM$PIPE_FORCE_RESUME",
    "summary": "Forces a pipe paused using ALTER PIPE to resume.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_pipe_force_resume",
    "title": "SYSTEM$PIPE_FORCE_RESUME",
    "description": "Forces a pipe paused using",
    "syntax": "SYSTEM$PIPE_FORCE_RESUME( '<pipe_name>' , '[ STALENESS_CHECK_OVERRIDE ] [ , OWNERSHIP_TRANSFER_CHECK_OVERRIDE ]')",
    "example": "SELECT SYSTEM$PIPE_FORCE_RESUME('mydb.myschema.mypipe');\n\nSELECT SYSTEM$PIPE_FORCE_RESUME('mydb.myschema.\"myPipe\"');\n\nSELECT SYSTEM$PIPE_FORCE_RESUME('mydb.myschema.stalepipe','staleness_check_override, ownership_transfer_check_override');",
    "arguments": [
        {
            "name": "pipe_name",
            "description": "Pipe to resume running."
        },
        {
            "name": "STALENESS_CHECK_OVERRIDE",
            "description": "Specifies to resume a stale pipe. A pipe is considered stale when it is paused for longer than the limited retention period for event\nmessages received for the pipe (14 days by default). Note This argument only pertains to pipe objects that leverage cloud messaging to trigger data loads."
        },
        {
            "name": "OWNERSHIP_TRANSFER_CHECK_OVERRIDE",
            "description": "Specifies to resume a pipe after ownership of the pipe was transferred to another role. Note To ensure backward compatibility, passing pipe_name as the only input is syntactically equivalent to passing both pipe_name and OWNERSHIP_TRANSFER_CHECK_OVERRIDE ."
        }
    ]
},
{
    "function_name": "SYSTEM$MIGRATE_SAML_IDP_REGISTRATION",
    "summary": "Migrates an existing SAML identity provider (i.e. IdP) configuration as defined by the account parameter SAML_IDENTITY_PROVIDER to a security integration.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_migrate_saml_idp_registration",
    "title": "SYSTEM$MIGRATE_SAML_IDP_REGISTRATION",
    "description": "Migrates an existing SAML identity provider (i.e. IdP) configuration as defined by the account parameter",
    "syntax": "SYSTEM$MIGRATE_SAML_IDP_REGISTRATION( '<integration_name>', '<issuer>' )",
    "example": "SELECT SYSTEM$MIGRATE_SAML_IDP_REGISTRATION('my_fed_integration', 'http://my_idp.com');\n\n+---------------------------------------------------------------------------------+\n| SYSTEM$MIGRATE_SAML_IDP_REGISTRATION('MY_FED_INTEGRATION', 'HTTP://MY_IDP.COM') |\n+---------------------------------------------------------------------------------+\n| SUCCESS : [MY_FED_INTEGRATION] Fed SAML integration created                     |\n+---------------------------------------------------------------------------------+\n\nDESC INTEGRATION my_fed_integration;",
    "arguments": [
        {
            "name": "integration_name",
            "description": "Name of the new SAML2 security integration that will be created by the function. Note that the entire name must be enclosed in single quotes. Required."
        },
        {
            "name": "issuer",
            "description": "The EntityID / Issuer of the IdP. The entire name must be enclosed in single quotes. Required if not specified in the SAML_IDENTITY_PROVIDER parameter as the Issuer attribute. Important If the SAML_IDENTITY_PROVIDER parameter does not contain a value for Issuer , use your IdP’s metadata to locate the exact\nvalue. Depending on the IdP, you might be able to locate the issuer value through the user interface administrator settings,\na URL your IdP provides, or by downloading the SAML federation metadata XML to a local file. As a representative example, the following references detail how to locate the issuer value for Okta and Microsoft Entra ID: Okta SAML Settings Microsoft Entra ID integration with Snowflake"
        }
    ]
},
{
    "function_name": "SYSTEM$LOG, SYSTEM$LOG_<level> (for Snowflake Scripting)",
    "summary": "Logs a message at the specified severity level.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_log",
    "title": "SYSTEM$LOG, SYSTEM$LOG_<level> (for Snowflake Scripting)",
    "description": "Logs a message at the specified severity level.",
    "syntax": "SYSTEM$LOG('<level>', <message>);\n\nSYSTEM$LOG_TRACE(<message>);\nSYSTEM$LOG_DEBUG(<message>);\nSYSTEM$LOG_INFO(<message>);\nSYSTEM$LOG_WARN(<message>);\nSYSTEM$LOG_ERROR(<message>);\nSYSTEM$LOG_FATAL(<message>);",
    "example": "-- The following calls are equivalent.\n-- Both log information-level messages.\nSYSTEM$LOG('info', 'Information-level message');\nSYSTEM$LOG_INFO('Information-level message');\n\n-- The following calls are equivalent.\n-- Both log error messages.\nSYSTEM$LOG('error', 'Error message');\nSYSTEM$LOG_ERROR('Error message');\n\n\n-- The following calls are equivalent.\n-- Both log warning messages.\nSYSTEM$LOG('warning', 'Warning message');\nSYSTEM$LOG_WARN('Warning message');\n\n-- The following calls are equivalent.\n-- Both log debug messages.\nSYSTEM$LOG('debug', 'Debug message');\nSYSTEM$LOG_DEBUG('Debug message');\n\n-- The following calls are equivalent.\n-- Both log trace messages.\nSYSTEM$LOG('trace', 'Trace message');\nSYSTEM$LOG_TRACE('Trace message');\n\n-- The following calls are equivalent.\n-- Both log fatal messages.\nSYSTEM$LOG('fatal', 'Fatal message');\nSYSTEM$LOG_FATAL('Fatal message');",
    "arguments": [
        {
            "name": "'",
            "description": "The severity level at which to log the message. You can specify one of the following strings: ‘trace’ ‘debug’ ‘info’ ‘warn’ ‘error’ ‘fatal’"
        },
        {
            "name": "message",
            "description": "An expression that resolves to the message to log. If the message is not a string, the function converts the message to a string."
        }
    ]
},
{
    "function_name": "SYSTEM$LIST_NAMESPACES_FROM_CATALOG",
    "summary": "Lists the namespaces in a remote",
    "category": "iceberg-tm",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_list_namespaces_from_catalog",
    "title": "SYSTEM$LIST_NAMESPACES_FROM_CATALOG",
    "description": "Lists the namespaces in a remote Apache Iceberg™ REST catalog (including",
    "syntax": "SYSTEM$LIST_NAMESPACES_FROM_CATALOG( '<catalog_integration_name>'\n  [ , '<parent_namespace>', <levels> ] )",
    "example": "SELECT SYSTEM$LIST_NAMESPACES_FROM_CATALOG('my_catalog_integration');\n\nSELECT SYSTEM$LIST_NAMESPACES_FROM_CATALOG('my_catalog_integration', '', 0);\n\nSELECT SYSTEM$LIST_NAMESPACES_FROM_CATALOG('my_catalog_integration', 'db1');\n\nSELECT SYSTEM$LIST_NAMESPACES_FROM_CATALOG('my_catalog_integration', 'db1', 3);",
    "arguments": [
        {
            "name": "catalog_integration_name",
            "description": "Identifier for the catalog integration for Iceberg REST or Snowflake Open Catalog ."
        },
        {
            "name": "parent_namespace",
            "description": "The identifier of the namespace from which to start listing namespaces. If CATALOG_NAMESPACE is defined at the catalog integration level, to retrieve results for the 0th namespace level in the\ncatalog, specify an empty string ( '' ). If CATALOG_NAMESPACE is only defined at the table level, the results for the 0th namespace level are returned by default, so\nyou don’t need to specify an empty string ( '' ). Default: If CATALOG_NAMESPACE is defined at the catalog integration level, the namespace for the catalog integration. If CATALOG_NAMESPACE is only defined at the table level, you retrieve results for the 0th namespace level in the catalog."
        },
        {
            "name": "levels",
            "description": "Specifies the number of levels to traverse in the namespace hierarchy for listing child namespaces. For example: If set to 0, the function returns all of the namespaces, recursively, relative to the parent_namespace . If set to 1, the function returns all of the namespaces one level under the parent_namespace . If set to n , the function returns namespaces up to n levels deep, relative to the parent_namespace . Default: 1"
        }
    ],
    "returns": "Returns a JSON-formatted string which lists namespaces in the Iceberg REST catalog for the specified\nparent namespace and number of levels."
},
{
    "function_name": "SYSTEM$LIST_ICEBERG_TABLES_FROM_CATALOG",
    "summary": "Lists tables in a remote",
    "category": "iceberg-tm",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_list_iceberg_tables_from_catalog",
    "title": "SYSTEM$LIST_ICEBERG_TABLES_FROM_CATALOG",
    "description": "Lists tables in a remote Apache Iceberg™ REST catalog (including",
    "syntax": "SYSTEM$LIST_ICEBERG_TABLES_FROM_CATALOG( '<catalog_integration_name>'\n  [ , '<parent_namespace>', <levels> ] )",
    "example": "SELECT SYSTEM$LIST_ICEBERG_TABLES_FROM_CATALOG('myCatalogIntegration');\n\nSELECT SYSTEM$LIST_ICEBERG_TABLES_FROM_CATALOG('myCatalogIntegration', '', 0);\n\nSELECT SYSTEM$LIST_ICEBERG_TABLES_FROM_CATALOG('myCatalogIntegration', 'db1', 0);\n\nSELECT SYSTEM$LIST_ICEBERG_TABLES_FROM_CATALOG('myCatalogIntegration', 'db1', 3);",
    "arguments": [
        {
            "name": "catalog_integration_name",
            "description": "Identifier for the catalog integration for Iceberg REST or Snowflake Open Catalog ."
        },
        {
            "name": "parent_namespace",
            "description": "The identifier of the namespace from which to start listing tables. To retrieve\nresults for the 0th namespace level in the catalog, specify an empty string ( '' ). Default: The default namespace for the catalog integration ( CATALOG_NAMESPACE ), if specified.  If you don’t specify a default\nnamespace at the catalog integration level, the default is the 0th namespace level in the catalog. To list tables when the default is the\n0th namespace, you must specify an empty string ( CATALOG_NAMESPACE ) and the <levels> parameter."
        },
        {
            "name": "levels",
            "description": "Specifies the number of levels to traverse in the namespace hierarchy for listing tables. For example: If set to 0, the function returns all of the tables recursively, relative to the parent_namespace . If set to 1, the function returns all of the tables within the parent_namespace . If set to n , the function returns tables up to n levels deep, relative to the parent_namespace . Default: 1"
        }
    ],
    "returns": "Returns a JSON-formatted string which lists tables in the Iceberg REST catalog for the specified\nnamespace and number of levels."
},
{
    "function_name": "SYSTEM$LIST_APPLICATION_RESTRICTED_FEATURES",
    "summary": "Returns a JSON object containing a list of restricted features that the consumer has allowed a",
    "category": "native-app",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_list_application_restricted_features",
    "title": "SYSTEM$LIST_APPLICATION_RESTRICTED_FEATURES",
    "description": "Returns a JSON object containing a list of restricted features that the consumer has\nallowed a Snowflake Native App to use.",
    "syntax": "SYSTEM$LIST_APPLICATION_RESTRICTED_FEATURES( '<app_name>' )",
    "example": "SELECT SYSTEM$LIST_APPLICATION_RESTRICTED_FEATURES('hello_snowflake_app');\n\n[\n    {\"external_data\":{\"allowed_cloud_providers\":\"all\"}}\n]",
    "arguments": [
        {
            "name": "app_name",
            "description": "Name of the Snowflake Native App. Note This argument is ignored when the system function is called by the app."
        }
    ],
    "returns": "Returns a JSON-formatted string which lists all restricted feature settings allowed for the app.\nThe JSON-formatted string has the following structure:"
},
{
    "function_name": "SYSTEM$LINK_ORGANIZATION_USER_GROUP",
    "summary": "Links an organization user group with an access control role that already exists in the regular account.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_link_organization_user_group",
    "title": "SYSTEM$LINK_ORGANIZATION_USER_GROUP",
    "syntax": "SYSTEM$LINK_ORGANIZATION_USER_GROUP( <name> )",
    "example": "SELECT SYSTEM$LINK_ORGANIZATION_USER_GROUP('marketing_team');",
    "arguments": [
        {
            "name": "name",
            "description": "Name of an organization user group. This matches the name of an existing access control role."
        }
    ]
},
{
    "function_name": "SYSTEM$LINK_ORGANIZATION_USER",
    "summary": "Links an organization user with a user that already exists in the regular account.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_link_organization_user",
    "title": "SYSTEM$LINK_ORGANIZATION_USER",
    "syntax": "SYSTEM$LINK_ORGANIZATION_USER( '<local_user>', '<org_user>' )",
    "arguments": [
        {
            "name": "'",
            "description": "Name of a user object that exists in the regular account."
        },
        {
            "name": "'",
            "description": "Name of the organization user that corresponds to the same person as local_user ."
        }
    ]
},
{
    "function_name": "SYSTEM$LINK_ACCOUNT_OBJECTS_BY_NAME",
    "summary": "Adds a global identifier to account objects in the target (current) account that were created using scripts and that match objects with the same names in the source account.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_link_account_objects_by_name",
    "title": "SYSTEM$LINK_ACCOUNT_OBJECTS_BY_NAME",
    "syntax": "SYSTEM$LINK_ACCOUNT_OBJECTS_BY_NAME('<group_name>')",
    "example": "SELECT SYSTEM$LINK_ACCOUNT_OBJECTS_BY_NAME('myfg');",
    "arguments": [
        {
            "name": "group_name",
            "description": "Specifies the identifier for the replication or failover group."
        }
    ]
},
{
    "function_name": "SYSTEM$LAST_CHANGE_COMMIT_TIME",
    "summary": "Returns a token that can be used to detect whether a database table or view changed between two calls to the function.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_last_change_commit_time",
    "title": "SYSTEM$LAST_CHANGE_COMMIT_TIME",
    "description": "Returns a token that can be used to detect whether a database table or view changed between two calls to the function.\nIf the token returned by a call is different from the token returned by a separate call, then the table or view\nchanged between the two calls, typically due to a DML operation (e.g. an INSERT).",
    "syntax": "SYSTEM$LAST_CHANGE_COMMIT_TIME( '<object_name>'  )",
    "example": "CALL SYSTEM$LAST_CHANGE_COMMIT_TIME('mytable');\n\n+--------------------------------+\n| SYSTEM$LAST_CHANGE_COMMIT_TIME |\n|--------------------------------|\n|            1661920053987000000 |\n+--------------------------------+\n\nSELECT SYSTEM$LAST_CHANGE_COMMIT_TIME('mytable');\n\n+--------------------------------+\n| SYSTEM$LAST_CHANGE_COMMIT_TIME |\n|--------------------------------|\n|            1661920118648000000 |\n+--------------------------------+\n\nINSERT INTO mytable VALUES (2,100), (3,300);\n\nSELECT SYSTEM$LAST_CHANGE_COMMIT_TIME('mytable');\n\n+--------------------------------+\n| SYSTEM$LAST_CHANGE_COMMIT_TIME |\n|--------------------------------|\n|            1661920131893000000 |\n+--------------------------------+",
    "arguments": [
        {
            "name": "object_name",
            "description": "Specifies the table or view."
        }
    ],
    "returns": "The data type of the returned value is NUMBER with a scale of 0."
},
{
    "function_name": "SYSTEM$IS_LISTING_TRIAL",
    "summary": "Limits the functionality of a",
    "category": "native-app",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_is_listing_trial",
    "title": "SYSTEM$IS_LISTING_TRIAL",
    "syntax": "SYSTEM$IS_LISTING_TRIAL()",
    "example": "CREATE SECURE VIEW limited_functionality_view\n  AS\n  SELECT\n    *\n  FROM\n    exclusive_access_table\n  WHERE\n    is_trial\n    OR\n    SYSTEM$IS_LISTING_TRIAL() = TRUE;",
    "returns": "The function returns a value of type BOOLEAN."
},
{
    "function_name": "SYSTEM$IS_LISTING_PURCHASED",
    "summary": "Returns TRUE if the consumer account querying data has purchased the listing, otherwise returns FALSE.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_is_listing_purchased",
    "title": "SYSTEM$IS_LISTING_PURCHASED",
    "description": "Returns TRUE if the consumer account querying data has purchased the listing, otherwise returns FALSE. If an account is trialing the listing,\nthe function returns FALSE. Use this system function in a secure view to manage access to the data in a share and display certain data only\nto paying customers.",
    "syntax": "SYSTEM$IS_LISTING_PURCHASED()",
    "returns": "The function returns a value of type BOOLEAN."
},
{
    "function_name": "SYSTEM$IS_GLOBAL_DATA_SHARING_ENABLED_FOR_ACCOUNT",
    "summary": "Specifies whether Cross-Cloud Auto-Fulfillment is enabled or disabled on an account.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_is_global_data_sharing_enabled_for_account",
    "title": "SYSTEM$IS_GLOBAL_DATA_SHARING_ENABLED_FOR_ACCOUNT",
    "description": "Specifies whether Cross-Cloud Auto-Fulfillment is enabled or disabled on an account.",
    "syntax": "SYSTEM$IS_GLOBAL_DATA_SHARING_ENABLED_FOR_ACCOUNT( '<account_name>' )",
    "example": "SELECT SYSTEM$IS_GLOBAL_DATA_SHARING_ENABLED_FOR_ACCOUNT('my_account');\n\n+------------------------------------------------------------------------+\n| SYSTEM$SYSTEM$IS_GLOBAL_DATA_SHARING_ENABLED_FOR_ACCOUNT('my_account') |\n|------------------------------------------------------------------------|\n| TRUE                                                                   |\n+------------------------------------------------------------------------+",
    "arguments": [
        {
            "name": "account_name",
            "description": "Specifies the account on which you want to determine if Cross-Cloud Auto-Fulfillment is enabled or disabled. To learn more about Snowflake account identifiers and how to locate them, see Account identifiers ."
        }
    ],
    "returns": "Returns one of the following Boolean values:"
},
{
    "function_name": "SYSTEM$IS_APPLICATION_SHARING_EVENTS_WITH_PROVIDER",
    "summary": "Shows if event sharing is enabled.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_is_application_sharing_events_with_provider",
    "title": "SYSTEM$IS_APPLICATION_SHARING_EVENTS_WITH_PROVIDER",
    "description": "Shows if event sharing is enabled.",
    "syntax": "SYSTEM$IS_APPLICATION_SHARING_EVENTS_WITH_PROVIDER()",
    "example": "SELECT SYSTEM$IS_APPLICATION_SHARING_EVENTS_WITH_PROVIDER();",
    "returns": "This function returns the following status messages:"
},
{
    "function_name": "SYSTEM$IS_APPLICATION_INSTALLED_FROM_SAME_ACCOUNT",
    "summary": "Shows if an app is installed on the same account as the application package it is based on.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_is_application_installed_from_same_account",
    "title": "SYSTEM$IS_APPLICATION_INSTALLED_FROM_SAME_ACCOUNT",
    "description": "Shows if an app is installed on the same account as the application package it is based on.",
    "syntax": "SYSTEM$IS_APPLICATION_INSTALLED_FROM_SAME_ACCOUNT()",
    "example": "SELECT SYSTEM$IS_APPLICATION_INSTALLED_FROM_SAME_ACCOUNT();",
    "returns": "This function returns the following status messages:"
},
{
    "function_name": "SYSTEM$IS_APPLICATION_AUTHORIZED_FOR_TELEMETRY_EVENT_SHARING",
    "summary": "Indicates that the AUTHORIZE_TELEMETRY_EVENT_SHARING has been set on the app.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_is_application_authorized_for_telemetry_event_sharing",
    "title": "SYSTEM$IS_APPLICATION_AUTHORIZED_FOR_TELEMETRY_EVENT_SHARING",
    "description": "Indicates that the AUTHORIZE_TELEMETRY_EVENT_SHARING has been set on the app.",
    "syntax": "SYSTEM$IS_APPLICATION_AUTHORIZED_FOR_TELEMETRY_EVENT_SHARING()",
    "returns": "Returns TRUE if the AUTHORIZE_TELEMETRY_EVENT_SHARING property is\nset on the app. This indicates that event sharing is allowed in the\nconsumer account. Otherwise, returns FALSE."
},
{
    "function_name": "SYSTEM$IS_APPLICATION_ALL_MANDATORY_TELEMETRY_EVENT_DEFINITIONS_ENABLED",
    "summary": "Indicates that the AUTHORIZE_TELEMETRY_EVENT_SHARING property has been set on the app.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_is_application_all_mandatory_telemetry_event_definitions_enabled",
    "title": "SYSTEM$IS_APPLICATION_ALL_MANDATORY_TELEMETRY_EVENT_DEFINITIONS_ENABLED",
    "description": "Indicates that the AUTHORIZE_TELEMETRY_EVENT_SHARING property has been set on the app.",
    "syntax": "SYSTEM$IS_APPLICATION_ALL_MANDATORY_TELEMETRY_EVENT_DEFINITIONS_ENABLED",
    "returns": "Returns TRUE if the AUTHORIZE_TELEMETRY_EVENT_SHARING property is set\non the app. This indicates that event sharing is allowed in the consumer account.\nOtherwise, returns FALSE."
},
{
    "function_name": "SYSTEM$INTERNAL_STAGES_PUBLIC_ACCESS_STATUS",
    "summary": "Checks to see whether public IP addresses are allowed to access the internal stage of the current Snowflake account on Microsoft Azure.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_internal_stages_public_access_status",
    "title": "SYSTEM$INTERNAL_STAGES_PUBLIC_ACCESS_STATUS",
    "syntax": "SYSTEM$INTERNAL_STAGES_PUBLIC_ACCESS_STATUS()",
    "example": "USE ROLE accountadmin;\n\nSELECT SYSTEM$INTERNAL_STAGES_PUBLIC_ACCESS_STATUS();\n\nPublic Access to internal stages is blocked",
    "returns": "This function returns the following status messages:"
},
{
    "function_name": "SYSTEM$INITIATE_MOVE_ORGANIZATION_ACCOUNT",
    "summary": "Starts the process of moving an organization account to a new region.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_initiate_move_organization_account",
    "title": "SYSTEM$INITIATE_MOVE_ORGANIZATION_ACCOUNT",
    "syntax": "SYSTEM$INITIATE_MOVE_ORGANIZATION_ACCOUNT(\n    '<temp_name>' ,\n    '<region>' ,\n    { 'ALL' | '<object> [, <object> ...]' } )",
    "example": "SELECT SYSTEM$INITIATE_MOVE_ORGANIZATION_ACCOUNT('TEMP_ACCT', 'aws_us_west_2', 'ALL');",
    "arguments": [
        {
            "name": "'",
            "description": "Specifies a temporary account name by which the organization account in the new region can be identified until the move is finalized. The\nname must start with a letter and can only contain uppercase letters, numbers, and underscores. The name of the organization account in the new region changes from this temporary account name to the name of the original organization\naccount when the SYSTEM$COMMIT_MOVE_ORGANIZATION_ACCOUNT function finishes successfully."
        },
        {
            "name": "'",
            "description": "Snowflake Region ID of the region where the organization account will be moved."
        },
        {
            "name": "{",
            "description": "List of objects that will be moved to the organization account in its new region. Because Snowflake uses replication groups to move the\nobjects, you can only move objects that are supported by replication groups, which varies depending on your Snowflake edition. For a list\nof objects that can be moved, see Replicated objects . To move all objects that can be replicated, specify ALL ."
        }
    ]
},
{
    "function_name": "SYSTEM$HOLD_PRIVILEGE_ON_ACCOUNT",
    "summary": "Indicates if a privilege has been granted to a",
    "category": "native-app",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_hold_privilege_on_account",
    "title": "SYSTEM$HOLD_PRIVILEGE_ON_ACCOUNT",
    "description": "Indicates if a privilege has been granted to a Snowflake Native App. For example, providers\ncan use this function in the setup script to check if the app has the necessary\nprivileges to create an object.",
    "syntax": "SYSTEM$HOLD_PRIVILEGE_ON_ACCOUNT('<privilege_name>')",
    "example": "SELECT SYSTEM$HOLD_PRIVILEGE_ON_ACCOUNT('CREATE COMPUTE POOL');\n\nSELECT SYSTEM$HOLD_PRIVILEGE_ON_ACCOUNT('IMPORTED PRIVILEGES ON SNOWFLAKE DB');",
    "arguments": [
        {
            "name": "'",
            "description": "The name of the privilege."
        }
    ],
    "returns": "Returns TRUE if the app has been granted the specified privilege. Otherwise,\nreturns FALSE."
},
{
    "function_name": "SYSTEM$GLOBAL_ACCOUNT_SET_PARAMETER",
    "summary": "Enables replication and failover features for a specified account in an organization.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_global_account_set_parameter",
    "title": "SYSTEM$GLOBAL_ACCOUNT_SET_PARAMETER",
    "description": "Enables replication and failover features for a specified account in an",
    "syntax": "SELECT SYSTEM$GLOBAL_ACCOUNT_SET_PARAMETER('<account_identifier>',\n  'ENABLE_ACCOUNT_DATABASE_REPLICATION', 'true');",
    "example": "SELECT SYSTEM$GLOBAL_ACCOUNT_SET_PARAMETER('myorg.account1',\n  'ENABLE_ACCOUNT_DATABASE_REPLICATION', 'true');\n\nSELECT SYSTEM$GLOBAL_ACCOUNT_SET_PARAMETER('myorg.account2',\n  'ENABLE_ACCOUNT_DATABASE_REPLICATION', 'true');",
    "arguments": [
        {
            "name": "<account_identifier>",
            "description": "Identifier of an account for which you are enabling replication. The preferred format for the identifier is organization_name . account_name . Though the legacy account_locator format is also supported, its use is discouraged as it\ncan cause unexpected results when an organization has multiple accounts with the same locator (in different regions). Retrieve the set of accounts in your organization using the SHOW ACCOUNTS command, which returns\ndetails about each account, including the organization name, account name, and account locator."
        }
    ]
},
{
    "function_name": "SYSTEM$GET_TASK_GRAPH_CONFIG",
    "summary": "Returns the value of the configuration string for the task currently executing when invoked from the statement or stored procedure defined by the task.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_get_task_graph_config",
    "title": "SYSTEM$GET_TASK_GRAPH_CONFIG",
    "description": "Returns the value of the configuration string for the task currently executing when invoked from the\nstatement or stored procedure defined by the task.",
    "syntax": "SYSTEM$GET_TASK_GRAPH_CONFIG([configuration_path])",
    "example": "-- Create a task which defines and then uses configuration\nCREATE OR REPLACE TASK root_task_with_config\nWAREHOUSE=mywarehouse\nSCHEDULE='10 m'\nCONFIG=$${\"output_dir\": \"/temp/test_directory/\", \"learning_rate\": 0.1}$$\nAS\nBEGIN\n  LET OUTPUT_DIR STRING := SYSTEM$GET_TASK_GRAPH_CONFIG('output_dir')::string;\n  LET LEARNING_RATE DECIMAL := SYSTEM$GET_TASK_GRAPH_CONFIG('learning_rate')::DECIMAL;\n      ...\nEND;",
    "arguments": [
        {
            "name": "configuration_path",
            "description": "Path to the configuration value to return. Optional argument specifying the path of the value to be retrieved.\nUses the same syntax as Snowflake queries for semi-structured data.\nRefer to GET_PATH for more information."
        }
    ]
},
{
    "function_name": "SYSTEM$GET_TAG_ON_CURRENT_TABLE",
    "summary": "Returns the tag string value assigned to the table based upon the specified tag or NULL if a tag is not assigned to the specified table.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_get_tag_on_current_table",
    "title": "SYSTEM$GET_TAG_ON_CURRENT_TABLE",
    "description": "Returns the tag string value assigned to the table based upon the specified tag or NULL if a tag is not assigned to the specified table.",
    "syntax": "SYSTEM$GET_TAG_ON_CURRENT_TABLE( '<tag_name>' )",
    "arguments": [
        {
            "name": "'",
            "description": "Identifier for the tag as a string. For example, if the tag is named cost_center use 'cost_center' as the argument."
        }
    ]
},
{
    "function_name": "SYSTEM$GET_TAG_ON_CURRENT_COLUMN",
    "summary": "Returns the tag string value assigned to the column based upon the specified tag or NULL if a tag is not assigned to the specified column.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_get_tag_on_current_column",
    "title": "SYSTEM$GET_TAG_ON_CURRENT_COLUMN",
    "description": "Returns the tag string value assigned to the column based upon the specified tag or NULL if a tag is not assigned to the specified column.",
    "syntax": "SYSTEM$GET_TAG_ON_CURRENT_COLUMN( '<tag_name>' )",
    "example": "CREATE PROJECTION POLICY mypolicy\nAS () RETURNS PROJECTION_CONSTRAINT ->\nCASE\n  WHEN SYSTEM$GET_TAG_ON_CURRENT_COLUMN('tags.accounting_col') = 'public'\n    THEN PROJECTION_CONSTRAINT(ALLOW => true)\n  ELSE PROJECTION_CONSTRAINT(ALLOW => false)\nEND;",
    "arguments": [
        {
            "name": "'",
            "description": "Identifier for the tag as a string. For example, if the tag is named cost_center use 'cost_center' as the argument."
        }
    ]
},
{
    "function_name": "SYSTEM$GET_TAG_ALLOWED_VALUES",
    "summary": "Returns a comma-separated list of string values that can be set on a supported object, or NULL to indicate the tag key does not have any specified string values and accepts all possible string values.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_get_tag_allowed_values",
    "title": "SYSTEM$GET_TAG_ALLOWED_VALUES",
    "description": "Returns a comma-separated list of string values that can be set on a",
    "syntax": "SYSTEM$GET_TAG_ALLOWED_VALUES('<name>')",
    "example": "select system$get_tag_allowed_values('governance.tags.cost_center');",
    "arguments": [
        {
            "name": "name",
            "description": "The fully-qualified name of the tag key as a string."
        }
    ]
},
{
    "function_name": "SYSTEM$GET_TAG",
    "summary": "Returns the tag value associated with the specified Snowflake object or column.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_get_tag",
    "title": "SYSTEM$GET_TAG",
    "description": "Returns the tag value associated with the specified Snowflake object or column. Returns NULL if a tag is not set on the specified\nSnowflake object or column.",
    "syntax": "SYSTEM$GET_TAG( '<tag_name>' , '<obj_name>' , '<obj_domain>' )",
    "example": "select system$get_tag('cost_center', 'my_table', 'table');\n\n+-----------------------------------------------------+\n| SYSTEM$GET_TAG('COST_CENTER', 'MY_TABLE', 'TABLE')  |\n+-----------------------------------------------------+\n| NULL                                                |\n+-----------------------------------------------------+\n\nselect system$get_tag('cost_center', 'my_table', 'table');\n\n-----------------------------------------------------+\n| SYSTEM$GET_TAG('COST_CENTER', 'MY_TABLE', 'TABLE') |\n+----------------------------------------------------+\n| sales                                              |\n+----------------------------------------------------+\n\nselect system$get_tag('fiscal_quarter', 'my_table.revenue', 'column');\n\n+----------------------------------------------------------------+\n| SYSTEM$GET_TAG('FISCAL_QUARTER', 'MY_TABLE.REVENUE', 'COLUMN') |\n+----------------------------------------------------------------+\n| Q1                                                             |\n+----------------------------------------------------------------+",
    "arguments": [
        {
            "name": "'",
            "description": "The name of the tag as a string. The name is the key in the key-value pair of the tag. For example, in the tag cost_center = 'sales' , cost_center is the\nkey-name of the tag. For this argument, use 'cost_center' ."
        },
        {
            "name": "'",
            "description": "The name of the object as a string. For example, if a table name is my_table , use 'my_table' as the name of the object. To specify a column, use the format <table_name>.<column_name> . For example, my_table.revenue . For more information, see Object identifiers ."
        },
        {
            "name": "'",
            "description": "Domain of the reference object, such as a table or view, if the tag association is on the object. For columns, the domain is COLUMN if the tag association is on a column. Use one of the following values: 'ACCOUNT' 'ALERT' 'COLUMN' 'COMPUTE POOL' 'DATABASE' 'DATABASE ROLE' 'FAILOVER GROUP' 'FUNCTION' 'INTEGRATION' 'INSTANCE' 'NETWORK POLICY' 'PROCEDURE' 'REPLICATION GROUP' 'ROLE' 'SCHEMA' 'SHARE' 'STAGE' 'STREAM' 'TABLE' : Use this for all table-like objects such as views, materialized views, and external tables. 'TASK' 'USER' 'WAREHOUSE'"
        }
    ]
},
{
    "function_name": "SYSTEM$GET_SNOWFLAKE_PLATFORM_INFO",
    "summary": "Returns platform information for the cloud provider that hosts your Snowflake account.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_get_snowflake_platform_info",
    "title": "SYSTEM$GET_SNOWFLAKE_PLATFORM_INFO",
    "description": "Returns platform information for the cloud provider that hosts your Snowflake account.\nThe function returns different values, depending on your cloud provider:",
    "syntax": "SYSTEM$GET_SNOWFLAKE_PLATFORM_INFO()",
    "example": "SELECT SYSTEM$GET_SNOWFLAKE_PLATFORM_INFO();"
},
{
    "function_name": "SYSTEM$GET_SERVICE_STATUS — Deprecated",
    "summary": "Retrieves the status of a Snowpark Container Services service.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_get_service_status",
    "title": "SYSTEM$GET_SERVICE_STATUS —",
    "syntax": "SYSTEM$GET_SERVICE_STATUS( [ <db_name>.<schema_name>. ]<service_name> [ , <timeout_secs> ]  )",
    "example": "SELECT SYSTEM$GET_SERVICE_STATUS('echo_service', 5);\n\n[\n {\n    \"status\":\"READY\",\n    \"message\":\"Running\",\n    \"containerName\":\"echo\",\n    \"instanceId\":\"0\",\n    \"serviceName\":\"ECHO_SERVICE\",\n    \"image\":\"<account>.registry.snowflakecomputing.com/tutorial_db/data_schema/tutorial_repository/my_echo_service_image:tutorial\",\n    \"restartCount\":0,\n    \"startTime\":\"2023-01-01T00:00:00Z\"\n }\n]\n\n[\n  {\n  \"status\":\"READY\",\n  \"message\":\"Running\",\n  \"containerName\":\"echo-1\",\n  \"instanceId\":\"0\",\n  \"serviceName\":\"ECHO_SERVICE\",\n  \"image\":\"<account>.registry.snowflakecomputing.com/tutorial_db/data_schema/tutorial_repository/my_echo_service_image_x:tutorial\",\n  \"restartCount\":0,\n  \"startTime\":\"2023-01-01T00:00:00Z\"\n  },\n  {\n  \"status\":\"READY\",\n  \"message\":\"Running\",\n  \"containerName\":\"echo-2\",\n  \"instanceId\":\"0\",\n  \"serviceName\":\"ECHO_SERVICE\",\n  \"image\":\"<account>.registry.snowflakecomputing.com/tutorial_db/data_schema/tutorial_repository/my_echo_service_image_y:tutorial\",\n  \"restartCount\":0,\n  \"startTime\":\"2023-01-01T00:00:00Z\"\n  },\n  {\n  \"status\":\"READY\",\n  \"message\":\"Running\",\n  \"containerName\":\"echo-3\",\n  \"instanceId\":\"0\",\n  \"serviceName\":\"ECHO_SERVICE\",\n  \"image\":\"<account>.registry.snowflakecomputing.com/tutorial_db/data_schema/tutorial_repository/my_echo_service_image_z:tutorial\",\n  \"restartCount\":0,\n  \"startTime\":\"2023-01-01T00:00:00Z\"\n  }\n]",
    "arguments": [
        {
            "name": "service_name",
            "description": "Service name. If you omit the db_name and schema_name , the function uses the current database and schema."
        },
        {
            "name": "timeout_secs",
            "description": "Number of seconds to wait for the service to reach a steady state (for example, READY) before returning the status. If the\nservice does not reach a steady state within the specified time, Snowflake returns the current state. If not specified, Snowflake returns the current state immediately. Default: 0 seconds"
        }
    ],
    "returns": "Returns status information in a JSON array with one JSON object for each container in each service instance. The JSON fields are:"
},
{
    "function_name": "SYSTEM$GET_SERVICE_LOGS",
    "summary": "Retrieves local logs from a Snowpark Container Services service container.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_get_service_logs",
    "title": "SYSTEM$GET_SERVICE_LOGS",
    "syntax": "SYSTEM$GET_SERVICE_LOGS( <service_name>, <instance_id>, <container_name>\n   [, <number_of_most_recent_lines> ] [, <retrieve_previous_logs> ])",
    "example": "SELECT SYSTEM$GET_SERVICE_LOGS('TUTORIAL_DB.data_schema.echo_service', 0, 'echo', 10);\n\nSELECT value AS log_line\n  FROM TABLE(\n    SPLIT_TO_TABLE(SYSTEM$GET_SERVICE_LOGS('echo_service', 0, 'echo'), '\\n')\n  )\n\nSELECT value AS log_line\n  FROM TABLE(\n   SPLIT_TO_TABLE(SYSTEM$GET_SERVICE_LOGS('echo_service', '0', 'echo'), '\\n')\n  )\n  WHERE (CONTAINS(log_line, '06/Jun/2023 02:44:'))\n  ORDER BY log_line;\n\n+-----------------------------------------------------------------------------------------------------+\n| LOG_LINE                                                                                            |\n|-----------------------------------------------------------------------------------------------------|\n| 10.16.9.193 - - [06/Jun/2023 02:44:04] \"GET /healthcheck HTTP/1.1\" 200 -                            |\n| 10.16.9.193 - - [06/Jun/2023 02:44:09] \"GET /healthcheck HTTP/1.1\" 200 -                            |\n| 10.16.9.193 - - [06/Jun/2023 02:44:14] \"GET /healthcheck HTTP/1.1\" 200 -                            |\n+-----------------------------------------------------------------------------------------------------+\n\nSELECT SYSTEM$GET_SERVICE_LOGS('TUTORIAL_DB.data_schema.echo_service', 0, 'echo', 10, true);",
    "arguments": [
        {
            "name": "service_name",
            "description": "Service name."
        },
        {
            "name": "instance_id",
            "description": "ID of the service instance, starting with 0."
        },
        {
            "name": "container_name",
            "description": "Container name as specified in the service specification file."
        },
        {
            "name": "number_of_most_recent_lines",
            "description": "Number of trailing log lines to retrieve. Default: Up to 100 KB of the most recent log lines."
        },
        {
            "name": "retrieve_previous_logs",
            "description": "If TRUE, the function retrieves logs from a previously terminated container. You can specify this parameter only if the container has been restarted at least once. Default: false (retrieve logs from the currently running container)."
        }
    ],
    "returns": "Returns a string consisting of newline-separated log entries from the specified service container."
},
{
    "function_name": "SYSTEM$GET_SERVICE_DNS_DOMAIN",
    "summary": "Given a schema name, returns that schema’s DNS namespace hash as a string.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_get_service_dns_domain",
    "title": "SYSTEM$GET_SERVICE_DNS_DOMAIN",
    "syntax": "SYSTEM$GET_SERVICE_DNS_DOMAIN( <schema_name> )",
    "example": "SELECT SYSTEM$GET_SERVICE_DNS_DOMAIN('DATA_SCHEMA');\nSELECT SYSTEM$GET_SERVICE_DNS_DOMAIN('TUTORIAL_DB.DATA_SCHEMA');\n\n+----------------------------------------------+\n| SYSTEM$GET_SERVICE_DNS_DOMAIN('DATA_SCHEMA') |\n|----------------------------------------------|\n| k3m6.svc.spcs.internal                       |\n+----------------------------------------------+",
    "arguments": [
        {
            "name": "schema_name",
            "description": "Schema name. If the schema is not in the current database, specify the fully qualified name of the schema."
        }
    ],
    "returns": "Returns the schema’s DNS namespace hash as a string."
},
{
    "function_name": "SYSTEM$GET_RESULTSET_STATUS",
    "summary": "Returns the status of a RESULTSET in a Snowflake Scripting stored procedure.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_get_resultset_status",
    "title": "SYSTEM$GET_RESULTSET_STATUS",
    "description": "Returns the status of a",
    "syntax": "SYSTEM$GET_RESULTSET_STATUS( <resultset_name> )",
    "example": "EXECUTE IMMEDIATE $$\nDECLARE\n  status2 VARCHAR DEFAULT 'invalid';\nBEGIN\n  LET res RESULTSET := ASYNC (SELECT SYSTEM$WAIT(3));\n  LET status VARCHAR := SYSTEM$GET_RESULTSET_STATUS(res);\n\n  AWAIT res;\n  status2 := SYSTEM$GET_RESULTSET_STATUS(res);\n  RETURN [status, status2];\nEND;\n$$;\n\n+------------------+\n| GET_QUERY_STATUS |\n+------------------+\n| [                |\n|   \"RUNNING\",     |\n|   \"SUCCESS\"      |\n| ]                |\n+------------------+",
    "arguments": [
        {
            "name": "resultset_name",
            "description": "The name of the RESULTSET."
        }
    ],
    "returns": "This function returns the status of the RESULTSET in a value of type VARCHAR.\nThe following status values are possible:"
},
{
    "function_name": "SYSTEM$GET_REFERENCED_OBJECT_ID_HASH",
    "summary": "Returns the hash of the entity ID of the consumer object.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_get_referenced_object_id_hash",
    "title": "SYSTEM$GET_REFERENCED_OBJECT_ID_HASH",
    "description": "Returns the hash of the entity ID of the consumer object. This is the identifier of the entity resolved originally when a reference was created.",
    "syntax": "SYSTEM$GET_REFERENCED_OBJECT_ID_HASH('<reference_name>'[, '<alias>'])",
    "arguments": [
        {
            "name": "'",
            "description": "The name of the reference as specified in the manifest.yml file of the app."
        },
        {
            "name": "'",
            "description": "The system-generated ID of the reference to the object in the consumer account."
        }
    ]
},
{
    "function_name": "SYSTEM$GET_PRIVATELINK_ENDPOINTS_INFO",
    "summary": "Returns the status of all private connectivity endpoints that you provision.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_get_privatelink_endpoints_info",
    "title": "SYSTEM$GET_PRIVATELINK_ENDPOINTS_INFO",
    "syntax": "SYSTEM$GET_PRIVATELINK_ENDPOINTS_INFO()",
    "example": "SELECT SYSTEM$GET_PRIVATELINK_ENDPOINTS_INFO();\n\n[\n  {\n    \"provider_service_name\": \"com.amazonaws.us-west-2.s3\",\n    \"snowflake_endpoint_name\": \"vpce-123456789012abcdea\",\n    \"endpoint_state\": \"CREATED\",\n    \"host\": \"*.s3.us-west-2.amazonaws.com\",\n    \"status\": \"Available\"\n  },\n  ...\n]\n\nSELECT SYSTEM$GET_PRIVATELINK_ENDPOINTS_INFO();\n\n[\n     {\n        \"provider_resource_id\": \"/subscriptions/11111111-2222-3333-4444-5555555555/...\",\n        \"subresource\": \"sqlServer\",\n        \"snowflake_resource_id\": \"/subscriptions/fa57a1f0-b4e6-4847-9c00-95f39520f...\",\n        \"host\": \"testdb.database.windows.net\",\n        \"endpoint_state\": \"CREATED\",\n        \"status\": \"Approved\",\n     }\n  ]",
    "returns": "Returns a JSON object with the following fields:"
},
{
    "function_name": "SYSTEM$GET_PRIVATELINK_ENDPOINT_REGISTRATIONS",
    "summary": "Returns the registered private endpoints that can route your connection to the Snowflake service.",
    "category": "",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_get_privatelink_endpoint_registrations",
    "title": "SYSTEM$GET_PRIVATELINK_ENDPOINT_REGISTRATIONS",
    "syntax": "SYSTEM$GET_PRIVATELINK_ENDPOINT_REGISTRATIONS()",
    "example": "use role accountadmin;\n\nSELECT SYSTEM$GET_PRIVATELINK_ENDPOINT_REGISTRATIONS();\n\n[\n  {\n    \"consumerEndpointId\": \"148896251...\",\n    \"consumerEndpointType\": \"Aws Id\",\n    \"pinnedConsumerEndpointId\": \"vpce-0be92fc5953c0...\",\n    \"providerServiceEndpoint\": \"vpce-svc-0dcda6d2e9d14...\"\n  }\n]\n\nuse role accountadmin;\n\nSELECT SYSTEM$GET_PRIVATELINK_ENDPOINT_REGISTRATIONS();\n\n[\n  {\n    \"consumerEndpointId\": \"/subscriptions/a92a429f-83ba-4249.../..../snowflake-private-link\",\n    \"consumerEndpointType\": \"Azure Endpoint Connection Id\",\n    \"pinnedConsumerEndpointId\": \"184549...\",\n    \"providerServiceEndpoint\": \"sf-pvlinksvc-azcanadacentral.70f...\"\n  }\n]",
    "returns": "Returns a list of JSON objects, with each JSON object specifying a registered private connectivity endpoint. A string containing an\nempty JASON array (\"[]\") is returned if the account doesn’t have any registered private connectivity endpoints to the Snowflake Service."
},
{
    "function_name": "SYSTEM$GET_PRIVATELINK_CONFIG",
    "summary": "Returns a JSON representation of the Snowflake account information necessary to facilitate the self-service configuration of private connectivity to the Snowflake service or Snowflake internal stages.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_get_privatelink_config",
    "title": "SYSTEM$GET_PRIVATELINK_CONFIG",
    "description": "Returns a JSON representation of the Snowflake account information necessary to facilitate the self-service configuration of private\nconnectivity to the Snowflake service or Snowflake internal stages.",
    "syntax": "SYSTEM$GET_PRIVATELINK_CONFIG()",
    "example": "SELECT SYSTEM$GET_PRIVATELINK_CONFIG();\n\nselect key, value from table(flatten(input=>parse_json(SYSTEM$GET_PRIVATELINK_CONFIG())));\n\n+--------------------------------------+--------------------------------------+\n| KEY                                  | VALUE                                |\n+--------------------------------------+--------------------------------------+\n| regionless-snowsight-privatelink-url | \"<privatelink_org_snowsight_url>\"    |\n|--------------------------------------+--------------------------------------|\n| privatelink-account-name             | \"<account_identifier>\"               |\n|--------------------------------------+--------------------------------------|\n| privatelink-connection-ocsp-urls     | \"<client_redirect_ocsp_url_list>\"    |\n|--------------------------------------+--------------------------------------|\n| snowsight-privatelink-url            | \"<privatelink_region_snowsight_url>\" |\n|--------------------------------------+--------------------------------------|\n| privatelink-internal-stage           | \"<privatelink_stage_endpoint>\"       |\n|--------------------------------------+--------------------------------------|\n| privatelink-account-url              | \"<privatelink_account_url>\"          |\n|--------------------------------------+--------------------------------------|\n| privatelink-connection-urls          | \"<privatelink_connection_url_list>\"  |\n|--------------------------------------+--------------------------------------|\n| privatelink-pls-id                   | \"<azure_private_link_service_id>\"    |\n|--------------------------------------+--------------------------------------|\n| regionless-privatelink-account-url   | \"<privatelink_org_account_url>\"      |\n|--------------------------------------+--------------------------------------|\n| privatelink-ocsp-url                 | \"<privatelink_ocsp_url>\"             |\n|--------------------------------------+--------------------------------------|\n| regionless-privatelink-ocsp-url      | \"<privatelink_org_ocsp_url>\"         |\n+--------------------------------------+--------------------------------------+",
    "returns": "The function returns a JSON object containing the following name/value pairs based on the cloud platform where your Snowflake account is\nlocated:"
},
{
    "function_name": "SYSTEM$GET_PRIVATELINK_AUTHORIZED_ENDPOINTS",
    "summary": "Returns a list of the authorized endpoints for your current account to use with private connectivity to the Snowflake service.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_get_privatelink_authorized_endpoints",
    "title": "SYSTEM$GET_PRIVATELINK_AUTHORIZED_ENDPOINTS",
    "syntax": "SYSTEM$GET_PRIVATELINK_AUTHORIZED_ENDPOINTS()",
    "example": "use role accountadmin;\nselect system$get_privatelink_authorized_endpoints();\n\nselect\n  value: endpointId\nfrom\n  table(\n    flatten(\n      input => parse_json(system$get_privatelink_authorized_endpoints())\n    )\n  );\n\n+----------------------+---------------------+\n| KEY:ENDPOINT ID TYPE |   VALUE:ENDPOINT ID |\n+----------------------+---------------------+\n|  \"123456789012\"      |    \"123456789012\"   |\n+----------------------+---------------------+",
    "returns": "Returns a list of JSON objects that show key-value pairs where a key represents the endpoint Id Type, and a value represents the\nendpoint Id. For Azure, SYSTEM$GET_PRIVATELINK_AUTHORIZED_ENDPOINTS returns two values, an endpoint ID and a Link Identifier."
},
{
    "function_name": "SYSTEM$GET_PRIVATELINK",
    "summary": "Verifies whether your current account is authorized for private connectivity to the Snowflake service.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_get_privatelink",
    "title": "SYSTEM$GET_PRIVATELINK",
    "description": "Verifies whether your current account is authorized for private connectivity to the Snowflake service.",
    "syntax": "SYSTEM$GET_PRIVATELINK( '<aws_id>' , '<federated_token>' )",
    "example": "USE ROLE ACCOUNTADMIN;\n\nselect SYSTEM$GET_PRIVATELINK(\n    '185...',\n    '{\n      \"Credentials\": {\n          \"AccessKeyId\": \"ASI...\",\n          \"SecretAccessKey\": \"enw...\",\n          \"SessionToken\": \"Fwo...\",\n          \"Expiration\": \"2021-01-07T19:06:23+00:00\"\n      },\n      \"FederatedUser\": {\n          \"FederatedUserId\": \"185...:sam\",\n          \"Arn\": \"arn:aws:sts::185...:federated-user/sam\"\n      },\n      \"PackedPolicySize\": 0\n  }'\n  );\n\nUSE ROLE ACCOUNTADMIN;\n\nselect SYSTEM$GET_PRIVATELINK(\n  '/subscriptions/26d.../resourcegroups/sf-1/providers/microsoft.network/privateendpoints/test-self-service',\n  'eyJ...');\n\nUSE ROLE ACCOUNTADMIN;\n\nselect SYSTEM$GET_PRIVATELINK(\n  'my-gcp-project-id',\n  'ya29.a0AcM612zT4pJaXdYfwgY8aiMoDE9W_xkqQ20coFTB1TJcImKDPo...'\n  );",
    "arguments": [
        {
            "name": "'",
            "description": "The 12-digit identifier that uniquely identifies your Amazon Web Services (AWS) account, as a string."
        },
        {
            "name": "'",
            "description": "The identifier that uniquely identifies the private endpoint in Microsoft Azure (Azure) as a string."
        },
        {
            "name": "'",
            "description": "The federated token value that contains access credentials for a federated user as a string. To obtain this value, execute the appropriate command for the cloud platform that hosts your Snowflake account. Use the command-line tool\nprovided by the platform: For Snowflake on AWS: For Snowflake on Azure: Where: The unique identifier for your subscription. For example: 13c... To obtain this value, execute the following Azure CLI command in your command line environment: Note the output value in the SubscriptionID column, which is truncated in this example:"
        },
        {
            "name": "SubscriptionID",
            "description": "The unique identifier for your subscription. For example: 13c... To obtain this value, execute the following Azure CLI command in your command line environment: Note the output value in the SubscriptionID column, which is truncated in this example:"
        },
        {
            "name": "'",
            "description": "The identifier that uniquely identifies your Google Cloud (GCP) project, as a string."
        },
        {
            "name": "'",
            "description": "The access token value that contains access credentials for a Google Cloud user as a string."
        }
    ]
},
{
    "function_name": "SYSTEM$GET_PREVIEW_ACCESS_STATUS",
    "summary": "Determine if access to all preview features is enabled or disabled.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_get_preview_access_status",
    "title": "SYSTEM$GET_PREVIEW_ACCESS_STATUS",
    "description": "Determine if access to all preview features is enabled or disabled.",
    "syntax": "SYSTEM$GET_PREVIEW_ACCESS_STATUS()",
    "example": "SELECT SYSTEM$GET_PREVIEW_ACCESS_STATUS();",
    "returns": "Returns a VARCHAR status message representing whether preview features are enabled or disabled as shown below:"
},
{
    "function_name": "SYSTEM$GET_PREDECESSOR_RETURN_VALUE",
    "summary": "Retrieves the return value for the predecessor task in a task graph.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_get_predecessor_return_value",
    "title": "SYSTEM$GET_PREDECESSOR_RETURN_VALUE",
    "description": "Retrieves the return value for the predecessor task in a",
    "syntax": "SYSTEM$GET_PREDECESSOR_RETURN_VALUE('<task_name>')",
    "arguments": [
        {
            "name": "'",
            "description": "Identifier for the predecessor task that sets the return value to be retrieved. If the task has multiple predecessor tasks that are enabled, this argument is required. If the task has only one predecessor task that is enabled, the argument is optional.\nIf this argument is omitted, the function retrieves the return value for the only enabled predecessor task. If the immediate predecessor task name does not match the requested task name, but an ancestor predecessor does match the task name,\nthe return value of the matching ancestor is returned. The task name argument should not include the database name or schema name. All tasks in a graph are required to be within the same schema, so there should be no need to reference a task in a different schema. For example, you should use MYTASK as an input to this function, instead of using MYDATABASE.MYSCHEMA.MYTASK ."
        }
    ]
},
{
    "function_name": "SYSTEM$GET_LOGIN_FAILURE_DETAILS",
    "summary": "Returns a JSON object that represents an unsuccessful login attempt associated with External OAuth, SAML, or key pair authentication.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_get_login_failure_details",
    "title": "SYSTEM$GET_LOGIN_FAILURE_DETAILS",
    "description": "Returns a JSON object that represents an unsuccessful login attempt associated with External OAuth, SAML, or key pair authentication. The\nJSON object contains the error associated with the failed login attempt.",
    "syntax": "SYSTEM$GET_LOGIN_FAILURE_DETAILS('<uuid>')",
    "example": "Invalid  OAuth access token. [0ce9eb56-821d-4ca9-a774-04ae89a0cf5a]\n\nSELECT JSON_EXTRACT_PATH_TEXT(SYSTEM$GET_LOGIN_FAILURE_DETAILS('0ce9eb56-821d-4ca9-a774-04ae89a0cf5a'), 'errorCode');",
    "arguments": [
        {
            "name": "uuid",
            "description": "A string representing a UUID. The UUID appears after the error message that is returned from a failed login event associated with External\nOAuth, SAML, or key pair authentication."
        }
    ],
    "returns": "Returns the following elements in a JSON object:"
},
{
    "function_name": "SYSTEM$GET_ICEBERG_TABLE_INFORMATION",
    "summary": "Returns the location of the root metadata file and status of the latest snapshot for an Apache Iceberg™ table.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_get_iceberg_table_information",
    "title": "SYSTEM$GET_ICEBERG_TABLE_INFORMATION",
    "description": "Returns the location of the root metadata file and status of the latest snapshot for an",
    "syntax": "SYSTEM$GET_ICEBERG_TABLE_INFORMATION('<iceberg_table_name>')",
    "example": "SELECT SYSTEM$GET_ICEBERG_TABLE_INFORMATION('db1.schema1.it1');\n\n+-----------------------------------------------------------------------------------------------------------+\n| SYSTEM$GET_ICEBERG_TABLE_INFORMATION('DB1.SCHEMA1.IT1')                                                   |\n|-----------------------------------------------------------------------------------------------------------|\n| {\"metadataLocation\":\"s3://mybucket/metadata/v1.metadata.json\",\"status\":\"success\"}                         |\n+-----------------------------------------------------------------------------------------------------------+",
    "arguments": [
        {
            "name": "'",
            "description": "The name of the Iceberg table for which you want to retrieve information. The table name is a string, so it must be enclosed in single\nquotes. If the Iceberg table name is fully qualified, such as '<db>.<schema>.<iceberg_table_name>' ,\nthe entire name must be enclosed in single quotes, including the database and schema. If the Iceberg table name is case-sensitive or includes any special characters or spaces,\ndouble quotes are required to process the case/characters.\nThe double quotes must be enclosed within the single quotes, for example, '\"<case_sensitive_iceberg_table_name>\"' ."
        }
    ],
    "returns": "The function returns a JSON object containing the following name/value pairs:"
},
{
    "function_name": "SYSTEM$GET_HASH_FOR_APPLICATION",
    "summary": "Returns the hash value for a",
    "category": "native-app",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_get_hash_for_application",
    "title": "SYSTEM$GET_HASH_FOR_APPLICATION",
    "description": "Returns the hash value for a Snowflake Native App or query ID.",
    "syntax": "SYSTEM$GET_HASH_FOR_APPLICATION( '<app_name>' [ , '<query_id>' ] )",
    "example": "SELECT SYSTEM$GET_HASH_FOR_APPLICATION('hello_snowflake_app');\n\n+--------------------------------------------------------+\n| SYSTEM$GET_HASH_FOR_APPLICATION('HELLO_SNOWFLAKE_APP') |\n|--------------------------------------------------------|\n| yksY1823VLDNSbwRW3LrIuI+sfUII                          |\n+--------------------------------------------------------+\n\nSELECT SYSTEM$GET_HASH_FOR_APPLICATION('hello_snowflake_app', '01bafe06-3210-d462-0000-04150406931a');\n\n+------------------------------------------------------------------------------------------------+\n| SYSTEM$GET_HASH_FOR_APPLICATION('HELLO_SNOWFLAKE_APP', '01bafe06-3210-d462-0000-04150406931a') |\n|------------------------------------------------------------------------------------------------|\n| nGEP/JvFhc9a7r41p+y98hUx6Q=                                                                    |\n+------------------------------------------------------------------------------------------------+",
    "arguments": [
        {
            "name": "'",
            "description": "The name of the app whose hash value you want to return."
        },
        {
            "name": "'",
            "description": "The query ID whose hash value you want to return."
        }
    ],
    "returns": "Returns a signed 64-bit hash value. If a query ID is passed as\nan argument to this function, this function returns the hash value of the query\nID. Otherwise, it returns the hash value for the app."
},
{
    "function_name": "SYSTEM$GET_GCP_KMS_CMK_GRANT_ACCESS_CMD",
    "summary": "Returns a Google Cloud gcloud command to obtain policy information for the Google Cloud Key Management Service for use with customer-managed keys.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_get_gcp_kms_cmk_grant_access_cmd",
    "title": "SYSTEM$GET_GCP_KMS_CMK_GRANT_ACCESS_CMD",
    "description": "Returns a Google Cloud gcloud command to obtain policy information for the Google Cloud Key Management Service for use with\ncustomer-managed keys.",
    "syntax": "SYSTEM$GET_GCP_KMS_CMK_GRANT_ACCESS_CMD()",
    "example": "select SYSTEM$GET_GCP_KMS_CMK_GRANT_ACCESS_CMD();\n\ngcloud kms keys add-iam-policy-binding <key-name> --project <project-id> --location <location> --keyring <key-ring> --member serviceAccount:<service-account-email> --role roles/cloudkms.cryptoKeyEncrypterDecrypter"
},
{
    "function_name": "SYSTEM$GET_DIRECTORY_TABLE_STATUS",
    "summary": "Returns a list of records that contain the directory table consistency status for stages in your account.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_get_directory_table_status",
    "title": "SYSTEM$GET_DIRECTORY_TABLE_STATUS",
    "description": "Returns a list of records that contain the",
    "syntax": "SYSTEM$GET_DIRECTORY_TABLE_STATUS( [ '<stage_name>' ] )",
    "example": "SELECT SYSTEM$GET_DIRECTORY_TABLE_STATUS();\n\n[\n  {\n    \"stage\" : \"STAGE1\",\n    \"status\" : \"CONSISTENT\"\n  },\n  {\n    \"stage\" : \"STAGE2\",\n    \"status\" : \"INCONSISTENT\"\n  }\n]\n\nSELECT SYSTEM$GET_DIRECTORY_TABLE_STATUS('stage1');\n\n[\n  {\n    \"stage\" : \"STAGE1\",\n    \"status\" : \"CONSISTENT\"\n  }\n]",
    "arguments": [
        {
            "name": "'",
            "description": "Stage for which you want to retrieve the directory table consistency status. When you specify a stage name, the function returns a list\nwith a single record for the directory table on that stage."
        }
    ],
    "returns": "Returns a list of directory table consistency records for each stage in your account.  The list contains a maximum of 10,000 records.\nIf you specify a 'stage_name' argument, the function returns a list with a single record for the directory table on that stage."
},
{
    "function_name": "SYSTEM$GET_DEBUG_STATUS",
    "summary": "Returns the session debug mode status of the current session.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_get_debug_status",
    "title": "SYSTEM$GET_DEBUG_STATUS",
    "syntax": "SYSTEM$GET_DEBUG_STATUS()"
},
{
    "function_name": "SYSTEM$GET_COMPUTE_POOL_PENDING_MAINTENANCE",
    "summary": "Retrieves information about pending Snowflake maintenance actions for compute pools in the current account.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_get_compute_pool_pending_maintenance",
    "title": "SYSTEM$GET_COMPUTE_POOL_PENDING_MAINTENANCE",
    "description": "Retrieves information about pending Snowflake",
    "syntax": "SYSTEM$GET_COMPUTE_POOL_PENDING_MAINTENANCE()",
    "example": "SELECT SYSTEM$GET_COMPUTE_POOL_PENDING_MAINTENANCE();\n\n+---------------------------------------------------------------------------------------------------------+\n| SYSTEM$GET_COMPUTE_POOL_PENDING_MAINTENANCE()                                                           |\n|---------------------------------------------------------------------------------------------------------|\n| {\"maintenanceRequired\":false,\"maintenanceWindow\":{\"start\":\"2025-02-27T23:00\",\"end\":\"2025-02-28T00:00\"}} |\n+---------------------------------------------------------------------------------------------------------+",
    "returns": "Returns a JSON object that provides an indication of whether maintenance is required and the upcoming maintenance window timeline. The JSON fields are:"
},
{
    "function_name": "SYSTEM$GET_CMK_KMS_KEY_POLICY",
    "summary": "Returns an ARRAY containing a snippet of the AWS Key Management Service policy information related to customer-managed keys.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_get_cmk_kms_key_policy",
    "title": "SYSTEM$GET_CMK_KMS_KEY_POLICY",
    "description": "Returns an ARRAY containing a snippet of the AWS Key Management Service policy information related to customer-managed keys.",
    "syntax": "SYSTEM$GET_CMK_KMS_KEY_POLICY()",
    "example": "SELECT SYSTEM$GET_CMK_KMS_KEY_POLICY();"
},
{
    "function_name": "SYSTEM$GET_CMK_INFO",
    "summary": "Returns a status about your customer-managed key (CMK) for use with Tri-Secret Secure.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_get_cmk_info",
    "title": "SYSTEM$GET_CMK_INFO",
    "description": "Returns a status about your customer-managed key (CMK) for use with Tri-Secret Secure.",
    "syntax": "SYSTEM$GET_CMK_INFO()",
    "example": "SELECT SYSTEM$GET_CMK_INFO();",
    "returns": "Returns a status message indicating the state of your CMK. The output includes the values that you specified when calling\nSYSTEM$REGISTER_CMK_INFO."
},
{
    "function_name": "SYSTEM$GET_CMK_CONFIG",
    "summary": "Returns configuration information for use with customer-managed keys (CMKs) and Tri-Secret Secure.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_get_cmk_config",
    "title": "SYSTEM$GET_CMK_CONFIG",
    "description": "Returns configuration information for use with customer-managed keys (CMKs) and Tri-Secret Secure.",
    "syntax": "SYSTEM$GET_CMK_CONFIG()",
    "example": "SELECT SYSTEM$GET_CMK_CONFIG('b3ddabe4-e5ed-4e71-8827-0cefb99af240');",
    "arguments": [
        {
            "name": "tenant_id",
            "description": "Specifies the unique identifier for the Azure Key Vault tenant in your Microsoft Azure subscription. This value is in the GUID format, such as b3ddabe4-e5ed-4e71-8827-0cefb99af240 . You can find this value by logging into the Portal\nand navigating to Key Vault » Overview . Select the Directory ID value."
        }
    ],
    "returns": "The output depends on the cloud platform that hosts your Snowflake account:"
},
{
    "function_name": "SYSTEM$GET_CMK_AKV_CONSENT_URL",
    "summary": "Returns a consent URL to the Azure Key Vault account related to customer-managed keys.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_get_cmk_akv_consent_url",
    "title": "SYSTEM$GET_CMK_AKV_CONSENT_URL",
    "description": "Returns a consent URL to the Azure Key Vault account related to customer-managed keys.",
    "syntax": "SYSTEM$GET_CMK_AKV_CONSENT_URL( '<account_identifier>' , '<tenant_id>' )",
    "example": "SELECT SYSTEM$GET_CMK_AKV_CONSENT_URL('my-account' , 'b3ddabe4-e5ed-4e71-8827-0cefb99af240');\n\nhttps://login.microsoftonline.com/tenantId/oauth2/authorize?client_id=myClientId&response_type=code",
    "arguments": [
        {
            "name": "'",
            "description": "Specifies the account identifier for your Snowflake account on Azure. Required."
        },
        {
            "name": "'",
            "description": "Specifies the unique identifier for the tenant in your Azure\nsubscription. This value is in the GUID/UUID format, such as b3ddabe4-e5ed-4e71-8827-0cefb99af240 . Required. To locate this value, follow the instructions in How to find your Azure Active Directory tenant ID ."
        }
    ]
},
{
    "function_name": "SYSTEM$GET_CLASSIFICATION_RESULT",
    "summary": "Returns the classification result of the specified object.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_get_classification_result",
    "title": "SYSTEM$GET_CLASSIFICATION_RESULT",
    "syntax": "SELECT SYSTEM$GET_CLASSIFICATION_RESULT( '<object_name>' )",
    "example": "SELECT SYSTEM$GET_CLASSIFICATION_RESULT('hr.tables.empl_info');",
    "arguments": [
        {
            "name": "object_name",
            "description": "The name of the table, external table, view, or materialized view containing the columns to be classified. If a database and schema are\nnot in use in the current session, the name must be fully-qualified. The name must be specified exactly as it is stored in the database. If the name contains special characters, capitalization, or blank\nspaces, the name must be enclosed first in double-quotes and then in single quotes."
        }
    ],
    "returns": "Returns a JSON object in the following format. For example:"
},
{
    "function_name": "SYSTEM$GET_AWS_SNS_IAM_POLICY",
    "summary": "Returns an AWS IAM policy statement that must be added to the Amazon SNS topic policy in order to grant the Amazon SQS messaging queue created by Snowflake to subscribe to the topic.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_get_aws_sns_iam_policy",
    "title": "SYSTEM$GET_AWS_SNS_IAM_POLICY",
    "description": "Returns an AWS IAM policy statement that must be added to the Amazon SNS topic policy in order to grant the Amazon SQS messaging queue created by Snowflake to subscribe to the topic.",
    "syntax": "SYSTEM$GET_AWS_SNS_IAM_POLICY( '<sns_topic_arn>' )",
    "example": "select system$get_aws_sns_iam_policy('arn:aws:sns:us-west-2:001234567890:s3_mybucket');\n\n+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| SYSTEM$GET_AWS_SNS_IAM_POLICY('ARN:AWS:SNS:US-WEST-2:001234567890:S3_MYBUCKET')                                                                                                                                                                   |\n+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| {\"Version\":\"2012-10-17\",\"Statement\":[{\"Sid\":\"1\",\"Effect\":\"Allow\",\"Principal\":{\"AWS\":\"arn:aws:iam::123456789001:user/vj4g-a-abcd1234\"},\"Action\":[\"sns:Subscribe\"],\"Resource\":[\"arn:aws:sns:us-west-2:001234567890:s3_mybucket\"]}]}                 |\n+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+",
    "arguments": [
        {
            "name": "sns_topic_arn",
            "description": "Amazon Resource Name (ARN) of the SNS topic for your S3 bucket. The function returns an IAM policy for Snowflake’s SQS queue to subscribe to this topic."
        }
    ]
},
{
    "function_name": "SYSTEM$GET_ALL_REFERENCES",
    "summary": "Iterates through all associations for a reference and returns information about the associations.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_get_all_references",
    "title": "SYSTEM$GET_ALL_REFERENCES",
    "description": "Iterates through all associations for a reference and returns information about the associations.",
    "syntax": "SYSTEM$GET_ALL_REFERENCES('<reference_name>', [, <include_details> = True | False ])",
    "arguments": [
        {
            "name": "'",
            "description": "The name of the reference."
        },
        {
            "name": "include_details",
            "description": "Determines the type of information returned by the function.\nFor more information, see Returns ."
        }
    ],
    "returns": "If the include_details parameter is set to True, returns a\nVARCHAR containing a JSON object that contains an array of the following name/value pairs:"
},
{
    "function_name": "SYSTEM$GENERATE_SCIM_ACCESS_TOKEN",
    "summary": "Returns a new SCIM access token that is valid for six months.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_generate_scim_access_token",
    "title": "SYSTEM$GENERATE_SCIM_ACCESS_TOKEN",
    "description": "Returns a new SCIM access token that is valid for six months.",
    "syntax": "SYSTEM$GENERATE_SCIM_ACCESS_TOKEN('<integration_name>')",
    "example": "SELECT SYSTEM$GENERATE_SCIM_ACCESS_TOKEN('OKTA_PROVISIONING');",
    "arguments": [
        {
            "name": "<integration_name>",
            "description": "Name of the security integration where TYPE = SCIM . Note that the integration name is case-sensitive, must be uppercase, and be enclosed in single quotes. For more information, see CREATE SECURITY INTEGRATION ."
        }
    ]
},
{
    "function_name": "SYSTEM$GENERATE_SAML_CSR",
    "summary": "Generates a certificate signing request (CSR) with the subject set to the subject of the certificate stored in the SAML2 integration and can specify the DN to be used in the CSR.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_generate_saml_csr",
    "title": "SYSTEM$GENERATE_SAML_CSR",
    "description": "Generates a certificate signing request (CSR) with the subject set to the subject of the certificate stored in the",
    "syntax": "SYSTEM$GENERATE_SAML_CSR( <name> , <DN> )",
    "arguments": [
        {
            "name": "name",
            "description": "The name of the SAML2 security integration to generate the CSR. Required."
        },
        {
            "name": "DN",
            "description": "The distinguished name to be used the CSR. Note that a DN is a string of relative DNs separated by commas. For example: 'cn=juser, ou=dev, ou=people, o=eng, dc=com' Optional. If missing, the DN of the current certificate will be used. If using the self-signed certificate, the value will be the account alias, if set, or the account name."
        }
    ]
},
{
    "function_name": "SYSTEM$FINISH_OAUTH_FLOW",
    "summary": "Sets the OAUTH_REFRESH_TOKEN parameter value of the secret passed as an argument in the SYSTEM$START_OAUTH_FLOW call that began the OAuth flow.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_finish_oauth_flow",
    "title": "SYSTEM$FINISH_OAUTH_FLOW",
    "description": "Sets the OAUTH_REFRESH_TOKEN parameter value of the secret passed as an argument in the",
    "syntax": "SYSTEM$FINISH_OAUTH_FLOW( '<query_string>' )",
    "example": "SELECT SYSTEM$FINISH_OAUTH_FLOW('state=252462476&authz_code=54264262');",
    "arguments": [
        {
            "name": "'",
            "description": "Query string from the URL in the browser after completing user authentication and providing OAuth consent."
        }
    ]
},
{
    "function_name": "SYSTEM$EXTERNAL_TABLE_PIPE_STATUS",
    "summary": "Retrieves a JSON representation of the current refresh status for the internal (hidden) pipe object associated with an external table.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_external_table_pipe_status",
    "title": "SYSTEM$EXTERNAL_TABLE_PIPE_STATUS",
    "description": "Retrieves a JSON representation of the current refresh status for the internal (hidden) pipe object associated with an external table.",
    "syntax": "SYSTEM$EXTERNAL_TABLE_PIPE_STATUS( '<external_table_name>' )",
    "example": "SELECT SYSTEM$EXTERNAL_TABLE_PIPE_STATUS('mydb.myschema.exttable');\n\n+---------------------------------------------------------------+\n| SYSTEM$EXTERNAL_TABLE_PIPE_STATUS('MYDB.MYSCHEMA.EXTTABLE')   |\n|---------------------------------------------------------------|\n| {\"executionState\":\"RUNNING\",\"pendingFileCount\":0}             |\n+---------------------------------------------------------------+\n\nSELECT SYSTEM$EXTERNAL_TABLE_PIPE_STATUS('mydb.myschema.\"extTable\"');\n\n+---------------------------------------------------------------+\n| SYSTEM$EXTERNAL_TABLE_PIPE_STATUS('MYDB.MYSCHEMA.\"extTable\"') |\n|---------------------------------------------------------------|\n| {\"executionState\":\"RUNNING\",\"pendingFileCount\":0}             |\n+---------------------------------------------------------------+",
    "arguments": [
        {
            "name": "external_table_name",
            "description": "External table for which you want to retrieve the current automatic refresh status."
        }
    ]
},
{
    "function_name": "SYSTEM$EXPLAIN_PLAN_JSON",
    "summary": "Given the text of a SQL statement, this function generates the EXPLAIN plan in JSON.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_explain_plan_json",
    "title": "SYSTEM$EXPLAIN_PLAN_JSON",
    "description": "Given the text of a SQL statement, this function generates the EXPLAIN plan in JSON.",
    "syntax": "SYSTEM$EXPLAIN_PLAN_JSON( { <sql_statement_expression> | <sql_query_id_expression> } )",
    "example": "CREATE TABLE Z1 (ID INTEGER);\nCREATE TABLE Z2 (ID INTEGER);\nCREATE TABLE Z3 (ID INTEGER);\n\nSELECT SYSTEM$EXPLAIN_PLAN_JSON(\n  'SELECT Z1.ID, Z2.ID FROM Z1, Z2 WHERE Z2.ID = Z1.ID'\n  ) AS explain_plan;\n\n+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| EXPLAIN_PLAN                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |\n|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| {\"GlobalStats\":{\"partitionsTotal\":2,\"partitionsAssigned\":2,\"bytesAssigned\":1024},\"Operations\":[[{\"id\":0,\"operation\":\"Result\",\"expressions\":[\"Z1.ID\",\"Z2.ID\"]},{\"id\":1,\"parentOperators\":[0],\"operation\":\"InnerJoin\",\"expressions\":[\"joinKey: (Z2.ID = Z1.ID)\"]},{\"id\":2,\"parentOperators\":[1],\"operation\":\"TableScan\",\"objects\":[\"TESTDB.TEMPORARY_DOC_TEST.Z2\"],\"expressions\":[\"ID\"],\"partitionsAssigned\":1,\"partitionsTotal\":1,\"bytesAssigned\":512},{\"id\":3,\"parentOperators\":[1],\"operation\":\"JoinFilter\",\"expressions\":[\"joinKey: (Z2.ID = Z1.ID)\"]},{\"id\":4,\"parentOperators\":[3],\"operation\":\"TableScan\",\"objects\":[\"TESTDB.TEMPORARY_DOC_TEST.Z1\"],\"expressions\":[\"ID\"],\"partitionsAssigned\":1,\"partitionsTotal\":1,\"bytesAssigned\":512}]]} |\n+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n\nSELECT SYSTEM$EXPLAIN_PLAN_JSON(\n    $$ SELECT symptom, IFNULL(diagnosis, '(not yet diagnosed)') FROM medical $$\n    );\n\nSELECT Z1.ID, Z2.ID FROM Z1, Z2 WHERE Z2.ID = Z1.ID;\n\nSELECT SYSTEM$EXPLAIN_PLAN_JSON(LAST_QUERY_ID()) AS explain_plan;",
    "arguments": [
        {
            "name": "sql_statement_expression",
            "description": "A string, or an expression that evaluates to a string, containing the SQL statement for which you want the EXPLAIN\nplan.\nIf a literal string is used, it should be surrounded by single quote characters ' ."
        },
        {
            "name": "sql_query_id_expression",
            "description": "A string, or an expression that evaluates to a string, containing the query ID for which you want the EXPLAIN plan.\nIf a literal string is used, it should be surrounded by single quote characters ' . Snowflake retains historical data for query IDs executed within the previous 14 days. If you specify the query ID\nfor a query executed more than 14 days in the past, an error is returned. For more information, see Monitor query activity with Query History ."
        }
    ],
    "returns": "The function returns a VARCHAR containing the EXPLAIN output in JSON-compatible format."
},
{
    "function_name": "SYSTEM$EXPLAIN_JSON_TO_TEXT",
    "summary": "This function converts EXPLAIN output from JSON to formatted text.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_explain_json_to_text",
    "title": "SYSTEM$EXPLAIN_JSON_TO_TEXT",
    "description": "This function converts EXPLAIN output from JSON to formatted text.",
    "syntax": "SYSTEM$EXPLAIN_JSON_TO_TEXT( <explain_output_in_json_format> )",
    "example": "CREATE TABLE Z1 (ID INTEGER);\nCREATE TABLE Z2 (ID INTEGER);\nCREATE TABLE Z3 (ID INTEGER);\n\nSET QUERY_10 = 'SELECT Z1.ID, Z2.ID FROM Z1, Z2 WHERE Z2.ID = Z1.ID';\nCREATE TABLE json_explain_output_for_analysis (\n    ID INTEGER,\n    query VARCHAR,\n    explain_plan VARCHAR\n    );\nINSERT INTO json_explain_output_for_analysis (ID, query, explain_plan) \n    SELECT \n        1,\n        $QUERY_10 AS query,\n        SYSTEM$EXPLAIN_PLAN_JSON($QUERY_10) AS explain_plan;\n\nSELECT query, explain_plan FROM json_explain_output_for_analysis;\n+-----------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| QUERY                                               | EXPLAIN_PLAN                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |\n|-----------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| SELECT Z1.ID, Z2.ID FROM Z1, Z2 WHERE Z2.ID = Z1.ID | {\"GlobalStats\":{\"partitionsTotal\":2,\"partitionsAssigned\":2,\"bytesAssigned\":1024},\"Operations\":[[{\"id\":0,\"operation\":\"Result\",\"expressions\":[\"Z1.ID\",\"Z2.ID\"]},{\"id\":1,\"parentOperators\":[0],\"operation\":\"InnerJoin\",\"expressions\":[\"joinKey: (Z2.ID = Z1.ID)\"]},{\"id\":2,\"parentOperators\":[1],\"operation\":\"TableScan\",\"objects\":[\"TESTDB.TEMPORARY_DOC_TEST.Z2\"],\"expressions\":[\"ID\"],\"partitionsAssigned\":1,\"partitionsTotal\":1,\"bytesAssigned\":512},{\"id\":3,\"parentOperators\":[1],\"operation\":\"JoinFilter\",\"expressions\":[\"joinKey: (Z2.ID = Z1.ID)\"]},{\"id\":4,\"parentOperators\":[3],\"operation\":\"TableScan\",\"objects\":[\"TESTDB.TEMPORARY_DOC_TEST.Z1\"],\"expressions\":[\"ID\"],\"partitionsAssigned\":1,\"partitionsTotal\":1,\"bytesAssigned\":512}]]} |\n+-----------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n\nSELECT SYSTEM$EXPLAIN_JSON_TO_TEXT(explain_plan) \n    FROM json_explain_output_for_analysis\n    WHERE json_explain_output_for_analysis.ID = 1;\n+------------------------------------------------------------------------------------------------------------------------------------+\n| SYSTEM$EXPLAIN_JSON_TO_TEXT(EXPLAIN_PLAN)                                                                                          |\n|------------------------------------------------------------------------------------------------------------------------------------|\n| GlobalStats:                                                                                                                       |\n| \tbytesAssigned=1024                                                                                                                                                                                                                                                                         |\n| \tpartitionsAssigned=2                                                                                                                                                                                                                                                                         |\n| \tpartitionsTotal=2                                                                                                                                                                                                                                                                         |\n| Operations:                                                                                                                        |\n| 1:0     ->Result  Z1.ID, Z2.ID                                                                                                     |\n| 1:1          ->InnerJoin  joinKey: (Z2.ID = Z1.ID)                                                                                 |\n| 1:2               ->TableScan  TESTDB.TEMPORARY_DOC_TEST.Z2  ID  {partitionsTotal=1, partitionsAssigned=1, bytesAssigned=512}      |\n| 1:3               ->JoinFilter  joinKey: (Z2.ID = Z1.ID)                                                                           |\n| 1:4                    ->TableScan  TESTDB.TEMPORARY_DOC_TEST.Z1  ID  {partitionsTotal=1, partitionsAssigned=1, bytesAssigned=512} |\n|                                                                                                                                    |\n+------------------------------------------------------------------------------------------------------------------------------------+",
    "arguments": [
        {
            "name": "explain_output_in_json_format",
            "description": "A string, or an expression that evaluates to a string, containing EXPLAIN output as a JSON-compatible string.\nIf the input is a string, the string should be enclosed in single quotes ' ."
        }
    ],
    "returns": "The function returns a VARCHAR containing the EXPLAIN output as text that has been formatted to be relatively easy for\nhumans to read."
},
{
    "function_name": "SYSTEM$ESTIMATE_SEARCH_OPTIMIZATION_COSTS",
    "summary": "Returns the estimated costs of adding search optimization to a given table and configuring specific columns for search optimization.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_estimate_search_optimization_costs",
    "title": "SYSTEM$ESTIMATE_SEARCH_OPTIMIZATION_COSTS",
    "syntax": "SYSTEM$ESTIMATE_SEARCH_OPTIMIZATION_COSTS('<table_name>' [ , '<search_method_with_target>' ])",
    "example": "SELECT SYSTEM$ESTIMATE_SEARCH_OPTIMIZATION_COSTS('table_without_search_opt')\n  AS estimate_for_table_without_search_optimization;\n\n+---------------------------------------------------------------------------+\n| ESTIMATE_FOR_TABLE_WITHOUT_SEARCH_OPTIMIZATION                            |\n|---------------------------------------------------------------------------|\n| {                                                                         |\n|   \"tableName\" : \"TABLE_WITHOUT_SEARCH_OPT\",                               |\n|   \"searchOptimizationEnabled\" : false,                                    |\n|   \"costPositions\" : [ {                                                   |\n|     \"name\" : \"BuildCosts\",                                                |\n|     \"costs\" : {                                                           |\n|       \"value\" : 11.279,                                                   |\n|       \"unit\" : \"Credits\"                                                  |\n|     },                                                                    |\n|     \"computationMethod\" : \"Estimated\",                                    |\n|     \"comment\" : \"estimated via sampling\"                                  |\n|   }, {                                                                    |\n|     \"name\" : \"StorageCosts\",                                              |\n|     \"costs\" : {                                                           |\n|       \"value\" : 0.070493,                                                 |\n|       \"unit\" : \"TB\"                                                       |\n|     },                                                                    |\n|     \"computationMethod\" : \"Estimated\",                                    |\n|     \"comment\" : \"estimated via sampling\"                                  |\n|   }, {                                                                    |\n|     \"name\" : \"MaintenanceCosts\",                                          |\n|     \"costs\" : {                                                           |\n|       \"value\" : 30.296,                                                   |\n|       \"unit\" : \"Credits\",                                                 |\n|       \"perTimeUnit\" : \"MONTH\"                                             |\n|     },                                                                    |\n|     \"computationMethod\" : \"Estimated\",                                    |\n|     \"comment\" : \"Estimated from historic change rate over last ~11 days.\" |\n|   } ]                                                                     |\n| }                                                                         |\n+---------------------------------------------------------------------------+\n\nSELECT SYSTEM$ESTIMATE_SEARCH_OPTIMIZATION_COSTS('table_with_search_opt')\n  AS estimate_for_table_with_search_optimization;\n\n+---------------------------------------------------------------------------+\n| ESTIMATE_FOR_TABLE_WITH_SEARCH_OPTIMIZATION                               |\n|---------------------------------------------------------------------------|\n| {                                                                         |\n|   \"tableName\" : \"TABLE_WITH_SEARCH_OPT\",                                  |\n|   \"searchOptimizationEnabled\" : true,                                     |\n|   \"costPositions\" : [ {                                                   |\n|     \"name\" : \"BuildCosts\",                                                |\n|     \"computationMethod\" : \"NotAvailable\",                                 |\n|     \"comment\" : \"Search optimization is already enabled.\"                 |\n|   }, {                                                                    |\n|     \"name\" : \"StorageCosts\",                                              |\n|     \"costs\" : {                                                           |\n|       \"value\" : 0.052048,                                                 |\n|       \"unit\" : \"TB\"                                                       |\n|     },                                                                    |\n|     \"computationMethod\" : \"Measured\"                                      |\n|   }, {                                                                    |\n|     \"name\" : \"Benefit\",                                                   |\n|     \"computationMethod\" : \"NotAvailable\",                                 |\n|     \"comment\" : \"Currently not supported.\"                                |\n|   }, {                                                                    |\n|     \"name\" : \"MaintenanceCosts\",                                          |\n|     \"costs\" : {                                                           |\n|       \"value\" : 30.248,                                                   |\n|       \"unit\" : \"Credits\",                                                 |\n|       \"perTimeUnit\" : \"MONTH\"                                             |\n|     },                                                                    |\n|     \"computationMethod\" : \"EstimatedUpperBound\",                          |\n|     \"comment\" : \"Estimated from historic change rate over last ~11 days.\" |\n|   } ]                                                                     |\n| }                                                                         |\n+---------------------------------------------------------------------------+\n\nSELECT SYSTEM$ESTIMATE_SEARCH_OPTIMIZATION_COSTS('table_without_search_opt', 'EQUALITY(C1, C2, C3)')\n  AS estimate_for_columns_without_search_optimization;\n\n+---------------------------------------------------------------------------+\n| ESTIMATE_FOR_COLUMNS_WITHOUT_SEARCH_OPTIMIZATION                          |\n|---------------------------------------------------------------------------|\n| {                                                                         |\n|   \"tableName\" : \"TABLE_WITHOUT_SEARCH_OPT\",                               |\n|   \"searchOptimizationEnabled\" : false,                                    |\n|   \"costPositions\" : [ {                                                   |\n|     \"name\" : \"BuildCosts\",                                                |\n|     \"costs\" : {                                                           |\n|       \"value\" : 10.527,                                                   |\n|       \"unit\" : \"Credits\"                                                  |\n|     },                                                                    |\n|     \"computationMethod\" : \"Estimated\",                                    |\n|     \"comment\" : \"estimated via sampling\"                                  |\n|   }, {                                                                    |\n|     \"name\" : \"StorageCosts\",                                              |\n|     \"costs\" : {                                                           |\n|       \"value\" : 0.040323,                                                 |\n|       \"unit\" : \"TB\"                                                       |\n|     },                                                                    |\n|     \"computationMethod\" : \"Estimated\",                                    |\n|     \"comment\" : \"estimated via sampling\"                                  |\n|   }, {                                                                    |\n|     \"name\" : \"MaintenanceCosts\",                                          |\n|     \"costs\" : {                                                           |\n|       \"value\" : 22.821,                                                   |\n|       \"unit\" : \"Credits\",                                                 |\n|       \"perTimeUnit\" : \"MONTH\"                                             |\n|     },                                                                    |\n|     \"computationMethod\" : \"Estimated\",                                    |\n|     \"comment\" : \"Estimated from historic change rate over last ~7 days.\"  |\n|   } ]                                                                     |\n| }                                                                         |\n+---------------------------------------------------------------------------+\n\nSELECT SYSTEM$ESTIMATE_SEARCH_OPTIMIZATION_COSTS('table_with_search_opt', 'EQUALITY(C1, C2, C3)')\n  AS estimate_for_columns_with_search_optimization;\n\n+---------------------------------------------------------------------------+\n| ESTIMATE_FOR_COLUMNS_WITH_SEARCH_OPTIMIZATION                             |\n|---------------------------------------------------------------------------|\n| {                                                                         |\n|   \"tableName\" : \"TABLE_WITH_SEARCH_OPT\",                                  |\n|   \"searchOptimizationEnabled\" : true,                                     |\n|   \"costPositions\" : [ {                                                   |\n|     \"name\" : \"BuildCosts\",                                                |\n|     \"costs\" : {                                                           |\n|       \"value\" : 8.331,                                                    |\n|       \"unit\" : \"Credits\"                                                  |\n|     },                                                                    |\n|     \"computationMethod\" : \"Estimated\",                                    |\n|     \"comment\" : \"estimated via sampling\"                                  |\n|   }, {                                                                    |\n|     \"name\" : \"StorageCosts\",                                              |\n|     \"costs\" : {                                                           |\n|       \"value\" : 0.040323,                                                 |\n|       \"unit\" : \"TB\"                                                       |\n|     },                                                                    |\n|     \"computationMethod\" : \"Estimated\",                                    |\n|     \"comment\" : \"estimated via sampling\"                                  |\n|   }, {                                                                    |\n|     \"name\" : \"Benefit\",                                                   |\n|     \"computationMethod\" : \"NotAvailable\",                                 |\n|     \"comment\" : \"Currently not supported.\"                                |\n|   }, {                                                                    |\n|     \"name\" : \"MaintenanceCosts\",                                          |\n|     \"costs\" : {                                                           |\n|       \"value\" : 22.821,                                                   |\n|       \"unit\" : \"Credits\",                                                 |\n|       \"perTimeUnit\" : \"MONTH\"                                             |\n|     },                                                                    |\n|     \"computationMethod\" : \"Estimated\",                                    |\n|     \"comment\" : \"Estimated from historic change rate over last ~7 days.\"  |\n|   } ]                                                                     |\n| }                                                                         |\n+---------------------------------------------------------------------------+",
    "arguments": [
        {
            "name": "table_name",
            "description": "Table for which you want to estimate the search optimization costs. If the table name is not fully-qualified (in the form of db_name . schema_name . table_name or schema_name . table_name ), the function looks for the table in the current schema for the session. The entire name must be enclosed in single quotes."
        },
        {
            "name": "search_method_with_target",
            "description": "Specifies a search method and target for a column configuration similar to what can be\nspecified in the ON clause of the ALTER TABLE … ADD SEARCH\nOPTIMIZATION command. This entire argument must be enclosed in single quotes. Within this string, use double quotes around column names where required ."
        }
    ]
},
{
    "function_name": "SYSTEM$ESTIMATE_QUERY_ACCELERATION",
    "summary": "For a previously executed query, this function returns a JSON object that specifies if the query is eligible to benefit from the query acceleration service.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_estimate_query_acceleration",
    "title": "SYSTEM$ESTIMATE_QUERY_ACCELERATION",
    "description": "For a previously executed query, this function returns a JSON object that specifies if the query is eligible to benefit from the",
    "syntax": "SYSTEM$ESTIMATE_QUERY_ACCELERATION( '<query_id>' )"
},
{
    "function_name": "SYSTEM$ESTIMATE_AUTOMATIC_CLUSTERING_COSTS",
    "summary": "Returns estimated costs associated with enabling Automatic Clustering for a table.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_estimate_automatic_clustering_costs",
    "title": "SYSTEM$ESTIMATE_AUTOMATIC_CLUSTERING_COSTS",
    "description": "Returns estimated costs associated with enabling",
    "syntax": "SYSTEM$ESTIMATE_AUTOMATIC_CLUSTERING_COSTS( '<table_name>' ,\n [ '( <expr1> [ , <expr2> ... ] )' ] )",
    "example": "SELECT SYSTEM$ESTIMATE_AUTOMATIC_CLUSTERING_COSTS('myTable', '(day, tenantId)');\n\n{\n  \"reportTime\": \"Fri, 12 Jul 2024 01:06:18 GMT\",\n  \"clusteringKey\": \"LINEAR(day, tenantId)\",\n  \"initial\": {\n    \"unit\": \"Credits\",\n    \"value\": 98.2,\n    \"comment\": \"Total upper bound of one-time cost\"\n  },\n  \"maintenance\": {\n    \"unit\": \"Credits\",\n    \"value\": 10.0,\n    \"comment\": \"Daily maintenance cost estimate provided based on DML history from the\n    past seven days.\"\n  }\n}",
    "arguments": [
        {
            "name": "table_name",
            "description": "Name of the table for which you want to return the estimated cost of clustering."
        },
        {
            "name": "(",
            "description": "The proposed cluster key for the table is where each expression resolves to a table column. The function estimates the cost of\nclustering the table using these columns as the cluster key."
        }
    ],
    "returns": "A value of type VARCHAR. The returned string is in JSON format and contains the following name/value pairs:"
},
{
    "function_name": "SYSTEM$END_DEBUG_APPLICATION",
    "summary": "Disables session debug mode for a",
    "category": "native-app",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_end_debug_application",
    "title": "SYSTEM$END_DEBUG_APPLICATION",
    "syntax": "SYSTEM$END_DEBUG_APPLICATION()"
},
{
    "function_name": "SYSTEM$ENABLE_PREVIEW_ACCESS",
    "summary": "Enables access to open preview features.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_enable_preview_access",
    "title": "SYSTEM$ENABLE_PREVIEW_ACCESS",
    "description": "Enables access to",
    "syntax": "SYSTEM$ENABLE_PREVIEW_ACCESS()",
    "example": "USE ROLE ACCOUNTADMIN;\nSELECT SYSTEM$ENABLE_PREVIEW_ACCESS();",
    "returns": "Returns a VARCHAR status message that open preview features have been enabled:"
},
{
    "function_name": "SYSTEM$ENABLE_GLOBAL_DATA_SHARING_FOR_ACCOUNT",
    "summary": "Enables Cross-Cloud Auto-Fulfillment on an account.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_enable_global_data_sharing_for_account",
    "title": "SYSTEM$ENABLE_GLOBAL_DATA_SHARING_FOR_ACCOUNT",
    "description": "Enables Cross-Cloud Auto-Fulfillment on an account. Cross-Cloud Auto-Fulfillment allows you to automatically provide the share or application package attached to your listing to other Snowflake consumer regions.",
    "syntax": "SYSTEM$ENABLE_GLOBAL_DATA_SHARING_FOR_ACCOUNT( '<account_name>' )",
    "example": "SELECT SYSTEM$ENABLE_GLOBAL_DATA_SHARING_FOR_ACCOUNT('my_account');\n\n+--------------------------------------------------------------------+\n| SYSTEM$SYSTEM$ENABLE_GLOBAL_DATA_SHARING_FOR_ACCOUNT('my_account') |\n|--------------------------------------------------------------------|\n| Statement executed successfully                                    |\n+--------------------------------------------------------------------+",
    "arguments": [
        {
            "name": "account_name",
            "description": "Specifies the account on which to enable Cross-Cloud Auto-Fulfillment. To learn more about Snowflake account identifiers and how to locate them, see Account identifiers ."
        }
    ],
    "returns": "Returns the VARCHAR value Statement executed successfully if the function successfully enables Cross-Cloud Auto-Fulfillment on the account."
},
{
    "function_name": "SYSTEM$ENABLE_BEHAVIOR_CHANGE_BUNDLE",
    "summary": "Enables behavior changes included in the specified behavior change release bundle for the current account.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_enable_behavior_change_bundle",
    "title": "SYSTEM$ENABLE_BEHAVIOR_CHANGE_BUNDLE",
    "description": "Enables behavior changes included in the specified",
    "syntax": "SYSTEM$ENABLE_BEHAVIOR_CHANGE_BUNDLE( '<bundle_name>' )",
    "example": "SELECT SYSTEM$ENABLE_BEHAVIOR_CHANGE_BUNDLE('2020_08');\n\n+-------------------------------------------------+\n| SYSTEM$ENABLE_BEHAVIOR_CHANGE_BUNDLE('2020_08') |\n|-------------------------------------------------|\n| ENABLED                                         |\n+-------------------------------------------------+",
    "arguments": [
        {
            "name": "bundle_name",
            "description": "Name of the behavior change bundle, specified as a string. To obtain the name for a bundle, see Behavior change log ."
        }
    ],
    "returns": "Returns the VARCHAR value ENABLED if the function successfully enables the behavior changes."
},
{
    "function_name": "SYSTEM$DISABLE_PREVIEW_ACCESS",
    "summary": "Disables access to open preview and private preview features.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_disable_preview_access",
    "title": "SYSTEM$DISABLE_PREVIEW_ACCESS",
    "description": "Disables access to",
    "syntax": "SYSTEM$DISABLE_PREVIEW_ACCESS()",
    "example": "USE ROLE ACCOUNTADMIN;\nSELECT SYSTEM$DISABLE_PREVIEW_ACCESS();",
    "returns": "Returns a VARCHAR status message that preview features have been disabled:"
},
{
    "function_name": "SYSTEM$DISABLE_GLOBAL_DATA_SHARING_FOR_ACCOUNT",
    "summary": "Disables Cross-Cloud Auto-Fulfillment on an account.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_disable_global_data_sharing_for_account",
    "title": "SYSTEM$DISABLE_GLOBAL_DATA_SHARING_FOR_ACCOUNT",
    "description": "Disables Cross-Cloud Auto-Fulfillment on an account.",
    "syntax": "SYSTEM$DISABLE_GLOBAL_DATA_SHARING_FOR_ACCOUNT( '<account_name>' )",
    "example": "SELECT SYSTEM$DISABLE_GLOBAL_DATA_SHARING_FOR_ACCOUNT('my_account');\n\n+--------------------------------------------------------------------+\n| SYSTEM$ENABLE_GLOBAL_DATA_SHARING_FOR_ACCOUNT('my_account') |\n|--------------------------------------------------------------------|\n| Statement executed successfully                                    |\n+--------------------------------------------------------------------+",
    "arguments": [
        {
            "name": "account_name",
            "description": "Specifies the account on which to disable Cross-Cloud Auto-Fulfillment. To learn more about Snowflake account identifiers and how to locate them, see Account identifiers ."
        }
    ],
    "returns": "Returns the VARCHAR value Statement executed successfully if the function successfully disables Cross-Cloud Auto-Fulfillment on the account."
},
{
    "function_name": "SYSTEM$DISABLE_DATABASE_REPLICATION",
    "summary": "Disable replication for a primary database and any secondary databases linked to it.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_disable_database_replication",
    "title": "SYSTEM$DISABLE_DATABASE_REPLICATION",
    "description": "Disable replication for a primary database and any secondary databases linked to it.",
    "syntax": "SYSTEM$DISABLE_DATABASE_REPLICATION('<db_name>');",
    "example": "SELECT SYSTEM$DISABLE_DATABASE_REPLICATION('mydb');",
    "arguments": [
        {
            "name": "db_name",
            "description": "Specifies the identifier for the database."
        }
    ]
},
{
    "function_name": "SYSTEM$DISABLE_BEHAVIOR_CHANGE_BUNDLE",
    "summary": "Disables the behavior changes included in the specified behavior change release bundle for the current account.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_disable_behavior_change_bundle",
    "title": "SYSTEM$DISABLE_BEHAVIOR_CHANGE_BUNDLE",
    "description": "Disables the behavior changes included in the specified",
    "syntax": "SYSTEM$DISABLE_BEHAVIOR_CHANGE_BUNDLE( '<bundle_name>' )",
    "example": "SELECT SYSTEM$DISABLE_BEHAVIOR_CHANGE_BUNDLE('2020_08');\n\n+--------------------------------------------------+\n| SYSTEM$DISABLE_BEHAVIOR_CHANGE_BUNDLE('2020_08') |\n|--------------------------------------------------|\n| DISABLED                                         |\n+--------------------------------------------------+",
    "arguments": [
        {
            "name": "bundle_name",
            "description": "Name of the behavior change bundle, specified as a string. To obtain the name for a bundle, see Behavior change log ."
        }
    ],
    "returns": "Returns the VARCHAR value DISABLED if the function successfully disables the behavior changes."
},
{
    "function_name": "SYSTEM$DEPROVISION_PRIVATELINK_ENDPOINT",
    "summary": "Deprovisions a private connectivity endpoint in the Snowflake VPC or VNet to prevent Snowflake from connecting to an external service using private connectivity.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_deprovision_privatelink_endpoint",
    "title": "SYSTEM$DEPROVISION_PRIVATELINK_ENDPOINT",
    "syntax": "SYSTEM$DEPROVISION_PRIVATELINK_ENDPOINT( '<provider_service_name>' )",
    "example": "SELECT SYSTEM$DEPROVISION_PRIVATELINK_ENDPOINT('com.amazonaws.us-west-2.s3');\n\nSELECT SYSTEM$DEPROVISION_PRIVATELINK_ENDPOINT(\n  '/subscriptions/f4b00c5f-f6bf-41d6-806b-e1cac4f1f36f/resourceGroups/aztest1-external-function-rg/providers/Microsoft.ApiManagement/service/aztest1-external-function-api',\n  'Gateway'\n  );\n\nPrivate endpoint with id \"/subscriptions/e48379a7-2fc4-473e-b071-f94858cc83f5/resourcegroups/test_rg/providers/microsoft.network/privateendpoints/5ef8fd34-07db-4583-b0dd-0e2360398ed3\" successfully marked for deletion. Before it is fully deleted in 7-8 days, it can be restored.\n\nSELECT SYSTEM$DEPROVISION_PRIVATELINK_ENDPOINT(\n  '/subscriptions/11111111-2222-3333-4444-5555555555/resourceGroups/leorg1/providers/Microsoft.Sql/servers/myserver/databases/testdb',\n  'sqlServer'\n  );\n\n\"Resource Endpoint with id \"/subscriptions/f0abb333-1b05-47c6-8c31-dd36d2512fd1/resourceGroups/privatelink-test/providers/Microsoft.Network/privateEndpoints/external-network-access-pe\" deprovisioned successfully\"\n\nSELECT SYSTEM$DEPROVISION_PRIVATELINK_ENDPOINT(\n  '/subscriptions/cb72345g5-d347-4sdc-r3ee-70d234551a78/resourceGroups/rg-db-dev/providers/Microsoft.Storage/storageAccounts/dbasdfffext',\n  'blob'\n);\n\n\"Resource Endpoint with id \"/subscriptions/57faea9a-20c2-4d35-b283-9c0c1e9593d8/resourceGroups/privatelink-test/providers/Microsoft.Network/privateEndpoints/external-network-access-pe\" deprovisioned successfully\"",
    "arguments": [
        {
            "name": "provider_service_name",
            "description": "Specifies the external service or resource endpoint. For example, com.amazonaws.us-west-2.execute-api for the Amazon API\nGateway or com.amazonaws.us-west-2.s3 for Amazon S3."
        },
        {
            "name": "'",
            "description": "Specifies the fully-qualified identifier for the resource in your VPC or VNet."
        },
        {
            "name": "'",
            "description": "Specifies the name of the subresource of the Azure resource. This argument is not required for Azure Private Link Service and Azure API Management Service. For all supported values, see the Sub-resource table ."
        }
    ],
    "returns": "Returns a status message stating that the endpoint, with its identifier, is deprovisioned successfully."
},
{
    "function_name": "SYSTEM$DECODE_PAT",
    "summary": "Returns information about a programmatic access token, given the secret for the token.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_decode_pat",
    "title": "SYSTEM$DECODE_PAT",
    "description": "Returns information about a",
    "syntax": "SYSTEM$DECODE_PAT( '<secret_for_programmatic_access_token>' )",
    "example": "SELECT SYSTEM$DECODE_PAT('abC...Y5Z');\n\n+------------------------------------------------------------------------+\n| SYSTEM$DECODE_PAT('☺☺☺...☺☺☺')                                         |\n|------------------------------------------------------------------------|\n| {\"STATE\":\"ACTIVE\",\"PAT_NAME\":\"MY_EXAMPLE_TOKEN\",\"USER_NAME\":\"MY_USER\"} |\n+------------------------------------------------------------------------+",
    "arguments": [
        {
            "name": "'",
            "description": "Secret for the programmatic access token."
        }
    ],
    "returns": "Returns a VARCHAR value containing the token information in a JSON object. The JSON object has the following fields:"
},
{
    "function_name": "SYSTEM$DATABASE_REFRESH_PROGRESS , SYSTEM$DATABASE_REFRESH_PROGRESS_BY_JOB — Deprecated",
    "summary": "The SYSTEM$DATABASE_REFRESH_PROGRESS family of functions can be used to query the status of a database refresh along various dimensions.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_database_refresh_progress",
    "title": "SYSTEM$DATABASE_REFRESH_PROGRESS , SYSTEM$DATABASE_REFRESH_PROGRESS_BY_JOB —",
    "syntax": "SYSTEM$DATABASE_REFRESH_PROGRESS( '<secondary_db_name>' )\n\nSYSTEM$DATABASE_REFRESH_PROGRESS_BY_JOB( '<query_id>' )",
    "example": "SELECT SYSTEM$DATABASE_REFRESH_PROGRESS('mydb');\n\nSELECT value:phaseName::string AS \"Phase\",\n  value:resultName::string AS \"Result\",\n  TO_TIMESTAMP_LTZ(value:startTimeUTC::numeric,3) AS \"startTime\",\n  TO_TIMESTAMP_LTZ(value:endTimeUTC::numeric,3) AS \"endTime\",\n  value:details AS \"details\"\n  FROM table(flatten(INPUT=> PARSE_JSON(SYSTEM$DATABASE_REFRESH_PROGRESS('mydb1'))));\n\nSELECT SYSTEM$DATABASE_REFRESH_PROGRESS_BY_JOB('4cbd7187-51f6-446c-9814-92d7f57d939b');\n\nSELECT value:phaseName::string AS \"Phase\",\n  value:resultName::string AS \"Result\",\n  TO_TIMESTAMP_LTZ(value:startTimeUTC::numeric,3) AS \"startTime\",\n  TO_TIMESTAMP_LTZ(value:endTimeUTC::numeric,3) AS \"endTime\",\n  value:details AS \"details\"\n  FROM TABLE(FLATTEN(input=> PARSE_JSON(SYSTEM$DATABASE_REFRESH_PROGRESS_BY_JOB('4cbd7187-51f6-446c-9814-92d7f57d939b'))));",
    "arguments": [
        {
            "name": "secondary_db_name",
            "description": "Name of the secondary database. This argument is optional if the secondary database is the active database in the current session. Note that the entire name must be enclosed in single quotes."
        },
        {
            "name": "query_id",
            "description": "ID of the database refresh query. The query ID can be obtained from the History page in the web interface."
        }
    ]
},
{
    "function_name": "SYSTEM$DATABASE_REFRESH_HISTORY — Deprecated",
    "summary": "Returns a JSON object showing the refresh history for a secondary database.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_database_refresh_history",
    "title": "SYSTEM$DATABASE_REFRESH_HISTORY —",
    "syntax": "SYSTEM$DATABASE_REFRESH_HISTORY( '<secondary_db_name>' )",
    "example": "SELECT SYSTEM$DATABASE_REFRESH_HISTORY('mydb');\n\nSELECT\n    to_timestamp_ltz(value:startTimeUTC::numeric,3) AS \"start_time\"\n    , to_timestamp_ltz(value:endTimeUTC::numeric,3) AS \"end_time\"\n    , value:currentPhase::string AS \"phase\"\n  , value:jobUUID::string AS \"query_ID\"\n  , value:copy_bytes::integer AS \"bytes_transferred\"\nFROM TABLE(flatten(INPUT=> PARSE_JSON(SYSTEM$DATABASE_REFRESH_HISTORY('mydb'))));",
    "arguments": [
        {
            "name": "secondary_db_name",
            "description": "Name of the secondary database. This argument is optional if the secondary database is the active database in the current session. Note that the entire name must be enclosed in single quotes."
        }
    ]
},
{
    "function_name": "SYSTEM$DATA_METRIC_SCAN",
    "summary": "Returns the rows identified by a data quality metric as containing data that failed a data quality check.",
    "category": "System functions , Table functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_data_metric_scan",
    "title": "SYSTEM$DATA_METRIC_SCAN",
    "syntax": "SYSTEM$DATA_METRIC_SCAN(\n  REF_ENTITY_NAME  => '<object>'\n  , METRIC_NAME  => '<data_metric_function>'\n  , ARGUMENT_NAME => '<column>'\n   [ , AT_TIMESTAMP => '<timestamp>' ] )",
    "example": "SELECT *\n  FROM TABLE(SYSTEM$DATA_METRIC_SCAN(\n    REF_ENTITY_NAME  => 'governance.sch.employeesTable',\n    METRIC_NAME  => 'snowflake.core.null_count',\n    ARGUMENT_NAME => 'SSN'\n  ));\n\nSELECT *\n  FROM TABLE(SYSTEM$DATA_METRIC_SCAN(\n    REF_ENTITY_NAME  => 'governance.sch.employeesTable',\n    METRIC_NAME  => 'snowflake.core.blank_count',\n    ARGUMENT_NAME => 'name',\n    AT_TIMESTAMP => '2024-08-28 02:00:00 -0700'\n  ));",
    "arguments": [
        {
            "name": "REF_ENTITY_NAME",
            "description": "Name of the table or view on which the specified data metric function will run. The function returns rows from this object."
        },
        {
            "name": "METRIC_NAME",
            "description": "Name of the system data metric that you want to run to evaluate the specified table or view. Only the following system functions are\nsupported: SNOWFLAKE.CORE.NULL_COUNT SNOWFLAKE.CORE.NULL_PERCENT SNOWFLAKE.CORE.BLANK_COUNT SNOWFLAKE.CORE.BLANK_PERCENT SNOWFLAKE.CORE.DUPLICATE_COUNT"
        },
        {
            "name": "ARGUMENT_NAME",
            "description": "Name of the column in the specified table or view that is being passed as an argument to the specified data metric function."
        },
        {
            "name": "AT_TIMESTAMP",
            "description": "Timestamp that is being passed as an argument to check the results of a DMF evaluation on the table or view in the past."
        }
    ],
    "returns": "Rows from the specified table or view."
},
{
    "function_name": "SYSTEM$CURRENT_USER_TASK_NAME",
    "summary": "Returns the name of the task currently executing when invoked from the statement or stored procedure defined by the task.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_current_user_task_name",
    "title": "SYSTEM$CURRENT_USER_TASK_NAME",
    "description": "Returns the name of the task currently executing when invoked from the statement or stored procedure defined by the task.",
    "syntax": "SYSTEM$CURRENT_USER_TASK_NAME()",
    "example": "CREATE TASK mytask\n  WAREHOUSE = mywh,\n  SCHEDULE = '5 MINUTE'\nAS\n  INSERT INTO mytable(ts, task) VALUES(CURRENT_TIMESTAMP, SYSTEM$CURRENT_USER_TASK_NAME());\n\nSELECT * FROM mytable;\n\n+-------------------------+------------------------------------+\n| TS                      | TASK                               |\n|-------------------------+------------------------------------|\n| 2018-11-15 07:41:33.463 | MYDB.PUBLIC.MYTASK                 |\n+-------------------------+------------------------------------+"
},
{
    "function_name": "SYSTEM$CREATE_BILLING_EVENTS",
    "summary": "Creates multiple billable events that track consumer usage of installed monetized applications.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_create_billing_events",
    "title": "SYSTEM$CREATE_BILLING_EVENTS",
    "syntax": "SYSTEM$CREATE_BILLING_EVENTS('<json_array_of_events>')",
    "arguments": [
        {
            "name": "'",
            "description": "A STRING containing a JSON array of objects. Each object specifies a billing event. Each JSON object contains the following key-value pairs: The following table describes these key-value pairs: Key-value pair Type Description \"class\" STRING Identifier for the custom event class. \"subclass\" STRING Identifier for the custom event subclass. This field is only used by the provider. \"start_timestamp\" INTEGER The start time (UTC) of the event as a Unix timestamp in milliseconds. \"timestamp\" INTEGER The timestamp (UTC) when the event was created as a Unix timestamp in milliseconds. \"base_charge\" DOUBLE The amount in US dollars to charge for the billable event. The value must be greater than zero, less than 99,999.99, and must not exceed two decimal places of precision. For example, 1.00 or 0.07 . \"objects\" STRING A JSON string array containing fully qualified object names that apply to the event. \"additional_info\" STRING A JSON string of key-value pairs the provider can use to send additional info."
        }
    ],
    "returns": "This function returns the following status messages:"
},
{
    "function_name": "SYSTEM$CREATE_BILLING_EVENT",
    "summary": "Creates a billable event that tracks consumer usage of an installed monetized application.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_create_billing_event",
    "title": "SYSTEM$CREATE_BILLING_EVENT",
    "syntax": "SYSTEM$CREATE_BILLING_EVENT(\n '<class>',\n '<subclass>',\n <start_timestamp>,\n <timestamp>,\n <base_charge>,\n '<objects>',\n '<additional_info>'\n )",
    "arguments": [
        {
            "name": "'",
            "description": "Identifier for the custom event class. Type: STRING The identifier has the following requirements: Must start with a letter (A-Z) or an underscore (“_”). Must contain only letters, underscores, decimal digits (0-9), and dollar signs (“$”). Length cannot exceed 64 characters. Must not start with SNOWFLAKE_ . SNOWFLAKE_ is reserved for internal identifiers. The class name is stored and resolved as uppercase characters. Class name comparisons are case-insensitive."
        },
        {
            "name": "timestamp",
            "description": "Specifies the timestamp (UTC) when the event was created as a Unix timestamp in milliseconds. Type: Integer"
        },
        {
            "name": "base_charge",
            "description": "Specifies the amount in US dollars to charge for the billable event. The value must be greater than zero, less than 99,999.99, and must not exceed two decimal places of precision. For example, 1.00 or 0.07 . Type: DOUBLE"
        },
        {
            "name": "'",
            "description": "Identifier for the custom event subclass. This field is only used by the provider. Type: STRING The identifier has the same naming requirements as the class argument."
        },
        {
            "name": "start_timestamp",
            "description": "Specifies the start time (UTC) of the event as a Unix timestamp in milliseconds. Type: INTEGER Use to set the start time in cases where providers want to emit an event based on a time range; otherwise set to the same\nvalue used for the TIMESTAMP argument."
        },
        {
            "name": "'",
            "description": "A JSON string array containing fully qualified object names that apply to this event. Type: STRING The maximum size is 4 KB."
        },
        {
            "name": "'",
            "description": "A JSON string of key-value pairs the provider can use to send additional info. Type: STRING The maximum size is 4 KB."
        }
    ],
    "returns": "This function returns the following status messages:"
},
{
    "function_name": "SYSTEM$CONVERT_PIPES_SQS_TO_SNS",
    "summary": "Convert pipes using Amazon SQS (Simple Queue Service) notifications to the Amazon Simple Notification Service (SNS) service for an S3 bucket.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_convert_pipes_sqs_to_sns",
    "title": "SYSTEM$CONVERT_PIPES_SQS_TO_SNS",
    "description": "Convert pipes using Amazon SQS (Simple Queue Service) notifications to the Amazon Simple Notification Service (SNS) service for\nan S3 bucket.",
    "syntax": "SYSTEM$CONVERT_PIPES_SQS_TO_SNS( '<bucket_name>, '<sns_topic_arn>' )",
    "example": "SELECT SYSTEM$CONVERT_PIPES_SQS_TO_SNS(\n   'my_s3_bucket', 'arn:aws:sns:us-east-2:111122223333:sns_topic');",
    "arguments": [
        {
            "name": "bucket_name",
            "description": "Name of the S3 bucket."
        },
        {
            "name": "sns_topic_arn",
            "description": "ARN of Amazon SNS topic."
        }
    ]
},
{
    "function_name": "SYSTEM$COMMIT_MOVE_ORGANIZATION_ACCOUNT",
    "summary": "Finalizes the process of moving an organization account from one region to another.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_commit_move_organization_account",
    "title": "SYSTEM$COMMIT_MOVE_ORGANIZATION_ACCOUNT",
    "syntax": "SYSTEM$COMMIT_MOVE_ORGANIZATION_ACCOUNT( <grace_period> )",
    "example": "SELECT SYSTEM$COMMIT_MOVE_ORGANIZATION_ACCOUNT(14);",
    "arguments": [
        {
            "name": "grace_period",
            "description": "Specifies the number of days after which the organization account in the original region (that is, the source region) will be deleted."
        }
    ]
},
{
    "function_name": "SYSTEM$CLUSTERING_RATIO — Deprecated",
    "summary": "Calculates the clustering ratio for a table, based on one or more columns in the table.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_clustering_ratio",
    "title": "SYSTEM$CLUSTERING_RATIO —",
    "syntax": "SYSTEM$CLUSTERING_RATIO( '<table_name>' , '( <col1> [ , <col2> ... ] )' [ , '<predicate>' ] )",
    "example": "SELECT SYSTEM$CLUSTERING_RATIO('t2', '(col1, col3)');\n\n+-------------------------------+\n| SYSTEM$CLUSTERING_RATIO('T2') |\n|-------------------------------|\n|                          77.1 |\n+-------------------------------+\n\nSELECT SYSTEM$CLUSTERING_RATIO('t2', '(col1, col2)', 'col1 = ''A''');\n\n+-------------------------------+\n| SYSTEM$CLUSTERING_RATIO('T2') |\n|-------------------------------|\n|                          87.7 |\n+-------------------------------+\n\nSELECT SYSTEM$CLUSTERING_RATIO('t1');\n\n+-------------------------------+\n| SYSTEM$CLUSTERING_RATIO('T1') |\n|-------------------------------|\n|                         100.0 |\n+-------------------------------+",
    "arguments": [
        {
            "name": "table_name",
            "description": "Table for which you want to calculate the clustering ratio."
        },
        {
            "name": "col1",
            "description": "Column(s) in the table used to calculate the clustering ratio: For a table with no clustering key, this argument is required. If this argument is omitted, an error is returned. For a table with a clustering key, this argument is optional; if the argument is omitted, Snowflake uses the defined clustering key to calculate the ratio. Note You can use this argument to calculate the ratio for any columns in the table, regardless of the clustering key defined for the table."
        },
        {
            "name": "predicate",
            "description": "Clause that filters the range of values in the columns on which to calculate the clustering ratio. Note that predicate does not utilize a WHERE keyword at the beginning of the clause."
        }
    ]
},
{
    "function_name": "SYSTEM$CLUSTERING_INFORMATION",
    "summary": "Returns clustering information, including average clustering depth, for a table based on one or more columns in the table.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_clustering_information",
    "title": "SYSTEM$CLUSTERING_INFORMATION",
    "description": "Returns clustering information, including average clustering depth, for a table based on one or more columns in the table.",
    "syntax": "SYSTEM$CLUSTERING_INFORMATION( '<table_name>'\n    [ , { '( <expr1> [ , <expr2> ... ] )' | <number_of_errors> } ] )",
    "example": "SELECT SYSTEM$CLUSTERING_INFORMATION('t1', 5);\n\nSELECT SYSTEM$CLUSTERING_INFORMATION('test2', '(col1, col3)');\n\n+--------------------------------------------------------------------+\n| SYSTEM$CLUSTERING_INFORMATION('TEST2', '(COL1, COL3)')             |\n|--------------------------------------------------------------------|\n| {                                                                  |\n|   \"cluster_by_keys\" : \"LINEAR(COL1, COL3)\",                        |\n|   \"total_partition_count\" : 1156,                                  |\n|   \"total_constant_partition_count\" : 0,                            |\n|   \"average_overlaps\" : 117.5484,                                   |\n|   \"average_depth\" : 64.0701,                                       |\n|   \"partition_depth_histogram\" : {                                  |\n|     \"00000\" : 0,                                                   |\n|     \"00001\" : 0,                                                   |\n|     \"00002\" : 3,                                                   |\n|     \"00003\" : 3,                                                   |\n|     \"00004\" : 4,                                                   |\n|     \"00005\" : 6,                                                   |\n|     \"00006\" : 3,                                                   |\n|     \"00007\" : 5,                                                   |\n|     \"00008\" : 10,                                                  |\n|     \"00009\" : 5,                                                   |\n|     \"00010\" : 7,                                                   |\n|     \"00011\" : 6,                                                   |\n|     \"00012\" : 8,                                                   |\n|     \"00013\" : 8,                                                   |\n|     \"00014\" : 9,                                                   |\n|     \"00015\" : 8,                                                   |\n|     \"00016\" : 6,                                                   |\n|     \"00032\" : 98,                                                  |\n|     \"00064\" : 269,                                                 |\n|     \"00128\" : 698                                                  |\n|   },                                                               |\n|   \"clustering_errors\" : [ {                                        |\n|      \"timestamp\" : \"2023-04-03 17:50:42 +0000\",                    |\n|      \"error\" : \"(003325) Clustering service has been disabled.\\n\"  |\n|      }                                                             |\n|   ]                                                                |\n| }                                                                  |\n+--------------------------------------------------------------------+",
    "arguments": [
        {
            "name": "table_name",
            "description": "Table for which you want to return clustering information."
        },
        {
            "name": "(",
            "description": "Column names or expressions for which clustering information is returned: For a table with no clustering key, this argument is required. If this argument is omitted, an error is returned. For a table with a clustering key, this argument is optional; if the argument is omitted, Snowflake uses the defined clustering key to return clustering information. Even if only one column name or expression is passed, it must be inside parentheses. Note You can use this argument to return clustering information for any columns in the table, regardless of whether a clustering key is defined for the table. In other words, you can use this to help you decide what clustering to use in the future."
        },
        {
            "name": "number_of_errors",
            "description": "Number of clustering errors returned by the function. If this argument is omitted, the 10 most recent errors are returned."
        }
    ],
    "returns": "The function returns a value of type VARCHAR."
},
{
    "function_name": "SYSTEM$CLUSTERING_DEPTH",
    "summary": "Computes the average depth of the table according to the specified columns (or the clustering key defined for the table).",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_clustering_depth",
    "title": "SYSTEM$CLUSTERING_DEPTH",
    "description": "Computes the average depth of the table according to the specified columns (or the clustering key defined for the table). The average depth of a populated table (i.e. a table containing\ndata) is always",
    "syntax": "SYSTEM$CLUSTERING_DEPTH( '<table_name>' , '( <col1> [ , <col2> ... ] )' [ , '<predicate>' ] )",
    "example": "SELECT SYSTEM$CLUSTERING_DEPTH('TPCH_ORDERS');\n\n+----------------------------------------+\n| SYSTEM$CLUSTERING_DEPTH('TPCH_ORDERS') |\n|----------------------------------------+\n| 2.4865                                 |\n+----------------------------------------+\n\nSELECT SYSTEM$CLUSTERING_DEPTH('TPCH_ORDERS', '(C2, C9)');\n\n+----------------------------------------------------+\n| SYSTEM$CLUSTERING_DEPTH('TPCH_ORDERS', '(C2, C9)') |\n+----------------------------------------------------+\n| 23.1351                                            |\n+----------------------------------------------------+\n\nSELECT SYSTEM$CLUSTERING_DEPTH('TPCH_ORDERS', '(C2, C9)', 'C2 = 25');\n\n+----------------------------------------------------+\n| SYSTEM$CLUSTERING_DEPTH('TPCH_ORDERS', '(C2, C9)') |\n+----------------------------------------------------+\n| 11.2452                                            |\n+----------------------------------------------------+",
    "arguments": [
        {
            "name": "table_name",
            "description": "Table for which you want to calculate the clustering depth."
        },
        {
            "name": "col1",
            "description": "Column(s) in the table used to calculate the clustering depth: For a table with no clustering key, this argument is required. If this argument is omitted, an error is returned. For a table with a clustering key, this argument is optional; if the argument is omitted, Snowflake uses the defined clustering key to calculate the depth. Note You can use this argument to calculate the depth for any columns in the table, regardless of the clustering key defined for the table."
        },
        {
            "name": "predicate",
            "description": "Clause that filters the range of values in the columns on which to calculate the clustering depth. Note that predicate does not utilize a WHERE keyword at the beginning of the clause."
        }
    ]
},
{
    "function_name": "SYSTEM$CLIENT_VERSION_INFO",
    "summary": "Returns version information for Snowflake clients and drivers.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_client_version_info",
    "title": "SYSTEM$CLIENT_VERSION_INFO",
    "description": "Returns version information for Snowflake clients and drivers.",
    "syntax": "SYSTEM$CLIENT_VERSION_INFO()",
    "example": "SELECT SYSTEM$CLIENT_VERSION_INFO();\n\n[\n  {\n    \"clientId\": \"DOTNETDriver\",\n    \"clientAppId\": \".NET\",\n    \"minimumSupportedVersion\": \"2.0.9\",\n    \"minimumNearingEndOfSupportVersion\": \"2.0.11\",\n    \"recommendedVersion\": \"2.1.5\",\n    \"deprecatedVersions\": [],\n    \"_customSupportedVersions_\": []\n  },\n  {\n    \"clientId\": \"GO\",\n    \"clientAppId\": \"Go\",\n    \"minimumSupportedVersion\": \"1.6.6\",\n    \"minimumNearingEndOfSupportVersion\": \"1.6.9\",\n    \"recommendedVersion\": \"1.7.1\",\n    \"deprecatedVersions\": [],\n    \"_customSupportedVersions_\": [\n      \"1.1.5\"\n    ]\n  },\n  {\n    \"clientId\": \"JDBC\",\n    \"clientAppId\": \"JDBC\",\n    \"minimumSupportedVersion\": \"3.13.14\",\n    \"minimumNearingEndOfSupportVersion\": \"3.13.18\",\n    \"recommendedVersion\": \"3.14.4\",\n    \"deprecatedVersions\": [],\n    \"_customSupportedVersions_\": []\n  },\n  {\n    \"clientId\": \"JSDriver\",\n    \"clientAppId\": \"JavaScript\",\n    \"minimumSupportedVersion\": \"1.6.6\",\n    \"minimumNearingEndOfSupportVersion\": \"1.6.9\",\n    \"recommendedVersion\": \"1.9.2\",\n    \"deprecatedVersions\": [],\n    \"_customSupportedVersions_\": []\n  },\n  {\n    \"clientId\": \"ODBC\",\n    \"clientAppId\": \"ODBC\",\n    \"minimumSupportedVersion\": \"2.24.5\",\n    \"minimumNearingEndOfSupportVersion\": \"2.24.7\",\n    \"recommendedVersion\": \"3.1.4\",\n    \"deprecatedVersions\": [],\n    \"_customSupportedVersions_\": []\n  },\n  {\n    \"clientId\": \"PHP_PDO\",\n    \"clientAppId\": \"PDO\",\n    \"minimumSupportedVersion\": \"1.2.0\",\n    \"minimumNearingEndOfSupportVersion\": \"1.2.1\",\n    \"recommendedVersion\": \"2.0.1\",\n    \"deprecatedVersions\": [],\n    \"_customSupportedVersions_\": []\n  },\n  {\n    \"clientId\": \"PythonConnector\",\n    \"clientAppId\": \"PythonConnector\",\n    \"minimumSupportedVersion\": \"2.7.3\",\n    \"minimumNearingEndOfSupportVersion\": \"2.7.7\",\n    \"recommendedVersion\": \"3.6.0\",\n    \"deprecatedVersions\": [],\n    \"_customSupportedVersions_\": []\n  },\n  {\n    \"clientId\": \"SnowSQL\",\n    \"clientAppId\": \"SnowSQL\",\n    \"minimumSupportedVersion\": \"1.2.21\",\n    \"minimumNearingEndOfSupportVersion\": \"1.2.21\",\n    \"recommendedVersion\": \"1.2.31\",\n    \"deprecatedVersions\": [],\n    \"_customSupportedVersions_\": []\n  },\n  {\n    \"clientId\": \"SQLAPI\",\n    \"clientAppId\": \"SQLAPI\",\n    \"minimumSupportedVersion\": \"1.0.0\",\n    \"minimumNearingEndOfSupportVersion\": \"\",\n    \"recommendedVersion\": \"\",\n    \"deprecatedVersions\": [],\n    \"_customSupportedVersions_\": []\n  }\n]\n\nWITH output AS (\n  SELECT\n    PARSE_JSON(SYSTEM$CLIENT_VERSION_INFO()) a\n)\nSELECT\n    value:clientAppId::STRING AS client_app_id,\n    value:minimumSupportedVersion::STRING AS minimum_version,\n    value:minimumNearingEndOfSupportVersion::STRING AS near_end_of_support_version,\n    value:recommendedVersion::STRING AS recommended_version\n  FROM output r,\n    LATERAL FLATTEN(INPUT => r.a, MODE =>'array');\n\n+-----------------+-----------------+-----------------------------+---------------------+\n| CLIENT_APP_ID   | MINIMUM_VERSION | NEAR_END_OF_SUPPORT_VERSION | RECOMMENDED_VERSION |\n|-----------------+-----------------+-----------------------------+---------------------|\n| .NET            | 2.0.9           | 2.0.11                      | 2.1.5               |\n| Go              | 1.6.6           | 1.6.9                       | 1.7.1               |\n| JDBC            | 3.13.14         | 3.13.18                     | 3.14.4              |\n| JavaScript      | 1.6.6           | 1.6.9                       | 1.9.2               |\n| ODBC            | 2.23.5          | 2.24.7                      | 3.1.4               |\n| PDO             | 1.2.0           | 1.2.1                       | 2.0.1               |\n| PythonConnector | 2.7.3           | 2.7.7                       | 3.6.0               |\n| SnowSQL         | 1.2.21          | 1.2.21                      | 1.2.31              |\n| SQLAPI          | 1.0.0           |                             |                     |\n+-----------------+-----------------+-----------------------------+---------------------+\n\nWITH output AS (\n  SELECT\n    PARSE_JSON(SYSTEM$CLIENT_VERSION_INFO()) a\n)\nSELECT\n    value:clientId::STRING AS client_id,\n    value:minimumSupportedVersion::STRING AS minimum_version,\n    value:minimumNearingEndOfSupportVersion::STRING AS near_end_of_support_version,\n    value:recommendedVersion::STRING AS recommended_version\n  FROM output r,\n    LATERAL FLATTEN(INPUT => r.a, MODE =>'array')\n  WHERE client_id = 'JDBC';\n\n+-----------+-----------------+-----------------------------+---------------------+\n| CLIENT_ID | MINIMUM_VERSION | NEAR_END_OF_SUPPORT_VERSION | RECOMMENDED_VERSION |\n|-----------+-----------------+-----------------------------+---------------------|\n| JDBC      | 3.13.14         | 3.13.18                     | 3.14.4              |\n+-----------+-----------------+-----------------------------+---------------------+",
    "returns": "Return a string containing a JSON array of objects. Each object contains information about a specific client and driver, such as SnowSQL, the JDBC driver, and so on."
},
{
    "function_name": "SYSTEM$CLEANUP_DATABASE_ROLE_GRANTS",
    "summary": "Revokes privileges on dropped objects from the share and grants the database role to the share.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_cleanup_database_role_grants",
    "title": "SYSTEM$CLEANUP_DATABASE_ROLE_GRANTS",
    "description": "Revokes privileges on dropped objects from the share and grants the database role to the share.",
    "syntax": "SYSTEM$CLEANUP_DATABASE_ROLE_GRANTS( '<database_role_name>' , '<share_name>' )",
    "arguments": [
        {
            "name": "'",
            "description": "The name of the database role. If the identifier is not fully qualified in the form of db_name . database_role_name , the command uses the database role\nin the current database for the session."
        },
        {
            "name": "'",
            "description": "The name of the share."
        }
    ]
},
{
    "function_name": "SYSTEM$CANCEL_QUERY",
    "summary": "Cancels the specified query (or statement) if it is currently active/running.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_cancel_query",
    "title": "SYSTEM$CANCEL_QUERY",
    "description": "Cancels the specified query (or statement) if it is currently active/running.",
    "syntax": "SYSTEM$CANCEL_QUERY( <query_id> )",
    "example": "SELECT SYSTEM$CANCEL_QUERY('d5493e36-5e38-48c9-a47c-c476f2111ce5');\n\n+-------------------------------------------------------------+\n| SYSTEM$CANCEL_QUERY('D5493E36-5E38-48C9-A47C-C476F2111CE5') |\n|-------------------------------------------------------------|\n| query [d5493e36-5e38-48c9-a47c-c476f2111ce5] terminated.    |\n+-------------------------------------------------------------+",
    "arguments": [
        {
            "name": "query_id",
            "description": "Identifier for the query to cancel. To obtain the ID for a query executed within the last 14 days, log into the web interface and go to the History page."
        }
    ]
},
{
    "function_name": "SYSTEM$CANCEL_ALL_QUERIES",
    "summary": "Cancels all active/running queries in the specified session.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_cancel_all_queries",
    "title": "SYSTEM$CANCEL_ALL_QUERIES",
    "description": "Cancels all active/running queries in the specified session.",
    "syntax": "SYSTEM$CANCEL_ALL_QUERIES( <session_id> )",
    "example": "SELECT SYSTEM$CANCEL_ALL_QUERIES(1065153872298);\n\n+------------------------------------------+\n| SYSTEM$CANCEL_ALL_QUERIES(1065153872298) |\n|------------------------------------------|\n| 1 cancelled.                             |\n+------------------------------------------+",
    "arguments": [
        {
            "name": "session_id",
            "description": "Identifier for the session for which to cancel all queries. To obtain the ID for a session, log into the web interface as an account administrator (user with the ACCOUNTADMIN role) and go to: Account » Sessions"
        }
    ]
},
{
    "function_name": "SYSTEM$BLOCK_INTERNAL_STAGES_PUBLIC_ACCESS",
    "summary": "Prevents all public traffic from accessing the internal stage of the current Snowflake account on Microsoft Azure.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_block_internal_stages_public_access",
    "title": "SYSTEM$BLOCK_INTERNAL_STAGES_PUBLIC_ACCESS",
    "syntax": "SYSTEM$BLOCK_INTERNAL_STAGES_PUBLIC_ACCESS()",
    "example": "USE ROLE accountadmin;\n\nSELECT SYSTEM$BLOCK_INTERNAL_STAGES_PUBLIC_ACCESS();",
    "returns": "This function returns the following status messages:"
},
{
    "function_name": "SYSTEM$BEHAVIOR_CHANGE_BUNDLE_STATUS",
    "summary": "Returns the status of the specified behavior change release bundle for the current account.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_behavior_change_bundle_status",
    "title": "SYSTEM$BEHAVIOR_CHANGE_BUNDLE_STATUS",
    "description": "Returns the status of the specified",
    "syntax": "SYSTEM$BEHAVIOR_CHANGE_BUNDLE_STATUS( '<bundle_name>' )",
    "example": "SELECT SYSTEM$BEHAVIOR_CHANGE_BUNDLE_STATUS('2020_08');\n\n+-------------------------------------------------+\n| SYSTEM$BEHAVIOR_CHANGE_BUNDLE_STATUS('2020_08') |\n|-------------------------------------------------|\n| DISABLED                                        |\n+-------------------------------------------------+",
    "arguments": [
        {
            "name": "bundle_name",
            "description": "Name of the behavior change bundle, specified as a string. To obtain the name for a bundle, see Behavior change log ."
        }
    ],
    "returns": "Returns one of the following VARCHAR values:"
},
{
    "function_name": "SYSTEM$BEGIN_DEBUG_APPLICATION",
    "summary": "Enables session debug mode for a",
    "category": "native-app",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_begin_debug_application",
    "title": "SYSTEM$BEGIN_DEBUG_APPLICATION",
    "syntax": "SYSTEM$BEGIN_DEBUG_APPLICATION( '<app_name>' [ , <execution_mode>] )",
    "example": "SELECT SYSTEM$BEGIN_DEBUG_APPLICATION( 'hello_snowflake_app', execution_mode ='AS_APPLICATION')\n\nSELECT SYSTEM$BEGIN_DEBUG_APPLICATION( 'hello_snowflake_app', execution_mode = 'AS_SETUP_SCRIPT')",
    "arguments": [
        {
            "name": "'",
            "description": "The name of the app on which session debug mode is being enabled."
        },
        {
            "name": "execution_mode",
            "description": "The behavior of commands run during session debug mode. Possible values are: 'AS_APPLICATION' (DEFAULT) All statements are executed as using the same privileges as the app. This mimics the\nbehavior of the app in the consumer account. 'AS_SETUP_SCRIPT' All statements are executed using the same privileges as the setup script of the app. This\nallows providers to test the setup script using session debug mode."
        }
    ]
},
{
    "function_name": "SYSTEM$AUTO_REFRESH_STATUS",
    "summary": "Returns the automated refresh status for an externally managed Iceberg table.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_auto_refresh_status",
    "title": "SYSTEM$AUTO_REFRESH_STATUS",
    "description": "Returns the automated refresh status for an externally managed",
    "syntax": "SYSTEM$AUTO_REFRESH_STATUS('<table_name>')",
    "example": "SELECT SYSTEM$AUTO_REFRESH_STATUS('db1.schema1.my_iceberg_table');",
    "arguments": [
        {
            "name": "'",
            "description": "The name of the Iceberg table for which you want to retrieve the current automated refresh status. If using the fully qualified name, enclose the entire name in single quotes, including the database and schema.\nIf the table name is case-sensitive or includes any special characters or spaces, you must use double quotes.\nEnclose the double quotes within the single quotes, for example, '\"Table_Name\"' ."
        }
    ],
    "returns": "The function returns a JSON object containing the following name/value pairs:"
},
{
    "function_name": "SYSTEM$AUTHORIZE_STAGE_PRIVATELINK_ACCESS",
    "summary": "Authorizes Snowflake to access the Microsoft Azure Private Endpoint for Azure private endpoints for internal stages for the current account.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_authorize_stage_privatelink_access",
    "title": "SYSTEM$AUTHORIZE_STAGE_PRIVATELINK_ACCESS",
    "description": "Authorizes Snowflake to access the Microsoft Azure Private Endpoint for",
    "syntax": "-- Azure\nSYSTEM$AUTHORIZE_STAGE_PRIVATELINK_ACCESS( '<privateEndpointResourceID>' )",
    "example": "use role accountadmin;\n\nselect SYSTEM$AUTHORIZE_STAGE_PRIVATELINK_ACCESS('/subscriptions/subId/resourceGroups/rg1/providers/Microsoft.Network/privateEndpoints/pe1');",
    "arguments": [
        {
            "name": "'",
            "description": "The unique identifier for the Private Endpoint in Azure. Snowflake uses this endpoint value to access the internal stage through the Azure internal network to avoid the public Internet. For instructions on how to obtain this value, see Configuring private endpoints to access Snowflake internal stages ."
        }
    ]
},
{
    "function_name": "SYSTEM$AUTHORIZE_PRIVATELINK",
    "summary": "Enables private connectivity to the Snowflake service for the current account.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_authorize_privatelink",
    "title": "SYSTEM$AUTHORIZE_PRIVATELINK",
    "syntax": "SYSTEM$AUTHORIZE_PRIVATELINK( '<aws_id>' , '<federated_token>' )",
    "example": "USE ROLE ACCOUNTADMIN;\n\nselect SYSTEM$AUTHORIZE_PRIVATELINK(\n    '185...',\n    '{\n      \"Credentials\": {\n          \"AccessKeyId\": \"ASI...\",\n          \"SecretAccessKey\": \"enw...\",\n          \"SessionToken\": \"Fwo...\",\n          \"Expiration\": \"2021-01-07T19:06:23+00:00\"\n      },\n      \"FederatedUser\": {\n          \"FederatedUserId\": \"185...:sam\",\n          \"Arn\": \"arn:aws:sts::185...:federated-user/sam\"\n      },\n      \"PackedPolicySize\": 0\n  }'\n  );\n\nUSE ROLE ACCOUNTADMIN;\n\nselect SYSTEM$AUTHORIZE_PRIVATELINK(\n  '/subscriptions/26d.../resourcegroups/sf-1/providers/microsoft.network/privateendpoints/test-self-service',\n  'eyJ...');\n\nUSE ROLE ACCOUNTADMIN;\n\nselect SYSTEM$AUTHORIZE_PRIVATELINK(\n  'my-gcp-project-id',\n  'ya29.a0AcM612zT4pJaXdYfwgY8aiMoDE9W_xkqQ20coFTB1TJcImKDPo...'\n  );",
    "arguments": [
        {
            "name": "'",
            "description": "The 12-digit identifier that uniquely identifies your Amazon Web Services (AWS) account, as a string."
        },
        {
            "name": "'",
            "description": "The identifier that uniquely identifies your Snowflake account in Microsoft Azure (Azure) as a string."
        },
        {
            "name": "'",
            "description": "The federated token value that contains access credentials for a federated user as a string. To obtain this value, execute the appropriate command for the cloud platform that hosts your Snowflake account. Use the command-line tool\nprovided by the platform: For Snowflake on AWS: For Snowflake on Azure: Where: The unique identifier for your subscription. For example: 13c... To obtain this value, execute the following Azure CLI command in your command line environment: Note the output value in the SubscriptionID column, which is truncated in this example:"
        },
        {
            "name": "SubscriptionID",
            "description": "The unique identifier for your subscription. For example: 13c... To obtain this value, execute the following Azure CLI command in your command line environment: Note the output value in the SubscriptionID column, which is truncated in this example:"
        },
        {
            "name": "'",
            "description": "The identifier that uniquely identifies your Google Cloud (GCP) project, as a string."
        },
        {
            "name": "'",
            "description": "The access token value that contains access credentials for a Google Cloud user as a string."
        }
    ]
},
{
    "function_name": "SYSTEM$APPLICATION_GET_TRACE_LEVEL",
    "summary": "Returns the trace level for the specified object.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_application_get_trace_level",
    "title": "SYSTEM$APPLICATION_GET_TRACE_LEVEL",
    "description": "Returns the trace level for the specified object. The following objects are supported:",
    "syntax": "SYSTEM$APPLICATION_GET_TRACE_LEVEL( '<schema_name>.<object_name>' )",
    "example": "SELECT SYSTEM$APPLICATION_GET_TRACE_LEVEL('my_schema');",
    "arguments": [
        {
            "name": "'",
            "description": "The name of schema (or versioned schema) and object you want to determine the log\nlevel for."
        }
    ]
},
{
    "function_name": "SYSTEM$APPLICATION_GET_METRIC_LEVEL",
    "summary": "Returns the metric level for the specified object.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_application_get_metric_level",
    "title": "SYSTEM$APPLICATION_GET_METRIC_LEVEL",
    "description": "Returns the metric level for the specified object. The following objects are supported:",
    "syntax": "SYSTEM$APPLICATION_GET_METRIC_LEVEL( '<schema_name>.<object_name>' )",
    "arguments": [
        {
            "name": "'",
            "description": "The name of schema (or versioned schema) and object you want to determine the log\nlevel for."
        }
    ]
},
{
    "function_name": "SYSTEM$APPLICATION_GET_LOG_LEVEL",
    "summary": "Returns the log level for the specified object.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_application_get_log_level",
    "title": "SYSTEM$APPLICATION_GET_LOG_LEVEL",
    "description": "Returns the log level for the specified object. The following objects are supported:",
    "syntax": "SYSTEM$APPLICATION_GET_LOG_LEVEL( '<schema_name>.<object_name>' )",
    "arguments": [
        {
            "name": "'",
            "description": "The name of schema (or versioned schema) and object you want to determine the log\nlevel for."
        }
    ]
},
{
    "function_name": "SYSTEM$APP_COMPATIBILITY_CHECK",
    "summary": "Returns the Snowflake edition of the consumer account where an app is installed.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_app_compatibility_check",
    "title": "SYSTEM$APP_COMPATIBILITY_CHECK",
    "description": "Returns the",
    "syntax": "SYSTEM$APP_COMPATIBILITY_CHECK()",
    "example": "SELECT SYSTEM$APP_COMPATIBILITY_CHECK();\n\n{\n  \"ACCOUNT_EDITION\": \"STANDARD\"\n}",
    "returns": "Returns a VARCHAR value containing a JSON object. This object has the following\nstructure:"
},
{
    "function_name": "SYSTEM$ALLOWLIST_PRIVATELINK",
    "summary": "Returns hostnames and port numbers for AWS PrivateLink, Azure Private Link, and Google Cloud Private Service Connect deployments to add to your firewall’s allowed list so that you can access Snowflake from behind your firewall.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_allowlist_privatelink",
    "title": "SYSTEM$ALLOWLIST_PRIVATELINK",
    "description": "Returns hostnames and port numbers for",
    "syntax": "SYSTEM$ALLOWLIST_PRIVATELINK()",
    "example": "SELECT SYSTEM$ALLOWLIST_PRIVATELINK();\n\n[\n  {\"type\":\"SNOWFLAKE_DEPLOYMENT\", \"host\":\"xy12345.us-west-2.privatelink.snowflakecomputing.com\",\"port\":443},\n  {\"type\":\"STAGE\",                \"host\":\"sfc-ss-ds2-customer-stage.s3.us-west-2.amazonaws.com\",\"port\":443},\n  ...\n  {\"type\":\"SNOWSQL_REPO\",         \"host\":\"sfc-repo.snowflakecomputing.com\",                     \"port\":443},\n  ...\n  {\"type\":\"OUT_OF_BAND_TELEMETRY\",\"host\":\"client-telemetry.snowflakecomputing.com\",\"port\":443},\n  {\"type\":\"OCSP_CACHE\",           \"host\":\"ocsp.station00752.us-west-2.privatelink.snowflakecomputing.com\",\"port\":80}\n]\n\nSELECT t.VALUE:type::VARCHAR as type,\n       t.VALUE:host::VARCHAR as host,\n       t.VALUE:port as port\nFROM TABLE(FLATTEN(input => PARSE_JSON(SYSTEM$ALLOWLIST_PRIVATELINK()))) AS t;\n\n+-----------------------+---------------------------------------------------+------+\n| TYPE                  | HOST                                              | PORT |\n+-----------------------+---------------------------------------------------+------+\n| SNOWFLAKE_DEPLOYMENT  | xy12345.snowflakecomputing.com                    | 443  |\n| STAGE                 | sfc-customer-stage.s3.us-west-2.amazonaws.com     | 443  |\n  ...\n| SNOWSQL_REPO          | sfc-repo.snowflakecomputing.com                   | 443  |\n  ...\n| OCSP_CACHE            | ocsp.snowflakecomputing.com                       | 80   |\n  ...\n+-----------------------+---------------------------------------------------+------+",
    "returns": "The data type of the returned value is VARIANT. The value is an array of JSON structures. Each JSON structure contains three key/value\npairs:"
},
{
    "function_name": "SYSTEM$ALLOWLIST",
    "summary": "Returns hostnames and port numbers to add to your firewall’s allowed list so that you can access Snowflake from behind your firewall.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_allowlist",
    "title": "SYSTEM$ALLOWLIST",
    "description": "Returns hostnames and port numbers to add to your firewall’s allowed list so that you can access Snowflake from behind your firewall.\nThe output of this function can then be passed into",
    "syntax": "SYSTEM$ALLOWLIST()",
    "example": "SELECT SYSTEM$ALLOWLIST();\n\n[\n  {\"type\":\"SNOWFLAKE_DEPLOYMENT\", \"host\":\"xy12345.snowflakecomputing.com\",                 \"port\":443},\n  {\"type\":\"STAGE\",                \"host\":\"sfc-customer-stage.s3.us-west-2.amazonaws.com\",  \"port\":443},\n  ...\n  {\"type\":\"SNOWSQL_REPO\",         \"host\":\"sfc-repo.snowflakecomputing.com\",                \"port\":443},\n  ...\n  {\"type\":\"OCSP_CACHE\",           \"host\":\"ocsp.snowflakecomputing.com\",                    \"port\":80}\n  {\"type\":\"OCSP_RESPONDER\",       \"host\":\"o.ss2.us\",                                       \"port\":80},\n  ...\n]\n\nSELECT t.VALUE:type::VARCHAR as type,\n       t.VALUE:host::VARCHAR as host,\n       t.VALUE:port as port\nFROM TABLE(FLATTEN(input => PARSE_JSON(SYSTEM$ALLOWLIST()))) AS t;\n\n+-----------------------+---------------------------------------------------+------+\n| TYPE                  | HOST                                              | PORT |\n|-----------------------+---------------------------------------------------+------|\n| SNOWFLAKE_DEPLOYMENT  | xy12345.snowflakecomputing.com                    | 443  |\n| STAGE                 | sfc-customer-stage.s3.us-west-2.amazonaws.com     | 443  |\n  ...\n| SNOWSQL_REPO          | sfc-repo.snowflakecomputing.com                   | 443  |\n  ...\n| OCSP_CACHE            | ocsp.snowflakecomputing.com                       | 80   |\n| OCSP_RESPONDER        | ocsp.sca1b.amazontrust.com                        | 80   |\n  ...\n+-----------------------+---------------------------------------------------+------+",
    "returns": "The data type of the returned value is VARIANT. The value is an array of JSON structures. Each JSON structure contains three\nkey/value pairs:"
},
{
    "function_name": "SYSTEM$ADD_REFERENCE",
    "summary": "Called by a",
    "category": "native-app",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_add_reference",
    "title": "SYSTEM$ADD_REFERENCE",
    "description": "Called by a Snowflake Native App to associate a consumer reference string to a reference definition. The app can use this\nassociation to access the consumer object. The reference string passed to this system function is the value returned by the",
    "syntax": "SYSTEM$ADD_REFERENCE('<reference_name>', '<reference_string>')",
    "arguments": [
        {
            "name": "'",
            "description": "The name of the reference as specified in the manifest.yml file of the app."
        },
        {
            "name": "'",
            "description": "The system-generated ID of the reference to the object in the consumer account."
        }
    ]
},
{
    "function_name": "SYSTEM$ADD_EVENT (for Snowflake Scripting)",
    "summary": "Add an event for trace.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_add_event",
    "title": "SYSTEM$ADD_EVENT (for Snowflake Scripting)",
    "description": "Add an event for trace.",
    "syntax": "SYSTEM$ADD_EVENT('<name>', '<object>');",
    "example": "CREATE OR REPLACE PROCEDURE pi_proc()\n  RETURNS DOUBLE\n  LANGUAGE SQL\n  AS $$\n  BEGIN\n    -- Add an event without attributes\n    SYSTEM$ADD_EVENT('name_a');\n\n    -- Add an event with attributes\n    LET attr := {'score': 89, 'pass': TRUE};\n    SYSTEM$ADD_EVENT('name_b', attr);\n\n    -- Set attributes for the span\n    SYSTEM$SET_SPAN_ATTRIBUTES({'key1': 'value1', 'key2': TRUE});\n\n    RETURN 3.14;\n  END;\n  $$;",
    "arguments": [
        {
            "name": "'",
            "description": "The name of the event to add."
        },
        {
            "name": "'",
            "description": "An object containing name-value pairs representing the attributes to add."
        }
    ]
},
{
    "function_name": "SYSTEM$ABORT_TRANSACTION",
    "summary": "Aborts the specified transaction, if it is running.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_abort_transaction",
    "title": "SYSTEM$ABORT_TRANSACTION",
    "description": "Aborts the specified transaction, if it is running. If the transaction has already been committed or rolled back, then the state of the\ntransaction is not altered.",
    "syntax": "SYSTEM$ABORT_TRANSACTION(<transaction_id>)",
    "example": "SHOW LOCKS IN ACCOUNT;\n\n--------------+--------+---------------+---------------------------------+---------+---------------------------------+--------------------------------------+\n   session    | table  |  transaction  |     transaction_started_on      | status  |           acquired_on           |               query_id               |\n--------------+--------+---------------+---------------------------------+---------+---------------------------------+--------------------------------------+\n 103079321618 | ORDERS | 1442254688149 | Mon, 14 Sep 2015 11:18:08 -0700 | HOLDING | Mon, 14 Sep 2015 11:18:16 -0700 | 6a478582-9e8c-4603-b5bf-89b14c042e1a |\n 103079325702 | ORDERS | 1442255439400 | Mon, 14 Sep 2015 11:30:39 -0700 | WAITING | [NULL]                          | 82fea8a6-a679-4de1-b6e9-7a80905831cf |\n--------------+--------+---------------+---------------------------------+---------+---------------------------------+--------------------------------------+\n\nSELECT SYSTEM$ABORT_TRANSACTION(1442254688149);\n\n-----------------------------------------+\n SYSTEM$ABORT_TRANSACTION(1442254688149) |\n-----------------------------------------+\n Aborted transaction id: 1442254688149   |\n-----------------------------------------+",
    "arguments": [
        {
            "name": "transaction_id",
            "description": "Identifier for the transaction to abort. To obtain transaction IDs,\nyou can use the SHOW TRANSACTIONS or SHOW LOCKS commands."
        }
    ]
},
{
    "function_name": "SYSTEM$ABORT_SESSION",
    "summary": "Aborts the specified session.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/system_abort_session",
    "title": "SYSTEM$ABORT_SESSION",
    "description": "Aborts the specified session.",
    "syntax": "SYSTEM$ABORT_SESSION( <session_id> )",
    "example": "SELECT SYSTEM$ABORT_SESSION(1065153868222);\n\n+-------------------------------------+\n| SYSTEM$ABORT_SESSION(1065153868222) |\n|-------------------------------------|\n| session [1065153868222] terminated. |\n+-------------------------------------+",
    "arguments": [
        {
            "name": "session_id",
            "description": "Identifier for the session to abort. To obtain the ID for a session, log into the web interface as an account administrator (user with the ACCOUNTADMIN role) and go to: Account » Sessions"
        }
    ]
},
{
    "function_name": "SYSDATE",
    "summary": "Returns the current timestamp for the system in the UTC time zone.",
    "category": "Context functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/sysdate",
    "title": "SYSDATE",
    "description": "Returns the current timestamp for the system in the UTC time zone.",
    "syntax": "SYSDATE()",
    "example": "ALTER SESSION SET TIMESTAMP_NTZ_OUTPUT_FORMAT = 'YYYY-MM-DD HH24:MI:SS.FF4';\nALTER SESSION SET TIMESTAMP_LTZ_OUTPUT_FORMAT = 'YYYY-MM-DD HH24:MI:SS.FF4';\n\nALTER SESSION SET TIMEZONE = 'America/Los_Angeles';\n\nSELECT SYSDATE(), CURRENT_TIMESTAMP();\n\n+--------------------------+--------------------------+\n| SYSDATE()                | CURRENT_TIMESTAMP()      |\n|--------------------------+--------------------------|\n| 2024-04-17 22:47:54.3520 | 2024-04-17 15:47:54.3520 |\n+--------------------------+--------------------------+",
    "returns": "Returns the current timestamp in the UTC time zone."
},
{
    "function_name": "SUMMARIZE (SNOWFLAKE.CORTEX)",
    "summary": "Summarizes the given English-language input text.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/summarize-snowflake-cortex",
    "title": "SUMMARIZE (SNOWFLAKE.CORTEX)",
    "description": "Summarizes the given English-language input text.",
    "syntax": "SNOWFLAKE.CORTEX.SUMMARIZE(<text>)",
    "arguments": [
        {
            "name": "text",
            "description": "A string containing the English text from which a summary should be generated."
        }
    ],
    "returns": "A string containing a summary of the original text."
},
{
    "function_name": "SUM",
    "summary": "Returns the sum of non-NULL records for expr.",
    "category": "Aggregate functions , Window function syntax and usage",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/sum",
    "title": "SUM",
    "description": "Returns the sum of non-NULL records for",
    "syntax": "SUM( [ DISTINCT ] <expr1> )",
    "example": "CREATE OR REPLACE TABLE sum_example(k INT, d DECIMAL(10,5),\n                                    s1 VARCHAR(10), s2 VARCHAR(10));\n\nINSERT INTO sum_example VALUES\n  (1, 1.1, '1.1','one'),\n  (1, 10, '10','ten'),\n  (2, 2.2, '2.2','two'),\n  (2, null, null,'null'),\n  (3, null, null, 'null'),\n  (null, 9, '9.9','nine');\n\nSELECT * FROM sum_example;\n\n+------+----------+------+------+\n|    K |        D | S1   | S2   |\n|------+----------+------+------|\n|    1 |  1.10000 | 1.1  | one  |\n|    1 | 10.00000 | 10.0 | ten  |\n|    2 |  2.20000 | 2.2  | two  |\n|    2 |     NULL | NULL | null |\n|    3 |     NULL | NULL | null |\n| NULL |  9.00000 | 9.9  | nine |\n+------+----------+------+------+\n\nSELECT SUM(d), SUM(s1) FROM sum_example;\n\n+----------+---------+\n|   SUM(D) | SUM(S1) |\n|----------+---------|\n| 22.30000 |    23.2 |\n+----------+---------+\n\nSELECT k, SUM(d), SUM(s1) FROM sum_example GROUP BY k;\n\n+------+----------+---------+\n|    K |   SUM(D) | SUM(S1) |\n|------+----------+---------|\n|    1 | 11.10000 |    11.1 |\n|    2 |  2.20000 |     2.2 |\n|    3 |     NULL |    NULL |\n| NULL |  9.00000 |     9.9 |\n+------+----------+---------+\n\nSELECT SUM(s2) FROM sum_example;\n\n100038 (22018): Numeric value 'one' is not recognized\n\nCREATE OR REPLACE TABLE example_cumulative (p INT, o INT, i INT);\n\nINSERT INTO example_cumulative VALUES\n    (  0, 1, 10), (0, 2, 20), (0, 3, 30),\n    (100, 1, 10),(100, 2, 30),(100, 2, 5),(100, 3, 11),(100, 3, 120),\n    (200, 1, 10000),(200, 1, 200),(200, 1, 808080),(200, 2, 33333),(200, 3, null), (200, 3, 4),\n    (300, 1, null), (300, 1, null);\n\nSELECT\n    p, o, i,\n    COUNT(i) OVER (PARTITION BY p ORDER BY o ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) count_i_Rows_Pre,\n    SUM(i)   OVER (PARTITION BY p ORDER BY o ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) sum_i_Rows_Pre,\n    AVG(i)   OVER (PARTITION BY p ORDER BY o ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) avg_i_Rows_Pre,\n    MIN(i)   OVER (PARTITION BY p ORDER BY o ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) min_i_Rows_Pre,\n    MAX(i)   OVER (PARTITION BY p ORDER BY o ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) max_i_Rows_Pre\n  FROM example_cumulative\n  ORDER BY p,o;\n+-----+---+--------+------------------+----------------+----------------+----------------+----------------+\n|   P | O |      I | COUNT_I_ROWS_PRE | SUM_I_ROWS_PRE | AVG_I_ROWS_PRE | MIN_I_ROWS_PRE | MAX_I_ROWS_PRE |\n|-----+---+--------+------------------+----------------+----------------+----------------+----------------|\n|   0 | 1 |     10 |                1 |             10 |         10.000 |             10 |             10 |\n|   0 | 2 |     20 |                2 |             30 |         15.000 |             10 |             20 |\n|   0 | 3 |     30 |                3 |             60 |         20.000 |             10 |             30 |\n| 100 | 1 |     10 |                1 |             10 |         10.000 |             10 |             10 |\n| 100 | 2 |     30 |                2 |             40 |         20.000 |             10 |             30 |\n| 100 | 2 |      5 |                3 |             45 |         15.000 |              5 |             30 |\n| 100 | 3 |     11 |                4 |             56 |         14.000 |              5 |             30 |\n| 100 | 3 |    120 |                5 |            176 |         35.200 |              5 |            120 |\n| 200 | 1 |  10000 |                1 |          10000 |      10000.000 |          10000 |          10000 |\n| 200 | 1 |    200 |                2 |          10200 |       5100.000 |            200 |          10000 |\n| 200 | 1 | 808080 |                3 |         818280 |     272760.000 |            200 |         808080 |\n| 200 | 2 |  33333 |                4 |         851613 |     212903.250 |            200 |         808080 |\n| 200 | 3 |   NULL |                4 |         851613 |     212903.250 |            200 |         808080 |\n| 200 | 3 |      4 |                5 |         851617 |     170323.400 |              4 |         808080 |\n| 300 | 1 |   NULL |                0 |           NULL |           NULL |           NULL |           NULL |\n| 300 | 1 |   NULL |                0 |           NULL |           NULL |           NULL |           NULL |\n+-----+---+--------+------------------+----------------+----------------+----------------+----------------+",
    "arguments": [
        {
            "name": "expr1",
            "description": "This is an expression that evaluates to a numeric data type (INTEGER, FLOAT, DECIMAL, etc.)."
        },
        {
            "name": "expr2",
            "description": "This is the optional expression to partition by."
        },
        {
            "name": "expr3",
            "description": "This is the optional expression to order by within each partition. (This does not control the order of the\nentire query output.)"
        }
    ]
},
{
    "function_name": "SUBSTR , SUBSTRING",
    "summary": "Returns the portion of the string or binary value from base_expr, starting from the character/byte specified by start_expr, with optionally limited length.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/substr",
    "title": "SUBSTR , SUBSTRING",
    "description": "Returns the portion of the",
    "syntax": "SUBSTR( <base_expr>, <start_expr> [ , <length_expr> ] )\n\nSUBSTRING( <base_expr>, <start_expr> [ , <length_expr> ] )",
    "example": "SELECT SUBSTR('testing 1 2 3', 9, 3);\n\n+-------------------------------+\n| SUBSTR('TESTING 1 2 3', 9, 3) |\n|-------------------------------|\n| 1 2                           |\n+-------------------------------+\n\nCREATE OR REPLACE TABLE test_substr (\n    base_value VARCHAR,\n    start_value INT,\n    length_value INT)\n  AS SELECT\n    column1,\n    column2,\n    column3\n  FROM\n    VALUES\n      ('mystring', -1, 3),\n      ('mystring', -3, 3),\n      ('mystring', -3, 7),\n      ('mystring', -5, 3),\n      ('mystring', -7, 3),\n      ('mystring', 0, 3),\n      ('mystring', 0, 7),\n      ('mystring', 1, 3),\n      ('mystring', 1, 7),\n      ('mystring', 3, 3),\n      ('mystring', 3, 7),\n      ('mystring', 5, 3),\n      ('mystring', 5, 7),\n      ('mystring', 7, 3),\n      ('mystring', NULL, 3),\n      ('mystring', 3, NULL);\n\nSELECT base_value,\n       start_value,\n       length_value,\n       SUBSTR(base_value, start_value, length_value) AS substring\n  FROM test_substr;\n\n+------------+-------------+--------------+-----------+\n| BASE_VALUE | START_VALUE | LENGTH_VALUE | SUBSTRING |\n|------------+-------------+--------------+-----------|\n| mystring   |          -1 |            3 | g         |\n| mystring   |          -3 |            3 | ing       |\n| mystring   |          -3 |            7 | ing       |\n| mystring   |          -5 |            3 | tri       |\n| mystring   |          -7 |            3 | yst       |\n| mystring   |           0 |            3 | mys       |\n| mystring   |           0 |            7 | mystrin   |\n| mystring   |           1 |            3 | mys       |\n| mystring   |           1 |            7 | mystrin   |\n| mystring   |           3 |            3 | str       |\n| mystring   |           3 |            7 | string    |\n| mystring   |           5 |            3 | rin       |\n| mystring   |           5 |            7 | ring      |\n| mystring   |           7 |            3 | ng        |\n| mystring   |        NULL |            3 | NULL      |\n| mystring   |           3 |         NULL | NULL      |\n+------------+-------------+--------------+-----------+\n\nCREATE OR REPLACE TABLE customer_contact_example (\n    cust_id INT,\n    cust_email VARCHAR,\n    cust_phone VARCHAR,\n    activation_date VARCHAR)\n  AS SELECT\n    column1,\n    column2,\n    column3,\n    column4\n  FROM\n    VALUES\n      (1, 'some_text@example.com', '800-555-0100', '20210320'),\n      (2, 'some_other_text@example.org', '800-555-0101', '20240509'),\n      (3, 'some_different_text@example.net', '800-555-0102', '20191017');\n\nSELECT * from customer_contact_example;\n\n+---------+---------------------------------+--------------+-----------------+\n| CUST_ID | CUST_EMAIL                      | CUST_PHONE   | ACTIVATION_DATE |\n|---------+---------------------------------+--------------+-----------------|\n|       1 | some_text@example.com           | 800-555-0100 | 20210320        |\n|       2 | some_other_text@example.org     | 800-555-0101 | 20240509        |\n|       3 | some_different_text@example.net | 800-555-0102 | 20191017        |\n+---------+---------------------------------+--------------+-----------------+\n\nSELECT cust_id,\n       cust_email,\n       SUBSTR(cust_email, POSITION('@' IN cust_email) + 1) AS domain\n  FROM customer_contact_example;\n\n+---------+---------------------------------+-------------+\n| CUST_ID | CUST_EMAIL                      | DOMAIN      |\n|---------+---------------------------------+-------------|\n|       1 | some_text@example.com           | example.com |\n|       2 | some_other_text@example.org     | example.org |\n|       3 | some_different_text@example.net | example.net |\n+---------+---------------------------------+-------------+\n\nSELECT cust_id,\n       cust_phone,\n       SUBSTR(cust_phone, 1, 3) AS area_code\n  FROM customer_contact_example;\n\n+---------+--------------+-----------+\n| CUST_ID | CUST_PHONE   | AREA_CODE |\n|---------+--------------+-----------|\n|       1 | 800-555-0100 | 800       |\n|       2 | 800-555-0101 | 800       |\n|       3 | 800-555-0102 | 800       |\n+---------+--------------+-----------+\n\nSELECT cust_id,\n       cust_phone,\n       SUBSTR(cust_phone, 5) AS phone_without_area_code\n  FROM customer_contact_example;\n\n+---------+--------------+-------------------------+\n| CUST_ID | CUST_PHONE   | PHONE_WITHOUT_AREA_CODE |\n|---------+--------------+-------------------------|\n|       1 | 800-555-0100 | 555-0100                |\n|       2 | 800-555-0101 | 555-0101                |\n|       3 | 800-555-0102 | 555-0102                |\n+---------+--------------+-------------------------+\n\nSELECT cust_id,\n       activation_date,\n       SUBSTR(activation_date, 1, 4) AS year,\n       SUBSTR(activation_date, 5, 2) AS month,\n       SUBSTR(activation_date, 7, 2) AS day\n  FROM customer_contact_example;\n\n+---------+-----------------+------+-------+-----+\n| CUST_ID | ACTIVATION_DATE | YEAR | MONTH | DAY |\n|---------+-----------------+------+-------+-----|\n|       1 | 20210320        | 2021 | 03    | 20  |\n|       2 | 20240509        | 2024 | 05    | 09  |\n|       3 | 20191017        | 2019 | 10    | 17  |\n+---------+-----------------+------+-------+-----+",
    "arguments": [
        {
            "name": "base_expr",
            "description": "An expression that evaluates to a VARCHAR or BINARY value."
        },
        {
            "name": "start_expr",
            "description": "An expression that evaluates to an integer. It specifies the offset from which the substring starts. The offset is measured in: The number of UTF-8 characters if the input is a VARCHAR value. The number of bytes if the input is a BINARY value. The start position is 1-based, not 0-based. For example, SUBSTR('abc', 1, 1) returns a , not b ."
        },
        {
            "name": "length_expr",
            "description": "An expression that evaluates to an integer. It specifies: The number of UTF-8 characters to return if the input is VARCHAR. The number of bytes to return if the input is BINARY. Specify a length that is greater than or equal to zero. If the length is a negative number, the function returns an\nempty string."
        }
    ],
    "returns": "The data type of the returned value is the same as the data type of the base_expr (VARCHAR or BINARY)."
},
{
    "function_name": "STRTOK_TO_ARRAY",
    "summary": "Tokenizes the given string using the given set of delimiters and returns the tokens as an ARRAY value.",
    "category": "String & binary functions , Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/strtok_to_array",
    "title": "STRTOK_TO_ARRAY",
    "description": "Tokenizes the given string using the given set of delimiters and returns the tokens as an",
    "syntax": "STRTOK_TO_ARRAY( <string> [ , <delimiter> ] )",
    "example": "SELECT STRTOK_TO_ARRAY('a.b.c', '.') AS string_to_array;\n\n+-----------------+\n| STRING_TO_ARRAY |\n|-----------------|\n| [               |\n|   \"a\",          |\n|   \"b\",          |\n|   \"c\"           |\n| ]               |\n+-----------------+\n\nSELECT STRTOK_TO_ARRAY('user@snowflake.com', '.@') AS multiple_delimiters;\n\n+---------------------+\n| MULTIPLE_DELIMITERS |\n|---------------------|\n| [                   |\n|   \"user\",           |\n|   \"snowflake\",      |\n|   \"com\"             |\n| ]                   |\n+---------------------+",
    "arguments": [
        {
            "name": "string",
            "description": "Text to be tokenized."
        },
        {
            "name": "delimiter",
            "description": "Set of delimiters. Default: A single space character."
        }
    ],
    "returns": "This function returns a value of type ARRAY or NULL."
},
{
    "function_name": "STRTOK_SPLIT_TO_TABLE",
    "summary": "Tokenizes a string with the given set of delimiters and flattens the results into rows.",
    "category": "String & binary functions , Table functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/strtok_split_to_table",
    "title": "STRTOK_SPLIT_TO_TABLE",
    "description": "Tokenizes a string with the given set of delimiters and flattens the results into rows.",
    "syntax": "STRTOK_SPLIT_TO_TABLE(<string> [,<delimiter_list>])",
    "example": "SELECT table1.value\n  FROM TABLE(STRTOK_SPLIT_TO_TABLE('a.b', '.')) AS table1\n  ORDER BY table1.value;\n\n+-------+\n| VALUE |\n|-------|\n| a     |\n| b     |\n+-------+\n\nCREATE OR REPLACE TABLE splittable_strtok (v VARCHAR);\nINSERT INTO splittable_strtok (v) VALUES ('a b'), ('cde'), ('f|g'), ('');\nSELECT * FROM splittable_strtok;\n\n+-----+\n| V   |\n|-----|\n| a b |\n| cde |\n| f|g |\n|     |\n+-----+\n\nSELECT *\n  FROM splittable_strtok, LATERAL STRTOK_SPLIT_TO_TABLE(splittable_strtok.v, ' ')\n  ORDER BY SEQ, INDEX;\n\n+-----+-----+-------+-------+\n| V   | SEQ | INDEX | VALUE |\n|-----+-----+-------+-------|\n| a b |   1 |     1 | a     |\n| a b |   1 |     2 | b     |\n| cde |   2 |     1 | cde   |\n| f|g |   3 |     1 | f|g   |\n+-----+-----+-------+-------+\n\nSELECT *\n  FROM splittable_strtok, LATERAL STRTOK_SPLIT_TO_TABLE(splittable_strtok.v, ' |')\n  ORDER BY SEQ, INDEX;\n\n+-----+-----+-------+-------+\n| V   | SEQ | INDEX | VALUE |\n|-----+-----+-------+-------|\n| a b |   1 |     1 | a     |\n| a b |   1 |     2 | b     |\n| cde |   2 |     1 | cde   |\n| f|g |   3 |     1 | f     |\n| f|g |   3 |     2 | g     |\n+-----+-----+-------+-------+\n\nCREATE OR REPLACE TABLE authors_books_test2 (author VARCHAR, titles VARCHAR);\nINSERT INTO authors_books_test2 (author, titles) VALUES\n  ('Nathaniel Hawthorne', 'The Scarlet Letter ; The House of the Seven Gables;The Blithedale Romance'),\n  ('Herman Melville', 'Moby Dick,The Confidence-Man');\nSELECT * FROM authors_books_test2;\n\n+---------------------+---------------------------------------------------------------------------+\n| AUTHOR              | TITLES                                                                    |\n|---------------------+---------------------------------------------------------------------------|\n| Nathaniel Hawthorne | The Scarlet Letter ; The House of the Seven Gables;The Blithedale Romance |\n| Herman Melville     | Moby Dick,The Confidence-Man                                              |\n+---------------------+---------------------------------------------------------------------------+\n\nSELECT author, TRIM(value) AS title\n  FROM authors_books_test2, LATERAL STRTOK_SPLIT_TO_TABLE(titles, ',;')\n  ORDER BY author;\n\n+---------------------+-------------------------------+\n| AUTHOR              | TITLE                         |\n|---------------------+-------------------------------|\n| Herman Melville     | Moby Dick                     |\n| Herman Melville     | The Confidence-Man            |\n| Nathaniel Hawthorne | The Scarlet Letter            |\n| Nathaniel Hawthorne | The House of the Seven Gables |\n| Nathaniel Hawthorne | The Blithedale Romance        |\n+---------------------+-------------------------------+",
    "arguments": [
        {
            "name": "string",
            "description": "Text to be tokenized."
        },
        {
            "name": "delimiter_list",
            "description": "Optional set of delimiters. The default value is a single space character."
        }
    ]
},
{
    "function_name": "STRTOK",
    "summary": "Tokenizes a given string and returns the requested part.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/strtok",
    "title": "STRTOK",
    "description": "Tokenizes a given string and returns the requested part.",
    "syntax": "STRTOK(<string> [,<delimiter>] [,<partNr>])",
    "example": "SELECT STRTOK('a.b.c', '.', 1);\n+-------------------------+\n| STRTOK('A.B.C', '.', 1) |\n|-------------------------|\n| a                       |\n+-------------------------+\n\nSELECT STRTOK('user@snowflake.com', '@.', 1);\n+---------------------------------------+\n| STRTOK('USER@SNOWFLAKE.COM', '@.', 1) |\n|---------------------------------------|\n| user                                  |\n+---------------------------------------+\n\nSELECT STRTOK('user@snowflake.com', '@.', 2);\n+---------------------------------------+\n| STRTOK('USER@SNOWFLAKE.COM', '@.', 2) |\n|---------------------------------------|\n| snowflake                             |\n+---------------------------------------+\n\nSELECT STRTOK('user@snowflake.com', '@.', 3);\n+---------------------------------------+\n| STRTOK('USER@SNOWFLAKE.COM', '@.', 3) |\n|---------------------------------------|\n| com                                   |\n+---------------------------------------+\n\nselect strtok('user@snowflake.com.', '@.', 4);\n+----------------------------------------+\n| STRTOK('USER@SNOWFLAKE.COM.', '@.', 4) |\n|----------------------------------------|\n| NULL                                   |\n+----------------------------------------+\n\nselect strtok('', '', 1);\n+-------------------+\n| STRTOK('', '', 1) |\n|-------------------|\n| NULL              |\n+-------------------+\n\nselect strtok('a.b', '', 1);\n+----------------------+\n| STRTOK('A.B', '', 1) |\n|----------------------|\n| a.b                  |\n+----------------------+\n\nselect strtok(NULL, '.', 1);\n+----------------------+\n| STRTOK(NULL, '.', 1) |\n|----------------------|\n| NULL                 |\n+----------------------+\n\nselect strtok('a.b', NULL, 1);\n+------------------------+\n| STRTOK('A.B', NULL, 1) |\n|------------------------|\n| NULL                   |\n+------------------------+\n\nselect strtok('a.b', '.', NULL);\n+--------------------------+\n| STRTOK('A.B', '.', NULL) |\n|--------------------------|\n| NULL                     |\n+--------------------------+",
    "arguments": [
        {
            "name": "string",
            "description": "Text to be tokenized."
        },
        {
            "name": "delimiter",
            "description": "Text representing the set of delimiters to tokenize on. Each character in the delimiter string is a delimiter.\nIf the delimiter is empty, and the string is empty, then the function returns NULL. If the\ndelimiter is empty, and the string is non empty, then the whole string will be treated as one token.\nThe default value of the delimiter is a single space character."
        },
        {
            "name": "partNr",
            "description": "Requested token, which is 1-based (i.e. the first token is token number 1, not token number 0).\nIf the token number is out of range, then NULL is returned.\nThe default value is 1."
        }
    ],
    "returns": "The data type of the returned value is VARCHAR."
},
{
    "function_name": "STRIP_NULL_VALUE",
    "summary": "Converts a JSON null value to a SQL NULL value.",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/strip_null_value",
    "title": "STRIP_NULL_VALUE",
    "description": "Converts a",
    "syntax": "STRIP_NULL_VALUE( <variant_expr> )",
    "example": "CREATE OR REPLACE TABLE mytable\n(\n  SRC Variant\n);\n\nINSERT INTO mytable\n  SELECT PARSE_JSON(column1)\n  FROM VALUES\n  ('{\n  \"a\": \"1\",\n  \"b\": \"2\",\n  \"c\": null\n  }')\n  , ('{\n  \"a\": \"1\",\n  \"b\": \"2\",\n  \"c\": \"3\"\n  }');\n\nSELECT STRIP_NULL_VALUE(src:c) FROM mytable;\n\n+-------------------------+\n| STRIP_NULL_VALUE(SRC:C) |\n|-------------------------|\n| NULL                    |\n| \"3\"                     |\n+-------------------------+",
    "arguments": [
        {
            "name": "variant_expr",
            "description": "An expression of type VARIANT."
        }
    ],
    "returns": "If the expression contains a JSON null value, the function returns a SQL NULL."
},
{
    "function_name": "STDDEV_POP",
    "summary": "Returns the population standard deviation (square root of variance) of non-NULL values.",
    "category": "Aggregate functions , Window function syntax and usage",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/stddev_pop",
    "title": "STDDEV_POP",
    "description": "Returns the population standard deviation (square root of variance) of non-NULL values.",
    "syntax": "STDDEV_POP( [ DISTINCT ] <expr1>)",
    "arguments": [
        {
            "name": "expr1",
            "description": "An expression that evaluates to a numeric value. This is the expression on which the standard deviation is calculated."
        },
        {
            "name": "expr2",
            "description": "This is the optional expression to partition by."
        },
        {
            "name": "expr3",
            "description": "This is the optional expression to order by within each partition."
        }
    ],
    "returns": "The data type of the returned value is DOUBLE."
},
{
    "function_name": "STDDEV, STDDEV_SAMP",
    "summary": "Returns the sample standard deviation (square root of sample variance) of non-NULL values.",
    "category": "Aggregate functions , Window function syntax and usage",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/stddev",
    "title": "STDDEV, STDDEV_SAMP",
    "description": "Returns the sample standard deviation (square root of sample variance) of non-NULL values. STDDEV and STDDEV_SAMP are aliases\nfor the same function.",
    "syntax": "{ STDDEV | STDDEV_SAMP } ( [ DISTINCT ] <expr1> )",
    "arguments": [
        {
            "name": "expr1",
            "description": "An expression that evaluates to a numeric value. This is the expression on which the standard deviation is calculated."
        },
        {
            "name": "expr2",
            "description": "This is the optional expression to partition by."
        },
        {
            "name": "expr3",
            "description": "This is the optional expression to order by within each partition."
        }
    ],
    "returns": "The data type of the returned value is DOUBLE."
},
{
    "function_name": "STARTSWITH",
    "summary": "Returns true if expr1 starts with expr2.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/startswith",
    "title": "STARTSWITH",
    "description": "Returns true if",
    "syntax": "STARTSWITH( <expr1> , <expr2> )",
    "example": "select * from strings;\n\n---------+\n    S    |\n---------+\n coffee  |\n ice tea |\n latte   |\n tea     |\n [NULL]  |\n---------+\n\nselect * from strings where startswith(s, 'te');\n\n-----+\n  S  |\n-----+\n tea |\n-----+",
    "returns": "Returns a BOOLEAN. The value is TRUE if expr1 starts with expr2. Returns NULL if either\ninput expression is NULL. Otherwise, returns FALSE."
},
{
    "function_name": "STAGE_STORAGE_USAGE_HISTORY",
    "summary": "This table function can be used to query the average daily data storage usage, in bytes, for all the Snowflake stages in your account within a specified date range.",
    "category": "Information Schema , Table functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/stage_storage_usage_history",
    "title": "STAGE_STORAGE_USAGE_HISTORY",
    "description": "This table function can be used to query the average daily data storage usage, in bytes, for",
    "syntax": "STAGE_STORAGE_USAGE_HISTORY(\n      [ DATE_RANGE_START => <constant_expr> ]\n      [, DATE_RANGE_END => <constant_expr> ] )",
    "example": "select *\nfrom table(information_schema.stage_storage_usage_history(dateadd('days',-10,current_date()),current_date()));",
    "arguments": [
        {
            "name": "DATE_RANGE_START",
            "description": "The date range, within the last 6 months, for which to retrieve stage storage usage: If an end date is not specified, then CURRENT_DATE is used as the end of the range. If a start date is not specified, then DATE_RANGE_END is used as the start of the range (i.e. the default is one day of storage usage). If the range falls outside the last 6 months, an error is returned."
        }
    ]
},
{
    "function_name": "ST_YMIN",
    "summary": "Returns the minimum latitude (Y coordinate) of all points contained in the specified GEOGRAPHY or GEOMETRY object.",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/st_ymin",
    "title": "ST_YMIN",
    "description": "Returns the minimum latitude (Y coordinate) of all points contained in the specified",
    "syntax": "ST_YMIN( <geography_or_geometry_expression> )",
    "example": "CREATE or replace TABLE extreme_point_collection (id INTEGER, g GEOGRAPHY);\nINSERT INTO extreme_point_collection (id, g)\n    SELECT column1, TO_GEOGRAPHY(column2) FROM VALUES\n        (1, 'POINT(-180 0)'),\n        (2, 'POINT(180 0)'),\n        (3, 'LINESTRING(-179 0, 179 0)'),\n        (4, 'LINESTRING(-60 30, 60 30)'),\n        (5, 'LINESTRING(-60 -30, 60 -30)');\n\nSELECT\n    g,\n    ST_XMIN(g),\n    ST_XMAX(g),\n    ST_YMIN(g),\n    ST_YMAX(g)\n  FROM extreme_point_collection\n  ORDER BY id;\n+----------------------------+------------+------------+-------------------+-------------------+\n| G                          | ST_XMIN(G) | ST_XMAX(G) |        ST_YMIN(G) |        ST_YMAX(G) |\n|----------------------------+------------+------------+-------------------+-------------------|\n| POINT(-180 0)              |       -180 |        180 |   0               |   0               |\n| POINT(180 0)               |       -180 |        180 |   0               |   0               |\n| LINESTRING(-179 0,179 0)   |       -180 |        180 |  -6.883275617e-14 |   6.883275617e-14 |\n| LINESTRING(-60 30,60 30)   |        -60 |         60 |  30               |  49.106605351     |\n| LINESTRING(-60 -30,60 -30) |        -60 |         60 | -49.106605351     | -30               |\n+----------------------------+------------+------------+-------------------+-------------------+",
    "arguments": [
        {
            "name": "geography_or_geometry_expression",
            "description": "The argument must be an expression of type GEOGRAPHY or GEOMETRY."
        }
    ],
    "returns": "Returns a REAL value."
},
{
    "function_name": "STAGE_DIRECTORY_FILE_REGISTRATION_HISTORY",
    "summary": "This table function can be used to query information about the metadata history for a directory table.",
    "category": "Information Schema , Table functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/stage_directory_file_registration_history",
    "title": "STAGE_DIRECTORY_FILE_REGISTRATION_HISTORY",
    "description": "This table function can be used to query information about the metadata history for a directory table, including:",
    "syntax": "STAGE_DIRECTORY_FILE_REGISTRATION_HISTORY (\n      STAGE_NAME => '<string>'\n      [, START_TIME => <constant_expr> ] )",
    "example": "SELECT *\n  FROM TABLE(information_schema.stage_directory_file_registration_history(\n  STAGE_NAME=>'MYSTAGE'));\n\nSELECT *\n  FROM TABLE(information_schema.stage_directory_file_registration_history(\n    START_TIME=>DATEADD('hour',-1,current_timestamp()),\n    STAGE_NAME=>'mydb.public.mystage'));",
    "arguments": [
        {
            "name": "STAGE_NAME",
            "description": "A string specifying the name of a stage that has a directory table."
        },
        {
            "name": "START_TIME",
            "description": "Timestamp (in TIMESTAMP_LTZ format), within the last 14 days, marking the start of the time range for retrieving metadata update events. Note If no start time is specified, the function returns all update events within the last 14 days. If the start time falls outside the last 14 days, the function returns empty results."
        }
    ]
},
{
    "function_name": "ST_YMAX",
    "summary": "Returns the maximum latitude (Y coordinate) of all points contained in the specified GEOGRAPHY or GEOMETRY object.",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/st_ymax",
    "title": "ST_YMAX",
    "description": "Returns the maximum latitude (Y coordinate) of all points contained in the specified",
    "syntax": "ST_YMAX( <geography_or_geometry_expression> )",
    "example": "CREATE or replace TABLE extreme_point_collection (id INTEGER, g GEOGRAPHY);\nINSERT INTO extreme_point_collection (id, g)\n    SELECT column1, TO_GEOGRAPHY(column2) FROM VALUES\n        (1, 'POINT(-180 0)'),\n        (2, 'POINT(180 0)'),\n        (3, 'LINESTRING(-179 0, 179 0)'),\n        (4, 'LINESTRING(-60 30, 60 30)'),\n        (5, 'LINESTRING(-60 -30, 60 -30)');\n\nSELECT\n    g,\n    ST_XMIN(g),\n    ST_XMAX(g),\n    ST_YMIN(g),\n    ST_YMAX(g)\n  FROM extreme_point_collection\n  ORDER BY id;\n+----------------------------+------------+------------+-------------------+-------------------+\n| G                          | ST_XMIN(G) | ST_XMAX(G) |        ST_YMIN(G) |        ST_YMAX(G) |\n|----------------------------+------------+------------+-------------------+-------------------|\n| POINT(-180 0)              |       -180 |        180 |   0               |   0               |\n| POINT(180 0)               |       -180 |        180 |   0               |   0               |\n| LINESTRING(-179 0,179 0)   |       -180 |        180 |  -6.883275617e-14 |   6.883275617e-14 |\n| LINESTRING(-60 30,60 30)   |        -60 |         60 |  30               |  49.106605351     |\n| LINESTRING(-60 -30,60 -30) |        -60 |         60 | -49.106605351     | -30               |\n+----------------------------+------------+------------+-------------------+-------------------+",
    "arguments": [
        {
            "name": "geography_or_geometry_expression",
            "description": "The argument must be an expression of type GEOGRAPHY or GEOMETRY."
        }
    ],
    "returns": "Returns a REAL value."
},
{
    "function_name": "ST_Y",
    "summary": "Returns the latitude (Y coordinate) of a Point represented by a GEOGRAPHY or GEOMETRY object.",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/st_y",
    "title": "ST_Y",
    "description": "Returns the latitude (Y coordinate) of a Point represented by a",
    "syntax": "ST_Y( <geography_or_geometry_expression> )",
    "example": "SELECT ST_X(ST_MAKEPOINT(37.5, 45.5)), ST_Y(ST_MAKEPOINT(37.5, 45.5));\n+--------------------------------+--------------------------------+\n| ST_X(ST_MAKEPOINT(37.5, 45.5)) | ST_Y(ST_MAKEPOINT(37.5, 45.5)) |\n|--------------------------------+--------------------------------|\n|                           37.5 |                           45.5 |\n+--------------------------------+--------------------------------+\n\nSELECT\n    ST_X(ST_MAKEPOINT(NULL, NULL)), ST_X(NULL),\n    ST_Y(ST_MAKEPOINT(NULL, NULL)), ST_Y(NULL)\n    ;\n+--------------------------------+------------+--------------------------------+------------+\n| ST_X(ST_MAKEPOINT(NULL, NULL)) | ST_X(NULL) | ST_Y(ST_MAKEPOINT(NULL, NULL)) | ST_Y(NULL) |\n|--------------------------------+------------+--------------------------------+------------|\n|                           NULL |       NULL |                           NULL |       NULL |\n+--------------------------------+------------+--------------------------------+------------+",
    "arguments": [
        {
            "name": "geography_or_geometry_expression",
            "description": "The argument must be an expression of the type GEOGRAPHY or GEOMETRY and must contain a Point."
        }
    ],
    "returns": "Returns a REAL value."
},
{
    "function_name": "ST_XMIN",
    "summary": "Returns the minimum longitude (X coordinate) of all points contained in the specified GEOGRAPHY or GEOMETRY object.",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/st_xmin",
    "title": "ST_XMIN",
    "description": "Returns the minimum longitude (X coordinate) of all points contained in the specified",
    "syntax": "ST_XMIN( <geography_or_geometry_expression> )",
    "example": "CREATE or replace TABLE extreme_point_collection (id INTEGER, g GEOGRAPHY);\nINSERT INTO extreme_point_collection (id, g)\n    SELECT column1, TO_GEOGRAPHY(column2) FROM VALUES\n        (1, 'POINT(-180 0)'),\n        (2, 'POINT(180 0)'),\n        (3, 'LINESTRING(-179 0, 179 0)'),\n        (4, 'LINESTRING(-60 30, 60 30)'),\n        (5, 'LINESTRING(-60 -30, 60 -30)');\n\nSELECT\n    g,\n    ST_XMIN(g),\n    ST_XMAX(g),\n    ST_YMIN(g),\n    ST_YMAX(g)\n  FROM extreme_point_collection\n  ORDER BY id;\n+----------------------------+------------+------------+-------------------+-------------------+\n| G                          | ST_XMIN(G) | ST_XMAX(G) |        ST_YMIN(G) |        ST_YMAX(G) |\n|----------------------------+------------+------------+-------------------+-------------------|\n| POINT(-180 0)              |       -180 |        180 |   0               |   0               |\n| POINT(180 0)               |       -180 |        180 |   0               |   0               |\n| LINESTRING(-179 0,179 0)   |       -180 |        180 |  -6.883275617e-14 |   6.883275617e-14 |\n| LINESTRING(-60 30,60 30)   |        -60 |         60 |  30               |  49.106605351     |\n| LINESTRING(-60 -30,60 -30) |        -60 |         60 | -49.106605351     | -30               |\n+----------------------------+------------+------------+-------------------+-------------------+",
    "arguments": [
        {
            "name": "geography_or_geometry_expression",
            "description": "The argument must be an expression of type GEOGRAPHY or GEOMETRY."
        }
    ],
    "returns": "Returns a REAL value."
},
{
    "function_name": "ST_XMAX",
    "summary": "Returns the maximum longitude (X coordinate) of all points contained in the specified GEOGRAPHY or GEOMETRY object.",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/st_xmax",
    "title": "ST_XMAX",
    "description": "Returns the maximum longitude (X coordinate) of all points contained in the specified",
    "syntax": "ST_XMAX( <geography_or_geometry_expression> )",
    "example": "CREATE or replace TABLE extreme_point_collection (id INTEGER, g GEOGRAPHY);\nINSERT INTO extreme_point_collection (id, g)\n    SELECT column1, TO_GEOGRAPHY(column2) FROM VALUES\n        (1, 'POINT(-180 0)'),\n        (2, 'POINT(180 0)'),\n        (3, 'LINESTRING(-179 0, 179 0)'),\n        (4, 'LINESTRING(-60 30, 60 30)'),\n        (5, 'LINESTRING(-60 -30, 60 -30)');\n\nSELECT\n    g,\n    ST_XMIN(g),\n    ST_XMAX(g),\n    ST_YMIN(g),\n    ST_YMAX(g)\n  FROM extreme_point_collection\n  ORDER BY id;\n+----------------------------+------------+------------+-------------------+-------------------+\n| G                          | ST_XMIN(G) | ST_XMAX(G) |        ST_YMIN(G) |        ST_YMAX(G) |\n|----------------------------+------------+------------+-------------------+-------------------|\n| POINT(-180 0)              |       -180 |        180 |   0               |   0               |\n| POINT(180 0)               |       -180 |        180 |   0               |   0               |\n| LINESTRING(-179 0,179 0)   |       -180 |        180 |  -6.883275617e-14 |   6.883275617e-14 |\n| LINESTRING(-60 30,60 30)   |        -60 |         60 |  30               |  49.106605351     |\n| LINESTRING(-60 -30,60 -30) |        -60 |         60 | -49.106605351     | -30               |\n+----------------------------+------------+------------+-------------------+-------------------+",
    "arguments": [
        {
            "name": "geography_or_geometry_expression",
            "description": "The argument must be an expression of type GEOGRAPHY or GEOMETRY."
        }
    ],
    "returns": "Returns a REAL value."
},
{
    "function_name": "ST_X",
    "summary": "Returns the longitude (X coordinate) of a Point represented by a GEOGRAPHY or GEOMETRY object.",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/st_x",
    "title": "ST_X",
    "description": "Returns the longitude (X coordinate) of a Point represented by a",
    "syntax": "ST_X( <geography_or_geometry_expression> )",
    "example": "SELECT ST_X(ST_MAKEPOINT(37.5, 45.5)), ST_Y(ST_MAKEPOINT(37.5, 45.5));\n+--------------------------------+--------------------------------+\n| ST_X(ST_MAKEPOINT(37.5, 45.5)) | ST_Y(ST_MAKEPOINT(37.5, 45.5)) |\n|--------------------------------+--------------------------------|\n|                           37.5 |                           45.5 |\n+--------------------------------+--------------------------------+\n\nSELECT\n    ST_X(ST_MAKEPOINT(NULL, NULL)), ST_X(NULL),\n    ST_Y(ST_MAKEPOINT(NULL, NULL)), ST_Y(NULL)\n    ;\n+--------------------------------+------------+--------------------------------+------------+\n| ST_X(ST_MAKEPOINT(NULL, NULL)) | ST_X(NULL) | ST_Y(ST_MAKEPOINT(NULL, NULL)) | ST_Y(NULL) |\n|--------------------------------+------------+--------------------------------+------------|\n|                           NULL |       NULL |                           NULL |       NULL |\n+--------------------------------+------------+--------------------------------+------------+",
    "arguments": [
        {
            "name": "geography_or_geometry_expression",
            "description": "The argument must be an expression of the type GEOGRAPHY or GEOMETRY and must contain a Point."
        }
    ],
    "returns": "Returns a REAL value."
},
{
    "function_name": "ST_WITHIN",
    "summary": "Returns true if the first geospatial object is fully contained by the second geospatial object.",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/st_within",
    "title": "ST_WITHIN",
    "description": "Returns true if the first geospatial object is fully contained by the second geospatial object. In other words:",
    "syntax": "ST_WITHIN( <geography_expression_1> , <geography_expression_2> )\n\nST_WITHIN( <geometry_expression_1> , <geometry_expression_2> )",
    "example": "create table geospatial_table_01 (g1 GEOGRAPHY, g2 GEOGRAPHY);\ninsert into geospatial_table_01 (g1, g2) values \n    ('POLYGON((0 0, 3 0, 3 3, 0 3, 0 0))', 'POLYGON((1 1, 2 1, 2 2, 1 2, 1 1))');\n\nSELECT ST_WITHIN(g1, g2) \n    FROM geospatial_table_01;\n+-------------------+\n| ST_WITHIN(G1, G2) |\n|-------------------|\n| False             |\n+-------------------+",
    "arguments": [
        {
            "name": "geography_expression_1",
            "description": "A GEOGRAPHY object that is not a GeometryCollection or FeatureCollection."
        },
        {
            "name": "geography_expression_2",
            "description": "A GEOGRAPHY object that is not a GeometryCollection or FeatureCollection."
        },
        {
            "name": "geometry_expression_1",
            "description": "A GEOMETRY object that is not a GeometryCollection or FeatureCollection."
        },
        {
            "name": "geometry_expression_2",
            "description": "A GEOMETRY object that is not a GeometryCollection or FeatureCollection."
        }
    ],
    "returns": "BOOLEAN."
},
{
    "function_name": "ST_UNION_AGG",
    "summary": "Given a GEOGRAPHY column, returns a GEOGRAPHY object that represents the combined set of points that are in at least one of the shapes represented by the objects in the column (that is, the union of the shapes).",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/st_union_agg",
    "title": "ST_UNION_AGG",
    "description": "Given a GEOGRAPHY column, returns a GEOGRAPHY object that represents the combined set of points that are in\nat least one of the shapes represented by the objects in the column (that is, the union of the shapes).",
    "syntax": "ST_UNION_AGG( <geography_column> )",
    "example": "CREATE OR REPLACE TABLE st_union_agg_demo_table (g GEOGRAPHY);\n\nINSERT INTO st_union_agg_demo_table VALUES\n  ('POINT(1 1)'),\n  ('POINT(0 1)'),\n  ('LINESTRING(0 0, 0 1)'),\n  ('LINESTRING(0 0, 0 2)'),\n  ('POLYGON((10 10, 11 11, 11 10, 10 10))'),\n  ('POLYGON((10 10, 11 11, 11 10, 10 10))');\n\nALTER SESSION SET GEOGRAPHY_OUTPUT_FORMAT = 'WKT';\n\nSELECT ST_UNION_AGG(g) AS union_of_shapes\n  FROM st_union_agg_demo_table;\n\n+-------------------------------------------------------------------------------------------+\n| UNION_OF_SHAPES                                                                           |\n|-------------------------------------------------------------------------------------------|\n| GEOMETRYCOLLECTION(POINT(1 1),LINESTRING(0 0,0 1,0 2),POLYGON((11 10,11 11,10 10,11 10))) |\n+-------------------------------------------------------------------------------------------+",
    "arguments": [
        {
            "name": "geography_column",
            "description": "A GEOGRAPHY column."
        }
    ],
    "returns": "The function returns a value of type GEOGRAPHY."
},
{
    "function_name": "ST_UNION",
    "summary": "Given two input GEOGRAPHY objects, returns a GEOGRAPHY object that represents the combined set of shapes for both objects (i.e. the union of the two shapes).",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/st_union",
    "title": "ST_UNION",
    "description": "Given two input GEOGRAPHY objects, returns a GEOGRAPHY object that represents the combined set of shapes for both objects (i.e.\nthe union of the two shapes).",
    "syntax": "ST_UNION( <geography_expression_1> , <geography_expression_2> )",
    "example": "ALTER SESSION SET GEOGRAPHY_OUTPUT_FORMAT = 'WKT';\n\nSELECT ST_UNION(\n  TO_GEOGRAPHY('POLYGON((0 0, 1 0, 2 1, 1 2, 2 3, 1 4, 0 4, 0 0))'),\n  TO_GEOGRAPHY('POLYGON((3 0, 3 4, 2 4, 1 3, 2 2, 1 1, 2 0, 3 0))')\n) AS union_of_objects;\n\n+-------------------------------------------------------------------------------------------------------------------------------------------+\n| UNION_OF_OBJECTS                                                                                                                          |\n|-------------------------------------------------------------------------------------------------------------------------------------------|\n| POLYGON((3 0,3 4,2 4,1.5 3.500399839,1 4,0 4,0 0,1 0,1.5 0.5000571198,2 0,3 0),(1.5 1.500171359,1 2,1.5 2.500285599,2 2,1.5 1.500171359)) |\n+-------------------------------------------------------------------------------------------------------------------------------------------+",
    "arguments": [
        {
            "name": "geography_expression_1",
            "description": "A GEOGRAPHY object."
        },
        {
            "name": "geography_expression_2",
            "description": "A GEOGRAPHY object."
        }
    ],
    "returns": "The function returns a value of type GEOGRAPHY."
},
{
    "function_name": "ST_TRANSFORM",
    "summary": "Converts a GEOMETRY object from one spatial reference system (SRS) to another.",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/st_transform",
    "title": "ST_TRANSFORM",
    "description": "Converts a",
    "syntax": "ST_TRANSFORM( <geometry_expression> [ , <from_srid> ] , <to_srid> );",
    "example": "-- Set the output format to EWKT\nALTER SESSION SET GEOMETRY_OUTPUT_FORMAT='EWKT';\n\nSELECT\n  ST_TRANSFORM(\n    ST_GEOMFROMWKT('POINT(389866.35 5819003.03)', 32633),\n    3857\n  ) AS transformed_geom;\n\n+---------------------------------------------------------------+\n| transformed_geom                                              |\n|---------------------------------------------------------------|\n| SRID=3857;POINT(1489140.093765644 6892872.198680112)          |\n+---------------------------------------------------------------+\n\n-- Set the output format to EWKT\nALTER SESSION SET GEOMETRY_OUTPUT_FORMAT='EWKT';\n\nSELECT\n  ST_TRANSFORM(\n    ST_GEOMFROMWKT('POINT(4.500212 52.161170)'),\n    4326,\n    28992\n  ) AS transformed_geom;\n\n+---------------------------------------------------------------+\n| transformed_geom                                              |\n|---------------------------------------------------------------|\n| SRID=28992;POINT (94308.66600006013 464038.16881095537)       |\n+---------------------------------------------------------------+",
    "arguments": [
        {
            "name": "geometry_expression",
            "description": "The argument must be of type GEOMETRY."
        },
        {
            "name": "to_srid",
            "description": "The spatial reference system identifier (SRID) that identifies the SRS to use. The function transforms the input GEOMETRY\nobject to a new object that uses this SRS."
        },
        {
            "name": "from_srid",
            "description": "The SRID identifying the current SRS of the input GEOMETRY object. If this argument is omitted, the function uses the SRID specified in the input GEOMETRY object."
        }
    ],
    "returns": "The function returns a GEOMETRY object that uses the SRS identified by to_srid."
},
{
    "function_name": "ST_SYMDIFFERENCE",
    "summary": "Given two input GEOGRAPHY objects, returns a GEOGRAPHY object that represents the set of points from both input objects that are not part of the intersection of the objects (i.e. the symmetric difference of the two objects).",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/st_symdifference",
    "title": "ST_SYMDIFFERENCE",
    "description": "Given two input GEOGRAPHY objects, returns a GEOGRAPHY object that represents the set of points from both input objects that are\nnot part of the intersection of the objects (i.e. the",
    "syntax": "ST_SYMDIFFERENCE( <geography_expression_1> , <geography_expression_2> )",
    "example": "ALTER SESSION SET GEOGRAPHY_OUTPUT_FORMAT = 'WKT';\n\nSELECT ST_SYMDIFFERENCE(\n  TO_GEOGRAPHY('POLYGON((0 0, 1 0, 2 1, 1 2, 2 3, 1 4, 0 4, 0 0))'),\n  TO_GEOGRAPHY('POLYGON((3 0, 3 4, 2 4, 1 3, 2 2, 1 1, 2 0, 3 0))')\n) AS symmetric_difference_between_objects;\n\n+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| SYMMETRIC_DIFFERENCE_BETWEEN_OBJECTS                                                                                                                                                                                    |\n|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| MULTIPOLYGON(((1 1,1.5 1.500171359,1 2,1.5 2.500285599,1 3,1.5 3.500399839,1 4,0 4,0 0,1 0,1.5 0.5000571198,1 1)),((3 0,3 4,2 4,1.5 3.500399839,2 3,1.5 2.500285599,2 2,1.5 1.500171359,2 1,1.5 0.5000571198,2 0,3 0))) |\n+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+",
    "arguments": [
        {
            "name": "geography_expression_1",
            "description": "A GEOGRAPHY object."
        },
        {
            "name": "geography_expression_2",
            "description": "A GEOGRAPHY object."
        }
    ],
    "returns": "The function returns a value of type GEOGRAPHY."
},
{
    "function_name": "ST_STARTPOINT",
    "summary": "Returns the first Point in a LineString.",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/st_startpoint",
    "title": "ST_STARTPOINT",
    "description": "Returns the first Point in a LineString.",
    "syntax": "ST_STARTPOINT( <geography_or_geometry_expression> )",
    "example": "ALTER SESSION SET GEOGRAPHY_OUTPUT_FORMAT='WKT';\nSELECT ST_STARTPOINT(TO_GEOGRAPHY('LINESTRING(1 1, 2 2, 3 3, 4 4)'));\n\n+---------------------------------------------------------------+\n| ST_STARTPOINT(TO_GEOGRAPHY('LINESTRING(1 1, 2 2, 3 3, 4 4)')) |\n|---------------------------------------------------------------|\n| POINT(1 1)                                                    |\n+---------------------------------------------------------------+\n\nALTER SESSION SET GEOMETRY_OUTPUT_FORMAT='WKT';\nSELECT ST_STARTPOINT(TO_GEOMETRY('LINESTRING(1 1, 2 2, 3 3, 4 4)'));\n\n+--------------------------------------------------------------+\n| ST_STARTPOINT(TO_GEOMETRY('LINESTRING(1 1, 2 2, 3 3, 4 4)')) |\n|--------------------------------------------------------------|\n| POINT(1 1)                                                   |\n+--------------------------------------------------------------+",
    "arguments": [
        {
            "name": "geography_or_geometry_expression",
            "description": "The argument must be an expression of type GEOGRAPHY or GEOMETRY that represents a LineString."
        }
    ],
    "returns": "The function returns a value of type GEOGRAPHY or GEOMETRY that contains the first Point of the specified LineString."
},
{
    "function_name": "ST_SRID",
    "summary": "Returns the SRID (spatial reference system identifier) of a GEOGRAPHY or GEOMETRY object.",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/st_srid",
    "title": "ST_SRID",
    "description": "Returns the SRID (spatial reference system identifier) of a",
    "syntax": "ST_SRID( <geography_or_geometry_expression> )",
    "example": "SELECT ST_SRID(ST_MAKEPOINT(37.5, 45.5));\n+-----------------------------------+\n| ST_SRID(ST_MAKEPOINT(37.5, 45.5)) |\n|-----------------------------------|\n|                              4326 |\n+-----------------------------------+\n\nSELECT ST_SRID(ST_MAKEPOINT(NULL, NULL)), ST_SRID(NULL);\n+-----------------------------------+---------------+\n| ST_SRID(ST_MAKEPOINT(NULL, NULL)) | ST_SRID(NULL) |\n|-----------------------------------+---------------|\n|                              NULL |          NULL |\n+-----------------------------------+---------------+",
    "arguments": [
        {
            "name": "geography_or_geometry_expression",
            "description": "The argument must be an expression of type GEOGRAPHY or GEOMETRY."
        }
    ],
    "returns": "Returns a value of type NUMBER(4,0)."
},
{
    "function_name": "ST_SIMPLIFY",
    "summary": "Given an input GEOGRAPHY or GEOMETRY object that represents a Line or Polygon, returns a simpler approximation of the object.",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/st_simplify",
    "title": "ST_SIMPLIFY",
    "description": "Given an input",
    "syntax": "ST_SIMPLIFY( <geography_expression>, <tolerance> [ , <preserve_collapsed> ] )\nST_SIMPLIFY( <geometry_expression>, <tolerance> )",
    "example": "alter session set GEOGRAPHY_OUTPUT_FORMAT='WKT';\n\nSELECT ST_SIMPLIFY(\n    TO_GEOGRAPHY('LINESTRING(-122.306067 37.55412, -122.32328 37.561801, -122.325879 37.586852)'),\n    1000);\n+----------------------------------------------------------------------------------------------------+\n| ST_SIMPLIFY(                                                                                       |\n|     TO_GEOGRAPHY('LINESTRING(-122.306067 37.55412, -122.32328 37.561801, -122.325879 37.586852)'), |\n|     1000)                                                                                          |\n|----------------------------------------------------------------------------------------------------|\n| LINESTRING(-122.306067 37.55412,-122.325879 37.586852)                                             |\n+----------------------------------------------------------------------------------------------------+\n\nALTER SESSION SET GEOMETRY_OUTPUT_FORMAT='WKT';\n\nSELECT ST_SIMPIFY(\n  TO_GEOMETRY('LINESTRING(1100 1100, 2500 2100, 3100 3100, 4900 1100, 3100 1900)'),\n  500);\n\n+----------------------------------------------------------------------------------------------------+\n| ST_SIMPLIFY(TO_GEOMETRY('LINESTRING(1100 1100, 2500 2100, 3100 3100, 4900 1100, 3100 1900)'), 500) |\n|----------------------------------------------------------------------------------------------------|\n| LINESTRING(1100 1100,3100 3100,4900 1100,3100 1900)                                                |\n+----------------------------------------------------------------------------------------------------+\n\nSELECT ST_NUMPOINTS(geom) AS numpoints_before,\n  ST_NUMPOINTS(ST_Simplify(geom, 0.5)) AS numpoints_simplified_05,\n  ST_NUMPOINTS(ST_Simplify(geom, 1)) AS numpoints_simplified_1\n  FROM\n  (SELECT ST_BUFFER(to_geometry('LINESTRING(0 0, 1 1)'), 10) As geom);\n\n+------------------+-------------------------+------------------------+\n| NUMPOINTS_BEFORE | NUMPOINTS_SIMPLIFIED_05 | NUMPOINTS_SIMPLIFIED_1 |\n|------------------+-------------------------+------------------------|\n|               36 |                      16 |                     10 |\n+------------------+-------------------------+------------------------+",
    "arguments": [
        {
            "name": "geography_expression",
            "description": "The GEOGRAPHY or GEOMETRY object to simplify. Depending on the type of the GEOGRAPHY or GEOMETRY object, ST_SIMPLIFY has the following effect: Type of Object Effect of ST_SIMPLIFY LineString, MultiLineString, Polygon, or MultiPolygon ST_SIMPLIFY applies the simplification algorithm Point or MultiPoint ST_SIMPLIFY has no effect. GeometryCollection or FeatureCollection For GEOGRAPHY objects, ST_SIMPLIFY applies the simplification algorithm to each object in the collection. . . For GEOMETRY objects, ST_SIMPLIFY does not support these types."
        },
        {
            "name": "tolerance",
            "description": "The maximum distance in meters between a vertex and the edge resulting from the removal of the vertex. If the distance\nexceeds this tolerance for a vertex, ST_SIMPLIFY keeps that vertex in the simplified object."
        },
        {
            "name": "preserve_collapsed",
            "description": "(For GEOGRAPHY objects only) If TRUE , retains objects that would otherwise be too small given the tolerance. For example, when preserve_collapsed is FALSE and tolerance is 10 (meters), a 1m long line\nis reduced to a point in the simplified object. When preserve_collapsed is TRUE , the line is preserved in\nthe simplified object. Default: FALSE ."
        }
    ],
    "returns": "The function returns a value of type GEOGRAPHY or GEOMETRY."
},
{
    "function_name": "ST_SETSRID",
    "summary": "Returns a GEOMETRY object that has its SRID (spatial reference system identifier) set to the specified value.",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/st_setsrid",
    "title": "ST_SETSRID",
    "description": "Returns a",
    "syntax": "ST_SETSRID( <geometry_expression> , <srid> )",
    "example": "ALTER SESSION SET GEOMETRY_OUTPUT_FORMAT='EWKT';\n\nSELECT ST_SETSRID(TO_GEOMETRY('POINT(13 51)'), 4326);\n\n+-----------------------------------------------+\n| ST_SETSRID(TO_GEOMETRY('POINT(13 51)'), 4326) |\n|-----------------------------------------------|\n| SRID=4326;POINT(13 51)                        |\n+-----------------------------------------------+",
    "arguments": [
        {
            "name": "geometry_expression",
            "description": "The argument must be an expression of type GEOMETRY."
        },
        {
            "name": "srid",
            "description": "The SRID to set in the returned GEOMETRY object."
        }
    ],
    "returns": "The function returns a value of type GEOMETRY."
},
{
    "function_name": "ST_POINTN",
    "summary": "Returns a Point at a specified index in a LineString.",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/st_pointn",
    "title": "ST_POINTN",
    "description": "Returns a Point at a specified index in a LineString.",
    "syntax": "ST_POINTN( <geography_or_geometry_expression> , <index> )",
    "example": "ALTER SESSION SET GEOGRAPHY_OUTPUT_FORMAT='WKT';\nSELECT ST_POINTN(TO_GEOGRAPHY('LINESTRING(1 1, 2 2, 3 3, 4 4)'), 2);\n\n+--------------------------------------------------------------+\n| ST_POINTN(TO_GEOGRAPHY('LINESTRING(1 1, 2 2, 3 3, 4 4)'), 2) |\n|--------------------------------------------------------------|\n| POINT(2 2)                                                   |\n+--------------------------------------------------------------+\n\nALTER SESSION SET GEOGRAPHY_OUTPUT_FORMAT='WKT';\nSELECT ST_POINTN(TO_GEOGRAPHY('LINESTRING(1 1, 2 2, 3 3, 4 4)'), -2);\n\n+---------------------------------------------------------------+\n| ST_POINTN(TO_GEOGRAPHY('LINESTRING(1 1, 2 2, 3 3, 4 4)'), -2) |\n|---------------------------------------------------------------|\n| POINT(3 3)                                                    |\n+---------------------------------------------------------------+\n\nALTER SESSION SET GEOMETRY_OUTPUT_FORMAT='WKT';\nSELECT ST_POINTN(TO_GEOMETRY('LINESTRING(1 1, 2 2, 3 3, 4 4)'), 2);\n\n+-------------------------------------------------------------+\n| ST_POINTN(TO_GEOMETRY('LINESTRING(1 1, 2 2, 3 3, 4 4)'), 2) |\n|-------------------------------------------------------------|\n| POINT(2 2)                                                  |\n+-------------------------------------------------------------+\n\nALTER SESSION SET GEOMETRY_OUTPUT_FORMAT='WKT';\nSELECT ST_POINTN(TO_GEOMETRY('LINESTRING(1 1, 2 2, 3 3, 4 4)'), -2);\n\n+--------------------------------------------------------------+\n| ST_POINTN(TO_GEOMETRY('LINESTRING(1 1, 2 2, 3 3, 4 4)'), -2) |\n|--------------------------------------------------------------|\n| POINT(3 3)                                                   |\n+--------------------------------------------------------------+",
    "arguments": [
        {
            "name": "geography_or_geometry_expression",
            "description": "The argument must be an expression of type GEOGRAPHY or GEOMETRY that represents a LineString."
        },
        {
            "name": "index",
            "description": "The index of the Point to return. The index must be an integer. A negative index is interpreted as the offset from the end of the LineString. For example, -1 is interpreted as the last\nPoint in the LineString, -2 is interpreted as the second to the last Point, etc."
        }
    ],
    "returns": "The function returns a value of type GEOGRAPHY or GEOMETRY that contains the Point at the specified index of the LineString."
},
{
    "function_name": "ST_PERIMETER",
    "summary": "Returns the length of the perimeter of the polygon(s) in a GEOGRAPHY or GEOMETRY object.",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/st_perimeter",
    "title": "ST_PERIMETER",
    "description": "Returns the length of the perimeter of the polygon(s) in a",
    "syntax": "ST_PERIMETER( <geography_or_geometry_expression> )",
    "example": "SELECT ST_PERIMETER(TO_GEOGRAPHY('POLYGON((0 0, 1 0, 1 1, 0 1, 0 0))'));\n+------------------------------------------------------------------+\n| ST_PERIMETER(TO_GEOGRAPHY('POLYGON((0 0, 1 0, 1 1, 0 1, 0 0))')) |\n|------------------------------------------------------------------|\n|                                                 444763.468727621 |\n+------------------------------------------------------------------+\n\nSELECT ST_PERIMETER(g), ST_ASWKT(g)\nFROM (SELECT TO_GEOMETRY(column1) AS g\n  FROM VALUES ('POINT(1 1)'),\n              ('LINESTRING(0 0, 1 1)'),\n              ('POLYGON((0 0, 0 1, 1 1, 1 0, 0 0))'));\n\n+-----------------+--------------------------------+\n| ST_PERIMETER(G) | ST_ASWKT(G)                    |\n|-----------------+--------------------------------|\n|               0 | POINT(1 1)                     |\n|               0 | LINESTRING(0 0,1 1)            |\n|               4 | POLYGON((0 0,0 1,1 1,1 0,0 0)) |\n+-----------------+--------------------------------+",
    "arguments": [
        {
            "name": "geography_or_geometry_expression",
            "description": "The argument must be of type GEOGRAPHY or GEOMETRY."
        }
    ],
    "returns": "Returns a REAL value, which represents the length:"
},
{
    "function_name": "ST_NPOINTS , ST_NUMPOINTS",
    "summary": "Returns the number of points in a GEOGRAPHY or GEOGRAPHY object.",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/st_npoints",
    "title": "ST_NPOINTS , ST_NUMPOINTS",
    "description": "Returns the number of points in a",
    "syntax": "ST_NPOINTS( <geography_or_geometry_expression> )",
    "example": "create table geospatial_table_01 (g1 GEOGRAPHY, g2 GEOGRAPHY);\ninsert into geospatial_table_01 (g1, g2) values \n    ('POLYGON((0 0, 3 0, 3 3, 0 3, 0 0))', 'POLYGON((1 1, 2 1, 2 2, 1 2, 1 1))');\n\nSELECT ST_NPOINTS(g1) \n    FROM geospatial_table_01;\n+----------------+\n| ST_NPOINTS(G1) |\n|----------------|\n|              5 |\n+----------------+\n\nCREATE OR REPLACE TABLE geometry_shapes (g GEOMETRY);\nINSERT INTO geometry_shapes VALUES\n    ('POINT(66 12)'),\n    ('MULTIPOINT((45 21), (12 54))'),\n    ('LINESTRING(40 60, 50 50, 60 40)'),\n    ('MULTILINESTRING((1 1, 32 17), (33 12, 73 49, 87.1 6.1))'),\n    ('POLYGON((17 17, 17 30, 30 30, 30 17, 17 17))'),\n    ('MULTIPOLYGON(((-10 0,0 10,10 0,-10 0)),((-10 40,10 40,0 20,-10 40)))'),\n    ('GEOMETRYCOLLECTION(POLYGON((-10 0,0 10,10 0,-10 0)),LINESTRING(40 60, 50 50, 60 40), POINT(99 11))')\n    ;\n\nSELECT ST_NPOINTS(g), ST_ASWKT(g) FROM geometry_shapes;\n\n+---------------+-------------------------------------------------------------------------------------------------+\n| ST_NPOINTS(G) | ST_ASWKT(G)                                                                                     |\n|---------------+-------------------------------------------------------------------------------------------------|\n|             1 | POINT(66 12)                                                                                    |\n|             2 | MULTIPOINT((45 21),(12 54))                                                                     |\n|             3 | LINESTRING(40 60,50 50,60 40)                                                                   |\n|             5 | MULTILINESTRING((1 1,32 17),(33 12,73 49,87.1 6.1))                                             |\n|             5 | POLYGON((17 17,17 30,30 30,30 17,17 17))                                                        |\n|             8 | MULTIPOLYGON(((-10 0,0 10,10 0,-10 0)),((-10 40,10 40,0 20,-10 40)))                            |\n|             8 | GEOMETRYCOLLECTION(POLYGON((-10 0,0 10,10 0,-10 0)),LINESTRING(40 60,50 50,60 40),POINT(99 11)) |\n+---------------+-------------------------------------------------------------------------------------------------+",
    "arguments": [
        {
            "name": "geography_or_geometry_expression",
            "description": "The argument must be an expression of type GEOGRAPHY or GEOMETRY."
        }
    ],
    "returns": "Returns a value of type INTEGER."
},
{
    "function_name": "ST_MAKEPOLYGONORIENTED",
    "summary": "Constructs a GEOGRAPHY object that represents a Polygon without holes.",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/st_makepolygonoriented",
    "title": "ST_MAKEPOLYGONORIENTED",
    "description": "Constructs a",
    "syntax": "ST_MAKEPOLYGONORIENTED( <geography_expression> )",
    "example": "SELECT ST_AREA(\n  ST_MAKEPOLYGONORIENTED(\n    TO_GEOGRAPHY('LINESTRING(0.0 0.0, 1.0 0.0, 1.0 2.0, 0.0 2.0, 0.0 0.0)')\n  )\n) AS area_of_polygon;\n\n+------------------+\n|  AREA_OF_POLYGON |\n|------------------|\n| 24724306355.5504 |\n+------------------+\n\nSELECT ST_AREA(\n  ST_MAKEPOLYGONORIENTED(\n    TO_GEOGRAPHY('LINESTRING(0.0 0.0, 0.0 2.0, 1.0 2.0, 1.0 0.0, 0.0 0.0)')\n  )\n) AS area_of_polygon;\n\n+-----------------+\n| AREA_OF_POLYGON |\n|-----------------|\n| 510041348811633 |\n+-----------------+",
    "arguments": [
        {
            "name": "geography_expression",
            "description": "A GEOGRAPHY object that represents a LineString in which the last point is the same as the first (i.e. a loop)."
        }
    ],
    "returns": "The function returns a value of type GEOGRAPHY."
},
{
    "function_name": "ST_MAKEPOLYGON , ST_POLYGON",
    "summary": "Constructs a GEOGRAPHY or GEOMETRY object that represents a Polygon without holes.",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/st_makepolygon",
    "title": "ST_MAKEPOLYGON , ST_POLYGON",
    "description": "Constructs a",
    "syntax": "ST_MAKEPOLYGON( <geography_or_geometry_expression> )",
    "example": "SELECT ST_MAKEPOLYGON(\n   TO_GEOGRAPHY('LINESTRING(0.0 0.0, 1.0 0.0, 1.0 2.0, 0.0 2.0, 0.0 0.0)')\n   ) AS polygon1;\n+--------------------------------+\n| POLYGON1                       |\n|--------------------------------|\n| POLYGON((0 0,1 0,1 2,0 2,0 0)) |\n+--------------------------------+\n\nSELECT ST_MAKEPOLYGON(\n  TO_GEOMETRY('LINESTRING(0.0 0.0, 1.0 0.0, 1.0 2.0, 0.0 2.0, 0.0 0.0)')\n  ) AS polygon;\n\n+--------------------------------+\n| POLYGON                        |\n|--------------------------------|\n| POLYGON((0 0,1 0,1 2,0 2,0 0)) |\n+--------------------------------+",
    "arguments": [
        {
            "name": "geography_or_geometry_expression",
            "description": "A GEOGRAPHY or GEOMETRY object that represents a LineString in which the last point is the same as the first (i.e. a\nloop)."
        }
    ],
    "returns": "The function returns a value of type GEOGRAPHY or GEOMETRY."
},
{
    "function_name": "ST_MAKEPOINT , ST_POINT",
    "summary": "Constructs a GEOGRAPHY object that represents a point with the specified longitude and latitude.",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/st_makepoint",
    "title": "ST_MAKEPOINT , ST_POINT",
    "description": "Constructs a",
    "syntax": "ST_MAKEPOINT( <longitude> , <latitude> )",
    "example": "SELECT ST_MAKEPOINT(37.5, 45.5);\n+--------------------------+\n| ST_MAKEPOINT(37.5, 45.5) |\n|--------------------------|\n| POINT(37.5 45.5)         |\n+--------------------------+",
    "arguments": [
        {
            "name": "longitude",
            "description": "A REAL that represents the longitude."
        },
        {
            "name": "latitude",
            "description": "A REAL that represents the latitude."
        }
    ],
    "returns": "The function returns a value of type GEOGRAPHY."
},
{
    "function_name": "ST_MAKELINE",
    "summary": "Constructs a GEOGRAPHY or GEOMETRY object that represents a line connecting the points in the input objects.",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/st_makeline",
    "title": "ST_MAKELINE",
    "description": "Constructs a",
    "syntax": "ST_MAKELINE( <geography_expression_1> , <geography_expression_2> )\n\nST_MAKELINE( <geometry_expression_1> , <geometry_expression_2> )",
    "example": "alter session set GEOGRAPHY_OUTPUT_FORMAT='WKT';\n\nSELECT ST_MAKELINE(\n                   TO_GEOGRAPHY('POINT(37.0 45.0)'),\n                   TO_GEOGRAPHY('POINT(38.5 46.5)')\n                  ) AS line_between_two_points;\n+-----------------------------+\n| LINE_BETWEEN_TWO_POINTS     |\n|-----------------------------|\n| LINESTRING(37 45,38.5 46.5) |\n+-----------------------------+\n\nSELECT ST_MAKELINE(\n                   TO_GEOGRAPHY('POINT(-122.306067 37.55412)'),\n                   TO_GEOGRAPHY('MULTIPOINT((-122.32328 37.561801), (-122.325879 37.586852))')\n                  ) AS line_between_point_and_multipoint;\n+-----------------------------------------------------------------------------+\n| LINE_BETWEEN_POINT_AND_MULTIPOINT                                           |\n|-----------------------------------------------------------------------------|\n| LINESTRING(-122.306067 37.55412,-122.32328 37.561801,-122.325879 37.586852) |\n+-----------------------------------------------------------------------------+\n\nSELECT ST_MAKELINE(\n                   TO_GEOGRAPHY('MULTIPOINT((-122.32328 37.561801), (-122.325879 37.586852))'),\n                   TO_GEOGRAPHY('LINESTRING(-122.306067 37.55412, -122.496691 37.495627)')\n                  ) AS line_between_multipoint_and_linestring;\n+---------------------------------------------------------------------------------------------------+\n| LINE_BETWEEN_MULTIPOINT_AND_LINESTRING                                                            |\n|---------------------------------------------------------------------------------------------------|\n| LINESTRING(-122.32328 37.561801,-122.325879 37.586852,-122.306067 37.55412,-122.496691 37.495627) |\n+---------------------------------------------------------------------------------------------------+\n\nALTER SESSION SET GEOMETRY_OUTPUT_FORMAT='WKT';\n\nSELECT ST_MAKELINE(\n  TO_GEOMETRY('POINT(1.0 2.0)'),\n  TO_GEOMETRY('POINT(3.5 4.5)')) AS line_between_two_points;\n\n+-------------------------+\n| LINE_BETWEEN_TWO_POINTS |\n|-------------------------|\n| LINESTRING(1 2,3.5 4.5) |\n+-------------------------+\n\nSELECT ST_MAKELINE(\n  TO_GEOMETRY('POINT(1.0 2.0)'),\n  TO_GEOMETRY('MULTIPOINT(3.5 4.5, 6.1 7.9)')) AS line_from_point_and_multipoint;\n\n+---------------------------------+\n| LINE_FROM_POINT_AND_MULTIPOINT  |\n|---------------------------------|\n| LINESTRING(1 2,3.5 4.5,6.1 7.9) |\n+---------------------------------+\n\nSELECT ST_MAKELINE(\n  TO_GEOMETRY('LINESTRING(1.0 2.0, 10.1 5.5)'),\n  TO_GEOMETRY('MULTIPOINT(3.5 4.5, 6.1 7.9)')) AS line_from_linestring_and_multipoint;\n\n+------------------------------------------+\n| LINE_FROM_LINESTRING_AND_MULTIPOINT      |\n|------------------------------------------|\n| LINESTRING(1 2,10.1 5.5,3.5 4.5,6.1 7.9) |\n+------------------------------------------+",
    "arguments": [
        {
            "name": "geography_expression_1",
            "description": "A GEOGRAPHY object containing the points to connect. This object must be a Point, MultiPoint, or LineString."
        },
        {
            "name": "geography_expression_2",
            "description": "A GEOGRAPHY object containing the points to connect. This object must be a Point, MultiPoint, or LineString."
        },
        {
            "name": "geometry_expression_1",
            "description": "A GEOMETRY object containing the points to connect. This object must be a Point, MultiPoint, or LineString."
        },
        {
            "name": "geometry_expression_2",
            "description": "A GEOMETRY object containing the points to connect. This object must be a Point, MultiPoint, or LineString."
        }
    ],
    "returns": "The function returns a value of type GEOGRAPHY or GEOMETRY. The value is a LineString that connects all of the points specified by\nthe input GEOGRAPHY or GEOMETRY objects."
},
{
    "function_name": "ST_LENGTH",
    "summary": "Returns the great circle length of the LineString(s) in a GEOGRAPHY object or the Euclidean length of the LineString(s) in a GEOMETRY object.",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/st_length",
    "title": "ST_LENGTH",
    "description": "Returns the great circle length of the LineString(s) in a",
    "syntax": "ST_LENGTH( <geography_or_geometry_expression> )",
    "example": "SELECT ST_LENGTH(TO_GEOGRAPHY('LINESTRING(0.0 0.0, 1.0 0.0)'));\n+---------------------------------------------------------+\n| ST_LENGTH(TO_GEOGRAPHY('LINESTRING(0.0 0.0, 1.0 0.0)')) |\n|---------------------------------------------------------|\n|                                        111195.101177484 |\n+---------------------------------------------------------+\n\nSELECT ST_LENGTH(g), ST_ASWKT(g)\nFROM (SELECT TO_GEOMETRY(column1) AS g\n  FROM VALUES ('POINT(1 1)'),\n              ('LINESTRING(0 0, 1 1)'),\n              ('POLYGON((0 0, 0 1, 1 1, 1 0, 0 0))'));\n\n+--------------+--------------------------------+\n| ST_LENGTH(G) | ST_ASWKT(G)                    |\n|--------------+--------------------------------|\n|  0           | POINT(1 1)                     |\n|  1.414213562 | LINESTRING(0 0,1 1)            |\n|  0           | POLYGON((0 0,0 1,1 1,1 0,0 0)) |\n+--------------+--------------------------------+",
    "arguments": [
        {
            "name": "geography_or_geometry_expression",
            "description": "The argument must be of type GEOGRAPHY or GEOMETRY."
        }
    ],
    "returns": "Returns a REAL value, which represents the length:"
},
{
    "function_name": "ST_MAKEGEOMPOINT , ST_GEOMPOINT",
    "summary": "Constructs a GEOMETRY object that represents a Point with the specified longitude and latitude.",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/st_makegeompoint",
    "title": "ST_MAKEGEOMPOINT , ST_GEOMPOINT",
    "description": "Constructs a",
    "syntax": "ST_MAKEGEOMPOINT( <longitude> , <latitude> )",
    "arguments": [
        {
            "name": "longitude",
            "description": "A REAL that represents the longitude."
        },
        {
            "name": "latitude",
            "description": "A REAL that represents the latitude."
        }
    ],
    "returns": "The function returns a value of type GEOMETRY."
},
{
    "function_name": "ST_ISVALID",
    "summary": "Returns TRUE if the specified GEOGRAPHY or GEOMETRY object represents a valid shape.",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/st_isvalid",
    "title": "ST_ISVALID",
    "description": "Returns TRUE if the specified GEOGRAPHY or GEOMETRY object represents a",
    "syntax": "ST_ISVALID( <geography_or_geometry_expression> )",
    "arguments": [
        {
            "name": "geography_or_geometry_expression",
            "description": "The argument must be an expression of type GEOGRAPHY or GEOMETRY."
        }
    ],
    "returns": "Returns a BOOLEAN."
},
{
    "function_name": "ST_INTERSECTS",
    "summary": "Returns TRUE if the two GEOGRAPHY objects or the two GEOMETRY objects intersect (i.e. share any portion of space).",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/st_intersects",
    "title": "ST_INTERSECTS",
    "description": "Returns TRUE if the two",
    "syntax": "ST_INTERSECTS( <geography_expression_1> , <geography_expression_2> )\n\nST_INTERSECTS( <geometry_expression_1> , <geometry_expression_2> )",
    "example": "SELECT ST_INTERSECTS(\n    TO_GEOGRAPHY('POLYGON((0 0, 2 0, 2 2, 0 2, 0 0))'),\n    TO_GEOGRAPHY('POLYGON((1 1, 3 1, 3 3, 1 3, 1 1))')\n    );\n+---------------------------------------------------------+\n| ST_INTERSECTS(                                          |\n|     TO_GEOGRAPHY('POLYGON((0 0, 2 0, 2 2, 0 2, 0 0))'), |\n|     TO_GEOGRAPHY('POLYGON((1 1, 3 1, 3 3, 1 3, 1 1))')  |\n|     )                                                   |\n|---------------------------------------------------------|\n| True                                                    |\n+---------------------------------------------------------+\n\nSELECT ST_INTERSECTS(\n  TO_GEOMETRY('POLYGON((0 0, 0 2, 2 2, 2 0, 0 0))'),\n  TO_GEOMETRY('POLYGON((1 1, 3 1, 3 3, 1 3, 1 1))')\n);\n\n+------------------------------------------------------+\n| ST_INTERSECTS(                                       |\n|   TO_GEOMETRY('POLYGON((0 0, 0 2, 2 2, 2 0, 0 0))'), |\n|   TO_GEOMETRY('POLYGON((1 1, 3 1, 3 3, 1 3, 1 1))')  |\n| )                                                    |\n|------------------------------------------------------|\n| True                                                 |\n+------------------------------------------------------+",
    "arguments": [
        {
            "name": "geography_expression_1",
            "description": "A GEOGRAPHY object."
        },
        {
            "name": "geography_expression_2",
            "description": "A GEOGRAPHY object."
        },
        {
            "name": "geometry_expression_1",
            "description": "A GEOMETRY object."
        },
        {
            "name": "geometry_expression_2",
            "description": "A GEOMETRY object."
        }
    ],
    "returns": "BOOLEAN."
},
{
    "function_name": "ST_INTERSECTION_AGG",
    "summary": "Given a GEOGRAPHY column, returns a GEOGRAPHY object that represents the shape containing the combined set of points that are common to the shapes represented by the objects in the column (that is, the intersection of the shapes).",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/st_intersection_agg",
    "title": "ST_INTERSECTION_AGG",
    "description": "Given a GEOGRAPHY column, returns a GEOGRAPHY object that represents the shape containing the combined set of points that are\ncommon to the shapes represented by the objects in the column (that is, the intersection of the shapes).",
    "syntax": "ST_INTERSECTION_AGG( <geography_column> )",
    "example": "CREATE OR REPLACE TABLE st_intersection_agg_demo_table (g GEOGRAPHY);\n\nINSERT INTO st_intersection_agg_demo_table VALUES\n  ('POLYGON((10 10, 11 11, 11 10, 10 10))'),\n  ('POLYGON((10 10, 11 10, 10 11, 10 10))'),\n  ('POLYGON((10.5 10.5, 10 10, 11 10, 10.5 10.5))');\n\nALTER SESSION SET GEOGRAPHY_OUTPUT_FORMAT = 'WKT';\n\nSELECT ST_INTERSECTION_AGG(g) AS intersection_of_shapes\n  FROM st_intersection_agg_demo_table;\n\n+--------------------------------------------+\n| INTERSECTION_OF_SHAPES                     |\n|--------------------------------------------|\n| POLYGON((10.5 10.5,10 10,11 10,10.5 10.5)) |\n+--------------------------------------------+",
    "arguments": [
        {
            "name": "geography_column",
            "description": "A GEOGRAPHY column."
        }
    ],
    "returns": "The function returns a value of type GEOGRAPHY."
},
{
    "function_name": "ST_INTERSECTION",
    "summary": "Given two input GEOGRAPHY objects, returns a GEOGRAPHY object that represents the shape containing the set of points that are common to both input objects (i.e. the intersection of the two objects).",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/st_intersection",
    "title": "ST_INTERSECTION",
    "description": "Given two input GEOGRAPHY objects, returns a GEOGRAPHY object that represents the shape containing the set of points that are\ncommon to both input objects (i.e. the intersection of the two objects).",
    "syntax": "ST_INTERSECTION( <geography_expression_1> , <geography_expression_2> )",
    "example": "ALTER SESSION SET GEOGRAPHY_OUTPUT_FORMAT = 'WKT';\n\nSELECT ST_INTERSECTION(\n  TO_GEOGRAPHY('POLYGON((0 0, 1 0, 2 1, 1 2, 2 3, 1 4, 0 4, 0 0))'),\n  TO_GEOGRAPHY('POLYGON((3 0, 3 4, 2 4, 1 3, 2 2, 1 1, 2 0, 3 0))'))\nAS intersection_of_objects;\n\n+-----------------------------------------------------------------------------------------------------------------------------------------+\n| INTERSECTION_OF_OBJECTS                                                                                                                 |\n|-----------------------------------------------------------------------------------------------------------------------------------------|\n| MULTIPOLYGON(((1.5 0.5000571198,2 1,1.5 1.500171359,1 1,1.5 0.5000571198)),((1.5 2.500285599,2 3,1.5 3.500399839,1 3,1.5 2.500285599))) |\n+-----------------------------------------------------------------------------------------------------------------------------------------+",
    "arguments": [
        {
            "name": "geography_expression_1",
            "description": "A GEOGRAPHY object."
        },
        {
            "name": "geography_expression_2",
            "description": "A GEOGRAPHY object."
        }
    ],
    "returns": "The function returns a value of type GEOGRAPHY."
},
{
    "function_name": "ST_INTERPOLATE",
    "summary": "Given an input GEOGRAPHY object, returns an interpolated object that is within a specified tolerance.",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/st_interpolate",
    "title": "ST_INTERPOLATE",
    "description": "Given an input",
    "syntax": "ST_INTERPOLATE( <geography_expression> [ , <tolerance> ] )",
    "example": "ALTER SESSION SET GEOGRAPHY_OUTPUT_FORMAT = 'WKT';\n\nSELECT TO_GEOGRAPHY(\n  'POLYGON((2.365837 48.862456,-76.992874 39.009046,-16.091194 18.013997,2.365837 48.862456))')\n    AS input_object,\n  ST_INTERPOLATE(\n    TO_GEOGRAPHY(\n      'POLYGON((2.365837 48.862456,-76.992874 39.009046,-16.091194 18.013997,2.365837 48.862456))'\n    ),\n    1000\n  ) AS interpolated_object;\n\n+--------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| INPUT_OBJECT                                                                               | INTERPOLATED_OBJECT                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |\n|--------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| POLYGON((2.365837 48.862456,-76.992874 39.009046,-16.091194 18.013997,2.365837 48.862456)) | POLYGON((2.365837 48.862456,0.2362767764 49.398305615,-1.996262883 49.906689161,-4.332160104 50.382437182,-6.770456901 50.820131017,-9.308629958 51.214188609,-11.942383026 51.558974127,-13.293232976 51.711146148,-14.665482532 51.848930511,-16.058033739 51.971669906,-17.469660151 52.078731821,-18.899009042 52.169513959,-20.344605456 52.243449667,-21.804858156 52.300013293,-23.278067492 52.338725392,-24.762435158 52.359157656,-26.256075742 52.3609375,-27.757029917 52.343752197,-29.263279078 52.307352477,-30.772761157 52.251555506,-32.283387321 52.176247197,-33.793059226 52.081383774,-35.299686463 51.966992581,-36.801203842 51.833172099,-38.295588157 51.680091182,-39.780874093 51.507987534,-41.25516898 51.317165449,-42.716666126 51.107992889,-44.16365652 50.880897942,-45.594538759 50.636364763,-47.007827085 50.374929055,-48.402157513 50.097173201,-49.776292048 49.803721135,-51.129121057 49.495233035,-52.459663914 49.172399933,-53.767068032 48.835938324,-55.050606468 48.486584847,-57.543783773 47.752218706,-59.935729311 46.975406135,-62.224659081 46.162267318,-64.410251688 45.318811613,-66.493415436 44.450833283,-68.47605821 43.563829764,-70.360871429 42.662941503,-72.151135223 41.752911448,-73.850548486 40.838061719,-75.463084888 39.922284722,-76.992874 39.009046,-75.054371602 38.900776338,-73.070188895 38.756302935,-71.04361197 38.573354324,-68.978491512 38.349817237,-66.879224949 38.083791708,-64.750721339 37.773647264,-62.598348624 37.418078058,-60.427863866 37.016154514,-58.24532822 36.567368929,-56.057009424 36.07167252,-53.86927558 35.52950163,-51.688484598 34.941791231,-49.5208741 34.309974475,-47.372456469 33.635967742,-45.248923381 32.922141467,-43.155563394 32.171277799,-41.097195205 31.386516865,-39.078118124 30.57129403,-37.102080178 29.729270906,-35.172263312 28.864263107,-33.291284269 27.980167693,-31.461209158 27.080893062,-29.683579328 26.170293681,-27.959446009 25.252111561,-26.289411197 24.329925855,-24.673672456 23.407111409,-23.112069576 22.486806569,-21.604131345 21.571890097,-18.746079719 19.768360293,-16.091194 18.013997,-14.452640773 21.830752143,-12.663169134 25.760435024,-11.706340645 27.75379918,-10.704942742 29.757834797,-9.656443607 31.765812338,-8.558194149 33.770740816,-7.407434508 35.765476568,-6.20130448 37.742837326,-4.936858776 39.695716684,-3.61108818 41.617194045,-2.2209478 43.500635601,-0.7633937119 45.339782667,0.7645706485 47.128824761,2.365837 48.862456)) |\n+--------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+",
    "arguments": [
        {
            "name": "geography_expression",
            "description": "The GEOGRAPHY object to interpolate."
        },
        {
            "name": "tolerance",
            "description": "The maximum Hausdorff distance in meters between the original object and\nits planar (Mercator) projection . Default: 10 meters"
        }
    ],
    "returns": "The function returns a value of type GEOGRAPHY."
},
{
    "function_name": "ST_GEOMPOINTFROMGEOHASH",
    "summary": "Returns a GEOMETRY object for the point that represents center of a geohash.",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/st_geompointfromgeohash",
    "title": "ST_GEOMPOINTFROMGEOHASH",
    "description": "Returns a",
    "syntax": "ST_GEOMPOINTFROMGEOHASH( <geohash> )",
    "example": "SELECT ST_GEOMPOINTFROMGEOHASH('9q9j8ue2v71y5zzy0s4q')\n  AS geometry_center_point_of_geohash;\n\n+----------------------------------+\n| GEOMETRY_CENTER_POINT_OF_GEOHASH |\n|----------------------------------|\n| {                                |\n|   \"coordinates\": [               |\n|     -1.223061000000001e+02,      |\n|     3.755416199999996e+01        |\n|   ],                             |\n|   \"type\": \"Point\"                |\n| }                                |\n+----------------------------------+",
    "arguments": [
        {
            "name": "geohash",
            "description": "The argument must be a geohash."
        }
    ],
    "returns": "Returns a value of type GEOMETRY that represents the point that is the\ncenter of the geohash."
},
{
    "function_name": "ST_HAUSDORFFDISTANCE",
    "summary": "Returns the discrete Hausdorff distance between two GEOGRAPHY objects.",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/st_hausdorffdistance",
    "title": "ST_HAUSDORFFDISTANCE",
    "description": "Returns the discrete",
    "syntax": "ST_HAUSDORFFDISTANCE( <geography_expression_1> , <geography_expression_2> )",
    "example": "SELECT ST_HAUSDORFFDISTANCE(ST_POINT(0, 0), ST_POINT(0, 1));\n+------------------------------------------------------+\n| ST_HAUSDORFFDISTANCE(ST_POINT(0, 0), ST_POINT(0, 1)) |\n|------------------------------------------------------|\n|                                                    1 |\n+------------------------------------------------------+\n\nWITH\n    a AS (TO_GEOGRAPHY('POLYGON((-1 0, 0 1, 1 0, 0 -1, -1 0))')),\n    b AS (TO_GEOGRAPHY('POLYGON((-1 0, 0 1, 2 0, 0 -1, -1 0))')),\n    c AS (TO_GEOGRAPHY('POLYGON((-1 0, 0 3, 1 0, 0 -1, -1 0))'))\nSELECT\n    ST_HAUSDORFFDISTANCE(a, b) as distance_between_a_and_b,\n    ST_HAUSDORFFDISTANCE(a, c) as distance_between_a_and_c;\n+--------------------------+--------------------------+\n| DISTANCE_BETWEEN_A_AND_B | DISTANCE_BETWEEN_A_AND_C |\n|--------------------------+--------------------------|\n|                        1 |                        2 |\n+--------------------------+--------------------------+",
    "arguments": [
        {
            "name": "geography_expression_1",
            "description": "The argument must be an expression of type GEOGRAPHY."
        },
        {
            "name": "geography_expression_2",
            "description": "The argument must be an expression of type GEOGRAPHY."
        }
    ],
    "returns": "Returns a value of type REAL that represents the discrete Hausdorff distance in degrees."
},
{
    "function_name": "ST_GEOMFROMGEOHASH",
    "summary": "Returns a GEOMETRY object for the polygon that represents the boundaries of a geohash.",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/st_geomfromgeohash",
    "title": "ST_GEOMFROMGEOHASH",
    "description": "Returns a",
    "syntax": "ST_GEOMFROMGEOHASH( <geohash> [, <precision> ] )",
    "example": "SELECT ST_GEOMFROMGEOHASH('9q9j8ue2v71y5zzy0s4q')\n  AS geometry_from_geohash,\n  ST_AREA(ST_GEOMFROMGEOHASH('9q9j8ue2v71y5zzy0s4q'))\n  AS area_of_geohash;\n\n+---------------------------------+-----------------+\n| GEOMETRY_FROM_GEOHASH           | AREA_OF_GEOHASH |\n|---------------------------------+-----------------|\n| {                               | 5.492996255e-26 |\n|   \"coordinates\": [              |                 |\n|     [                           |                 |\n|       [                         |                 |\n|         -1.223061000000001e+02, |                 |\n|         3.755416199999996e+01   |                 |\n|       ],                        |                 |\n|       [                         |                 |\n|         -1.223061000000001e+02, |                 |\n|         3.755416200000012e+01   |                 |\n|       ],                        |                 |\n|       [                         |                 |\n|         -1.223060999999998e+02, |                 |\n|         3.755416200000012e+01   |                 |\n|       ],                        |                 |\n|       [                         |                 |\n|         -1.223060999999998e+02, |                 |\n|         3.755416199999996e+01   |                 |\n|       ],                        |                 |\n|       [                         |                 |\n|         -1.223061000000001e+02, |                 |\n|         3.755416199999996e+01   |                 |\n|       ]                         |                 |\n|     ]                           |                 |\n|   ],                            |                 |\n|   \"type\": \"Polygon\"             |                 |\n| }                               |                 |\n+---------------------------------+-----------------+\n\nSELECT ST_GEOMFROMGEOHASH('9q9j8ue2v71y5zzy0s4q', 6)\n  AS geometry_from_less_precise_geohash,\n  ST_AREA(ST_GEOMFROMGEOHASH('9q9j8ue2v71y5zzy0s4q', 6))\n  AS area_of_geohash;\n\n+------------------------------------+-----------------+\n| GEOMETRY_FROM_LESS_PRECISE_GEOHASH | AREA_OF_GEOHASH |\n|------------------------------------+-----------------|\n| {                                  | 6.034970284e-05 |\n|   \"coordinates\": [                 |                 |\n|     [                              |                 |\n|       [                            |                 |\n|         -1.223107910156250e+02,    |                 |\n|         3.755126953125000e+01      |                 |\n|       ],                           |                 |\n|       [                            |                 |\n|         -1.223107910156250e+02,    |                 |\n|         3.755676269531250e+01      |                 |\n|       ],                           |                 |\n|       [                            |                 |\n|         -1.222998046875000e+02,    |                 |\n|         3.755676269531250e+01      |                 |\n|       ],                           |                 |\n|       [                            |                 |\n|         -1.222998046875000e+02,    |                 |\n|         3.755126953125000e+01      |                 |\n|       ],                           |                 |\n|       [                            |                 |\n|         -1.223107910156250e+02,    |                 |\n|         3.755126953125000e+01      |                 |\n|       ]                            |                 |\n|     ]                              |                 |\n|   ],                               |                 |\n|   \"type\": \"Polygon\"                |                 |\n| }                                  |                 |\n+------------------------------------+-----------------+",
    "arguments": [
        {
            "name": "geohash",
            "description": "The argument must be a geohash."
        },
        {
            "name": "precision",
            "description": "The number of characters to use in the geohash. You can specify a value from 1 to 20 . By default, precision is 20 , which produces a geohash that is 20 characters long."
        }
    ],
    "returns": "Returns a value of type GEOMETRY."
},
{
    "function_name": "ST_GEOMETRYFROMWKT",
    "summary": "Parses a WKT (well-known text) or EWKT (extended well-known text) input and returns a value of type GEOMETRY.",
    "category": "Geospatial functions , Conversion functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/st_geometryfromwkt",
    "title": "ST_GEOMETRYFROMWKT",
    "description": "Parses a",
    "syntax": "ST_GEOMETRYFROMWKT( <varchar_expression> [ , <srid> ] [ , <allow_invalid> ] )\n\nST_GEOMFROMWKT( <varchar_expression> [ , <srid> ] [ , <allow_invalid> ] )\n\nST_GEOMETRYFROMEWKT( <varchar_expression> [ , <srid> ] [ , <allow_invalid> ] )\n\nST_GEOMFROMEWKT( <varchar_expression> [ , <srid> ] [ , <allow_invalid> ] )\n\nST_GEOMETRYFROMTEXT( <varchar_expression> [ , <srid> ] [ , <allow_invalid> ] )\n\nST_GEOMFROMTEXT( <varchar_expression> [ , <srid> ] [ , <allow_invalid> ] )",
    "example": "-- Set the output format to EWKT\nALTER SESSION SET GEOMETRY_OUTPUT_FORMAT='EWKT';\n\nSELECT ST_GEOMETRYFROMEWKT('SRID=32633;POINT(389866.35 5819003.03)');\n\n+---------------------------------------------------------------+\n| ST_GEOMETRYFROMEWKT('SRID=32633;POINT(389866.35 5819003.03)') |\n|---------------------------------------------------------------|\n| SRID=32633;POINT(389866.35 5819003.03)                        |\n+---------------------------------------------------------------+\n\n-- Set the output format to EWKT\nALTER SESSION SET GEOMETRY_OUTPUT_FORMAT='EWKT';\n\nSELECT ST_GEOMETRYFROMEWKT('SRID=32633;POINTZ(389866.35 5819003.03 30)');\n\n+-------------------------------------------------------------------+\n| ST_GEOMETRYFROMEWKT('SRID=32633;POINTZ(389866.35 5819003.03 30)') |\n|-------------------------------------------------------------------|\n| SRID=32633;POINTZ(389866.35 5819003.03 30)                        |\n+-------------------------------------------------------------------+\n\n-- Set the output format to EWKT\nALTER SESSION SET GEOMETRY_OUTPUT_FORMAT='EWKT';\n\nSELECT ST_GEOMETRYFROMWKT('POINT(389866.35 5819003.03)', 4326);\n\n+----------------------------------------------------------+\n| ST_GEOMETRYFROMWKT('POINT(389866.35 5819003.03)', 4326)  |\n|----------------------------------------------------------|\n| SRID=4326;POINT(389866.35 5819003.03)                    |\n+----------------------------------------------------------+",
    "arguments": [
        {
            "name": "varchar_expression",
            "description": "The argument must be a string expression in WKT or EWKT that represents a valid geospatial object."
        },
        {
            "name": "srid",
            "description": "The integer value of the SRID to use."
        },
        {
            "name": "allow_invalid",
            "description": "If TRUE, specifies that the function should return a GEOGRAPHY or GEOMETRY object, even when the input shape is invalid and\ncannot be repaired. For details, refer to Specifying how invalid geospatial shapes are handled ."
        }
    ],
    "returns": "The function returns a value of type GEOMETRY."
},
{
    "function_name": "ST_GEOMETRYFROMWKB",
    "summary": "Parses a WKB (well-known binary) or EWKB (extended well-known binary) input and returns a value of type GEOMETRY.",
    "category": "Geospatial functions , Conversion functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/st_geometryfromwkb",
    "title": "ST_GEOMETRYFROMWKB",
    "description": "Parses a",
    "syntax": "ST_GEOMETRYFROMWKB( <varchar_or_binary_expression> [ , <srid> ]  [ , <allow_invalid> ] )\n\nST_GEOMFROMWKB( <varchar_or_binary_expression> [ , <srid> ]  [ , <allow_invalid> ] )\n\nST_GEOMETRYFROMEWKB( <varchar_or_binary_expression> [ , <srid> ] [ , <allow_invalid> ] )\n\nST_GEOMFROMEWKB( <varchar_or_binary_expression> [ , <srid> ] [ , <allow_invalid> ] )",
    "example": "-- Set the geometry output format to EWKT\nALTER SESSION SET GEOMETRY_OUTPUT_FORMAT='EWKT';\n\nSELECT ST_GEOMETRYFROMEWKB('0101000020797F000066666666A9CB17411F85EBC19E325641');\n\n+---------------------------------------------------------------------------+\n| ST_GEOMETRYFROMEWKB('0101000020797F000066666666A9CB17411F85EBC19E325641') |\n|---------------------------------------------------------------------------|\n| SRID=32633;POINT(389866.35 5819003.03)                                    |\n+---------------------------------------------------------------------------+\n\n-- Set the geometry output format to EWKT\nALTER SESSION SET GEOMETRY_OUTPUT_FORMAT='EWKT';\n\nSELECT ST_GEOMETRYFROMEWKB('010100000066666666A9CB17411F85EBC19E325641');\n\n+-------------------------------------------------------------------+\n| ST_GEOMETRYFROMEWKB('010100000066666666A9CB17411F85EBC19E325641') |\n|-------------------------------------------------------------------|\n| SRID=0;POINT(389866.35 5819003.03)                                |\n+-------------------------------------------------------------------+",
    "arguments": [
        {
            "name": "varchar_or_binary_expression",
            "description": "The argument must be a string or binary expression in WKB or EWKB that represents a valid geospatial object. A string expression must be in hexadecimal format (without a leading 0x )."
        },
        {
            "name": "srid",
            "description": "The integer value of the SRID to use."
        },
        {
            "name": "allow_invalid",
            "description": "If TRUE, specifies that the function should return a GEOGRAPHY or GEOMETRY object, even when the input shape is invalid and\ncannot be repaired. For details, refer to Specifying how invalid geospatial shapes are handled ."
        }
    ],
    "returns": "The function returns a value of type GEOMETRY."
},
{
    "function_name": "ST_GEOHASH",
    "summary": "Returns the geohash for a GEOGRAPHY or GEOMETRY object.",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/st_geohash",
    "title": "ST_GEOHASH",
    "description": "Returns the",
    "syntax": "ST_GEOHASH( <geography_expression> [, <precision> ] )\n\nST_GEOHASH( <geometry_expression> [, <precision> ] )",
    "example": "SELECT ST_GEOHASH(\n  TO_GEOGRAPHY('POINT(-122.306100 37.554162)'))\n  AS geohash_of_point_a;\n\n+----------------------+\n| GEOHASH_OF_POINT_A   |\n|----------------------|\n| 9q9j8ue2v71y5zzy0s4q |\n+----------------------+\n\nSELECT ST_GEOHASH(\n  TO_GEOGRAPHY('POINT(-122.306100 37.554162)'),\n  5) AS less_precise_geohash_a;\n\n+------------------------+\n| LESS_PRECISE_GEOHASH_A |\n|------------------------|\n| 9q9j8                  |\n+------------------------+\n\nSELECT ST_GEOHASH(\n  TO_GEOMETRY('POINT(-122.306100 37.554162)', 4326))\n  AS geohash_of_point_a;\n\n+----------------------+\n| GEOHASH_OF_POINT_A   |\n|----------------------|\n| 9q9j8ue2v71y5zzy0s4q |\n+----------------------+\n\nSELECT\n  ST_GEOHASH(\n    TO_GEOGRAPHY('POINT(-122.306100 37.554162)'))\n    AS geohash_of_point_a,\n  ST_GEOHASH(\n    TO_GEOGRAPHY('POINT(-122.323111 37.562333)'))\n    AS geohash_of_point_b;\n\n+----------------------+----------------------+\n| GEOHASH_OF_POINT_A   | GEOHASH_OF_POINT_B   |\n|----------------------+----------------------|\n| 9q9j8ue2v71y5zzy0s4q | 9q9j8qp02yms1tpjesmc |\n+----------------------+----------------------+\n\nSELECT\n  ST_GEOHASH(\n    TO_GEOGRAPHY('POINT(-122.306100 37.554162)'),\n    5) AS less_precise_geohash_a,\n  ST_GEOHASH(\n    TO_GEOGRAPHY('POINT(-122.323111 37.562333)'),\n    5) AS less_precise_geohash_b;\n\n+------------------------+------------------------+\n| LESS_PRECISE_GEOHASH_A | LESS_PRECISE_GEOHASH_B |\n|------------------------+------------------------|\n| 9q9j8                  | 9q9j8                  |\n+------------------------+------------------------+\n\nSELECT\n  ST_GEOHASH(\n    TO_GEOGRAPHY(\n      'POLYGON((-122.306100 37.554162, -122.306100 37.562333, -122.323111 37.562333, -122.323111 37.554162, -122.306100 37.554162))'\n    )\n  ) AS geohash_of_polygon;\n\n+--------------------+\n| GEOHASH_OF_POLYGON |\n|--------------------|\n| 9q9j8              |\n+--------------------+",
    "arguments": [
        {
            "name": "geography_expression",
            "description": "The argument must be an expression of type GEOGRAPHY."
        },
        {
            "name": "geometry_expression",
            "description": "The argument must be an expression of type GEOMETRY with the SRID 4326."
        },
        {
            "name": "precision",
            "description": "The number of characters to use in the geohash. You can specify a value from 1 to 20 . By default, precision is 20 , which produces a geohash that is 20 characters long."
        }
    ],
    "returns": "Returns the geohash (a value of type STRING) for the specified object."
},
{
    "function_name": "ST_GEOGRAPHYFROMWKT",
    "summary": "Parses a WKT (well-known text) or EWKT (extended well-known text) input and returns a value of type GEOGRAPHY.",
    "category": "Geospatial functions , Conversion functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/st_geographyfromwkt",
    "title": "ST_GEOGRAPHYFROMWKT",
    "description": "Parses a",
    "syntax": "ST_GEOGRAPHYFROMWKT( <varchar_expression> [ , <allow_invalid> ] )\n\nST_GEOGFROMWKT( <varchar_expression> [ , <allow_invalid> ] )\n\nST_GEOGRAPHYFROMEWKT( <varchar_expression> [ , <allow_invalid> ] )\n\nST_GEOGFROMEWKT( <varchar_expression> [ , <allow_invalid> ] )\n\nST_GEOGRAPHYFROMTEXT( <varchar_expression> [ , <allow_invalid> ] )\n\nST_GEOGFROMTEXT( <varchar_expression> [ , <allow_invalid> ] )",
    "example": "-- Set the output format to WKT\nalter session set GEOGRAPHY_OUTPUT_FORMAT='WKT';\n\nselect ST_GEOGRAPHYFROMWKT('POINT(-122.35 37.55)');\n\n+---------------------------------------------+\n| ST_GEOGRAPHYFROMWKT('POINT(-122.35 37.55)') |\n|---------------------------------------------|\n| POINT(-122.35 37.55)                        |\n+---------------------------------------------+\n\n-- Set the output format to WKT\nalter session set GEOGRAPHY_OUTPUT_FORMAT='WKT';\n\nselect ST_GEOGRAPHYFROMWKT('POINTZ(-122.35 37.55 30)');\n\n+-------------------------------------------------+\n| ST_GEOGRAPHYFROMWKT('POINTZ(-122.35 37.55 30)') |\n|-------------------------------------------------|\n| POINTZ(-122.35 37.55 30)                        |\n+-------------------------------------------------+\n\n-- Set the output format to EWKT\nalter session set GEOGRAPHY_OUTPUT_FORMAT='EWKT';\n\nselect ST_GEOGRAPHYFROMEWKT('SRID=4326;POINT(-122.35 37.55)');\n\n+--------------------------------------------------------+\n| ST_GEOGRAPHYFROMEWKT('SRID=4326;POINT(-122.35 37.55)') |\n|--------------------------------------------------------|\n| SRID=4326;POINT(-122.35 37.55)                         |\n+--------------------------------------------------------+",
    "arguments": [
        {
            "name": "varchar_expression",
            "description": "The argument must be a string expression in WKT or EWKT that represents a valid geospatial object."
        },
        {
            "name": "allow_invalid",
            "description": "If TRUE, specifies that the function should return a GEOGRAPHY or GEOMETRY object, even when the input shape is invalid and\ncannot be repaired. For details, refer to Specifying how invalid geospatial shapes are handled ."
        }
    ],
    "returns": "The function returns a value of type GEOGRAPHY."
},
{
    "function_name": "ST_GEOGPOINTFROMGEOHASH",
    "summary": "Returns a GEOGRAPHY object for the Point that represents the center of a geohash.",
    "category": "Geospatial functions , Conversion functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/st_geogpointfromgeohash",
    "title": "ST_GEOGPOINTFROMGEOHASH",
    "description": "Returns a",
    "syntax": "ST_GEOGPOINTFROMGEOHASH( <geohash> )",
    "example": "SELECT ST_GEOGPOINTFROMGEOHASH('9q9j8ue2v71y5zzy0s4q')\n    AS geography_center_point_of_geohash;\n+-----------------------------------+\n| GEOGRAPHY_CENTER_POINT_OF_GEOHASH |\n|-----------------------------------|\n| {                                 |\n|   \"coordinates\": [                |\n|     -1.223060999999999e+02,       |\n|     3.755416200000003e+01         |\n|   ],                              |\n|   \"type\": \"Point\"                 |\n| }                                 |\n+-----------------------------------+",
    "arguments": [
        {
            "name": "geohash",
            "description": "The argument must be a geohash."
        }
    ],
    "returns": "The function returns a value of type GEOGRAPHY that represents the Point that is\nthe center of the geohash."
},
{
    "function_name": "ST_GEOGRAPHYFROMWKB",
    "summary": "Parses a WKB (well-known binary) or EWKB (extended well-known binary) input and returns a value of type GEOGRAPHY.",
    "category": "Geospatial functions , Conversion functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/st_geographyfromwkb",
    "title": "ST_GEOGRAPHYFROMWKB",
    "description": "Parses a",
    "syntax": "ST_GEOGRAPHYFROMWKB( <varchar_or_binary_expression> [ , <allow_invalid> ] )\n\nST_GEOGFROMWKB( <varchar_or_binary_expression> [ , <allow_invalid> ] )\n\nST_GEOGRAPHYFROMEWKB( <varchar_or_binary_expression> [ , <allow_invalid> ] )\n\nST_GEOGFROMEWKB( <varchar_or_binary_expression> [ , <allow_invalid> ] )",
    "example": "-- Set the output format to WKT\nalter session set GEOGRAPHY_OUTPUT_FORMAT='WKT';\n\nselect ST_GEOGRAPHYFROMWKB('01010000006666666666965EC06666666666C64240');\n+-------------------------------------------------------------------+\n| ST_GEOGRAPHYFROMWKB('01010000006666666666965EC06666666666C64240') |\n|-------------------------------------------------------------------|\n| POINT(-122.35 37.55)                                              |\n+-------------------------------------------------------------------+\n\n-- Set the output format to EWKT\nalter session set GEOGRAPHY_OUTPUT_FORMAT='EWKT';\n\nselect ST_GEOGRAPHYFROMEWKB('0101000020E61000006666666666965EC06666666666C64240');\n+----------------------------------------------------------------------------+\n| ST_GEOGRAPHYFROMEWKB('0101000020E61000006666666666965EC06666666666C64240') |\n|----------------------------------------------------------------------------|\n| SRID=4326;POINT(-122.35 37.55)                                             |\n+----------------------------------------------------------------------------+",
    "arguments": [
        {
            "name": "varchar_or_binary_expression",
            "description": "The argument must be a string or binary expression in WKB or EWKB that represents a valid geospatial object. A string expression must be in hexadecimal format (without a leading 0x )."
        },
        {
            "name": "allow_invalid",
            "description": "If TRUE, specifies that the function should return a GEOGRAPHY or GEOMETRY object, even when the input shape is invalid and\ncannot be repaired. For details, refer to Specifying how invalid geospatial shapes are handled ."
        }
    ],
    "returns": "The function returns a value of type GEOGRAPHY."
},
{
    "function_name": "ST_GEOGFROMGEOHASH",
    "summary": "Returns a GEOGRAPHY object for the polygon that represents the boundaries of a geohash.",
    "category": "Geospatial functions , Conversion functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/st_geogfromgeohash",
    "title": "ST_GEOGFROMGEOHASH",
    "description": "Returns a",
    "syntax": "ST_GEOGFROMGEOHASH( <geohash> [, <precision> ] )",
    "example": "SELECT ST_GEOGFROMGEOHASH('9q9j8ue2v71y5zzy0s4q')\n    AS geography_from_geohash,\n    ST_AREA(ST_GEOGFROMGEOHASH('9q9j8ue2v71y5zzy0s4q'))\n    AS area_of_geohash;\n+---------------------------------+-----------------+\n| GEOGRAPHY_FROM_GEOHASH          | AREA_OF_GEOHASH |\n|---------------------------------+-----------------|\n| {                               |  5.48668572e-16 |\n|   \"coordinates\": [              |                 |\n|     [                           |                 |\n|       [                         |                 |\n|         -1.223061000000001e+02, |                 |\n|         3.755416199999996e+01   |                 |\n|       ],                        |                 |\n|       [                         |                 |\n|         -1.223061000000001e+02, |                 |\n|         3.755416200000012e+01   |                 |\n|       ],                        |                 |\n|       [                         |                 |\n|         -1.223060999999998e+02, |                 |\n|         3.755416200000012e+01   |                 |\n|       ],                        |                 |\n|       [                         |                 |\n|         -1.223060999999998e+02, |                 |\n|         3.755416199999996e+01   |                 |\n|       ],                        |                 |\n|       [                         |                 |\n|         -1.223061000000001e+02, |                 |\n|         3.755416199999996e+01   |                 |\n|       ]                         |                 |\n|     ]                           |                 |\n|   ],                            |                 |\n|   \"type\": \"Polygon\"             |                 |\n| }                               |                 |\n+---------------------------------+-----------------+\n\nSELECT ST_GEOGFROMGEOHASH('9q9j8ue2v71y5zzy0s4q', 6)\n    AS geography_from_less_precise_geohash,\n    ST_AREA(ST_GEOGFROMGEOHASH('9q9j8ue2v71y5zzy0s4q', 6))\n    AS area_of_geohash;\n+-------------------------------------+-----------------+\n| GEOGRAPHY_FROM_LESS_PRECISE_GEOHASH | AREA_OF_GEOHASH |\n|-------------------------------------+-----------------|\n| {                                   | 591559.75661851 |\n|   \"coordinates\": [                  |                 |\n|     [                               |                 |\n|       [                             |                 |\n|         -1.223107910156250e+02,     |                 |\n|         3.755126953125000e+01       |                 |\n|       ],                            |                 |\n|       [                             |                 |\n|         -1.223107910156250e+02,     |                 |\n|         3.755676269531250e+01       |                 |\n|       ],                            |                 |\n|       [                             |                 |\n|         -1.222998046875000e+02,     |                 |\n|         3.755676269531250e+01       |                 |\n|       ],                            |                 |\n|       [                             |                 |\n|         -1.222998046875000e+02,     |                 |\n|         3.755126953125000e+01       |                 |\n|       ],                            |                 |\n|       [                             |                 |\n|         -1.223107910156250e+02,     |                 |\n|         3.755126953125000e+01       |                 |\n|       ]                             |                 |\n|     ]                               |                 |\n|   ],                                |                 |\n|   \"type\": \"Polygon\"                 |                 |\n| }                                   |                 |\n+-------------------------------------+-----------------+",
    "arguments": [
        {
            "name": "geohash",
            "description": "The argument must be a geohash."
        },
        {
            "name": "precision",
            "description": "The number of characters to use from the input geohash. For example, passing 5 for precision causes\nthe function to use the first 5 characters in the geohash. You can specify a value from 1 to 20 . By default, precision is 20 , which causes the function to use up to the first 20 characters of the geohash."
        }
    ],
    "returns": "The function returns a value of type GEOGRAPHY."
},
{
    "function_name": "ST_ENVELOPE",
    "summary": "Returns the minimum bounding box (a rectangular “envelope”) that encloses a specified GEOGRAPHY or GEOMETRY object.",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/st_envelope",
    "title": "ST_ENVELOPE",
    "syntax": "ST_ENVELOPE( <geography_or_geometry_expression> )",
    "example": "SELECT ST_ENVELOPE(\n    TO_GEOGRAPHY(\n        'POLYGON((-122.306067 37.55412, -122.32328 37.561801, -122.325879 37.586852, -122.306067 37.55412))'\n    )\n) as minimum_bounding_box_around_polygon;\n+-----------------------------------------------------------------------------------------------------------------------+\n| MINIMUM_BOUNDING_BOX_AROUND_POLYGON                                                                                   |\n|-----------------------------------------------------------------------------------------------------------------------|\n| POLYGON((-122.325879 37.55412,-122.306067 37.55412,-122.306067 37.586852,-122.325879 37.586852,-122.325879 37.55412)) |\n+-----------------------------------------------------------------------------------------------------------------------+\n\nSELECT ST_ENVELOPE(\n    TO_GEOGRAPHY(\n        'LINESTRING(-122.32328 37.561801, -122.32328 37.562001)'\n    )\n) as minimum_bounding_box_around_meridian_arc;\n+-------------------------------------------------------+\n| MINIMUM_BOUNDING_BOX_AROUND_MERIDIAN_ARC              |\n|-------------------------------------------------------|\n| LINESTRING(-122.32328 37.561801,-122.32328 37.562001) |\n+-------------------------------------------------------+\n\nSELECT ST_ENVELOPE(\n    TO_GEOGRAPHY(\n        'LINESTRING(-122.32328 37.561801,-122.32351 37.561801)'\n    )\n) as minimum_bounding_box_around_arc_along_parallel;\n+---------------------------------------------------------------------------------------------------------------------+\n| MINIMUM_BOUNDING_BOX_AROUND_ARC_ALONG_PARALLEL                                                                      |\n|---------------------------------------------------------------------------------------------------------------------|\n| POLYGON((-122.32351 37.561801,-122.32328 37.561801,-122.32328 37.561801,-122.32351 37.561801,-122.32351 37.561801)) |\n+---------------------------------------------------------------------------------------------------------------------+\n\nSELECT ST_ENVELOPE(\n    TO_GEOGRAPHY(\n        'POINT(-122.32328 37.561801)'\n    )\n) as minimum_bounding_box_around_point;\n+-----------------------------------+\n| MINIMUM_BOUNDING_BOX_AROUND_POINT |\n|-----------------------------------|\n| POINT(-122.32328 37.561801)       |\n+-----------------------------------+",
    "arguments": [
        {
            "name": "geography_or_geometry_expression",
            "description": "The argument must be of type GEOGRAPHY or GEOMETRY."
        }
    ],
    "returns": "The function returns a value of type GEOGRAPHY or GEOMETRY\nthat represents the minimum bounding box around the input object."
},
{
    "function_name": "ST_ENDPOINT",
    "summary": "Returns the last Point in a LineString.",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/st_endpoint",
    "title": "ST_ENDPOINT",
    "description": "Returns the last Point in a LineString.",
    "syntax": "ST_ENDPOINT( <geography_or_geometry_expression> )",
    "example": "ALTER SESSION SET GEOGRAPHY_OUTPUT_FORMAT='WKT';\nSELECT ST_ENDPOINT(TO_GEOGRAPHY('LINESTRING(1 1, 2 2, 3 3, 4 4)'));\n\n+-------------------------------------------------------------+\n| ST_ENDPOINT(TO_GEOGRAPHY('LINESTRING(1 1, 2 2, 3 3, 4 4)')) |\n|-------------------------------------------------------------|\n| POINT(4 4)                                                  |\n+-------------------------------------------------------------+\n\nALTER SESSION SET GEOMETRY_OUTPUT_FORMAT='WKT';\nSELECT ST_ENDPOINT(TO_GEOMETRY('LINESTRING(1 1, 2 2, 3 3, 4 4)'));\n\n+------------------------------------------------------------+\n| ST_ENDPOINT(TO_GEOMETRY('LINESTRING(1 1, 2 2, 3 3, 4 4)')) |\n|------------------------------------------------------------|\n| POINT(4 4)                                                 |\n+------------------------------------------------------------+",
    "arguments": [
        {
            "name": "geography_or_geometry_expression",
            "description": "The argument must be an expression of type GEOGRAPHY or GEOMETRY that represents a LineString."
        }
    ],
    "returns": "The function returns a value of type GEOGRAPHY or GEOMETRY that contains the last Point of the specified LineString."
},
{
    "function_name": "ST_DWITHIN",
    "summary": "Returns TRUE if the minimum great circle distance between two points (two GEOGRAPHY objects) is within the specified distance.",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/st_dwithin",
    "title": "ST_DWITHIN",
    "description": "Returns TRUE if the minimum great circle distance between two points (two",
    "syntax": "ST_DWITHIN( <geography_expression_1> , <geography_expression_2> , <distance_in_meters> )",
    "example": "SELECT ST_DWITHIN (ST_MAKEPOINT(0, 0), ST_MAKEPOINT(1, 0), 150000);\n+-------------------------------------------------------------+\n| ST_DWITHIN (ST_MAKEPOINT(0, 0), ST_MAKEPOINT(1, 0), 150000) |\n|-------------------------------------------------------------|\n| True                                                        |\n+-------------------------------------------------------------+",
    "arguments": [
        {
            "name": "geography_expression_1",
            "description": "The argument must be an expression of type GEOGRAPHY."
        },
        {
            "name": "geography_expression_2",
            "description": "The argument must be an expression of type GEOGRAPHY."
        },
        {
            "name": "distance_in_meters",
            "description": "The argument must be an expression of type REAL. The distance is in meters."
        }
    ],
    "returns": "Returns a BOOLEAN."
},
{
    "function_name": "ST_DISTANCE",
    "summary": "Returns the minimum great circle distance between two GEOGRAPHY or the minimum Euclidean distance between two GEOMETRY objects.",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/st_distance",
    "title": "ST_DISTANCE",
    "description": "Returns the minimum great circle distance between two",
    "syntax": "ST_DISTANCE( <geography_or_geometry_expression_1> , <geography_or_geometry_expression_2> )",
    "example": "WITH d AS\n  ( ST_DISTANCE(ST_MAKEPOINT(0, 0), ST_MAKEPOINT(1, 0)) )\nSELECT d / 1000 AS kilometers, d / 1609 AS miles;\n\n+---------------+--------------+\n|    KILOMETERS |        MILES |\n|---------------+--------------|\n| 111.195101177 | 69.108204585 |\n+---------------+--------------+\n\nSELECT ST_DISTANCE(ST_MAKEPOINT(0, 0), ST_MAKEPOINT(NULL, NULL)) AS null_input;\n\n+------------+\n| NULL_INPUT |\n|------------|\n|       NULL |\n+------------+\n\nSELECT ST_DISTANCE(TO_GEOMETRY('POINT(0 0)'), TO_GEOMETRY('POINT(1 1)')) AS geometry_distance,\n  ST_DISTANCE(TO_GEOGRAPHY('POINT(0 0)'), TO_GEOGRAPHY('POINT(1 1)')) AS geography_distance;\n\n+-------------------+--------------------+\n| GEOMETRY_DISTANCE | GEOGRAPHY_DISTANCE |\n|-------------------+--------------------|\n|       1.414213562 |   157249.628092508 |\n+-------------------+--------------------+",
    "arguments": [
        {
            "name": "geography_or_geometry_expression_1",
            "description": "The argument must be of type GEOGRAPHY or GEOMETRY."
        },
        {
            "name": "geography_or_geometry_expression_2",
            "description": "The argument must be of type GEOGRAPHY or GEOMETRY."
        }
    ],
    "returns": "Returns a FLOAT value, which represents the distance, or NULL:"
},
{
    "function_name": "ST_DISJOINT",
    "summary": "Returns TRUE if the two GEOGRAPHY objects or the two GEOMETRY objects are disjoint (i.e. do not share any portion of space).",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/st_disjoint",
    "title": "ST_DISJOINT",
    "description": "Returns TRUE if the two",
    "syntax": "ST_DISJOINT( <geography_expression_1> , <geography_expression_2> )\n\nST_DISJOINT( <geometry_expression_1> , <geometry_expression_2> )",
    "example": "-- These two polygons are disjoint and do not intersect.\nSELECT ST_DISJOINT(\n    TO_GEOGRAPHY('POLYGON((0 0, 2 0, 2 2, 0 2, 0 0))'),\n    TO_GEOGRAPHY('POLYGON((3 3, 5 3, 5 5, 3 5, 3 3))')\n    );\n+---------------------------------------------------------+\n| ST_DISJOINT(                                            |\n|     TO_GEOGRAPHY('POLYGON((0 0, 2 0, 2 2, 0 2, 0 0))'), |\n|     TO_GEOGRAPHY('POLYGON((3 3, 5 3, 5 5, 3 5, 3 3))')  |\n|     )                                                   |\n|---------------------------------------------------------|\n| True                                                    |\n+---------------------------------------------------------+\n\n-- These two polygons intersect and are not disjoint.\nSELECT ST_DISJOINT(\n    TO_GEOGRAPHY('POLYGON((0 0, 2 0, 2 2, 0 2, 0 0))'),\n    TO_GEOGRAPHY('POLYGON((1 1, 3 1, 3 3, 1 3, 1 1))')\n    );\n+---------------------------------------------------------+\n| ST_DISJOINT(                                            |\n|     TO_GEOGRAPHY('POLYGON((0 0, 2 0, 2 2, 0 2, 0 0))'), |\n|     TO_GEOGRAPHY('POLYGON((1 1, 3 1, 3 3, 1 3, 1 1))')  |\n|     )                                                   |\n|---------------------------------------------------------|\n| False                                                   |\n+---------------------------------------------------------+",
    "arguments": [
        {
            "name": "geography_expression_1",
            "description": "A GEOGRAPHY object."
        },
        {
            "name": "geography_expression_2",
            "description": "A GEOGRAPHY object."
        },
        {
            "name": "geometry_expression_1",
            "description": "A GEOMETRY object."
        },
        {
            "name": "geometry_expression_2",
            "description": "A GEOMETRY object."
        }
    ],
    "returns": "BOOLEAN."
},
{
    "function_name": "ST_DIMENSION",
    "summary": "Given a value of type GEOGRAPHY or GEOMETRY, return the “dimension” of the value.",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/st_dimension",
    "title": "ST_DIMENSION",
    "description": "Given a value of type",
    "syntax": "ST_DIMENSION( <geography_or_geometry_expression> )",
    "example": "create table geospatial_table_02 (id INTEGER, g GEOGRAPHY);\ninsert into geospatial_table_02 values\n    (1, 'POINT(-122.35 37.55)'),\n    (2, 'MULTIPOINT((-122.35 37.55), (0.00 -90.0))'),\n    (3, 'LINESTRING(-124.20 42.00, -120.01 41.99)'),\n    (4, 'LINESTRING(-124.20 42.00, -120.01 41.99, -122.5 42.01)'),\n    (5, 'MULTILINESTRING((-124.20 42.00, -120.01 41.99, -122.5 42.01), (10.0 0.0, 20.0 10.0, 30.0 0.0))'),\n    (6, 'POLYGON((-124.20 42.00, -120.01 41.99, -121.1 42.01, -124.20 42.00))'),\n    (7, 'MULTIPOLYGON(((-124.20 42.00, -120.01 41.99, -121.1 42.01, -124.20 42.0)), ((20.0 20.0, 40.0 20.0, 40.0 40.0, 20.0 40.0, 20.0 20.0)))')\n    ;\n\nselect st_dimension(g) as dimension, st_aswkt(g)\n    from geospatial_table_02\n    order by dimension, id;\n+-----------+----------------------------------------------------------------------------------------------------+\n| DIMENSION | ST_ASWKT(G)                                                                                        |\n|-----------+----------------------------------------------------------------------------------------------------|\n|         0 | POINT(-122.35 37.55)                                                                               |\n|         0 | MULTIPOINT((-122.35 37.55),(0 -90))                                                                |\n|         1 | LINESTRING(-124.2 42,-120.01 41.99)                                                                |\n|         1 | LINESTRING(-124.2 42,-120.01 41.99,-122.5 42.01)                                                   |\n|         1 | MULTILINESTRING((-124.2 42,-120.01 41.99,-122.5 42.01),(10 0,20 10,30 0))                          |\n|         2 | POLYGON((-124.2 42,-120.01 41.99,-121.1 42.01,-124.2 42))                                          |\n|         2 | MULTIPOLYGON(((-124.2 42,-120.01 41.99,-121.1 42.01,-124.2 42)),((20 20,40 20,40 40,20 40,20 20))) |\n+-----------+----------------------------------------------------------------------------------------------------+\n\nCREATE OR REPLACE TABLE geometry_shapes (g GEOMETRY);\nINSERT INTO geometry_shapes VALUES\n    ('POINT(66 12)'),\n    ('MULTIPOINT((45 21), (12 54))'),\n    ('LINESTRING(40 60, 50 50, 60 40)'),\n    ('MULTILINESTRING((1 1, 32 17), (33 12, 73 49, 87.1 6.1))'),\n    ('POLYGON((17 17, 17 30, 30 30, 30 17, 17 17))'),\n    ('MULTIPOLYGON(((-10 0,0 10,10 0,-10 0)),((-10 40,10 40,0 20,-10 40)))'),\n    ('GEOMETRYCOLLECTION(POLYGON((-10 0,0 10,10 0,-10 0)),LINESTRING(40 60, 50 50, 60 40), POINT(99 11))')\n    ;\n\nSELECT ST_DIMENSION(g), ST_ASWKT(g) FROM geometry_shapes;\n\n+-----------------+-------------------------------------------------------------------------------------------------+\n| ST_DIMENSION(G) | ST_ASWKT(G)                                                                                     |\n|-----------------+-------------------------------------------------------------------------------------------------|\n|               0 | POINT(66 12)                                                                                    |\n|               0 | MULTIPOINT((45 21),(12 54))                                                                     |\n|               1 | LINESTRING(40 60,50 50,60 40)                                                                   |\n|               1 | MULTILINESTRING((1 1,32 17),(33 12,73 49,87.1 6.1))                                             |\n|               2 | POLYGON((17 17,17 30,30 30,30 17,17 17))                                                        |\n|               2 | MULTIPOLYGON(((-10 0,0 10,10 0,-10 0)),((-10 40,10 40,0 20,-10 40)))                            |\n|               2 | GEOMETRYCOLLECTION(POLYGON((-10 0,0 10,10 0,-10 0)),LINESTRING(40 60,50 50,60 40),POINT(99 11)) |\n+-----------------+-------------------------------------------------------------------------------------------------+",
    "arguments": [
        {
            "name": "geography_or_geometry_expression",
            "description": "The argument must be an expression of type GEOGRAPHY or GEOMETRY."
        }
    ],
    "returns": "A value of type INTEGER."
},
{
    "function_name": "ST_DIFFERENCE",
    "summary": "Given two input GEOGRAPHY objects, returns a GEOGRAPHY object that represents the points in the first object that are not in the second object (i.e. the difference between the two objects).",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/st_difference",
    "title": "ST_DIFFERENCE",
    "description": "Given two input GEOGRAPHY objects, returns a GEOGRAPHY object that represents the points in the first object that are not in the\nsecond object (i.e. the difference between the two objects).",
    "syntax": "ST_DIFFERENCE( <geography_expression_1> , <geography_expression_2> )",
    "example": "ALTER SESSION SET GEOGRAPHY_OUTPUT_FORMAT = 'WKT';\n\nSELECT ST_DIFFERENCE(\n  TO_GEOGRAPHY('POLYGON((0 0, 1 0, 2 1, 1 2, 2 3, 1 4, 0 4, 0 0))'),\n  TO_GEOGRAPHY('POLYGON((3 0, 3 4, 2 4, 1 3, 2 2, 1 1, 2 0, 3 0))'))\nAS difference_between_objects;\n\n+-------------------------------------------------------------------------------------------------------------+\n| DIFFERENCE_BETWEEN_OBJECTS                                                                                  |\n|-------------------------------------------------------------------------------------------------------------|\n| POLYGON((1 1,1.5 1.500171359,1 2,1.5 2.500285599,1 3,1.5 3.500399839,1 4,0 4,0 0,1 0,1.5 0.5000571198,1 1)) |\n+-------------------------------------------------------------------------------------------------------------+",
    "arguments": [
        {
            "name": "geography_expression_1",
            "description": "A GEOGRAPHY object."
        },
        {
            "name": "geography_expression_2",
            "description": "A GEOGRAPHY object."
        }
    ],
    "returns": "The function returns a value of type GEOGRAPHY."
},
{
    "function_name": "ST_COVERS",
    "summary": "Returns TRUE if no point in one geospatial object is outside of another geospatial object.",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/st_covers",
    "title": "ST_COVERS",
    "description": "Returns TRUE if no point in one geospatial object is outside of another geospatial object. In other words:",
    "syntax": "ST_COVERS( <geography_expression_1> , <geography_expression_2> )\n\nST_COVERS( <geometry_expression_1> , <geometry_expression_2> )",
    "example": "create table geospatial_table_01 (g1 GEOGRAPHY, g2 GEOGRAPHY);\ninsert into geospatial_table_01 (g1, g2) values \n    ('POLYGON((0 0, 3 0, 3 3, 0 3, 0 0))', 'POLYGON((1 1, 2 1, 2 2, 1 2, 1 1))');\n\nSELECT ST_COVERS(g1, g2) \n    FROM geospatial_table_01;\n+-------------------+\n| ST_COVERS(G1, G2) |\n|-------------------|\n| True              |\n+-------------------+\n\nSELECT ST_COVERS(poly, poly_inside),\n       ST_COVERS(poly, poly),\n       ST_COVERS(poly, line_on_boundary),\n       ST_COVERS(poly, line_inside)\n  FROM (SELECT TO_GEOMETRY('POLYGON((-2 0, 0 2, 2 0, -2 0))') AS poly,\n               TO_GEOMETRY('POLYGON((-1 0, 0 1, 1 0, -1 0))') AS poly_inside,\n               TO_GEOMETRY('LINESTRING(-1 1, 0 2, 1 1)') AS line_on_boundary,\n               TO_GEOMETRY('LINESTRING(-2 0, 0 0, 0 1)') AS line_inside);\n\n+------------------------------+----------------------+----------------------------------+-----------------------------+\n| ST_COVERS(POLY, POLY_INSIDE) | ST_COVERS(POLY,POLY) | ST_COVERS(POLY,LINE_ON_BOUNDARY) | ST_COVERS(POLY,LINE_INSIDE) |\n|------------------------------+----------------------+----------------------------------+-----------------------------|\n| True                         | True                 | True                             | True                        |\n+------------------------------+----------------------+----------------------------------+-----------------------------+",
    "arguments": [
        {
            "name": "geography_expression_1",
            "description": "A GEOGRAPHY object that is not a GeometryCollection or FeatureCollection."
        },
        {
            "name": "geography_expression_2",
            "description": "A GEOGRAPHY object that is not a GeometryCollection or FeatureCollection."
        },
        {
            "name": "geometry_expression_1",
            "description": "A GEOMETRY object that is not a GeometryCollection or FeatureCollection."
        },
        {
            "name": "geometry_expression_2",
            "description": "A GEOMETRY object that is not a GeometryCollection or FeatureCollection."
        }
    ],
    "returns": "BOOLEAN."
},
{
    "function_name": "ST_COVEREDBY",
    "summary": "Returns TRUE if no point in one geospatial object is outside another geospatial object.",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/st_coveredby",
    "title": "ST_COVEREDBY",
    "description": "Returns TRUE if no point in one geospatial object is outside another geospatial object. In other words:",
    "syntax": "ST_COVEREDBY( <geography_expression_1> , <geography_expression_2> )\n\nST_COVEREDBY( <geometry_expression_1> , <geometry_expression_2> )",
    "example": "create table geospatial_table_01 (g1 GEOGRAPHY, g2 GEOGRAPHY);\ninsert into geospatial_table_01 (g1, g2) values \n    ('POLYGON((0 0, 3 0, 3 3, 0 3, 0 0))', 'POLYGON((1 1, 2 1, 2 2, 1 2, 1 1))');\n\nSELECT ST_COVEREDBY(g1, g2) \n    FROM geospatial_table_01;\n+----------------------+\n| ST_COVEREDBY(G1, G2) |\n|----------------------|\n| False                |\n+----------------------+",
    "arguments": [
        {
            "name": "geography_expression_1",
            "description": "A GEOGRAPHY object that is not a GeometryCollection or FeatureCollection."
        },
        {
            "name": "geography_expression_2",
            "description": "A GEOGRAPHY object that is not a GeometryCollection or FeatureCollection."
        },
        {
            "name": "geometry_expression_1",
            "description": "A GEOMETRY object that is not a GeometryCollection or FeatureCollection."
        },
        {
            "name": "geometry_expression_2",
            "description": "A GEOMETRY object that is not a GeometryCollection or FeatureCollection."
        }
    ],
    "returns": "BOOLEAN."
},
{
    "function_name": "ST_CONTAINS",
    "summary": "Returns TRUE if a GEOGRAPHY or GEOMETRY object is completely inside another object of the same type.",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/st_contains",
    "title": "ST_CONTAINS",
    "description": "Returns TRUE if a",
    "syntax": "ST_CONTAINS( <geography_expression_1> , <geography_expression_2> )\n\nST_CONTAINS( <geometry_expression_1> , <geometry_expression_2> )",
    "example": "create table geospatial_table_01 (g1 GEOGRAPHY, g2 GEOGRAPHY);\ninsert into geospatial_table_01 (g1, g2) values \n    ('POLYGON((0 0, 3 0, 3 3, 0 3, 0 0))', 'POLYGON((1 1, 2 1, 2 2, 1 2, 1 1))');\n\nSELECT ST_CONTAINS(g1, g2) \n    FROM geospatial_table_01;\n+---------------------+\n| ST_CONTAINS(G1, G2) |\n|---------------------|\n| True                |\n+---------------------+\n\nSELECT ST_CONTAINS(poly, poly_inside),\n      ST_CONTAINS(poly, poly),\n      ST_CONTAINS(poly, line_on_boundary),\n      ST_CONTAINS(poly, line_inside)\n  FROM (SELECT\n    TO_GEOMETRY('POLYGON((-2 0, 0 2, 2 0, -2 0))') AS poly,\n    TO_GEOMETRY('POLYGON((-1 0, 0 1, 1 0, -1 0))') AS poly_inside,\n    TO_GEOMETRY('LINESTRING(-1 1, 0 2, 1 1)') AS line_on_boundary,\n    TO_GEOMETRY('LINESTRING(-2 0, 0 0, 0 1)') AS line_inside);\n\n+--------------------------------+------------------------+------------------------------------+-------------------------------+\n| ST_CONTAINS(POLY, POLY_INSIDE) | ST_CONTAINS(POLY,POLY) | ST_CONTAINS(POLY,LINE_ON_BOUNDARY) | ST_CONTAINS(POLY,LINE_INSIDE) |\n|--------------------------------+------------------------+------------------------------------+-------------------------------|\n| True                           | True                   | False                              | True                          |\n+--------------------------------+------------------------+------------------------------------+-------------------------------+",
    "arguments": [
        {
            "name": "geography_expression_1",
            "description": "A GEOGRAPHY object that is not a GeometryCollection or FeatureCollection."
        },
        {
            "name": "geography_expression_2",
            "description": "A GEOGRAPHY object that is not a GeometryCollection or FeatureCollection."
        },
        {
            "name": "geometry_expression_1",
            "description": "A GEOMETRY object that is not a GeometryCollection or FeatureCollection."
        },
        {
            "name": "geometry_expression_2",
            "description": "A GEOMETRY object that is not a GeometryCollection or FeatureCollection."
        }
    ],
    "returns": "BOOLEAN."
},
{
    "function_name": "ST_COLLECT",
    "summary": "There are two forms of ST_COLLECT.",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/st_collect",
    "title": "ST_COLLECT",
    "description": "There are two forms of ST_COLLECT:",
    "syntax": "Scalar:\n\n    ST_COLLECT( <geography_expression_1> , <geography_expression_2> )\n\nAggregate:\n\n    ST_COLLECT( <geography_expression_1> )",
    "example": "CREATE TABLE geo3 (g1 GEOGRAPHY, g2 GEOGRAPHY);\nINSERT INTO geo3 (g1, g2) VALUES\n    ( 'POINT(-180 -90)', 'POINT(-45 -45)' ),\n    ( 'POINT(   0   0)', 'POINT(-60 -60)' ),\n    ( 'POINT(+180 +90)', 'POINT(+45 +45)' );\n\n-- Scalar function:\nSELECT ST_COLLECT(g1, g2) FROM geo3;\n+------------------------+\n| ST_COLLECT(G1, G2)     |\n|------------------------|\n| {                      |\n|   \"coordinates\": [     |\n|     [                  |\n|       -180,            |\n|       -90              |\n|     ],                 |\n|     [                  |\n|       -45,             |\n|       -45              |\n|     ]                  |\n|   ],                   |\n|   \"type\": \"MultiPoint\" |\n| }                      |\n| {                      |\n|   \"coordinates\": [     |\n|     [                  |\n|       0,               |\n|       0                |\n|     ],                 |\n|     [                  |\n|       -60,             |\n|       -60              |\n|     ]                  |\n|   ],                   |\n|   \"type\": \"MultiPoint\" |\n| }                      |\n| {                      |\n|   \"coordinates\": [     |\n|     [                  |\n|       180,             |\n|       90               |\n|     ],                 |\n|     [                  |\n|       45,              |\n|       45               |\n|     ]                  |\n|   ],                   |\n|   \"type\": \"MultiPoint\" |\n| }                      |\n+------------------------+\n\n-- Aggregate function:\nSELECT ST_COLLECT(g1), ST_COLLECT(g2) FROM geo3;\n+------------------------+------------------------+\n| ST_COLLECT(G1)         | ST_COLLECT(G2)         |\n|------------------------+------------------------|\n| {                      | {                      |\n|   \"coordinates\": [     |   \"coordinates\": [     |\n|     [                  |     [                  |\n|       -180,            |       -45,             |\n|       -90              |       -45              |\n|     ],                 |     ],                 |\n|     [                  |     [                  |\n|       0,               |       -60,             |\n|       0                |       -60              |\n|     ],                 |     ],                 |\n|     [                  |     [                  |\n|       180,             |       45,              |\n|       90               |       45               |\n|     ]                  |     ]                  |\n|   ],                   |   ],                   |\n|   \"type\": \"MultiPoint\" |   \"type\": \"MultiPoint\" |\n| }                      | }                      |\n+------------------------+------------------------+\n\n-- Aggregate and then Collect:\nSELECT ST_COLLECT(ST_COLLECT(g1), ST_COLLECT(g2)) FROM geo3;\n+--------------------------------------------+\n| ST_COLLECT(ST_COLLECT(G1), ST_COLLECT(G2)) |\n|--------------------------------------------|\n| {                                          |\n|   \"geometries\": [                          |\n|     {                                      |\n|       \"coordinates\": [                     |\n|         [                                  |\n|           -180,                            |\n|           -90                              |\n|         ],                                 |\n|         [                                  |\n|           0,                               |\n|           0                                |\n|         ],                                 |\n|         [                                  |\n|           180,                             |\n|           90                               |\n|         ]                                  |\n|       ],                                   |\n|       \"type\": \"MultiPoint\"                 |\n|     },                                     |\n|     {                                      |\n|       \"coordinates\": [                     |\n|         [                                  |\n|           -45,                             |\n|           -45                              |\n|         ],                                 |\n|         [                                  |\n|           -60,                             |\n|           -60                              |\n|         ],                                 |\n|         [                                  |\n|           45,                              |\n|           45                               |\n|         ]                                  |\n|       ],                                   |\n|       \"type\": \"MultiPoint\"                 |\n|     }                                      |\n|   ],                                       |\n|   \"type\": \"GeometryCollection\"             |\n| }                                          |\n+--------------------------------------------+",
    "arguments": [
        {
            "name": "geography_expression_1",
            "description": "A GEOGRAPHY object."
        },
        {
            "name": "geography_expression_2",
            "description": "A GEOGRAPHY object."
        }
    ],
    "returns": "The function returns a value of type GEOGRAPHY."
},
{
    "function_name": "ST_CENTROID",
    "summary": "Returns the Point representing the geometric center of a GEOGRAPHY or GEOMETRY object.",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/st_centroid",
    "title": "ST_CENTROID",
    "description": "Returns the Point representing the geometric center of a",
    "syntax": "ST_CENTROID( <geography_or_geometry_expression> )",
    "example": "SELECT ST_CENTROID(\n    TO_GEOGRAPHY(\n        'LINESTRING(0 0, 0 -2)'\n    )\n) as center_of_linestring;\n+----------------------+\n| CENTER_OF_LINESTRING |\n|----------------------|\n| POINT(0 -1)          |\n+----------------------+\n\nSELECT ST_CENTROID(\n    TO_GEOGRAPHY(\n        'POLYGON((10 10, 10 20, 20 20, 20 10, 10 10))'\n    )\n) as center_of_polygon;\n+------------------------+\n| CENTER_OF_POLYGON      |\n|------------------------|\n| POINT(15 15.014819855) |\n+------------------------+\n\nSELECT ST_CENTROID(\n    TO_GEOGRAPHY(\n        'GEOMETRYCOLLECTION(POLYGON((10 10, 10 20, 20 20, 20 10, 10 10)), LINESTRING(0 0, 0 -2), POINT(50 -50))'\n    )\n) as center_of_collection_with_polygons;\n+------------------------------------+\n| CENTER_OF_COLLECTION_WITH_POLYGONS |\n|------------------------------------|\n| POINT(15 15.014819855)             |\n+------------------------------------+\n\nSELECT ST_CENTROID(TO_GEOMETRY('POLYGON((10 10, 10 20, 20 20, 20 10, 10 10))'));\n\n+--------------------------------------------------------------------------+\n| ST_CENTROID(TO_GEOMETRY('POLYGON((10 10, 10 20, 20 20, 20 10, 10 10))')) |\n|--------------------------------------------------------------------------|\n| POINT(15 15)                                                             |\n+--------------------------------------------------------------------------+",
    "arguments": [
        {
            "name": "geography_or_geometry_expression",
            "description": "The argument must be an expression of type GEOGRAPHY or GEOMETRY."
        }
    ],
    "returns": "Returns a GEOGRAPHY or GEOMETRY object for the Point that represents geometric center of the input object."
},
{
    "function_name": "ST_BUFFER",
    "summary": "Returns a GEOMETRY object that represents a MultiPolygon containing the points within a specified distance of the input GEOMETRY object.",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/st_buffer",
    "title": "ST_BUFFER",
    "description": "Returns a",
    "syntax": "ST_BUFFER( <geometry_expression> , <distance> )",
    "example": "ALTER SESSION SET GEOMETRY_OUTPUT_FORMAT='WKT';\n\nSELECT ST_BUFFER(TO_GEOMETRY('POINT(0 0)'), 1) AS geom;\n\n+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| GEOM                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |\n|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| MULTIPOLYGON(((1 0,0.9807852804 -0.195090322,0.9238795325 -0.3826834324,0.8314696123 -0.555570233,0.7071067812 -0.7071067812,0.555570233 -0.8314696123,0.3826834324 -0.9238795325,0.195090322 -0.9807852804,6.123233996e-17 -1,-0.195090322 -0.9807852804,-0.3826834324 -0.9238795325,-0.555570233 -0.8314696123,-0.7071067812 -0.7071067812,-0.8314696123 -0.555570233,-0.9238795325 -0.3826834324,-0.9807852804 -0.195090322,-1 7.657137398e-16,-0.9807852804 0.195090322,-0.9238795325 0.3826834324,-0.8314696123 0.555570233,-0.7071067812 0.7071067812,-0.555570233 0.8314696123,-0.3826834324 0.9238795325,-0.195090322 0.9807852804,2.480838239e-15 1,0.195090322 0.9807852804,0.3826834324 0.9238795325,0.555570233 0.8314696123,0.7071067812 0.7071067812,0.8314696123 0.555570233,0.9238795325 0.3826834324,0.9807852804 0.195090322,1 0))) |\n+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n\nSELECT ST_BUFFER(TO_GEOMETRY('SRID=2261;POLYGON((\n  1540792.21541900 290472.63529214, 1547018.61770388 302537.02285369,\n  1546965.96550151 302752.51514772, 1547018.61770388 302537.02285369,\n  1549532.42729914 301257.07398027, 1543327.42218339 289322.60923536,\n  1540792.21541900 290472.63529214))', True), -1e-08) AS geom;\n\n+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| GEOM                                                                                                                                                                                        |\n|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| MULTIPOLYGON(((1543327.42218339 289322.609235373,1540792.21541901 290472.635292145,1547018.61770388 302537.022853677,1549532.42729913 301257.073980266,1543327.42218339 289322.609235373))) |\n+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+",
    "arguments": [
        {
            "name": "geometry_expression",
            "description": "The argument must be an expression of type GEOMETRY."
        },
        {
            "name": "distance",
            "description": "The distance from the GEOMETRY object. To “shrink” the object, you can specify a negative value for the distance. The units depend on the spatial reference system identifier (SRID) of the GEOMETRY object. For example, ESPG:4326 units are degrees, while ESPG:25855 units are meters."
        }
    ],
    "returns": "Returns a GEOMETRY object."
},
{
    "function_name": "ST_ASWKT , ST_ASTEXT",
    "summary": "Given a value of type GEOGRAPHY or GEOMETRY, return the text (VARCHAR) representation of that value in WKT (well-known text) format.",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/st_aswkt",
    "title": "ST_ASWKT , ST_ASTEXT",
    "description": "Given a value of type",
    "syntax": "ST_ASWKT( <geography_or_geometry_expression> )\n\nST_ASTEXT( <geography_or_geometry_expression> )",
    "example": "create table geospatial_table (id INTEGER, g GEOGRAPHY);\ninsert into geospatial_table values\n    (1, 'POINT(-122.35 37.55)'), (2, 'LINESTRING(-124.20 42.00, -120.01 41.99)');\n\nselect st_astext(g)\n    from geospatial_table\n    order by id;\n+-------------------------------------+\n| ST_ASTEXT(G)                        |\n|-------------------------------------|\n| POINT(-122.35 37.55)                |\n| LINESTRING(-124.2 42,-120.01 41.99) |\n+-------------------------------------+\n\nselect st_aswkt(g)\n    from geospatial_table\n    order by id;\n+-------------------------------------+\n| ST_ASWKT(G)                         |\n|-------------------------------------|\n| POINT(-122.35 37.55)                |\n| LINESTRING(-124.2 42,-120.01 41.99) |\n+-------------------------------------+\n\nCREATE OR REPLACE TABLE geometry_table (g GEOMETRY);\nINSERT INTO geometry_table VALUES\n  ('POINT(-122.35 37.55)'), ('LINESTRING(0.75 0.75, -10 20)');\n\nALTER SESSION SET GEOMETRY_OUTPUT_FORMAT='WKT';\nSELECT ST_ASWKT(g) FROM geometry_table;\n\n+------------------------------+\n| ST_ASWKT(G)                  |\n|------------------------------|\n| POINT(-122.35 37.55)         |\n| LINESTRING(0.75 0.75,-10 20) |\n+------------------------------+",
    "arguments": [
        {
            "name": "geography_or_geometry_expression",
            "description": "The argument must be an expression of type GEOGRAPHY or GEOMETRY."
        }
    ],
    "returns": "A VARCHAR."
},
{
    "function_name": "ST_AZIMUTH",
    "summary": "Given a Point that represents the origin (the location of the observer) and a specified Point, returns the azimuth in radians.",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/st_azimuth",
    "title": "ST_AZIMUTH",
    "description": "Given a Point that represents the origin (the location of the observer) and a specified Point, returns the azimuth in radians.\nBoth Points must be either",
    "syntax": "ST_AZIMUTH( <geography_expression_for_origin> , <geography_expression_for_target> )\nST_AZIMUTH( <geometry_expression_for_origin> , <geometry_expression_for_target> )",
    "example": "SELECT ST_AZIMUTH(\n    TO_GEOGRAPHY('POINT(0 1)'),\n    TO_GEOGRAPHY('POINT(0 0)')\n);\n+---------------------------------+\n|                     ST_AZIMUTH( |\n|     TO_GEOGRAPHY('POINT(0 1)'), |\n|      TO_GEOGRAPHY('POINT(0 0)') |\n|                               ) |\n|---------------------------------|\n|                     3.141592654 |\n+---------------------------------+\n\nSELECT DEGREES(ST_AZIMUTH(\n    TO_GEOGRAPHY('POINT(0 1)'),\n    TO_GEOGRAPHY('POINT(1 2)')\n));\n+---------------------------------+\n|             DEGREES(ST_AZIMUTH( |\n|     TO_GEOGRAPHY('POINT(0 1)'), |\n|      TO_GEOGRAPHY('POINT(1 2)') |\n|                              )) |\n|---------------------------------|\n|                    44.978182941 |\n+---------------------------------+\n\nSELECT ST_AZIMUTH(\n    TO_GEOMETRY('POINT(0 1)', TO_GEOMETRY('POINT(0 0)')\n);\n\n+------------------------------------------------------------------+\n| ST_AZIMUTH(TO_GEOMETRY('POINT(0 1)'), TO_GEOMETRY('POINT(0 0)')) |\n|------------------------------------------------------------------|\n| 3.141592654                                                      |\n+------------------------------------------------------------------+\n\nSELECT ST_AZIMUTH(\n    TO_GEOMETRY('POINT(0 0)', TO_GEOMETRY(0.707 0.707')\n);\n\n+-------------------------------------------------------------------------+\n| ST_AZIMUTH(TO_GEOMETRY('POINT(0 0)'), TO_GEOMETRY('POINT(0.707 0.707')) |\n|-------------------------------------------------------------------------|\n| 0.7853981634                                                            |\n+-------------------------------------------------------------------------+",
    "arguments": [
        {
            "name": "geography_expression_for_origin",
            "description": "A GEOGRAPHY object that is a Point representing the origin (where the observer is located)."
        },
        {
            "name": "geography_expression_for_target",
            "description": "A GEOGRAPHY object that is a Point for which you want to calculate the azimuth."
        },
        {
            "name": "geometry_expression_for_origin",
            "description": "A GEOMETRY object that is a Point representing the origin (where the observer is located)."
        },
        {
            "name": "geometry_expression_for_target",
            "description": "A GEOMETRY object that is a Point for which you want to calculate the azimuth."
        }
    ],
    "returns": "Returns a value of type REAL that is the azimuth in radians."
},
{
    "function_name": "ST_ASWKB , ST_ASBINARY",
    "summary": "Given a value of type GEOGRAPHY or GEOMETRY, return the binary representation of that value in WKB (well-known binary) format.",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/st_aswkb",
    "title": "ST_ASWKB , ST_ASBINARY",
    "description": "Given a value of type",
    "syntax": "ST_ASWKB( <geography_or_geometry_expression> )\n\nST_ASBINARY( <geography_or_geometry_expression> )",
    "example": "create table geospatial_table (id INTEGER, g GEOGRAPHY);\ninsert into geospatial_table values\n    (1, 'POINT(-122.35 37.55)'), (2, 'LINESTRING(-124.20 42.00, -120.01 41.99)');\n\nselect st_aswkb(g)\n    from geospatial_table\n    order by id;\n+------------------------------------------------------------------------------------+\n| ST_ASWKB(G)                                                                        |\n|------------------------------------------------------------------------------------|\n| 01010000006666666666965EC06666666666C64240                                         |\n| 010200000002000000CDCCCCCCCC0C5FC00000000000004540713D0AD7A3005EC01F85EB51B8FE4440 |\n+------------------------------------------------------------------------------------+\n\nCREATE OR REPLACE TABLE geometry_table (g GEOMETRY);\nINSERT INTO geometry_table VALUES\n  ('POINT(-122.35 37.55)'), ('LINESTRING(0.75 0.75, -10 20)');\n\nSELECT ST_ASWKB(g) FROM geometry_table;\n\n+------------------------------------------------------------------------------------+\n| ST_ASWKB(G)                                                                        |\n|------------------------------------------------------------------------------------|\n| 01010000006666666666965EC06666666666C64240                                         |\n| 010200000002000000000000000000E83F000000000000E83F00000000000024C00000000000003440 |\n+------------------------------------------------------------------------------------+",
    "arguments": [
        {
            "name": "geography_or_geometry_expression",
            "description": "The argument must be an expression of type GEOGRAPHY or GEOMETRY."
        }
    ],
    "returns": "A value of type BINARY."
},
{
    "function_name": "ST_ASGEOJSON",
    "summary": "Given a value of type GEOGRAPHY or GEOMETRY, return the GeoJSON representation of that value.",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/st_asgeojson",
    "title": "ST_ASGEOJSON",
    "description": "Given a value of type",
    "syntax": "ST_ASGEOJSON( <geography_or_geometry_expression> )",
    "example": "create table geospatial_table (id INTEGER, g GEOGRAPHY);\ninsert into geospatial_table values\n    (1, 'POINT(-122.35 37.55)'), (2, 'LINESTRING(-124.20 42.00, -120.01 41.99)');\n\nselect st_asgeojson(g)\n    from geospatial_table\n    order by id;\n+------------------------+\n| ST_ASGEOJSON(G)        |\n|------------------------|\n| {                      |\n|   \"coordinates\": [     |\n|     -122.35,           |\n|     37.55              |\n|   ],                   |\n|   \"type\": \"Point\"      |\n| }                      |\n| {                      |\n|   \"coordinates\": [     |\n|     [                  |\n|       -124.2,          |\n|       42               |\n|     ],                 |\n|     [                  |\n|       -120.01,         |\n|       41.99            |\n|     ]                  |\n|   ],                   |\n|   \"type\": \"LineString\" |\n| }                      |\n+------------------------+\n\nselect st_asgeojson(g)::varchar\n    from geospatial_table\n    order by id;\n+-------------------------------------------------------------------+\n| ST_ASGEOJSON(G)::VARCHAR                                          |\n|-------------------------------------------------------------------|\n| {\"coordinates\":[-122.35,37.55],\"type\":\"Point\"}                    |\n| {\"coordinates\":[[-124.2,42],[-120.01,41.99]],\"type\":\"LineString\"} |\n+-------------------------------------------------------------------+\n\nSELECT ST_ASGEOJSON(TO_GEOMETRY('SRID=4326;LINESTRING(389866 5819003, 390000 5830000)')) AS geojson;\n\n+------------------------+\n| GEOJSON                |\n|------------------------|\n|{                       |\n|  \"coordinates\": [      |\n|    [                   |\n|      389866,           |\n|      5819003           |\n|    ],                  |\n|    [                   |\n|      390000,           |\n|      5830000           |\n|    ]                   |\n|  ],                    |\n|  \"type\": \"LineString\"  |\n|}                       |\n+------------------------+",
    "arguments": [
        {
            "name": "geography_or_geometry_expression",
            "description": "The argument must be an expression of type GEOGRAPHY or GEOMETRY."
        }
    ],
    "returns": "An OBJECT in GeoJSON format."
},
{
    "function_name": "ST_ASEWKT",
    "summary": "Given a value of type GEOGRAPHY or GEOMETRY, return the text (VARCHAR) representation of that value in EWKT (extended well-known text) format.",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/st_asewkt",
    "title": "ST_ASEWKT",
    "description": "Given a value of type",
    "syntax": "ST_ASEWKT( <geography_or_geometry_expression> )",
    "example": "create table geospatial_table (id INTEGER, g GEOGRAPHY);\ninsert into geospatial_table values\n    (1, 'POINT(-122.35 37.55)'), (2, 'LINESTRING(-124.20 42.00, -120.01 41.99)');\n\nselect st_asewkt(g)\n    from geospatial_table\n    order by id;\n+-----------------------------------------------+\n| ST_ASEWKT(G)                                  |\n|-----------------------------------------------|\n| SRID=4326;POINT(-122.35 37.55)                |\n| SRID=4326;LINESTRING(-124.2 42,-120.01 41.99) |\n+-----------------------------------------------+\n\nCREATE OR REPLACE TABLE geometry_table (g GEOMETRY);\nINSERT INTO geometry_table VALUES\n  ('SRID=4326;POINT(-122.35 37.55)'),\n  ('SRID=0;LINESTRING(0.75 0.75, -10 20)');\n\nALTER SESSION SET GEOMETRY_OUTPUT_FORMAT='EWKT';\nSELECT ST_ASEWKT(g) FROM geometry_table;\n\n+-------------------------------------+\n| ST_ASEWKT(G)                        |\n|-------------------------------------|\n| SRID=4326;POINT(-122.35 37.55)      |\n| SRID=0;LINESTRING(0.75 0.75,-10 20) |\n+-------------------------------------+",
    "arguments": [
        {
            "name": "geography_or_geometry_expression",
            "description": "The argument must be an expression of type GEOGRAPHY or GEOMETRY."
        }
    ],
    "returns": "A VARCHAR."
},
{
    "function_name": "ST_ASEWKB",
    "summary": "Given a value of type GEOGRAPHY or GEOMETRY, return the binary representation of that value in EWKB (extended well-known binary) format.",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/st_asewkb",
    "title": "ST_ASEWKB",
    "description": "Given a value of type",
    "syntax": "ST_ASEWKB( <geography_or_geometry_expression> )",
    "example": "create table geospatial_table (id INTEGER, g GEOGRAPHY);\ninsert into geospatial_table values\n    (1, 'POINT(-122.35 37.55)'), (2, 'LINESTRING(-124.20 42.00, -120.01 41.99)');\n\nselect st_asewkb(g)\n    from geospatial_table\n    order by id;\n+--------------------------------------------------------------------------------------------+\n| ST_ASEWKB(G)                                                                               |\n|--------------------------------------------------------------------------------------------|\n| 0101000020E61000006666666666965EC06666666666C64240                                         |\n| 0102000020E610000002000000CDCCCCCCCC0C5FC00000000000004540713D0AD7A3005EC01F85EB51B8FE4440 |\n+--------------------------------------------------------------------------------------------+\n\nCREATE OR REPLACE TABLE geometry_table (g GEOMETRY);\nINSERT INTO geometry_table VALUES\n  ('SRID=4326;POINT(-122.35 37.55)'),\n  ('SRID=0;LINESTRING(0.75 0.75, -10 20)');\n\nSELECT ST_ASEWKB(g) FROM geometry_table;\n\n+--------------------------------------------------------------------------------------------+\n| ST_ASEWKB(G)                                                                               |\n|--------------------------------------------------------------------------------------------|\n| 0101000020E61000006666666666965EC06666666666C64240                                         |\n| 01020000200000000002000000000000000000E83F000000000000E83F00000000000024C00000000000003440 |\n+--------------------------------------------------------------------------------------------+",
    "arguments": [
        {
            "name": "geography_or_geometry_expression",
            "description": "The argument must be an expression of type GEOGRAPHY or GEOMETRY."
        }
    ],
    "returns": "A value of type BINARY."
},
{
    "function_name": "ST_AREA",
    "summary": "Returns the area of the Polygon(s) in a GEOGRAPHY or GEOMETRY object.",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/st_area",
    "title": "ST_AREA",
    "description": "Returns the area of the Polygon(s) in a",
    "syntax": "ST_AREA( <geography_or_geometry_expression> )",
    "example": "SELECT ST_AREA(TO_GEOGRAPHY('POLYGON((0 0, 1 0, 1 1, 0 1, 0 0))')) AS area;\n+------------------+\n|             AREA |\n|------------------|\n| 12364036567.0764 |\n+------------------+\n\nSELECT ST_AREA(g), ST_ASWKT(g)\nFROM (SELECT TO_GEOMETRY(column1) as g\n  from values ('POINT(1 1)'),\n              ('LINESTRING(0 0, 1 1)'),\n              ('POLYGON((0 0, 0 1, 1 1, 1 0, 0 0))'));\n\n+------------+--------------------------------+\n| ST_AREA(G) | ST_ASWKT(G)                    |\n|------------+--------------------------------|\n|          0 | POINT(1 1)                     |\n|          0 | LINESTRING(0 0,1 1)            |\n|          1 | POLYGON((0 0,0 1,1 1,1 0,0 0)) |\n+------------+--------------------------------+",
    "arguments": [
        {
            "name": "geography_or_geometry_expression",
            "description": "The argument must be of type GEOGRAPHY or GEOMETRY."
        }
    ],
    "returns": "Returns a REAL value, which represents the area:"
},
{
    "function_name": "SQUARE",
    "summary": "Returns the square of a numeric expression (i.e. a numeric expression multiplied by itself).",
    "category": "Numeric functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/square",
    "title": "SQUARE",
    "description": "Returns the square of a numeric expression (i.e. a numeric expression multiplied by itself).",
    "syntax": "SQUARE(expr)",
    "example": "SELECT column1, square(column1)\nFROM (values (0), (1), (-2), (3.15), (null)) v;\n\n---------+-----------------+\n column1 | square(column1) |\n---------+-----------------+\n 0       | 0               |\n 1       | 1               |\n -2      | 4               |\n 3.15    | 9.9225          |\n [NULL]  | [NULL]          |\n---------+-----------------+"
},
{
    "function_name": "SQRT",
    "summary": "Returns the square-root of a non-negative numeric expression.",
    "category": "Numeric functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/sqrt",
    "title": "SQRT",
    "description": "Returns the square-root of a non-negative numeric expression.",
    "syntax": "SQRT(expr)",
    "example": "SELECT x, sqrt(x) FROM tab;\n\n--------+-------------+\n   x    |   sqrt(x)   |\n--------+-------------+\n 0      | 0           |\n 2      | 1.414213562 |\n 10     | 3.16227766  |\n [NULL] | [NULL]      |\n--------+-------------+"
},
{
    "function_name": "SPLIT_TO_TABLE",
    "summary": "This table function splits a string (based on a specified delimiter) and flattens the results into rows.",
    "category": "String & binary functions , Table functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/split_to_table",
    "title": "SPLIT_TO_TABLE",
    "description": "This table function splits a string (based on a specified delimiter) and flattens the results into rows.",
    "syntax": "SPLIT_TO_TABLE(<string>, <delimiter>)",
    "example": "SELECT table1.value\n  FROM TABLE(SPLIT_TO_TABLE('a.b', '.')) AS table1\n  ORDER BY table1.value;\n\n+-------+\n| VALUE |\n|-------|\n| a     |\n| b     |\n+-------+\n\nCREATE OR REPLACE TABLE splittable (v VARCHAR);\nINSERT INTO splittable (v) VALUES ('a.b.c'), ('d'), ('');\nSELECT * FROM splittable;\n\n+-------+\n| V     |\n|-------|\n| a.b.c |\n| d     |\n|       |\n+-------+\n\nSELECT *\n  FROM splittable, LATERAL SPLIT_TO_TABLE(splittable.v, '.')\n  ORDER BY SEQ, INDEX;\n\n+-------+-----+-------+-------+\n| V     | SEQ | INDEX | VALUE |\n|-------+-----+-------+-------|\n| a.b.c |   1 |     1 | a     |\n| a.b.c |   1 |     2 | b     |\n| a.b.c |   1 |     3 | c     |\n| d     |   2 |     1 | d     |\n|       |   3 |     1 |       |\n+-------+-----+-------+-------+\n\nCREATE OR REPLACE TABLE authors_books_test (author VARCHAR, titles VARCHAR);\nINSERT INTO authors_books_test (author, titles) VALUES\n  ('Nathaniel Hawthorne', 'The Scarlet Letter , The House of the Seven Gables,The Blithedale Romance'),\n  ('Herman Melville', 'Moby Dick,The Confidence-Man');\nSELECT * FROM authors_books_test;\n\n+---------------------+---------------------------------------------------------------------------+\n| AUTHOR              | TITLES                                                                    |\n|---------------------+---------------------------------------------------------------------------|\n| Nathaniel Hawthorne | The Scarlet Letter , The House of the Seven Gables,The Blithedale Romance |\n| Herman Melville     | Moby Dick,The Confidence-Man                                              |\n+---------------------+---------------------------------------------------------------------------+\n\nSELECT author, TRIM(value) AS title\n  FROM authors_books_test, LATERAL SPLIT_TO_TABLE(titles, ',')\n  ORDER BY author;\n\n+---------------------+-------------------------------+\n| AUTHOR              | TITLE                         |\n|---------------------+-------------------------------|\n| Herman Melville     | Moby Dick                     |\n| Herman Melville     | The Confidence-Man            |\n| Nathaniel Hawthorne | The Scarlet Letter            |\n| Nathaniel Hawthorne | The House of the Seven Gables |\n| Nathaniel Hawthorne | The Blithedale Romance        |\n+---------------------+-------------------------------+",
    "arguments": [
        {
            "name": "string",
            "description": "Text to be split."
        },
        {
            "name": "delimiter",
            "description": "Text to split the string by."
        }
    ]
},
{
    "function_name": "SPLIT_TEXT_RECURSIVE_CHARACTER (SNOWFLAKE.CORTEX)",
    "summary": "The SPLIT_TEXT_RECURSIVE_CHARACTER function splits a string into shorter stings, recursively, for preprocessing text to be used with text embedding or search indexing functions.",
    "category": "",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/split_text_recursive_character-snowflake-cortex",
    "title": "SPLIT_TEXT_RECURSIVE_CHARACTER (SNOWFLAKE.CORTEX)",
    "description": "The SPLIT_TEXT_RECURSIVE_CHARACTER function splits a string into shorter stings, recursively, for preprocessing\ntext to be used with text embedding or search indexing functions. The function returns an array of text chunks, where the\nchunks are derived from the original text based on the input parameters provided.",
    "syntax": "SNOWFLAKE.CORTEX.SPLIT_TEXT_RECURSIVE_CHARACTER (\n  '<text_to_split>',\n  '<format>',\n  <chunk_size>,\n  [ <overlap> ],\n  [ <separators> ]\n)",
    "example": "SELECT SNOWFLAKE.CORTEX.SPLIT_TEXT_RECURSIVE_CHARACTER (\n   'hello world are you here',\n   'none',\n   15,\n   10\n);\n\n['hello world are', 'world are you', 'are you here']\n\n-- Create sample markdown data table\nCREATE OR REPLACE TABLE sample_documents (\n   doc_id INT AUTOINCREMENT, -- Monotonically increasing integer\n   document STRING\n);\n\n-- Insert sample data\nINSERT INTO sample_documents (document)\nVALUES\n   ('### Heading 1\\\\nThis is a sample markdown document. It contains a list:\\\\n- Item 1\\\\n- Item 2\\\\n- Item 3\\\\n'),\n   ('## Subheading\\\\nThis markdown contains a link [example](http://example.com) and some \\**bold*\\* text.'),\n   ('### Heading 2\\\\nHere is a code snippet:\\\\n```\\\\ncode_block_here()\\\\n```\\\\nAnd some more regular text.'),\n   ('## Another Subheading\\\\nMarkdown example with \\_italic\\_ text and a [second link](http://example.com).'),\n   ('### Heading 3\\\\nText with an ordered list:\\\\n1. First item\\\\n2. Second item\\\\n3. Third item\\\\nMore text follows here.');\n\n-- split text\nSELECT\n   doc_id,\n   c.value\nFROM\n   sample_documents,\n   LATERAL FLATTEN( input => SNOWFLAKE.CORTEX.SPLIT_TEXT_RECURSIVE_CHARACTER (\n      document,\n      'markdown',\n      25,\n      10\n   )) c;",
    "arguments": [
        {
            "name": "'",
            "description": "The text to split."
        },
        {
            "name": "'",
            "description": "The format of your input text, which determines the default separators in the splitting algorithm. Must be one of the following: none : No format-specific separators. Only the separators in the separators field are used for splitting. markdown : Separates on headers, code blocks, and tables, in addition to any separators in the separators field."
        },
        {
            "name": "chunk_size",
            "description": "An integer specifying the maximum number of characters in each chunk. The value must be greater than zero."
        },
        {
            "name": "overlap",
            "description": "An integer that specifies the number of characters to overlap between consecutive chunks. By default, chunks have no overlap.\nIf overlap is specified, it must be smaller than the chunk_size argument. Overlap is useful for ensuring that each chunk has some context about the previous chunk. This can help improve the quality of search\nresults or other processing."
        },
        {
            "name": "separators",
            "description": "An ordered list of character sequences to use as boundaries when determining where to split the text, in addition to\nany separators dictated by the format parameter. The last item in this list should be a general separator, such\nas an empty string (which allows a split to be made between any two characters), so that the algorithm is guaranteed to\nbe able to split the text into chunks of the desired size. Default: [”\\n\\n”, “\\n”, “ “, “”], meaning a paragraph break, a line break, a space, and between any two characters (the empty string)."
        }
    ],
    "returns": "Returns an array of strings that contains text chunks extracted from the input string."
},
{
    "function_name": "SPLIT_PART",
    "summary": "Splits a given string at a specified character and returns the requested part.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/split_part",
    "title": "SPLIT_PART",
    "description": "Splits a given string at a specified character and returns the requested part.",
    "syntax": "SPLIT_PART(<string>, <delimiter>, <partNumber>)",
    "example": "SELECT column1 part_number_value, column2 portion\n  FROM VALUES\n    (0, SPLIT_PART('11.22.33', '.',  0)),\n    (1, SPLIT_PART('11.22.33', '.',  1)),\n    (2, SPLIT_PART('11.22.33', '.',  2)),\n    (3, SPLIT_PART('11.22.33', '.',  3)),\n    (4, SPLIT_PART('11.22.33', '.',  4)),\n    (-1, SPLIT_PART('11.22.33', '.',  -1)),\n    (-2, SPLIT_PART('11.22.33', '.',  -2)),\n    (-3, SPLIT_PART('11.22.33', '.',  -3)),\n    (-4, SPLIT_PART('11.22.33', '.',  -4));\n\n+-------------------+---------+\n| PART_NUMBER_VALUE | PORTION |\n|-------------------+---------|\n|                 0 | 11      |\n|                 1 | 11      |\n|                 2 | 22      |\n|                 3 | 33      |\n|                 4 |         |\n|                -1 | 33      |\n|                -2 | 22      |\n|                -3 | 11      |\n|                -4 |         |\n+-------------------+---------+\n\nSELECT SPLIT_PART('127.0.0.1', '.', 1) AS first_part,\n       SPLIT_PART('127.0.0.1', '.', -1) AS last_part;\n\n+------------+-----------+\n| FIRST_PART | LAST_PART |\n|------------+-----------|\n| 127        | 1         |\n+------------+-----------+\n\nSELECT SPLIT_PART('|a|b|c|', '|', 1) AS first_part,\n       SPLIT_PART('|a|b|c|', '|', 2) AS last_part;\n\n+------------+-----------+\n| FIRST_PART | LAST_PART |\n|------------+-----------|\n|            | a         |\n+------------+-----------+\n\nSELECT SPLIT_PART('aaa--bbb-BBB--ccc', '--', 2) AS multi_character_separator;\n\n+---------------------------+\n| MULTI_CHARACTER_SEPARATOR |\n|---------------------------|\n| bbb-BBB                   |\n+---------------------------+\n\nSELECT column1 part_number_value, column2 portion\n  FROM VALUES\n    (1, split_part('user@snowflake.com', '',  1)),\n    (-1, split_part('user@snowflake.com', '', -1)),\n    (2, split_part('user@snowflake.com', '',  2)),\n    (-2, split_part('user@snowflake.com', '', -2));\n\n+-------------------+--------------------+\n| PART_NUMBER_VALUE | PORTION            |\n|-------------------+--------------------|\n|                 1 | user@snowflake.com |\n|                -1 | user@snowflake.com |\n|                 2 |                    |\n|                -2 |                    |\n+-------------------+--------------------+",
    "arguments": [
        {
            "name": "string",
            "description": "Text to be split into parts."
        },
        {
            "name": "delimiter",
            "description": "Text representing the delimiter to split by."
        },
        {
            "name": "partNumber",
            "description": "Requested part of the split (1-based). If the value is negative, the parts are counted backward from the end of the string."
        }
    ],
    "returns": "This function returns a value of type VARCHAR."
},
{
    "function_name": "SPLIT",
    "summary": "Splits a given string with a given separator and returns the result in an array of strings.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/split",
    "title": "SPLIT",
    "description": "Splits a given string with a given separator and returns the result in an array of strings.",
    "syntax": "SPLIT(<string>, <separator>)",
    "example": "SELECT SPLIT('127.0.0.1', '.');\n\n+-------------------------+\n| SPLIT('127.0.0.1', '.') |\n|-------------------------|\n| [                       |\n|   \"127\",                |\n|   \"0\",                  |\n|   \"0\",                  |\n|   \"1\"                   |\n| ]                       |\n+-------------------------+\n\nSELECT SPLIT('|a||', '|');\n\n+--------------------+\n| SPLIT('|A||', '|') |\n|--------------------|\n| [                  |\n|   \"\",              |\n|   \"a\",             |\n|   \"\",              |\n|   \"\"               |\n| ]                  |\n+--------------------+\n\nSELECT * FROM persons;\n\n------+---------------------+\n NAME |      CHILDREN       |\n------+---------------------+\n Mark | Marky,Mark Jr,Maria |\n John | Johnny,Jane         |\n------+---------------------+\n\nSELECT name, C.value::string AS childName\nFROM persons,\n     LATERAL FLATTEN(input=>split(children, ',')) C;\n\n------+-----------+\n NAME | CHILDNAME |\n------+-----------+\n John | Johnny    |\n John | Jane      |\n Mark | Marky     |\n Mark | Mark Jr   |\n Mark | Maria     |\n------+-----------+",
    "arguments": [
        {
            "name": "string",
            "description": "Text to be split into parts."
        },
        {
            "name": "separator",
            "description": "Text to split string by."
        }
    ],
    "returns": "The data type of the returned value is ARRAY."
},
{
    "function_name": "SPACE",
    "summary": "Builds a string consisting of the specified number of blank spaces.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/space",
    "title": "SPACE",
    "description": "Builds a string consisting of the specified number of blank spaces.",
    "syntax": "SPACE(<n>)",
    "example": "SELECT SPACE(3);",
    "arguments": [
        {
            "name": "n",
            "description": "The number of blank spaces used to build the string."
        }
    ]
},
{
    "function_name": "SOUNDEX_P123",
    "summary": "Returns a string that contains a phonetic representation of the input string, and retains the Soundex code number for the second letter when the first and second letters use the same number.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/soundex_p123",
    "title": "SOUNDEX_P123",
    "description": "Returns a string that contains a phonetic representation of the input string, and retains the Soundex code number for the second\nletter when the first and second letters use the same number.",
    "syntax": "SOUNDEX_P123( <varchar_expr> )",
    "example": "SELECT SOUNDEX('Pfister'),\n       SOUNDEX_P123('Pfister'),\n       SOUNDEX('LLoyd'),\n       SOUNDEX_P123('Lloyd');\n+--------------------+-------------------------+------------------+-----------------------+\n| SOUNDEX('Pfister') | SOUNDEX_P123('Pfister') | SOUNDEX('Lloyd') | SOUNDEX_P123('Lloyd') |\n|--------------------+-------------------------+------------------+-----------------------|\n| P236               | P123                    | L300             | L430                  |\n+--------------------+-------------------------+------------------+-----------------------+",
    "arguments": [
        {
            "name": "varchar_expr",
            "description": "The string for which a representation of the pronunciation is returned. The string should use the Latin or Unicode character set."
        }
    ],
    "returns": "The returned value is a VARCHAR that contains the phonetic representation of the input string. In other words, the return value\nis a string (not a sound) that represents the pronunciation (not the spelling) of the input string."
},
{
    "function_name": "SOUNDEX",
    "summary": "Returns a string that contains a phonetic representation of the input string.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/soundex",
    "title": "SOUNDEX",
    "description": "Returns a string that contains a phonetic representation of the input string.",
    "syntax": "SOUNDEX( <varchar_expr> )",
    "example": "SELECT SOUNDEX('Marks'), SOUNDEX('Marx');\n+------------------+-----------------+\n| SOUNDEX('MARKS') | SOUNDEX('MARX') |\n|------------------+-----------------|\n| M620             | M620            |\n+------------------+-----------------+\n\nCREATE TABLE sounding_board (v VARCHAR);\nCREATE TABLE sounding_bored (v VARCHAR);\nINSERT INTO sounding_board (v) VALUES ('Marsha');\nINSERT INTO sounding_bored (v) VALUES ('Marcia');\n\nSELECT * \n    FROM sounding_board AS board, sounding_bored AS bored \n    WHERE bored.v = board.v;\n+---+---+\n| V | V |\n|---+---|\n+---+---+\n\nSELECT * \n    FROM sounding_board AS board, sounding_bored AS bored \n    WHERE SOUNDEX(bored.v) = SOUNDEX(board.v);\n+--------+--------+\n| V      | V      |\n|--------+--------|\n| Marsha | Marcia |\n+--------+--------+",
    "arguments": [
        {
            "name": "varchar_expr",
            "description": "The string for which a representation of the pronunciation is returned. The string should use the Latin or Unicode character set."
        }
    ],
    "returns": "The returned value is a VARCHAR that contains the phonetic representation of the input string. In other words, the return value\nis a string (not a sound) that represents the pronunciation (not the spelling) of the input string."
},
{
    "function_name": "SKEW",
    "summary": "Returns the sample skewness of non-NULL records.",
    "category": "Aggregate functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/skew",
    "title": "SKEW",
    "description": "Returns the sample skewness of non-NULL records. If all records inside a group are NULL, the function returns NULL.",
    "syntax": "SKEW( <expr> )",
    "example": "create or replace table aggr(k int, v decimal(10,2), v2 decimal(10, 2));\n\ninsert into aggr values\n    (1, 10, null),\n    (2, 10, null),\n    (2, 20, 22),\n    (2, 25, null),\n    (2, 30, 35);\n\nselect * \n    from aggr\n    order by k, v;\n+---+-------+-------+\n| K |     V |    V2 |\n|---+-------+-------|\n| 1 | 10.00 |  NULL |\n| 2 | 10.00 |  NULL |\n| 2 | 20.00 | 22.00 |\n| 2 | 25.00 |  NULL |\n| 2 | 30.00 | 35.00 |\n+---+-------+-------+\n\nselect SKEW(K), SKEW(V), SKEW(V2) \n    from aggr;\n+--------------+---------------+----------+\n|      SKEW(K) |       SKEW(V) | SKEW(V2) |\n|--------------+---------------+----------|\n| -2.236069766 | 0.05240788515 |     NULL |\n+--------------+---------------+----------+",
    "arguments": [
        {
            "name": "expr",
            "description": "This is an expression that evaluates to a numeric data type (INTEGER, FLOAT, DECIMAL, etc.)."
        }
    ],
    "returns": "This function returns a value of type DOUBLE."
},
{
    "function_name": "SINH",
    "summary": "Computes the hyperbolic sine of its argument.",
    "category": "Numeric functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/sinh",
    "title": "SINH",
    "description": "Computes the hyperbolic sine of its argument.",
    "syntax": "SINH( <real_expr> )",
    "example": "SELECT SINH(1.5);\n\n-------------+\n  SINH(1.5)  |\n-------------+\n 2.129279455 |\n-------------+",
    "arguments": [
        {
            "name": "real_expr",
            "description": "This expression should evaluate to a real number."
        }
    ]
},
{
    "function_name": "SIN",
    "summary": "Computes the sine of its argument; the argument should be expressed in radians.",
    "category": "Numeric functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/sin",
    "title": "SIN",
    "description": "Computes the sine of its argument; the argument should be expressed in\nradians.",
    "syntax": "SIN( <real_expr> )",
    "example": "SELECT SIN(0), SIN(PI()/3), SIN(RADIANS(90));\n--------+--------------+------------------+\n SIN(0) | SIN(PI()/3)  | SIN(RADIANS(90)) |\n--------+--------------+------------------+\n 0      | 0.8660254038 | 1                |\n--------+--------------+------------------+",
    "arguments": [
        {
            "name": "real_expr",
            "description": "This expression should evaluate to a real number. The value should be in\nradians, not degrees."
        }
    ]
},
{
    "function_name": "SIGN",
    "summary": "Returns the sign of its argument.",
    "category": "Numeric functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/sign",
    "title": "SIGN",
    "description": "Returns the sign of its argument:",
    "syntax": "SIGN( <expr> )",
    "example": "SELECT SIGN(5), SIGN(-1.35e-10), SIGN(0);\n\n---------+-----------------+---------+\n SIGN(5) | SIGN(-1.35E-10) | SIGN(0) |\n---------+-----------------+---------+\n 1       | -1              | 0       |\n---------+-----------------+---------+"
},
{
    "function_name": "SHOW_PYTHON_PACKAGES_DEPENDENCIES",
    "summary": "Returns a list of the dependencies and their versions for the Python packages that were specified.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/show_python_packages_dependencies",
    "title": "SHOW_PYTHON_PACKAGES_DEPENDENCIES",
    "description": "Returns a list of the dependencies and their versions for the Python packages that were specified.\nFor more information, see",
    "syntax": "SNOWFLAKE.SNOWPARK.SHOW_PYTHON_PACKAGES_DEPENDENCIES( '<Python_runtime_version>', '<packages_list>' )",
    "example": "USE ROLE ACCOUNTADMIN;\n\nselect SNOWFLAKE.SNOWPARK.SHOW_PYTHON_PACKAGES_DEPENDENCIES('3.10', ['numpy']);\n\n['_libgcc_mutex==0.1', '_openmp_mutex==5.1', 'blas==1.0', 'ca-certificates==2023.05.30', 'intel-openmp==2021.4.0',\n'ld_impl_linux-64==2.38', 'ld_impl_linux-aarch64==2.38', 'libffi==3.4.4', 'libgcc-ng==11.2.0', 'libgfortran-ng==11.2.0',\n'libgfortran5==11.2.0', 'libgomp==11.2.0', 'libopenblas==0.3.21', 'libstdcxx-ng==11.2.0', 'mkl-service==2.4.0',\n'mkl==2021.4.0', 'mkl_fft==1.3.1', 'mkl_random==1.2.2', 'ncurses==6.4', 'numpy-base==1.24.3', 'numpy==1.24.3',\n'openssl==3.0.10', 'python==3.10', 'readline==8.2', 'six==1.16.0', 'sqlite==3.41.2', 'tk==8.6.12', 'xz==5.4.2', 'zlib==1.2.13']",
    "arguments": [
        {
            "name": "Python_runtime_version",
            "description": "String specifying the version of the Python runtime."
        },
        {
            "name": "packages_list",
            "description": "ARRAY of strings that specify the list of packages to check. You can use an ARRAY constant to specify this list."
        }
    ],
    "returns": "Returns a JSON array that contains the dependencies and their versions.\nEach element in the array is a string in the following format: <package_name>==<version_name>."
},
{
    "function_name": "SHA2_BINARY",
    "summary": "Returns a binary containing the N-bit SHA-2 message digest, where N is the specified output digest size.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/sha2_binary",
    "title": "SHA2_BINARY",
    "description": "Returns a binary containing the N-bit SHA-2 message digest,\nwhere N is the specified output digest size.",
    "syntax": "SHA2_BINARY(<msg> [, <digest_size>])",
    "example": "SELECT sha2_binary('Snowflake', 384);\n\n--------------------------------------------------------------------------------------------------+\n                                   SHA2_BINARY('SNOWFLAKE', 384)                                  |\n--------------------------------------------------------------------------------------------------+\n 736BD8A53845348830B1EE63A8CD3972F031F13B111F66FFDEC2271A7AE709662E503A0CA305BD50DA8D1CED48CD45D9 |\n--------------------------------------------------------------------------------------------------+\n\nCREATE TABLE sha_table(\n    v VARCHAR, \n    v_as_sha1 VARCHAR,\n    v_as_sha1_hex VARCHAR,\n    v_as_sha1_binary BINARY,\n    v_as_sha2 VARCHAR,\n    v_as_sha2_hex VARCHAR,\n    v_as_sha2_binary BINARY\n    );\nINSERT INTO sha_table(v) VALUES ('AbCd0');\nUPDATE sha_table SET \n    v_as_sha1 = SHA1(v),\n    v_as_sha1_hex = SHA1_HEX(v),\n    v_as_sha1_binary = SHA1_BINARY(v),\n    v_as_sha2 = SHA2(v),\n    v_as_sha2_hex = SHA2_HEX(v),\n    v_as_sha2_binary = SHA2_BINARY(v)\n    ;\n\nSELECT v, v_as_sha2_binary\n  FROM sha_table\n  ORDER BY v;\n+-------+------------------------------------------------------------------+\n| V     | V_AS_SHA2_BINARY                                                 |\n|-------+------------------------------------------------------------------|\n| AbCd0 | E1D8BA27889D6782008F495473278C4F071995C5549A976E4D4F93863CE93643 |\n+-------+------------------------------------------------------------------+",
    "arguments": [
        {
            "name": "msg",
            "description": "A string expression, the message to be hashed"
        },
        {
            "name": "digest_size",
            "description": "Size (in bits) of the output, corresponding to the\nspecific SHA-2 function used to encrypt the string: 224 = SHA-224 256 = SHA-256 (Default) 384 = SHA-384 512 = SHA-512 SHA-512/224 and SHA-512/256 are not supported."
        }
    ],
    "returns": "The data type of the returned value is BINARY."
},
{
    "function_name": "SHA2 , SHA2_HEX",
    "summary": "Returns a hex-encoded string containing the N-bit SHA-2 message digest, where N is the specified output digest size.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/sha2",
    "title": "SHA2 , SHA2_HEX",
    "description": "Returns a hex-encoded string containing the N-bit SHA-2 message digest,\nwhere N is the specified output digest size.",
    "syntax": "SHA2( <msg> [, <digest_size>] )\n\nSHA2_HEX( <msg> [, <digest_size>] )",
    "example": "SELECT sha2('Snowflake', 224);\n\n----------------------------------------------------------+\n                  SHA2('SNOWFLAKE', 224)                  |\n----------------------------------------------------------+\n 6267d3d7a59929e6864dd4b737d98e3ef8569d9f88a7466647838532 |\n----------------------------------------------------------+\n\nCREATE TABLE sha_table(\n    v VARCHAR, \n    v_as_sha1 VARCHAR,\n    v_as_sha1_hex VARCHAR,\n    v_as_sha1_binary BINARY,\n    v_as_sha2 VARCHAR,\n    v_as_sha2_hex VARCHAR,\n    v_as_sha2_binary BINARY\n    );\nINSERT INTO sha_table(v) VALUES ('AbCd0');\nUPDATE sha_table SET \n    v_as_sha1 = SHA1(v),\n    v_as_sha1_hex = SHA1_HEX(v),\n    v_as_sha1_binary = SHA1_BINARY(v),\n    v_as_sha2 = SHA2(v),\n    v_as_sha2_hex = SHA2_HEX(v),\n    v_as_sha2_binary = SHA2_BINARY(v)\n    ;\n\nSELECT v, v_as_sha2, v_as_sha2_hex\n  FROM sha_table\n  ORDER BY v;\n+-------+------------------------------------------------------------------+------------------------------------------------------------------+\n| V     | V_AS_SHA2                                                        | V_AS_SHA2_HEX                                                    |\n|-------+------------------------------------------------------------------+------------------------------------------------------------------|\n| AbCd0 | e1d8ba27889d6782008f495473278c4f071995c5549a976e4d4f93863ce93643 | e1d8ba27889d6782008f495473278c4f071995c5549a976e4d4f93863ce93643 |\n+-------+------------------------------------------------------------------+------------------------------------------------------------------+",
    "arguments": [
        {
            "name": "msg",
            "description": "A string expression, the message to be hashed"
        },
        {
            "name": "digest_size",
            "description": "Size (in bits) of the output, corresponding to the\nspecific SHA-2 function used to encrypt the string: 224 = SHA-224 256 = SHA-256 (Default) 384 = SHA-384 512 = SHA-512 SHA-512/224 and SHA-512/256 are not supported."
        }
    ],
    "returns": "The data type of the returned value is VARCHAR."
},
{
    "function_name": "SHA1_BINARY",
    "summary": "Returns a 20-byte binary containing the 160-bit SHA-1 message digest.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/sha1_binary",
    "title": "SHA1_BINARY",
    "description": "Returns a 20-byte binary containing the 160-bit SHA-1 message digest.",
    "syntax": "SHA1_BINARY(<msg>)",
    "example": "SELECT sha1_binary('Snowflake');\n\n------------------------------------------+\n         SHA1_BINARY('SNOWFLAKE')         |\n------------------------------------------+\n FDA76B0BCC1E87CF259B1D1E3271D76F590FB5DD |\n------------------------------------------+\n\nCREATE TABLE sha_table(\n    v VARCHAR, \n    v_as_sha1 VARCHAR,\n    v_as_sha1_hex VARCHAR,\n    v_as_sha1_binary BINARY,\n    v_as_sha2 VARCHAR,\n    v_as_sha2_hex VARCHAR,\n    v_as_sha2_binary BINARY\n    );\nINSERT INTO sha_table(v) VALUES ('AbCd0');\nUPDATE sha_table SET \n    v_as_sha1 = SHA1(v),\n    v_as_sha1_hex = SHA1_HEX(v),\n    v_as_sha1_binary = SHA1_BINARY(v),\n    v_as_sha2 = SHA2(v),\n    v_as_sha2_hex = SHA2_HEX(v),\n    v_as_sha2_binary = SHA2_BINARY(v)\n    ;\n\nSELECT v, v_as_sha1_binary\n  FROM sha_table\n  ORDER BY v;\n+-------+------------------------------------------+\n| V     | V_AS_SHA1_BINARY                         |\n|-------+------------------------------------------|\n| AbCd0 | 9DDB991863D53B35A52C490DB256207C776AB8D8 |\n+-------+------------------------------------------+",
    "arguments": [
        {
            "name": "msg",
            "description": "A string expression, the message to be hashed."
        }
    ],
    "returns": "The data type of the returned value is BINARY."
},
{
    "function_name": "SHA1 , SHA1_HEX",
    "summary": "Returns a 40-character hex-encoded string containing the 160-bit SHA-1 message digest.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/sha1",
    "title": "SHA1 , SHA1_HEX",
    "description": "Returns a 40-character hex-encoded string containing the 160-bit SHA-1\nmessage digest.",
    "syntax": "SHA1(<msg>)\n\nSHA1_HEX(<msg>)",
    "example": "SELECT sha1('Snowflake');\n\n------------------------------------------+\n            SHA1('SNOWFLAKE')             |\n------------------------------------------+\n fda76b0bcc1e87cf259b1d1e3271d76f590fb5dd |\n------------------------------------------+\n\nCREATE TABLE sha_table(\n    v VARCHAR, \n    v_as_sha1 VARCHAR,\n    v_as_sha1_hex VARCHAR,\n    v_as_sha1_binary BINARY,\n    v_as_sha2 VARCHAR,\n    v_as_sha2_hex VARCHAR,\n    v_as_sha2_binary BINARY\n    );\nINSERT INTO sha_table(v) VALUES ('AbCd0');\nUPDATE sha_table SET \n    v_as_sha1 = SHA1(v),\n    v_as_sha1_hex = SHA1_HEX(v),\n    v_as_sha1_binary = SHA1_BINARY(v),\n    v_as_sha2 = SHA2(v),\n    v_as_sha2_hex = SHA2_HEX(v),\n    v_as_sha2_binary = SHA2_BINARY(v)\n    ;\n\nSELECT v, v_as_sha1, v_as_sha1_hex\n  FROM sha_table\n  ORDER BY v;\n+-------+------------------------------------------+------------------------------------------+\n| V     | V_AS_SHA1                                | V_AS_SHA1_HEX                            |\n|-------+------------------------------------------+------------------------------------------|\n| AbCd0 | 9ddb991863d53b35a52c490db256207c776ab8d8 | 9ddb991863d53b35a52c490db256207c776ab8d8 |\n+-------+------------------------------------------+------------------------------------------+",
    "arguments": [
        {
            "name": "msg",
            "description": "A string expression, the message to be hashed."
        }
    ],
    "returns": "The data type of the returned value is VARCHAR."
},
{
    "function_name": "SERVERLESS_TASK_HISTORY",
    "summary": "This table function is used for querying the serverless task usage history.",
    "category": "Information Schema , Table functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/serverless_task_history",
    "title": "SERVERLESS_TASK_HISTORY",
    "description": "This table function is used for querying the",
    "syntax": "SERVERLESS_TASK_HISTORY(\n      [ DATE_RANGE_START => <constant_expr> ]\n      [ , DATE_RANGE_END => <constant_expr> ]\n      [ , TASK_NAME => '<string>' ] )",
    "example": "select *\n  from table(information_schema.serverless_task_history(\n    date_range_start=>'2021-10-08 19:00:00.000',\n    date_range_end=>'2021-10-08 20:00:00.000'));\n\n+-------------------------------+-------------------------------+-----------+--------------+\n| START_TIME                    | END_TIME                      | TASK_NAME | CREDITS_USED |\n|-------------------------------+-------------------------------+-----------+--------------|\n| 2021-10-08 04:16:22.000 -0700 | 2021-10-08 05:16:22.000 -0700 | T1        |  0.000286714 |\n| 2021-10-08 05:16:22.000 -0700 | 2021-10-08 06:16:22.000 -0700 | T1        |  0.007001568 |\n+-------------------------------+-------------------------------+-----------+--------------+\n\nselect *\n  from table(information_schema.serverless_task_history(\n    date_range_start=>dateadd(H, -12, current_timestamp)));\n\nselect *\n  from table(information_schema.serverless_task_history(\n    date_range_start=>dateadd(D, -7, current_date),\n    date_range_end=>current_date));\n\nselect *\n  from table(information_schema.serverless_task_history(\n    date_range_start=>dateadd(D, -7, current_date),\n    date_range_end=>current_date,\n    task_name=>'mydb.myschema.mytask'));",
    "arguments": [
        {
            "name": "DATE_RANGE_START",
            "description": "Date/time range of the usage window: If an end date is not specified, then CURRENT_DATE is used as the end of the range. If a start date is not specified, then the range starts 10 minutes prior to the start of DATE_RANGE_END (i.e. the default is to\nshow the previous 10 minutes of the usage history). For example, if DATE_RANGE_END is CURRENT_DATE , then the default DATE_RANGE_START is 11:50 PM on the previous day."
        },
        {
            "name": "TASK_NAME",
            "description": "The name of the task to retrieve usage history for. Only the usage data for the specified task is returned. Note that the task name must be enclosed in single quotes. Also, if the task name contains any spaces, mixed-case characters, or special\ncharacters, the name must be double-quoted within the single quotes (e.g. '\"My Task\"' vs 'mytask' )."
        }
    ]
},
{
    "function_name": "SERVERLESS_ALERT_HISTORY",
    "summary": "This table function is used for querying the serverless alert usage history.",
    "category": "Information Schema , Table functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/serverless_alert_history",
    "title": "SERVERLESS_ALERT_HISTORY",
    "description": "This table function is used for querying the",
    "syntax": "SERVERLESS_ALERT_HISTORY(\n  [ DATE_RANGE_START => <constant_expr> ]\n  [ , DATE_RANGE_END => <constant_expr> ]\n  [ , ALERT_NAME => '<string>' ] )",
    "example": "SELECT *\n  FROM TABLE(INFORMATION_SCHEMA.SERVERLESS_ALERT_HISTORY(\n    DATE_RANGE_START=>'2024-10-08 19:00:00.000 -0700',\n    DATE_RANGE_END=>'2024-10-08 20:00:00.000 -0700'));\n\n+-------------------------------+-------------------------------+------------+--------------+\n| START_TIME                    | END_TIME                      | ALERT_NAME | CREDITS_USED |\n|-------------------------------+-------------------------------+------------+--------------|\n| 2024-10-08 04:16:22.000 -0700 | 2024-10-08 05:16:22.000 -0700 | A1         |  0.000286714 |\n| 2024-10-08 05:16:22.000 -0700 | 2024-10-08 06:16:22.000 -0700 | A1         |  0.007001568 |\n+-------------------------------+-------------------------------+------------+--------------+\n\nSELECT *\n  FROM TABLE(INFORMATION_SCHEMA.SERVERLESS_ALERT_HISTORY(\n    DATE_RANGE_START=>DATEADD(H, -12, CURRENT_TIMESTAMP)));\n\nSELECT *\n  FROM TABLE(INFORMATION_SCHEMA.SERVERLESS_ALERT_HISTORY(\n    DATE_RANGE_START=>DATEADD(D, -7, CURRENT_DATE),\n    DATE_RANGE_END=>CURRENT_DATE));\n\nSELECT *\n  FROM TABLE(INFORMATION_SCHEMA.SERVERLESS_ALERT_HISTORY(\n    DATE_RANGE_START=>DATEADD(D, -7, CURRENT_DATE),\n    DATE_RANGE_END=>CURRENT_DATE,\n    ALERT_NAME=>'my_database.my_schema.my_alert'));",
    "arguments": [
        {
            "name": "DATE_RANGE_START",
            "description": "Date/time range of the usage window: If an end date is not specified, then CURRENT_DATE is used as the end of the range. If a start date is not specified, then the range starts 10 minutes prior to the start of DATE_RANGE_END (that is, the\ndefault is to show the previous 10 minutes of the usage history). For example, if DATE_RANGE_END is CURRENT_DATE , then the default DATE_RANGE_START is 11:50 PM on the previous day."
        },
        {
            "name": "ALERT_NAME",
            "description": "The name of the alert for which to retrieve usage history. Only the usage data for the specified alert is returned. Note that the alert name must be enclosed in single quotes. Also, if the alert name contains any spaces, mixed-case characters,\nor special characters, the name must be double-quoted within the single quotes (e.g. '\"My Alert\"' vs 'myalert' )."
        }
    ]
},
{
    "function_name": "SEQ1 / SEQ2 / SEQ4 / SEQ8",
    "summary": "Returns a sequence of monotonically increasing integers, with wrap-around.",
    "category": "Data generation functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/seq1",
    "title": "SEQ1 / SEQ2 / SEQ4 / SEQ8",
    "description": "Returns a sequence of monotonically increasing integers, with wrap-around. Wrap-around occurs after the largest representable integer of the integer width (1, 2, 4, or 8 byte).",
    "syntax": "SEQ1( [0|1] )\n\nSEQ2( [0|1] )\n\nSEQ4( [0|1] )\n\nSEQ8( [0|1] )",
    "example": "SELECT seq8() FROM table(generator(rowCount => 5));\n\n+--------+\n| SEQ8() |\n|--------|\n|      0 |\n|      1 |\n|      2 |\n|      3 |\n|      4 |\n+--------+\n\nSELECT * FROM (SELECT seq2(0), seq1(1) FROM table(generator(rowCount => 132))) ORDER BY seq2(0) LIMIT 7 OFFSET 125;\n\n+---------+---------+\n| SEQ2(0) | SEQ1(1) |\n|---------+---------|\n|     125 |     125 |\n|     126 |     126 |\n|     127 |     127 |\n|     128 |    -128 |\n|     129 |    -127 |\n|     130 |    -126 |\n|     131 |    -125 |\n+---------+---------+\n\nSELECT ROW_NUMBER() OVER (ORDER BY seq4()) \n    FROM TABLE(generator(rowcount => 10));\n+-------------------------------------+\n| ROW_NUMBER() OVER (ORDER BY SEQ4()) |\n|-------------------------------------|\n|                                   1 |\n|                                   2 |\n|                                   3 |\n|                                   4 |\n|                                   5 |\n|                                   6 |\n|                                   7 |\n|                                   8 |\n|                                   9 |\n|                                  10 |\n+-------------------------------------+"
},
{
    "function_name": "SENTIMENT (SNOWFLAKE.CORTEX)",
    "summary": "Returns an overall sentiment score for the given English-language input text.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/sentiment-snowflake-cortex",
    "title": "SENTIMENT (SNOWFLAKE.CORTEX)",
    "description": "Returns an overall sentiment score for the given English-language input text.",
    "syntax": "SNOWFLAKE.CORTEX.SENTIMENT(<text>)",
    "arguments": [
        {
            "name": "text",
            "description": "A string containing the text for which a sentiment score should be calculated."
        }
    ],
    "returns": "A floating-point number from -1 to 1 (inclusive) indicating the level of negative or positive sentiment in the text.\nValues around 0 indicate neutral sentiment."
},
{
    "function_name": "SEARCH_PREVIEW (SNOWFLAKE.CORTEX)",
    "summary": "Given a Cortex Search service name, and a query, returns a response from the specified service.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/search_preview-snowflake-cortex",
    "title": "SEARCH_PREVIEW (SNOWFLAKE.CORTEX)",
    "syntax": "SNOWFLAKE.CORTEX.SEARCH_PREVIEW(\n    '<service_name>',\n    '<query_parameters_object>'\n)",
    "example": "SELECT\n  SNOWFLAKE.CORTEX.SEARCH_PREVIEW (\n      'mydb.mysch.sample_service',\n      '{\n          \"query\": \"test query\",\n          \"columns\": [\"col1\", \"col2\"],\n          \"limit\": 3\n      }'\n  );\n\n{\n  \"results\":[\n      {\"col1\":\"text\", \"col2\":\"text\"},\n      {\"col1\":\"text\", \"col2\":\"text\"},\n      {\"col1\":\"text\", \"col2\":\"text\"}\n  ],\n  \"request_id\":\"a27d1d85-e02c-4730-b320-74bf94f72d0d\"\n}",
    "arguments": [
        {
            "name": "service_name",
            "description": "Name of your Cortex Search service. Use the fully qualified name if the service is in a schema different from the current session."
        },
        {
            "name": "query_parameters_object",
            "description": "A STRING that contains a JSON object that specifies the query parameters for invoking the service. Key Type Description Default query String Your search query, to search over the text column in the service. This is required. columns Array A comma-separated list of columns to return for each relevant result in the response. These columns must be included in the source\nquery for the service. Search column that was specified when the service was created. filter Object A filter object for filtering results based on data in the ATTRIBUTES columns. For detailed syntax,\nsee Filter syntax . Empty object limit Integer Maximum number of results to return in the response. 10"
        }
    ],
    "returns": "Returns an OBJECT that contains the result of your query from your Cortex Search service and a unique\nrequest ID. See example output in Examples."
},
{
    "function_name": "SEARCH_OPTIMIZATION_HISTORY",
    "summary": "This table function is used for querying the search optimization service maintenance history for a specified table within a specified date range.",
    "category": "Information Schema , Table functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/search_optimization_history",
    "title": "SEARCH_OPTIMIZATION_HISTORY",
    "syntax": "SEARCH_OPTIMIZATION_HISTORY(\n      [ DATE_RANGE_START => <constant_expr> ]\n      [ , DATE_RANGE_END => <constant_expr> ]\n      [ , TABLE_NAME => '<string>' ] )",
    "example": "select *\n  from table(information_schema.search_optimization_history(\n    date_range_start=>'2019-05-22 19:00:00.000',\n    date_range_end=>'2019-05-22 20:00:00.000'));\n\n+-------------------------------+-------------------------------+--------------+----------------------------------+\n| START_TIME                    | END_TIME                      | CREDITS_USED | TABLE_NAME                       |\n|-------------------------------+-------------------------------+--------------+----------------------------------|\n| 2019-05-22 19:00:00.000 -0700 | 2019-05-22 20:00:00.000 -0700 |  0.223276651 | TEST_DB.TEST_SCHEMA.TEST_TABLE_1 |\n+-------------------------------+-------------------------------+--------------+----------------------------------+\n\nselect *\n  from table(information_schema.search_optimization_history(\n    date_range_start=>dateadd(H, -12, current_timestamp)));\n\nselect *\n  from table(information_schema.search_optimization_history(\n    date_range_start=>dateadd(D, -7, current_date),\n    date_range_end=>current_date,\n    table_name=>'mydb.myschema.my_table')\n    );\n\nselect *\n  from table(information_schema.search_optimization_history(\n    date_range_start=>dateadd(D, -7, current_date),\n    date_range_end=>current_date)\n    );",
    "arguments": [
        {
            "name": "DATE_RANGE_START",
            "description": "The date/time range for which to display the history.\nFor example, if you specify that the start date is 2019-04-03 and the end date is 2019-04-05, then you get data for\nApril 3, April 4, and April 5. (The endpoints are included.) If neither a start date nor an end date is specified, the default is the last 12 hours. If an end date is not specified, but a start date is specified, then CURRENT_DATE at midnight is used as the end of the range. If a start date is not specified, but an end date is specified, then the range starts 12 hours prior to the start\nof DATE_RANGE_END ."
        },
        {
            "name": "TABLE_NAME",
            "description": "The table name. If specified, only shows the history for the specified table. The name can include the schema name and the database\nname. If a name is not specified, then the results include the data for each table that has search optimization for\nwhich maintenance occurred within the specified time range."
        }
    ]
},
{
    "function_name": "SEARCH_IP",
    "summary": "Searches for valid IPv4 addresses in specified character-string columns from one or more tables, including fields in VARIANT, OBJECT, and ARRAY columns.",
    "category": "",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/search_ip",
    "title": "SEARCH_IP",
    "description": "Searches for valid IPv4 addresses in specified character-string columns from one or more tables, including fields\nin VARIANT, OBJECT, and ARRAY columns. The search is based on a single IP address or a range of IP addresses\nthat you specify. If this IP address matches an IP address in the specified column or field, the function\nreturns TRUE.",
    "syntax": "SEARCH_IP( <search_data>, <search_string> )",
    "example": "CREATE OR REPLACE TABLE ipt(id INT, ip1 VARCHAR(20), ip2 VARCHAR(20));\nINSERT INTO ipt VALUES(1, '192.0.2.146', '203.0.113.5');\nINSERT INTO ipt VALUES(2, '192.0.2.111', '192.000.002.146');\n\nSELECT ip1,\n       ip2,\n       SEARCH_IP((ip1, ip2), '192.0.2.146')\n  FROM ipt\n  ORDER BY ip1;\n\n+-------------+-----------------+--------------------------------------+\n| IP1         | IP2             | SEARCH_IP((IP1, IP2), '192.0.2.146') |\n|-------------+-----------------+--------------------------------------|\n| 192.0.2.111 | 192.000.002.146 | True                                 |\n| 192.0.2.146 | 203.0.113.5     | True                                 |\n+-------------+-----------------+--------------------------------------+\n\nSELECT ip1,\n       ip2,\n       SEARCH_IP((ip1, ip2), '192.0.2.1/20')\n  FROM ipt\n  ORDER BY ip1;\n\n+-------------+-----------------+---------------------------------------+\n| IP1         | IP2             | SEARCH_IP((IP1, IP2), '192.0.2.1/20') |\n|-------------+-----------------+---------------------------------------|\n| 192.0.2.111 | 192.000.002.146 | True                                  |\n| 192.0.2.146 | 203.0.113.5     | True                                  |\n+-------------+-----------------+---------------------------------------+\n\nSELECT ip1,\n       ip2,\n       SEARCH_IP((ip1, ip2), '203.000.113.005')\n  FROM ipt\n  ORDER BY ip1;\n\n+-------------+-----------------+------------------------------------------+\n| IP1         | IP2             | SEARCH_IP((IP1, IP2), '203.000.113.005') |\n|-------------+-----------------+------------------------------------------|\n| 192.0.2.111 | 192.000.002.146 | False                                    |\n| 192.0.2.146 | 203.0.113.5     | True                                     |\n+-------------+-----------------+------------------------------------------+\n\nSELECT ip1,\n       ip2\n  FROM ipt\n  WHERE SEARCH_IP(ip2, '203.0.113.5')\n  ORDER BY ip1;\n\n+-------------+-------------+\n| IP1         | IP2         |\n|-------------+-------------|\n| 192.0.2.146 | 203.0.113.5 |\n+-------------+-------------+\n\nSELECT ip1,\n       ip2\n  FROM ipt\n  WHERE SEARCH_IP(ip2, '203.0.113.1')\n  ORDER BY ip1;\n\n+-----+-----+\n| IP1 | IP2 |\n|-----+-----|\n+-----+-----+\n\nSELECT ip1,\n       ip2\n  FROM ipt\n  WHERE SEARCH_IP((*), '203.0.113.5')\n  ORDER BY ip1;\n\n+-------------+-------------+\n| IP1         | IP2         |\n|-------------+-------------|\n| 192.0.2.146 | 203.0.113.5 |\n+-------------+-------------+\n\nSELECT ip1,\n       ip2\n  FROM ipt\n  WHERE SEARCH_IP(* ILIKE 'ip%', '192.0.2.111')\n  ORDER BY ip1;\n\n+-------------+-----------------+\n| IP1         | IP2             |\n|-------------+-----------------|\n| 192.0.2.111 | 192.000.002.146 |\n+-------------+-----------------+\n\nALTER TABLE ipt ADD SEARCH OPTIMIZATION ON FULL_TEXT(\n  ip1,\n  ip2,\n  ANALYZER => 'ENTITY_ANALYZER');\n\nCREATE OR REPLACE TABLE iptv(ip1 VARIANT);\nINSERT INTO iptv(ip1)\n  SELECT PARSE_JSON(' { \"ipv1\": \"203.0.113.5\", \"ipv2\": \"203.0.113.5\" } ');\nINSERT INTO iptv(ip1)\n  SELECT PARSE_JSON(' { \"ipv1\": \"192.0.2.146\", \"ipv2\": \"203.0.113.5\" } ');\n\nSELECT * FROM iptv\n  WHERE SEARCH_IP((ip1:\"ipv1\"), '203.0.113.5');\n\n+--------------------------+\n| IP1                      |\n|--------------------------|\n| {                        |\n|   \"ipv1\": \"203.0.113.5\", |\n|   \"ipv2\": \"203.0.113.5\"  |\n| }                        |\n+--------------------------+\n\nSELECT * FROM iptv\n  WHERE SEARCH_IP((ip1:\"ipv1\",ip1:\"ipv2\"), '203.0.113.5');\n\n+--------------------------+\n| IP1                      |\n|--------------------------|\n| {                        |\n|   \"ipv1\": \"203.0.113.5\", |\n|   \"ipv2\": \"203.0.113.5\"  |\n| }                        |\n| {                        |\n|   \"ipv1\": \"192.0.2.146\", |\n|   \"ipv2\": \"203.0.113.5\"  |\n| }                        |\n+--------------------------+\n\nALTER TABLE iptv ADD SEARCH OPTIMIZATION ON FULL_TEXT(\n  ip1:\"ipv1\",\n  ip1:\"ipv2\",\n  ANALYZER => 'ENTITY_ANALYZER');\n\nCREATE OR REPLACE TABLE ipt_log(id INT, ip_request_log VARCHAR(200));\nINSERT INTO ipt_log VALUES(1, 'Connection from IP address 192.0.2.146 succeeded.');\nINSERT INTO ipt_log VALUES(2, 'Connection from IP address 203.0.113.5 failed.');\nINSERT INTO ipt_log VALUES(3, 'Connection from IP address 192.0.2.146 dropped.');\n\nSELECT * FROM ipt_log\n  WHERE SEARCH_IP(ip_request_log, '192.0.2.146')\n  ORDER BY id;\n\n+----+---------------------------------------------------+\n| ID | IP_REQUEST_LOG                                    |\n|----+---------------------------------------------------|\n|  1 | Connection from IP address 192.0.2.146 succeeded. |\n|  3 | Connection from IP address 192.0.2.146 dropped.   |\n+----+---------------------------------------------------+\n\nSELECT SEARCH_IP(ip1, 5) FROM ipt;\n\n001045 (22023): SQL compilation error:\nargument needs to be a string: '1'\n\nSELECT SEARCH_IP(ip1, '1925.0.2.146') FROM ipt;\n\n000937 (22023): SQL compilation error: error line 1 at position 22\ninvalid argument for function [SEARCH_IP(IPT.IP1, '1925.0.2.146')] unexpected argument [1925.0.2.146] at position 1,\n\nSELECT SEARCH_IP(ip1, '') FROM ipt;\n\n000937 (22023): SQL compilation error: error line 1 at position 22\ninvalid argument for function [SEARCH_IP(IPT.IP1, '')] unexpected argument [] at position 1,\n\nSELECT SEARCH_IP(id, '192.0.2.146') FROM ipt;\n\n001173 (22023): SQL compilation error: error line 1 at position 7: Expected non-empty set of columns supporting full-text search.\n\nSELECT SEARCH_IP((id, ip1), '192.0.2.146') FROM ipt;\n\n+-------------------------------------+\n| SEARCH_IP((ID, IP1), '192.0.2.146') |\n|-------------------------------------|\n| True                                |\n| False                               |\n+-------------------------------------+",
    "arguments": [
        {
            "name": "search_data",
            "description": "The data you want to search, expressed as a comma-delimited list of string literals, column names, or paths to fields in VARIANT columns. The search data can\nalso be a single literal string, which can be useful when you are testing the function. You can specify the wildcard character ( * ), where * expands to all qualifying columns in all of the\ntables that are in scope for the function. Qualifying columns are those that have VARCHAR (text), VARIANT,\nARRAY, and OBJECT data types. VARIANT, ARRAY, and OBJECT data is converted to text for searching. You can\nalso use the ILIKE and EXCLUDE keywords for filtering. For more information about this argument, see the search_data description for the SEARCH function."
        },
        {
            "name": "search_string",
            "description": "A VARCHAR string that contains one of the following: A complete and valid IP address in standard IPv4 format, such as 192.0.2.1 . A valid IP address in standard IPv4 format with a Classless Inter-Domain Routing (CIDR) range,\nsuch as 192.0.2.1/24 . A valid IP address in standard IPv4 format with leading zeros, such as 192.000.002.001 (instead of 192.0.2.1 ).\nThe function accepts up to three digits for each part of the IP address. This argument must be a literal string. Specify one pair of single quotes around the string. The following types of arguments aren’t supported: Column names Empty strings More than one IP address Partial IPv4 addresses IPv6 addresses"
        }
    ],
    "returns": "Returns a BOOLEAN."
},
{
    "function_name": "SEARCH",
    "summary": "Searches character data (text) in specified columns from one or more tables, including fields in VARIANT, OBJECT, and ARRAY columns.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/search",
    "title": "SEARCH",
    "description": "Searches character data (text) in specified columns from one or more tables, including fields in VARIANT, OBJECT,\nand ARRAY columns. A text analyzer breaks the text into tokens, which are discrete units of text, such as words\nor numbers. A default analyzer is applied if you do not specify one.",
    "syntax": "SEARCH( <search_data>, <search_string>\n  [ , ANALYZER => '<analyzer_name>' ]\n  [ , SEARCH_MODE => { 'OR' | 'AND' } ] )",
    "example": "SELECT SEARCH('king','KING');\n\n+-----------------------------+\n| SEARCH('KING','KING')       |\n|-----------------------------|\n| True                        |\n+-----------------------------+\n\nSELECT SEARCH('5.1.33','32');\n\n+-----------------------------+\n| SEARCH('5.1.33','32')       |\n|-----------------------------|\n| False                       |\n+-----------------------------+\n\nSELECT SEARCH(character, 'king queen'), character\n  FROM lines\n  WHERE line_id=4;\n\n+---------------------------------+---------------+\n| SEARCH(CHARACTER, 'KING QUEEN') | CHARACTER     |\n|---------------------------------+---------------|\n| True                            | KING HENRY IV |\n+---------------------------------+---------------+\n\nSELECT SEARCH(character, 'king queen', SEARCH_MODE => 'AND'), character\n  FROM lines\n  WHERE line_id=4;\n\n+-------------------------------------------------------+---------------+\n| SEARCH(CHARACTER, 'KING QUEEN', SEARCH_MODE => 'AND') | CHARACTER     |\n|-------------------------------------------------------+---------------|\n| False                                                 | KING HENRY IV |\n+-------------------------------------------------------+---------------+\n\nSELECT *\n  FROM lines\n  WHERE SEARCH(line, 'wherefore')\n  ORDER BY character LIMIT 5;\n\n+---------+----------------------+------------+----------------+-----------+-----------------------------------------------------+\n| LINE_ID | PLAY                 | SPEECH_NUM | ACT_SCENE_LINE | CHARACTER | LINE                                                |\n|---------+----------------------+------------+----------------+-----------+-----------------------------------------------------|\n|  100109 | Troilus and Cressida |         31 | 2.1.53         | ACHILLES  | Why, how now, Ajax! wherefore do you thus? How now, |\n|   16448 | As You Like It       |          2 | 2.3.6          | ADAM      | And wherefore are you gentle, strong and valiant?   |\n|   24055 | The Comedy of Errors |         14 | 5.1.41         | AEMELIA   | Be quiet, people. Wherefore throng you hither?      |\n|   99330 | Troilus and Cressida |         30 | 1.1.102        | AENEAS    | How now, Prince Troilus! wherefore not afield?      |\n|   92454 | The Tempest          |        150 | 2.1.343        | ALONSO    | Wherefore this ghastly looking?                     |\n+---------+----------------------+------------+----------------+-----------+-----------------------------------------------------+\n\nSELECT play, character\n  FROM lines\n  WHERE SEARCH((play, character), 'king')\n  ORDER BY play, character LIMIT 10;\n\n+---------------------------+-----------------+\n| PLAY                      | CHARACTER       |\n|---------------------------+-----------------|\n| All's Well That Ends Well | KING            |\n| Hamlet                    | KING CLAUDIUS   |\n| Hamlet                    | KING CLAUDIUS   |\n| Henry IV Part 1           | KING HENRY IV   |\n| Henry IV Part 1           | KING HENRY IV   |\n| King John                 | CHATILLON       |\n| King John                 | KING JOHN       |\n| King Lear                 | GLOUCESTER      |\n| King Lear                 | KENT            |\n| Richard II                | KING RICHARD II |\n+---------------------------+-----------------+\n\nSELECT play, character, line, act_scene_line\n  FROM lines\n  WHERE SEARCH((lines.*), 'king')\n  ORDER BY act_scene_line LIMIT 10;\n\n+-----------------+-----------------+----------------------------------------------------+----------------+\n| PLAY            | CHARACTER       | LINE                                               | ACT_SCENE_LINE |\n|-----------------+-----------------+----------------------------------------------------+----------------|\n| Pericles        | LODOVICO        | This king unto him took a fere,                    | 1.0.21         |\n| Richard II      | KING RICHARD II | Old John of Gaunt, time-honour'd Lancaster,        | 1.1.1          |\n| Henry VI Part 3 | WARWICK         | I wonder how the king escaped our hands.           | 1.1.1          |\n| King John       | KING JOHN       | Now, say, Chatillon, what would France with us?    | 1.1.1          |\n| King Lear       | KENT            | I thought the king had more affected the Duke of   | 1.1.1          |\n| Henry IV Part 1 | KING HENRY IV   | So shaken as we are, so wan with care,             | 1.1.1          |\n| Henry IV Part 1 | KING HENRY IV   | Which, like the meteors of a troubled heaven,      | 1.1.10         |\n| King Lear       | GLOUCESTER      | so often blushed to acknowledge him, that now I am | 1.1.10         |\n| Cymbeline       | First Gentleman | Is outward sorrow, though I think the king         | 1.1.10         |\n| King John       | CHATILLON       | To this fair island and the territories,           | 1.1.10         |\n+-----------------+-----------------+----------------------------------------------------+----------------+\n\nSELECT play, character, line, act_scene_line\n  FROM lines\n  WHERE SEARCH((lines.* ILIKE '%line'), 'king')\n  ORDER BY act_scene_line LIMIT 10;\n\n+-----------------+-----------------+--------------------------------------------------+----------------+\n| PLAY            | CHARACTER       | LINE                                             | ACT_SCENE_LINE |\n|-----------------+-----------------+--------------------------------------------------+----------------|\n| Pericles        | LODOVICO        | This king unto him took a fere,                  | 1.0.21         |\n| Henry VI Part 3 | WARWICK         | I wonder how the king escaped our hands.         | 1.1.1          |\n| King Lear       | KENT            | I thought the king had more affected the Duke of | 1.1.1          |\n| Cymbeline       | First Gentleman | Is outward sorrow, though I think the king       | 1.1.10         |\n+-----------------+-----------------+--------------------------------------------------+----------------+\n\nSELECT play, character, line, act_scene_line\n  FROM lines\n  WHERE SEARCH((lines.* EXCLUDE character), 'king')\n  ORDER BY act_scene_line LIMIT 10;\n\n+-----------------+-----------------+----------------------------------------------------+----------------+\n| PLAY            | CHARACTER       | LINE                                               | ACT_SCENE_LINE |\n|-----------------+-----------------+----------------------------------------------------+----------------|\n| Pericles        | LODOVICO        | This king unto him took a fere,                    | 1.0.21         |\n| Henry VI Part 3 | WARWICK         | I wonder how the king escaped our hands.           | 1.1.1          |\n| King John       | KING JOHN       | Now, say, Chatillon, what would France with us?    | 1.1.1          |\n| King Lear       | KENT            | I thought the king had more affected the Duke of   | 1.1.1          |\n| Cymbeline       | First Gentleman | Is outward sorrow, though I think the king         | 1.1.10         |\n| King Lear       | GLOUCESTER      | so often blushed to acknowledge him, that now I am | 1.1.10         |\n| King John       | CHATILLON       | To this fair island and the territories,           | 1.1.10         |\n+-----------------+-----------------+----------------------------------------------------+----------------+\n\nSELECT SEARCH((*), 'king') result, *\n  FROM lines\n  ORDER BY act_scene_line LIMIT 10;\n\n+--------+---------+---------------------------+------------+----------------+-----------------+--------------------------------------------------------+\n| RESULT | LINE_ID | PLAY                      | SPEECH_NUM | ACT_SCENE_LINE | CHARACTER       | LINE                                                   |\n|--------+---------+---------------------------+------------+----------------+-----------------+--------------------------------------------------------|\n| True   |   75787 | Pericles                  |        178 | 1.0.21         | LODOVICO        | This king unto him took a fere,                        |\n| True   |   43494 | King John                 |          1 | 1.1.1          | KING JOHN       | Now, say, Chatillon, what would France with us?        |\n| True   |   49031 | King Lear                 |          1 | 1.1.1          | KENT            | I thought the king had more affected the Duke of       |\n| True   |   78407 | Richard II                |          1 | 1.1.1          | KING RICHARD II | Old John of Gaunt, time-honour'd Lancaster,            |\n| False  |   67000 | A Midsummer Night's Dream |          1 | 1.1.1          | THESEUS         | Now, fair Hippolyta, our nuptial hour                  |\n| True   |       4 | Henry IV Part 1           |          1 | 1.1.1          | KING HENRY IV   | So shaken as we are, so wan with care,                 |\n| False  |   12664 | All's Well That Ends Well |          1 | 1.1.1          | COUNTESS        | In delivering my son from me, I bury a second husband. |\n| True   |    9526 | Henry VI Part 3           |          1 | 1.1.1          | WARWICK         | I wonder how the king escaped our hands.               |\n| False  |   52797 | Love's Labour's Lost      |          1 | 1.1.1          | FERDINAND       | Let fame, that all hunt after in their lives,          |\n| True   |   28487 | Cymbeline                 |          3 | 1.1.10         | First Gentleman | Is outward sorrow, though I think the king             |\n+--------+---------+---------------------------+------------+----------------+-----------------+--------------------------------------------------------+\n\nSELECT SEARCH(* ILIKE '%line', 'king') result, play, character, line\n  FROM lines\n  ORDER BY act_scene_line LIMIT 10;\n\n+--------+---------------------------+-----------------+--------------------------------------------------------+\n| RESULT | PLAY                      | CHARACTER       | LINE                                                   |\n|--------+---------------------------+-----------------+--------------------------------------------------------|\n| True   | Pericles                  | LODOVICO        | This king unto him took a fere,                        |\n| False  | King John                 | KING JOHN       | Now, say, Chatillon, what would France with us?        |\n| True   | King Lear                 | KENT            | I thought the king had more affected the Duke of       |\n| False  | Richard II                | KING RICHARD II | Old John of Gaunt, time-honour'd Lancaster,            |\n| False  | A Midsummer Night's Dream | THESEUS         | Now, fair Hippolyta, our nuptial hour                  |\n| False  | Henry IV Part 1           | KING HENRY IV   | So shaken as we are, so wan with care,                 |\n| False  | All's Well That Ends Well | COUNTESS        | In delivering my son from me, I bury a second husband. |\n| True   | Henry VI Part 3           | WARWICK         | I wonder how the king escaped our hands.               |\n| False  | Love's Labour's Lost      | FERDINAND       | Let fame, that all hunt after in their lives,          |\n| True   | Cymbeline                 | First Gentleman | Is outward sorrow, though I think the king             |\n+--------+---------------------------+-----------------+--------------------------------------------------------+\n\nSELECT SEARCH(* EXCLUDE (play, line), 'king') result, play, character, line\n  FROM lines\n  ORDER BY act_scene_line LIMIT 10;\n\n+--------+---------------------------+-----------------+--------------------------------------------------------+\n| RESULT | PLAY                      | CHARACTER       | LINE                                                   |\n|--------+---------------------------+-----------------+--------------------------------------------------------|\n| False  | Pericles                  | LODOVICO        | This king unto him took a fere,                        |\n| True   | King John                 | KING JOHN       | Now, say, Chatillon, what would France with us?        |\n| False  | King Lear                 | KENT            | I thought the king had more affected the Duke of       |\n| True   | Richard II                | KING RICHARD II | Old John of Gaunt, time-honour'd Lancaster,            |\n| False  | A Midsummer Night's Dream | THESEUS         | Now, fair Hippolyta, our nuptial hour                  |\n| True   | Henry IV Part 1           | KING HENRY IV   | So shaken as we are, so wan with care,                 |\n| False  | All's Well That Ends Well | COUNTESS        | In delivering my son from me, I bury a second husband. |\n| False  | Henry VI Part 3           | WARWICK         | I wonder how the king escaped our hands.               |\n| False  | Love's Labour's Lost      | FERDINAND       | Let fame, that all hunt after in their lives,          |\n| False  | Cymbeline                 | First Gentleman | Is outward sorrow, though I think the king             |\n+--------+---------------------------+-----------------+--------------------------------------------------------+\n\nCREATE OR REPLACE TABLE t1 (col1 INT, col2 VARCHAR(20), col3 VARCHAR(20));\nINSERT INTO t1 VALUES\n  (1,'Mini','Cooper'),\n  (2,'Mini','Cooper S'),\n  (3,'Mini','Countryman'),\n  (4,'Mini','Countryman S');\nCREATE OR REPLACE TABLE t2 (col1 INT, col2 VARCHAR(20), col3 VARCHAR(20), col4 VARCHAR(20));\nINSERT INTO t2 VALUES\n  (1,'Mini','Cooper', 'Convertible'),\n  (2,'Mini','Cooper S', 'Convertible'),\n  (3,'Mini','Countryman SE','ALL4'),\n  (4,'Mini','Countryman S','ALL4');\n\nSELECT * FROM t1 JOIN t2 USING(col1)\n  WHERE SEARCH((t1.*),'s all4');\n\n+------+------+--------------+------+--------------+-------------+\n| COL1 | COL2 | COL3         | COL2 | COL3         | COL4        |\n|------+------+--------------+------+--------------+-------------|\n|    2 | Mini | Cooper S     | Mini | Cooper S     | Convertible |\n|    4 | Mini | Countryman S | Mini | Countryman S | ALL4        |\n+------+------+--------------+------+--------------+-------------+\n\nSELECT * FROM t1 JOIN t2 USING(col1)\n  WHERE SEARCH((t2.*),'s all4');\n\n+------+------+--------------+------+---------------+-------------+\n| COL1 | COL2 | COL3         | COL2 | COL3          | COL4        |\n|------+------+--------------+------+---------------+-------------|\n|    2 | Mini | Cooper S     | Mini | Cooper S      | Convertible |\n|    3 | Mini | Countryman   | Mini | Countryman SE | ALL4        |\n|    4 | Mini | Countryman S | Mini | Countryman S  | ALL4        |\n+------+------+--------------+------+---------------+-------------+\n\nSELECT *\n  FROM (\n    SELECT col1, col2, col3 FROM t1\n    UNION\n    SELECT col1, col2, col3 FROM t2\n    ) AS T3\n  WHERE SEARCH((T3.*),'s');\n\n+------+------+--------------+\n| COL1 | COL2 | COL3         |\n|------+------+--------------|\n|    2 | Mini | Cooper S     |\n|    4 | Mini | Countryman S |\n+------+------+--------------+\n\nSELECT act_scene_line, character, line\n  FROM lines\n  WHERE SEARCH(line, 'Rosencrantz Guildenstern', SEARCH_MODE => 'AND')\n    AND act_scene_line IS NOT NULL;\n\n+----------------+------------------+-----------------------------------------------------------+\n| ACT_SCENE_LINE | CHARACTER        | LINE                                                      |\n|----------------+------------------+-----------------------------------------------------------|\n| 2.2.1          | KING CLAUDIUS    | Welcome, dear Rosencrantz and Guildenstern!               |\n| 2.2.35         | KING CLAUDIUS    | Thanks, Rosencrantz and gentle Guildenstern.              |\n| 2.2.36         | QUEEN GERTRUDE   | Thanks, Guildenstern and gentle Rosencrantz:              |\n| 2.2.241        | HAMLET           | Guildenstern? Ah, Rosencrantz! Good lads, how do ye both? |\n| 4.6.27         | HORATIO          | where I am. Rosencrantz and Guildenstern hold their       |\n| 5.2.60         | HORATIO          | So Guildenstern and Rosencrantz go to't.                  |\n| 5.2.389        | First Ambassador | That Rosencrantz and Guildenstern are dead:               |\n+----------------+------------------+-----------------------------------------------------------+\n\nSELECT act_scene_line, character, line\n  FROM lines\n  WHERE SEARCH(line, 'KING Rosencrantz', SEARCH_MODE => 'AND')\n    AND act_scene_line IS NOT NULL;\n\n+----------------+-----------+------+\n| ACT_SCENE_LINE | CHARACTER | LINE |\n|----------------+-----------+------|\n+----------------+-----------+------+\n\nSELECT act_scene_line, character, line\n  FROM lines\n  WHERE SEARCH(line, 'KING Rosencrantz', SEARCH_MODE => 'OR')\n    AND act_scene_line IS NOT NULL;\n\n+----------------+------------------+-----------------------------------------------------------+\n| ACT_SCENE_LINE | CHARACTER        | LINE                                                      |\n|----------------+------------------+-----------------------------------------------------------|\n| 1.1.1          | WARWICK          | I wonder how the king escaped our hands.                  |\n| 1.1.10         | First Gentleman  | Is outward sorrow, though I think the king                |\n| 2.2.1          | KING CLAUDIUS    | Welcome, dear Rosencrantz and Guildenstern!               |\n| 2.2.35         | KING CLAUDIUS    | Thanks, Rosencrantz and gentle Guildenstern.              |\n| 2.2.36         | QUEEN GERTRUDE   | Thanks, Guildenstern and gentle Rosencrantz:              |\n| 2.2.241        | HAMLET           | Guildenstern? Ah, Rosencrantz! Good lads, how do ye both? |\n| 4.6.27         | HORATIO          | where I am. Rosencrantz and Guildenstern hold their       |\n| 5.2.60         | HORATIO          | So Guildenstern and Rosencrantz go to't.                  |\n| 5.2.389        | First Ambassador | That Rosencrantz and Guildenstern are dead:               |\n| 1.1.1          | KENT             | I thought the king had more affected the Duke of          |\n| 1.0.21         | LODOVICO         | This king unto him took a fere,                           |\n+----------------+------------------+-----------------------------------------------------------+\n\nCREATE OR REPLACE TABLE car_rentals(\n  vehicle_make VARCHAR(30),\n  dealership VARCHAR(30),\n  salesperson VARCHAR(30));\n\nINSERT INTO car_rentals VALUES\n  ('Toyota', 'Tindel Toyota', 'Greg Northrup'),\n  ('Honda', 'Valley View Auto Sales', 'Frank Beasley'),\n  ('Tesla', 'Valley View Auto Sales', 'Arturo Sandoval');\n\nSELECT SEARCH((r.vehicle_make, r.dealership, s.src:dealership), 'Toyota Tesla')\n    AS contains_toyota_tesla, r.vehicle_make, r.dealership,s.src:dealership\n  FROM car_rentals r JOIN car_sales s\n    ON r.SALESPERSON=s.src:salesperson.name;\n\n+-----------------------+--------------+------------------------+--------------------------+\n| CONTAINS_TOYOTA_TESLA | VEHICLE_MAKE | DEALERSHIP             | S.SRC:DEALERSHIP         |\n|-----------------------+--------------+------------------------+--------------------------|\n| True                  | Toyota       | Tindel Toyota          | \"Tindel Toyota\"          |\n| False                 | Honda        | Valley View Auto Sales | \"Valley View Auto Sales\" |\n+-----------------------+--------------+------------------------+--------------------------+\n\nSELECT SEARCH((r.vehicle_make, r.dealership, s.src:dealership), 'Toyota Honda')\n    AS contains_toyota_honda, r.vehicle_make, r.dealership, s.src:dealership\n  FROM car_rentals r JOIN car_sales s\n    ON r.SALESPERSON =s.src:salesperson.name;\n\n+-----------------------+--------------+------------------------+--------------------------+\n| CONTAINS_TOYOTA_HONDA | VEHICLE_MAKE | DEALERSHIP             | S.SRC:DEALERSHIP         |\n|-----------------------+--------------+------------------------+--------------------------|\n| True                  | Toyota       | Tindel Toyota          | \"Tindel Toyota\"          |\n| True                  | Honda        | Valley View Auto Sales | \"Valley View Auto Sales\" |\n+-----------------------+--------------+------------------------+--------------------------+\n\nSELECT line_id, act_scene_line FROM lines\n  WHERE SEARCH(act_scene_line, '1.2.500', ANALYZER=>'NO_OP_ANALYZER');\n\n+---------+----------------+\n| LINE_ID | ACT_SCENE_LINE |\n|---------+----------------|\n|   91998 | 1.2.500        |\n|  108464 | 1.2.500        |\n+---------+----------------+\n\nSELECT DISTINCT(play)\n  FROM lines\n  WHERE SEARCH(play, 'love''s', ANALYZER=>'UNICODE_ANALYZER');\n\n+----------------------+\n| PLAY                 |\n|----------------------|\n| Love's Labour's Lost |\n+----------------------+\n\nSELECT DISTINCT(play) FROM lines WHERE SEARCH(play, 'love''s');\n\n+---------------------------+\n| PLAY                      |\n|---------------------------|\n| All's Well That Ends Well |\n| Love's Labour's Lost      |\n| A Midsummer Night's Dream |\n| The Winter's Tale         |\n+---------------------------+\n\nSELECT SEARCH(line, 5) FROM lines;\n\n001045 (22023): SQL compilation error:\nargument needs to be a string: '1'\n\nSELECT SEARCH(line_id, 'dream') FROM lines;\n\n001173 (22023): SQL compilation error: error line 1 at position 7: Expected non-empty set of columns supporting full-text search.\n\nSELECT SEARCH((line_id, play), 'dream') FROM lines\n  ORDER BY play LIMIT 5;\n\n+----------------------------------+\n| SEARCH((LINE_ID, PLAY), 'DREAM') |\n|----------------------------------|\n| True                             |\n| True                             |\n| False                            |\n| False                            |\n| False                            |\n+----------------------------------+\n\nSELECT SEARCH('docs@snowflake.com', 'careers@snowflake.com', '@');\n\n001881 (42601): SQL compilation error: Expected 1 named argument(s), found 0\n\nSELECT SEARCH(play,line,'king', ANALYZER=>'UNICODE_ANALYZER') FROM lines;\n\n000939 (22023): SQL compilation error: error line 1 at position 7\ntoo many arguments for function [SEARCH(LINES.PLAY, LINES.LINE, 'king', 'UNICODE_ANALYZER')] expected 3, got 4\n\nSELECT SEARCH(line, character) FROM lines;\n\n001015 (22023): SQL compilation error:\nargument 2 to function SEARCH needs to be constant, found 'LINES.CHARACTER'\n\nDESCRIBE TABLE lines;\n\n+----------------+---------------+--------+-------+-\n| name           | type          | kind   | null? |\n|----------------+---------------+--------+-------+-\n| LINE_ID        | NUMBER(38,0)  | COLUMN | Y     |\n| PLAY           | VARCHAR(50)   | COLUMN | Y     |\n| SPEECH_NUM     | NUMBER(38,0)  | COLUMN | Y     |\n| ACT_SCENE_LINE | VARCHAR(10)   | COLUMN | Y     |\n| CHARACTER      | VARCHAR(30)   | COLUMN | Y     |\n| LINE           | VARCHAR(2000) | COLUMN | Y     |\n+----------------+---------------+--------+-------+-\n\nSELECT * FROM lines\n  WHERE line_id=34230;\n\n+---------+--------+------------+----------------+-----------+--------------------------------------------+\n| LINE_ID | PLAY   | SPEECH_NUM | ACT_SCENE_LINE | CHARACTER | LINE                                       |\n|---------+--------+------------+----------------+-----------+--------------------------------------------|\n|   34230 | Hamlet |         19 | 3.1.64         | HAMLET    | To be, or not to be, that is the question: |\n+---------+--------+------------+----------------+-----------+--------------------------------------------+\n\nCREATE OR REPLACE TABLE lines(\n  line_id INT,\n  play VARCHAR(50),\n  speech_num INT,\n  act_scene_line VARCHAR(10),\n  character VARCHAR(30),\n  line VARCHAR(2000)\n  );\n\nINSERT INTO lines VALUES\n  (4,'Henry IV Part 1',1,'1.1.1','KING HENRY IV','So shaken as we are, so wan with care,'),\n  (13,'Henry IV Part 1',1,'1.1.10','KING HENRY IV','Which, like the meteors of a troubled heaven,'),\n  (9526,'Henry VI Part 3',1,'1.1.1','WARWICK','I wonder how the king escaped our hands.'),\n  (12664,'All''s Well That Ends Well',1,'1.1.1','COUNTESS','In delivering my son from me, I bury a second husband.'),\n  (15742,'All''s Well That Ends Well',114,'5.3.378','KING','Your gentle hands lend us, and take our hearts.'),\n  (16448,'As You Like It',2,'2.3.6','ADAM','And wherefore are you gentle, strong and valiant?'),\n  (24055,'The Comedy of Errors',14,'5.1.41','AEMELIA','Be quiet, people. Wherefore throng you hither?'),\n  (28487,'Cymbeline',3,'1.1.10','First Gentleman','Is outward sorrow, though I think the king'),\n  (33522,'Hamlet',1,'2.2.1','KING CLAUDIUS','Welcome, dear Rosencrantz and Guildenstern!'),\n  (33556,'Hamlet',5,'2.2.35','KING CLAUDIUS','Thanks, Rosencrantz and gentle Guildenstern.'),\n  (33557,'Hamlet',6,'2.2.36','QUEEN GERTRUDE','Thanks, Guildenstern and gentle Rosencrantz:'),\n  (33776,'Hamlet',67,'2.2.241','HAMLET','Guildenstern? Ah, Rosencrantz! Good lads, how do ye both?'),\n  (34230,'Hamlet',19,'3.1.64','HAMLET','To be, or not to be, that is the question:'),\n  (35672,'Hamlet',7,'4.6.27','HORATIO','where I am. Rosencrantz and Guildenstern hold their'),\n  (36289,'Hamlet',14,'5.2.60','HORATIO','So Guildenstern and Rosencrantz go to''t.'),\n  (36640,'Hamlet',143,'5.2.389','First Ambassador','That Rosencrantz and Guildenstern are dead:'),\n  (43494,'King John',1,'1.1.1','KING JOHN','Now, say, Chatillon, what would France with us?'),\n  (43503,'King John',5,'1.1.10','CHATILLON','To this fair island and the territories,'),\n  (49031,'King Lear',1,'1.1.1','KENT','I thought the king had more affected the Duke of'),\n  (49040,'King Lear',4,'1.1.10','GLOUCESTER','so often blushed to acknowledge him, that now I am'),\n  (52797,'Love''s Labour''s Lost',1,'1.1.1','FERDINAND','Let fame, that all hunt after in their lives,'),\n  (55778,'Love''s Labour''s Lost',405,'5.2.971','ADRIANO DE ARMADO','Apollo. You that way: we this way.'),\n  (67000,'A Midsummer Night''s Dream',1,'1.1.1','THESEUS','Now, fair Hippolyta, our nuptial hour'),\n  (69296,'A Midsummer Night''s Dream',104,'5.1.428','PUCK','And Robin shall restore amends.'),\n  (75787,'Pericles',178,'1.0.21','LODOVICO','This king unto him took a fere,'),\n  (78407,'Richard II',1,'1.1.1','KING RICHARD II','Old John of Gaunt, time-honour''d Lancaster,'),\n  (91998,'The Tempest',108,'1.2.500','FERDINAND','Were I but where ''tis spoken.'),\n  (92454,'The Tempest',150,'2.1.343','ALONSO','Wherefore this ghastly looking?'),\n  (99330,'Troilus and Cressida',30,'1.1.102','AENEAS','How now, Prince Troilus! wherefore not afield?'),\n  (100109,'Troilus and Cressida',31,'2.1.53','ACHILLES','Why, how now, Ajax! wherefore do you thus? How now,'),\n  (108464,'The Winter''s Tale',106,'1.2.500','CAMILLO','As or by oath remove or counsel shake')\n  ;",
    "returns": "Returns a BOOLEAN."
},
{
    "function_name": "SCHEDULED_TIME",
    "summary": "Returns the timestamp representing the scheduled time of the current alert.",
    "category": "Date & time functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/scheduled_time",
    "title": "SCHEDULED_TIME",
    "description": "Returns the timestamp representing the scheduled time of the current alert. Refer to",
    "syntax": "SNOWFLAKE.ALERT.SCHEDULED_TIME()",
    "returns": "TIMESTAMP_LTZ value that represents the scheduled time of the current alert."
},
{
    "function_name": "SANITIZE_WEBHOOK_CONTENT",
    "summary": "Removes placeholders (for example, the SNOWFLAKE_WEBHOOK_SECRET placeholder, which specifies a secret) from the body of a notification message to be sent.",
    "category": "Notification functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/sanitize_webhook_content",
    "title": "SANITIZE_WEBHOOK_CONTENT",
    "description": "Removes placeholders (for example, the SNOWFLAKE_WEBHOOK_SECRET placeholder, which specifies a secret) from the body of a\nnotification message to be sent.",
    "syntax": "SNOWFLAKE.NOTIFICATION.SANITIZE_WEBHOOK_CONTENT( <message> )",
    "arguments": [
        {
            "name": "message",
            "description": "A VARCHAR value containing the message to sanitize."
        }
    ],
    "returns": "Returns a VARCHAR value with placeholders replaced with the string REDACTED."
},
{
    "function_name": "RTRIMMED_LENGTH",
    "summary": "Returns the length of its argument, minus trailing whitespace, but including leading whitespace.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/rtrimmed_length",
    "title": "RTRIMMED_LENGTH",
    "description": "Returns the length of its argument, minus trailing whitespace, but including leading whitespace.",
    "syntax": "RTRIMMED_LENGTH( <string_expr> )",
    "example": "SELECT RTRIMMED_LENGTH(' ABCD ');\n\n+---------------------------+\n| RTRIMMED_LENGTH(' ABCD ') |\n|---------------------------|\n|                         5 |\n+---------------------------+"
},
{
    "function_name": "RTRIM",
    "summary": "Removes trailing characters, including whitespace, from a string.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/rtrim",
    "title": "RTRIM",
    "description": "Removes trailing characters, including whitespace, from a string.",
    "syntax": "RTRIM(<expr> [, <characters> ])",
    "example": "SELECT RTRIM('$125.00', '0.');\n\n+------------------------+\n| RTRIM('$125.00', '0.') |\n|------------------------|\n| $125                   |\n+------------------------+\n\nCREATE OR REPLACE TABLE test_rtrim_function(column1 VARCHAR);\n\nINSERT INTO test_rtrim_function VALUES ('Trailing Spaces#  ');\n\nSELECT CONCAT('>', CONCAT(column1, '<')) AS original_value,\n       CONCAT('>', CONCAT(RTRIM(column1), '<')) AS trimmed_value\n  FROM test_rtrim_function;\n\n+----------------------+--------------------+\n| ORIGINAL_VALUE       | TRIMMED_VALUE      |\n|----------------------+--------------------|\n| >Trailing Spaces#  < | >Trailing Spaces#< |\n+----------------------+--------------------+\n\nSELECT CONCAT('>', CONCAT(column1, '<')) AS original_value,\n       CONCAT('>', CONCAT(RTRIM(column1, '# '), '<')) AS trimmed_value\n  FROM test_rtrim_function;\n\n+----------------------+-------------------+\n| ORIGINAL_VALUE       | TRIMMED_VALUE     |\n|----------------------+-------------------|\n| >Trailing Spaces#  < | >Trailing Spaces< |\n+----------------------+-------------------+",
    "arguments": [
        {
            "name": "expr",
            "description": "The string expression to be trimmed."
        },
        {
            "name": "characters",
            "description": "One or more characters to remove from the right side of expr : The default value is ' ' (a single blank space character).\nIf no characters are specified, only blank spaces are removed."
        }
    ],
    "returns": "This function returns a value of VARCHAR data type or NULL. If either argument is NULL, returns NULL."
},
{
    "function_name": "RPAD",
    "summary": "Right-pads a string with characters from another string, or right-pads a binary value with bytes from another binary value.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/rpad",
    "title": "RPAD",
    "description": "Right-pads a string with characters from another string, or right-pads a binary value with bytes from another binary value.",
    "syntax": "RPAD( <base>, <length_expr> [, <pad>] )",
    "example": "CREATE OR REPLACE TABLE padding_example (v VARCHAR, b BINARY);\n\nINSERT INTO padding_example (v, b)\n  SELECT\n    'Hi',\n    HEX_ENCODE('Hi');\n\nINSERT INTO padding_example (v, b)\n  SELECT\n    '-123.00',\n    HEX_ENCODE('-123.00');\n\nINSERT INTO padding_example (v, b)\n  SELECT\n    'Twelve Dollars',\n    TO_BINARY(HEX_ENCODE('Twelve Dollars'), 'HEX');\n\nSELECT * FROM padding_example;\n\n+----------------+------------------------------+\n| V              | B                            |\n|----------------+------------------------------|\n| Hi             | 4869                         |\n| -123.00        | 2D3132332E3030               |\n| Twelve Dollars | 5477656C766520446F6C6C617273 |\n+----------------+------------------------------+\n\nSELECT v,\n       RPAD(v, 10, '_') AS pad_with_underscore,\n       RPAD(v, 10, '$') AS pad_with_dollar_sign\n  FROM padding_example\n  ORDER BY v;\n\n+----------------+---------------------+----------------------+\n| V              | PAD_WITH_UNDERSCORE | PAD_WITH_DOLLAR_SIGN |\n|----------------+---------------------+----------------------|\n| -123.00        | -123.00___          | -123.00$$$           |\n| Hi             | Hi________          | Hi$$$$$$$$           |\n| Twelve Dollars | Twelve Dol          | Twelve Dol           |\n+----------------+---------------------+----------------------+\n\nSELECT b,\n       RPAD(b, 10, TO_BINARY(HEX_ENCODE('_'))) AS pad_with_underscore,\n       RPAD(b, 10, TO_BINARY(HEX_ENCODE('$'))) AS pad_with_dollar_sign\n  FROM padding_example\n  ORDER BY b;\n\n+------------------------------+----------------------+----------------------+\n| B                            | PAD_WITH_UNDERSCORE  | PAD_WITH_DOLLAR_SIGN |\n|------------------------------+----------------------+----------------------|\n| 2D3132332E3030               | 2D3132332E30305F5F5F | 2D3132332E3030242424 |\n| 4869                         | 48695F5F5F5F5F5F5F5F | 48692424242424242424 |\n| 5477656C766520446F6C6C617273 | 5477656C766520446F6C | 5477656C766520446F6C |\n+------------------------------+----------------------+----------------------+\n\nSELECT RPAD('123.50', 19, '*_');\n\n+--------------------------+\n| RPAD('123.50', 19, '*_') |\n|--------------------------|\n| 123.50*_*_*_*_*_*_*      |\n+--------------------------+",
    "arguments": [
        {
            "name": "base",
            "description": "A VARCHAR or BINARY value."
        },
        {
            "name": "length_expr",
            "description": "An expression that evaluates to an integer. It specifies: The number of UTF-8 characters to return if the input is VARCHAR. The number of bytes to return if the input is BINARY."
        },
        {
            "name": "pad",
            "description": "A VARCHAR or BINARY value. The type must match the data type of the base argument.\nCharacters (or bytes) from this argument are used to pad the base ."
        }
    ],
    "returns": "The data type of the returned value is the same as the data type of the base input value (VARCHAR or BINARY)."
},
{
    "function_name": "ROW_NUMBER",
    "summary": "Returns a unique row number for each row within a window partition.",
    "category": "Window function syntax and usage",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/row_number",
    "title": "ROW_NUMBER",
    "description": "Returns a unique row number for each row within a window partition.",
    "syntax": "ROW_NUMBER() OVER (\n  [ PARTITION BY <expr1> [, <expr2> ... ] ]\n  ORDER BY <expr3> [ , <expr4> ... ] [ { ASC | DESC } ]\n  )",
    "example": "SELECT\n    symbol,\n    exchange,\n    shares,\n    ROW_NUMBER() OVER (PARTITION BY exchange ORDER BY shares) AS row_number\n  FROM trades;\n\n+------+--------+------+----------+\n|SYMBOL|EXCHANGE|SHARES|ROW_NUMBER|\n+------+--------+------+----------+\n|SPY   |C       |   250|         1|\n|AAPL  |C       |   250|         2|\n|AAPL  |C       |   300|         3|\n|SPY   |N       |   100|         1|\n|AAPL  |N       |   300|         2|\n|SPY   |N       |   500|         3|\n|QQQ   |N       |   800|         4|\n|QQQ   |N       |  2000|         5|\n|YHOO  |N       |  5000|         6|\n+------+--------+------+----------+"
},
{
    "function_name": "ROUND",
    "summary": "Returns rounded values for input_expr.",
    "category": "Numeric functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/round",
    "title": "ROUND",
    "description": "Returns rounded values for",
    "syntax": "ROUND( <input_expr> [ , <scale_expr> [ , <rounding_mode> ] ] )",
    "example": "SELECT ROUND(135.135), ROUND(-975.975);\n+----------------+-----------------+\n| ROUND(135.135) | ROUND(-975.975) |\n|----------------+-----------------|\n|            135 |            -976 |\n+----------------+-----------------+\n\nSELECT n, scale, ROUND(n, scale)\n  FROM test_ceiling\n  ORDER BY n, scale;\n+----------+-------+-----------------+\n|        N | SCALE | ROUND(N, SCALE) |\n|----------+-------+-----------------|\n| -975.975 |    -1 |        -980     |\n| -975.975 |     0 |        -976     |\n| -975.975 |     2 |        -975.98  |\n|  135.135 |    -2 |         100     |\n|  135.135 |     0 |         135     |\n|  135.135 |     1 |         135.1   |\n|  135.135 |     3 |         135.135 |\n|  135.135 |    50 |         135.135 |\n|  135.135 |  NULL |            NULL |\n+----------+-------+-----------------+\n\nSELECT ROUND(2.5, 0), ROUND(2.5, 0, 'HALF_TO_EVEN');\n\n+---------------+-------------------------------+\n| ROUND(2.5, 0) | ROUND(2.5, 0, 'HALF_TO_EVEN') |\n|---------------+-------------------------------|\n|             3 |                             2 |\n+---------------+-------------------------------+\n\nSELECT ROUND(-2.5, 0), ROUND(2.5, 0, 'HALF_TO_EVEN');\n\n+---------------+--------------------------------+\n| ROUND(2.5, 0) | ROUND(-2.5, 0, 'HALF_TO_EVEN') |\n|---------------+--------------------------------|\n|            -3 |                             -2 |\n+---------------+--------------------------------+\n\nSELECT ROUND(\n  EXPR => -2.5,\n  SCALE => 0);\n\n+---------------------------------+\n| ROUND(EXPR => -2.5, SCALE => 0) |\n|---------------------------------|\n|                              -3 |\n+---------------------------------+\n\nSELECT ROUND(\n  EXPR => -2.5,\n  SCALE => 0,\n  ROUNDING_MODE => 'HALF_TO_EVEN');\n\n+------------------------------------------------------------------+\n| ROUND(EXPR => -2.5, SCALE => 0, ROUNDING_MODE => 'HALF_TO_EVEN') |\n|------------------------------------------------------------------|\n|                                                               -2 |\n+------------------------------------------------------------------+\n\nCREATE OR REPLACE TEMP TABLE rnd1(f float, d DECIMAL(10, 3));\nINSERT INTO rnd1 (f, d) VALUES\n      ( -10.005,  -10.005),\n      (  -1.005,   -1.005),\n      (   1.005,    1.005),\n      (  10.005,   10.005)\n      ;\n\nselect f, round(f, 2), \n       d, round(d, 2) \n    from rnd1 \n    order by 1;\n+---------+-------------+---------+-------------+\n|       F | ROUND(F, 2) |       D | ROUND(D, 2) |\n|---------+-------------+---------+-------------|\n| -10.005 |      -10.01 | -10.005 |      -10.01 |\n|  -1.005 |       -1    |  -1.005 |       -1.01 |\n|   1.005 |        1    |   1.005 |        1.01 |\n|  10.005 |       10.01 |  10.005 |       10.01 |\n+---------+-------------+---------+-------------+",
    "arguments": [
        {
            "name": "input_expr",
            "description": "The value or expression to operate on. The data type should be one of the numeric data types, such as FLOAT or NUMBER. If you specify the EXPR => named argument, you must also specify the SCALE => named argument."
        },
        {
            "name": "scale_expr",
            "description": "The number of digits the output should include after the decimal point. The expression should evaluate to an\ninteger from -38 to +38. The default scale_expr is zero, meaning that the function removes all digits after the decimal point. For information about negative numbers, see the Usage Notes below. If you specify the SCALE => named argument, you must specify EXPR => as the preceding named argument."
        },
        {
            "name": "rounding_mode",
            "description": "The rounding mode to use. You can specify one of the following values: 'HALF_AWAY_FROM_ZERO' . This mode rounds the value half away from zero . 'HALF_TO_EVEN' . This mode rounds the value half to even . Default: 'HALF_AWAY_FROM_ZERO' If you specify the ROUNDING_MODE => named argument, you must specify both EXPR => and SCALE => as preceding named arguments. Note If you specify either value for the rounding_mode argument, the data type of input_expr must be one of the data types for a fixed-point number . Data types for floating point numbers (e.g. FLOAT) are not supported\nwith this argument."
        }
    ],
    "returns": "The return type is based on the input type:"
},
{
    "function_name": "[ NOT ] RLIKE",
    "summary": "Performs a comparison to determine whether a string matches or does not match a specified pattern.",
    "category": "String functions (regular expressions)",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/rlike",
    "title": "[ NOT ] RLIKE",
    "description": "Performs a comparison to determine whether a string matches or does not match a specified pattern. Both inputs must be text expressions.",
    "syntax": "-- 1st syntax\nRLIKE( <subject> , <pattern> [ , <parameters> ] )\n\n-- 2nd syntax\n<subject> [ NOT ] RLIKE <pattern>",
    "example": "CREATE OR REPLACE TABLE rlike_ex(city VARCHAR(20));\nINSERT INTO rlike_ex VALUES ('Sacramento'), ('San Francisco'), ('San Jose'), (null);\n\nSELECT * FROM rlike_ex WHERE RLIKE(city, 'san.*', 'i');\n\n+---------------+\n| CITY          |\n|---------------|\n| San Francisco |\n| San Jose      |\n+---------------+\n\nSELECT * FROM rlike_ex WHERE NOT RLIKE(city, 'san.*', 'i');\n\n+------------+\n| CITY       |\n|------------|\n| Sacramento |\n+------------+\n\nSELECT RLIKE('800-456-7891',\n             $$[2-9]\\d{2}-\\d{3}-\\d{4}$$) AS matches_phone_number;\n\n+----------------------+\n| MATCHES_PHONE_NUMBER |\n|----------------------|\n| True                 |\n+----------------------+\n\nSELECT RLIKE('jsmith@email.com',\n             $$\\w+@[a-zA-Z_]+?\\.[a-zA-Z]{2,3}$$) AS matches_email_address;\n\n+-----------------------+\n| MATCHES_EMAIL_ADDRESS |\n|-----------------------|\n| True                  |\n+-----------------------+\n\nSELECT RLIKE('800-456-7891',\n             '[2-9]\\\\d{2}-\\\\d{3}-\\\\d{4}') AS matches_phone_number;\n\n+----------------------+\n| MATCHES_PHONE_NUMBER |\n|----------------------|\n| True                 |\n+----------------------+\n\nSELECT RLIKE('jsmith@email.com',\n             '\\\\w+@[a-zA-Z_]+?\\\\.[a-zA-Z]{2,3}') AS matches_email_address;\n\n+-----------------------+\n| MATCHES_EMAIL_ADDRESS |\n|-----------------------|\n| True                  |\n+-----------------------+\n\nSELECT RLIKE('800-456-7891',\n             '[2-9][0-9]{2}-[0-9]{3}-[0-9]{4}') AS matches_phone_number;\n\n+----------------------+\n| MATCHES_PHONE_NUMBER |\n|----------------------|\n| True                 |\n+----------------------+\n\nSELECT RLIKE('jsmith@email.com',\n             '[a-zA-Z_]+@[a-zA-Z_]+?\\\\.[a-zA-Z]{2,3}') AS matches_email_address;\n\n+-----------------------+\n| MATCHES_EMAIL_ADDRESS |\n|-----------------------|\n| True                  |\n+-----------------------+\n\nSELECT * FROM rlike_ex WHERE city RLIKE 'San.* [fF].*';\n\n+---------------+\n| CITY          |\n|---------------|\n| San Francisco |\n+---------------+",
    "arguments": [
        {
            "name": "subject",
            "description": "The string to search for matches."
        },
        {
            "name": "pattern",
            "description": "Pattern to match. For guidelines on specifying patterns, see String functions (regular expressions) ."
        },
        {
            "name": "parameters",
            "description": "String of one or more characters that specifies the parameters used for searching for matches. Supported values: Parameter Description c Case-sensitive matching i Case-insensitive matching m Multi-line mode e Extract submatches s POSIX wildcard character . matches \\n Default: c For more details, see Specifying the parameters for the regular expression ."
        }
    ],
    "returns": "Returns a BOOLEAN or NULL."
},
{
    "function_name": "RIGHT",
    "summary": "Returns a rightmost substring of its input.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/right",
    "title": "RIGHT",
    "description": "Returns a rightmost substring of its input.",
    "syntax": "RIGHT( <string_expr> , <length_expr> )",
    "example": "SELECT RIGHT('ABCDEFG', 3);\n\n+---------------------+\n| RIGHT('ABCDEFG', 3) |\n|---------------------|\n| EFG                 |\n+---------------------+\n\nCREATE OR REPLACE TABLE customer_contact_example (\n    cust_id INT,\n    cust_email VARCHAR,\n    cust_phone VARCHAR,\n    activation_date VARCHAR)\n  AS SELECT\n    column1,\n    column2,\n    column3,\n    column4\n  FROM\n    VALUES\n      (1, 'some_text@example.com', '800-555-0100', '20210320'),\n      (2, 'some_other_text@example.org', '800-555-0101', '20240509'),\n      (3, 'some_different_text@example.net', '800-555-0102', '20191017');\n\nSELECT * from customer_contact_example;\n\n+---------+---------------------------------+--------------+-----------------+\n| CUST_ID | CUST_EMAIL                      | CUST_PHONE   | ACTIVATION_DATE |\n|---------+---------------------------------+--------------+-----------------|\n|       1 | some_text@example.com           | 800-555-0100 | 20210320        |\n|       2 | some_other_text@example.org     | 800-555-0101 | 20240509        |\n|       3 | some_different_text@example.net | 800-555-0102 | 20191017        |\n+---------+---------------------------------+--------------+-----------------+\n\nSELECT cust_id,\n       cust_email,\n       RIGHT(cust_email, LENGTH(cust_email) - (POSITION('@' IN cust_email))) AS domain\n  FROM customer_contact_example;\n\n+---------+---------------------------------+-------------+\n| CUST_ID | CUST_EMAIL                      | DOMAIN      |\n|---------+---------------------------------+-------------|\n|       1 | some_text@example.com           | example.com |\n|       2 | some_other_text@example.org     | example.org |\n|       3 | some_different_text@example.net | example.net |\n+---------+---------------------------------+-------------+\n\nSELECT cust_id,\n       cust_phone,\n       RIGHT(cust_phone, 8) AS phone_without_area_code\n  FROM customer_contact_example;\n\n+---------+--------------+-------------------------+\n| CUST_ID | CUST_PHONE   | PHONE_WITHOUT_AREA_CODE |\n|---------+--------------+-------------------------|\n|       1 | 800-555-0100 | 555-0100                |\n|       2 | 800-555-0101 | 555-0101                |\n|       3 | 800-555-0102 | 555-0102                |\n+---------+--------------+-------------------------+\n\nSELECT cust_id,\n       activation_date,\n       RIGHT(activation_date, 2) AS day\n  FROM customer_contact_example;\n\n+---------+-----------------+-----+\n| CUST_ID | ACTIVATION_DATE | DAY |\n|---------+-----------------+-----|\n|       1 | 20210320        | 20  |\n|       2 | 20240509        | 09  |\n|       3 | 20191017        | 17  |\n+---------+-----------------+-----+",
    "arguments": [
        {
            "name": "string_expr",
            "description": "An expression that evaluates to a VARCHAR or BINARY value."
        },
        {
            "name": "length_expr",
            "description": "An expression that evaluates to an integer. It specifies: The number of UTF-8 characters to return if the input is a VARCHAR value. The number of bytes to return if the input is a BINARY value. Specify a length that is greater than or equal to zero. If the length is a negative number, the function returns an\nempty string."
        }
    ],
    "returns": "The data type of the returned value is the same as the data type of the string_expr (VARCHAR or BINARY)."
},
{
    "function_name": "REVERSE",
    "summary": "Reverses the order of characters in a string, or of bytes in a binary value.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/reverse",
    "title": "REVERSE",
    "description": "Reverses the order of characters in a string, or of bytes in a binary value.",
    "syntax": "REVERSE(<subject>)",
    "example": "SELECT REVERSE('Hello, world!');\n+--------------------------+\n| REVERSE('HELLO, WORLD!') |\n|--------------------------|\n| !dlrow ,olleH            |\n+--------------------------+\n\nSELECT '2019-05-22'::DATE, REVERSE('2019-05-22'::DATE) AS reversed;\n+--------------------+------------+\n| '2019-05-22'::DATE | REVERSED   |\n|--------------------+------------|\n| 2019-05-22         | 22-50-9102 |\n+--------------------+------------+\n\nCREATE TABLE strings (s1 VARCHAR COLLATE 'en', s2 VARCHAR COLLATE 'hu');\nINSERT INTO strings (s1, s2) VALUES ('dzsa', COLLATE('dzsa', 'hu'));\n\nSELECT s1, s2, REVERSE(s1), REVERSE(s2) \n    FROM strings;\n+------+------+-------------+-------------+\n| S1   | S2   | REVERSE(S1) | REVERSE(S2) |\n|------+------+-------------+-------------|\n| dzsa | dzsa | aszd        | aszd        |\n+------+------+-------------+-------------+"
},
{
    "function_name": "RESULT_SCAN",
    "summary": "Returns the result set of a previous command (within 24 hours of when you ran the query) as if the result was a table.",
    "category": "Table functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/result_scan",
    "title": "RESULT_SCAN",
    "description": "Returns the result set of a previous command (within 24 hours of when you ran the query) as if the result was a table.\nThis function is particularly useful if you want to process the output from any of the following operations:",
    "syntax": "RESULT_SCAN ( { '<query_id>' | <query_index>  | LAST_QUERY_ID() } )",
    "example": "SELECT $1 AS value FROM VALUES (1), (2), (3);\n\n+-------+\n| VALUE |\n|-------|\n|     1 |\n|     2 |\n|     3 |\n+-------+\n\nSELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID())) WHERE value > 1;\n\n+-------+\n| VALUE |\n|-------|\n|     2 |\n|     3 |\n+-------+\n\nSELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID(-2)));\n\nSELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID(1)));\n\nSELECT c2 FROM TABLE(RESULT_SCAN('ce6687a4-331b-4a57-a061-02b2b0f0c17c'));\n\nDESC USER jessicajones;\nSELECT \"property\", \"value\" FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()))\n  WHERE \"property\" = 'DEFAULT_ROLE';\n\nSHOW TABLES;\nSELECT \"database_name\", \"schema_name\", \"name\" as \"table_name\", \"rows\", \"created_on\"\n  FROM table(RESULT_SCAN(LAST_QUERY_ID()))\n  WHERE \"rows\" = 0 AND \"created_on\" < DATEADD(day, -21, CURRENT_TIMESTAMP())\n  ORDER BY \"created_on\";\n\n-- Show byte counts with suffixes such as \"KB\", \"MB\", and \"GB\".\nCREATE OR REPLACE FUNCTION NiceBytes(NUMBER_OF_BYTES INTEGER)\nRETURNS VARCHAR\nAS\n$$\nCASE\n  WHEN NUMBER_OF_BYTES < 1024\n    THEN NUMBER_OF_BYTES::VARCHAR\n  WHEN NUMBER_OF_BYTES >= 1024 AND NUMBER_OF_BYTES < 1048576\n    THEN (NUMBER_OF_BYTES / 1024)::VARCHAR || 'KB'\n  WHEN NUMBER_OF_BYTES >= 1048576 AND NUMBER_OF_BYTES < (POW(2, 30))\n    THEN (NUMBER_OF_BYTES / 1048576)::VARCHAR || 'MB'\n  ELSE\n    (NUMBER_OF_BYTES / POW(2, 30))::VARCHAR || 'GB'\nEND\n$$\n;\nSHOW TABLES;\n-- Show all of my tables in descending order of size.\nSELECT \"database_name\", \"schema_name\", \"name\" as \"table_name\", NiceBytes(\"bytes\") AS \"size\"\n  FROM table(RESULT_SCAN(LAST_QUERY_ID()))\n  ORDER BY \"bytes\" DESC;\n\nCREATE OR REPLACE PROCEDURE return_json()\n  RETURNS VARCHAR\n  LANGUAGE JavaScript\n  AS\n  $$\n    return '{\"keyA\": \"ValueA\", \"keyB\": \"ValueB\"}';\n  $$\n  ;\n\nCALL return_json();\n\n+--------------------------------------+\n| RETURN_JSON                          |\n|--------------------------------------|\n| {\"keyA\": \"ValueA\", \"keyB\": \"ValueB\"} |\n+--------------------------------------+\n\nSELECT $1 AS output_col FROM table(RESULT_SCAN(LAST_QUERY_ID()));\n\n+--------------------------------------+\n| OUTPUT_COL                           |\n|--------------------------------------|\n| {\"keyA\": \"ValueA\", \"keyB\": \"ValueB\"} |\n+--------------------------------------+\n\nSELECT PARSE_JSON(output_col) AS json_col FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));\n\n+---------------------+\n| JSON_COL            |\n|---------------------|\n| {                   |\n|   \"keyA\": \"ValueA\", |\n|   \"keyB\": \"ValueB\"  |\n| }                   |\n+---------------------+\n\nSELECT json_col:keyB FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));\n\n+---------------+\n| JSON_COL:KEYB |\n|---------------|\n| \"ValueB\"      |\n+---------------+\n\nCALL return_json();\n\n+--------------------------------------+\n| RETURN_JSON                          |\n|--------------------------------------|\n| {\"keyA\": \"ValueA\", \"keyB\": \"ValueB\"} |\n+--------------------------------------+\n\nSELECT JSON_COL:keyB\n FROM (\n      SELECT PARSE_JSON($1::VARIANT) AS json_col\n        FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()))\n      );\n\n+---------------+\n| JSON_COL:KEYB |\n|---------------|\n| \"ValueB\"      |\n+---------------+\n\nCALL return_json();\n\n+--------------------------------------+\n| RETURN_JSON                          |\n|--------------------------------------|\n| {\"keyA\": \"ValueA\", \"keyB\": \"ValueB\"} |\n+--------------------------------------+\n\nSELECT json_col:keyB\n  FROM (\n       SELECT PARSE_JSON(RETURN_JSON::VARIANT) AS json_col\n         FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()))\n       );\n\n+---------------+\n| JSON_COL:KEYB |\n|---------------|\n| \"ValueB\"      |\n+---------------+\n\nCREATE TABLE employees (id INT);\n\nCREATE TABLE dependents (id INT, employee_id INT);\n\nINSERT INTO employees (id) VALUES (11);\n\nINSERT INTO dependents (id, employee_id) VALUES (101, 11);\n\nSELECT *\n  FROM employees INNER JOIN dependents\n    ON dependents.employee_ID = employees.id\n  ORDER BY employees.id, dependents.id;\n\n+----+-----+-------------+\n| ID |  ID | EMPLOYEE_ID |\n|----+-----+-------------|\n| 11 | 101 |          11 |\n+----+-----+-------------+\n\nSELECT id, id_1, employee_id\n  FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()))\n  WHERE id_1 = 101;\n\n+----+------+-------------+\n| ID | ID_1 | EMPLOYEE_ID |\n|----+------+-------------|\n| 11 |  101 |          11 |\n+----+------+-------------+",
    "arguments": [
        {
            "name": "'",
            "description": "A specification of a query that you ran within the last 24 hours in any session, an integer index of a query in the\ncurrent session, or the LAST_QUERY_ID function, which returns the ID of a query within your current session. Snowflake query IDs are unique strings that resemble 01b71944-0001-b181-0000-0129032279f6 . Query indexes are relative to the first query in the current session (if positive) or to the most recent query (if\nnegative). For example, RESULT_SCAN(-1) is equivalent to RESULT_SCAN(LAST_QUERY_ID()) ."
        }
    ]
},
{
    "function_name": "REST_EVENT_HISTORY",
    "summary": "Returns a list of SCIM REST API requests made to Snowflake over a specified time interval.",
    "category": "Table functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/rest_event_history",
    "title": "REST_EVENT_HISTORY",
    "description": "Returns a list of SCIM REST API requests made to Snowflake over a specified time interval.",
    "syntax": "REST_EVENT_HISTORY(\n      REST_SERVICE_TYPE => 'scim'\n      [, TIME_RANGE_START => <constant_expr> ]\n      [, TIME_RANGE_END => <constant_expr> ]\n      [, RESULT_LIMIT => <integer> ] )",
    "example": "use role accountadmin;\nuse database my_db;\nuse schema information_schema;\nselect *\n  from table(rest_event_history(\n      rest_service_type => 'scim',\n      time_range_start => dateadd('minutes',-5,current_timestamp()),\n      time_range_end => current_timestamp(),\n      200))\n  order by event_timestamp;",
    "arguments": [
        {
            "name": "REST_SERVICE_TYPE",
            "description": "The type of REST API service. Currently, Snowflake only supports SCIM ."
        },
        {
            "name": "TIME_RANGE_START",
            "description": "Time range (in TIMESTAMP_LTZ format), within the last 7 days, in which the login event occurred. If TIME_RANGE_START is not specified, all logs from the last seven days are returned. If TIME_RANGE_END is not specified, all logs are returned. If the time range does not fall within the last 7 days, an error is returned. For more information on functions that you can use, see Date & time functions ."
        },
        {
            "name": "RESULT_LIMIT",
            "description": "A number specifying the maximum number of rows returned by the function. If the number of matching rows is greater than this limit, the queries with the most recent end time (or those that are still executing) are returned, up to the specified limit. Range: 1 to 10000 Default: 100 ."
        }
    ]
},
{
    "function_name": "REPLICATION_USAGE_HISTORY",
    "summary": "This table function can be used to query the replication history for a specified database within a specified date range.",
    "category": "Information Schema , Table functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/replication_usage_history",
    "title": "REPLICATION_USAGE_HISTORY",
    "syntax": "REPLICATION_USAGE_HISTORY(\n  [ DATE_RANGE_START => <constant_expr> ]\n  [ , DATE_RANGE_END => <constant_expr> ]\n  [ , DATABASE_NAME => '<string>' ] )",
    "example": "select *\n  from table(information_schema.replication_usage_history(\n    date_range_start=>'2019-02-10 12:00:00.000 +0000',\n    date_range_end=>'2019-02-10 12:30:00.000 +0000'));\n\nselect *\n  from table(information_schema.replication_usage_history(\n    date_range_start=>dateadd(H, -12, current_timestamp)));\n\nselect *\n  from table(information_schema.replication_usage_history(\n    date_range_start=>dateadd(d, -7, current_date),\n    date_range_end=>current_date));\n\nselect *\n  from table(information_schema.replication_usage_history(\n    date_range_start=>dateadd(d, -7, current_date),\n    date_range_end=>current_date,\n    database_name=>'mydb'));",
    "arguments": [
        {
            "name": "DATE_RANGE_START",
            "description": "The date/time range to display the database replication history: If an end date is not specified, then CURRENT_DATE is used as the end of the range. If a start date is not specified, then the range starts 10 minutes prior to the start of DATE_RANGE_END (i.e. the default is to show the previous 10 minutes of history). For example, if DATE_RANGE_END is CURRENT_DATE, then the default DATE_RANGE_START is 11:50 PM on the previous day."
        },
        {
            "name": "DATABASE_NAME",
            "description": "Database name. If specified, only shows the history for the specified database. If a name is not specified, then the results include the data for each database replicated within the specified time range."
        }
    ]
},
{
    "function_name": "REPLICATION_GROUP_USAGE_HISTORY",
    "summary": "Returns the replication usage history for secondary replication or failover groups within the last 14 days.",
    "category": "Information Schema , Table functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/replication_group_usage_history",
    "title": "REPLICATION_GROUP_USAGE_HISTORY",
    "syntax": "REPLICATION_GROUP_USAGE_HISTORY(\n   [ DATE_RANGE_START => <constant_expr> ]\n   [, DATE_RANGE_END => <constant_expr> ]\n   [, REPLICATION_GROUP_NAME => '<string>' ] )",
    "example": "SELECT START_TIME, END_TIME, REPLICATION_GROUP_NAME, CREDITS_USED, BYTES_TRANSFERRED\n  FROM TABLE(information_schema.replication_group_usage_history(date_range_start=>dateadd('day', -7, current_date())));\n\nSELECT START_TIME, END_TIME, REPLICATION_GROUP_NAME, CREDITS_USED, BYTES_TRANSFERRED\n  FROM TABLE(information_schema.replication_group_usage_history(\n    date_range_start => dateadd('day', -7, current_date()),\n    replication_group_name => 'myrg'\n));",
    "arguments": [
        {
            "name": "DATE_RANGE_START",
            "description": "The date/time range, within the last 2 weeks, for which to retrieve the data load history: If an end date is not specified, then CURRENT_TIMESTAMP is used as the end of the range. If a start date is not specified, then the range starts 12 hours prior to the DATE_RANGE_END"
        },
        {
            "name": "REPLICATION_GROUP_NAME",
            "description": "A string specifying a replication or failover group. Only replication operations for the specified group are returned."
        }
    ]
},
{
    "function_name": "REPLICATION_GROUP_REFRESH_PROGRESS, REPLICATION_GROUP_REFRESH_PROGRESS_BY_JOB, REPLICATION_GROUP_REFRESH_PROGRESS_ALL",
    "summary": "You can use the REPLICATION_GROUP_REFRESH_PROGRESS family of table functions to query the status of refresh operations for replication or failover groups.",
    "category": "Information Schema , Table functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/replication_group_refresh_progress",
    "title": "REPLICATION_GROUP_REFRESH_PROGRESS, REPLICATION_GROUP_REFRESH_PROGRESS_BY_JOB, REPLICATION_GROUP_REFRESH_PROGRESS_ALL",
    "syntax": "REPLICATION_GROUP_REFRESH_PROGRESS( '<secondary_group_name>' )\n\nREPLICATION_GROUP_REFRESH_PROGRESS_BY_JOB( '<query_id>' )\n\nREPLICATION_GROUP_REFRESH_PROGRESS_ALL()",
    "example": "SELECT phase_name, start_time, end_time, progress, details\n  FROM TABLE(INFORMATION_SCHEMA.REPLICATION_GROUP_REFRESH_PROGRESS('rg1'));\n\nSELECT phase_name, start_time, end_time, progress, details\n  FROM TABLE(\n    INFORMATION_SCHEMA.REPLICATION_GROUP_REFRESH_PROGRESS_BY_JOB(\n      '012a3b45-1234-a12b-0000-1aa200012345'));\n\nSELECT phase_name, start_time, end_time, progress, details\n  FROM TABLE(INFORMATION_SCHEMA.REPLICATION_GROUP_REFRESH_PROGRESS_ALL());",
    "arguments": [
        {
            "name": "'",
            "description": "Name of the secondary replication or failover group. Note that the entire name must be enclosed in single quotes."
        },
        {
            "name": "'",
            "description": "ID of the replication group refresh query. The query ID can be obtained from the History page in the web\ninterface."
        }
    ]
},
{
    "function_name": "REPLICATION_GROUP_REFRESH_HISTORY, REPLICATION_GROUP_REFRESH_HISTORY_ALL",
    "summary": "You can use the REPLICATION_GROUP_REFRESH_HISTORY family of table functions to query the replication history for one secondary replication or failover group, or all such groups, within the last 14 days.",
    "category": "Information Schema , Table functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/replication_group_refresh_history",
    "title": "REPLICATION_GROUP_REFRESH_HISTORY, REPLICATION_GROUP_REFRESH_HISTORY_ALL",
    "syntax": "REPLICATION_GROUP_REFRESH_HISTORY( '<secondary_group_name>' )\n\nREPLICATION_GROUP_REFRESH_HISTORY_ALL()",
    "example": "SELECT phase_name, start_time, end_time,\n       total_bytes, object_count, error\n  FROM TABLE(\n      INFORMATION_SCHEMA.REPLICATION_GROUP_REFRESH_HISTORY('myfg')\n  );\n\nSELECT phase_name, start_time, end_time,\n       total_bytes, object_count, error\n  FROM TABLE(\n      INFORMATION_SCHEMA.REPLICATION_GROUP_REFRESH_HISTORY_ALL()\n  );",
    "arguments": [
        {
            "name": "'",
            "description": "Name of the secondary group. The entire name must be enclosed in single quotes."
        }
    ]
},
{
    "function_name": "REPLACE",
    "summary": "Removes all occurrences of a specified substring, and optionally replaces them with another substring.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/replace",
    "title": "REPLACE",
    "description": "Removes all occurrences of a specified substring, and optionally replaces them with another substring.",
    "syntax": "REPLACE( <subject> , <pattern> [ , <replacement> ] )",
    "example": "SELECT REPLACE('down', 'down', 'up');\n\n+-------------------------------+\n| REPLACE('DOWN', 'DOWN', 'UP') |\n|-------------------------------|\n| up                            |\n+-------------------------------+\n\nSELECT REPLACE('Vacation in Athens', 'Athens', 'Rome');\n\n+-------------------------------------------------+\n| REPLACE('VACATION IN ATHENS', 'ATHENS', 'ROME') |\n|-------------------------------------------------|\n| Vacation in Rome                                |\n+-------------------------------------------------+\n\nSELECT REPLACE('abcd', 'bc');\n\n+-----------------------+\n| REPLACE('ABCD', 'BC') |\n|-----------------------|\n| ad                    |\n+-----------------------+\n\nCREATE OR REPLACE TABLE replace_example(\n  subject VARCHAR(10),\n  pattern VARCHAR(10),\n  replacement VARCHAR(10));\n\nINSERT INTO replace_example VALUES\n  ('old car', 'old car', 'new car'),\n  ('sad face', 'sad', 'happy'),\n  ('snowman', 'snow', 'fire');\n\nSELECT subject,\n       pattern,\n       replacement,\n       REPLACE(subject, pattern, replacement) AS new\n  FROM replace_example\n  ORDER BY subject;\n\n+----------+---------+-------------+------------+\n| SUBJECT  | PATTERN | REPLACEMENT | NEW        |\n|----------+---------+-------------+------------|\n| old car  | old car | new car     | new car    |\n| sad face | sad     | happy       | happy face |\n| snowman  | snow    | fire        | fireman    |\n+----------+---------+-------------+------------+",
    "arguments": [
        {
            "name": "subject",
            "description": "The subject is the string in which to do the replacements. Typically,\nthis is a column, but it can be a literal."
        },
        {
            "name": "pattern",
            "description": "This is the substring that you want to replace. Typically, this is a literal,\nbut it can be a column or expression. Note that this is not a “regular\nexpression”; if you want to use regular expressions to search for a\npattern, use the REGEXP_REPLACE function."
        },
        {
            "name": "replacement",
            "description": "This is the value used as a replacement for the pattern . If this\nis omitted, or is an empty string, then the REPLACE function simply\ndeletes all occurrences of the pattern ."
        }
    ],
    "returns": "The returned value is the string after all replacements have been done."
},
{
    "function_name": "REPEAT",
    "summary": "Builds a string by repeating the input for the specified number of times.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/repeat",
    "title": "REPEAT",
    "description": "Builds a string by repeating the input for the specified number of\ntimes.",
    "syntax": "REPEAT(<input>, <n>)",
    "example": "SELECT REPEAT('xy', 5);\n\n-----------------+\n REPEAT('XY', 5) |\n-----------------+\n xyxyxyxyxy      |\n-----------------+",
    "arguments": [
        {
            "name": "input",
            "description": "The input string from which the output string is built."
        },
        {
            "name": "n",
            "description": "The number of times the input string should be repeated. The minimum\nvalid number is 0 (which results in an empty string)."
        }
    ]
},
{
    "function_name": "REGR_VALY",
    "summary": "Returns NULL if the second argument is NULL; otherwise, returns the first argument.",
    "category": "Conditional expression functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/regr_valy",
    "title": "REGR_VALY",
    "description": "Returns NULL if the second argument is NULL; otherwise, returns the first argument.",
    "syntax": "REGR_VALY( <y> , <x> )",
    "example": "SELECT REGR_VALY(NULL, 10), REGR_VALY(1, NULL), REGR_VALY(1, 10);\n+---------------------+--------------------+------------------+\n| REGR_VALY(NULL, 10) | REGR_VALY(1, NULL) | REGR_VALY(1, 10) |\n|---------------------+--------------------+------------------|\n|                NULL |               NULL |                1 |\n+---------------------+--------------------+------------------+\n\nCREATE TABLE xy (col_x DOUBLE, col_y DOUBLE);\nINSERT INTO xy (col_x, col_y) VALUES\n    (1.0, 2.0),\n    (3.0, NULL),\n    (NULL, 6.0);\n\nSELECT col_y, col_x, REGR_VALX(col_y, col_x), REGR_VALY(col_y, col_x)\n    FROM xy;\n+-------+-------+-------------------------+-------------------------+\n| COL_Y | COL_X | REGR_VALX(COL_Y, COL_X) | REGR_VALY(COL_Y, COL_X) |\n|-------+-------+-------------------------+-------------------------|\n|     2 |     1 |                       1 |                       2 |\n|  NULL |     3 |                    NULL |                    NULL |\n|     6 |  NULL |                    NULL |                    NULL |\n+-------+-------+-------------------------+-------------------------+",
    "arguments": [
        {
            "name": "y",
            "description": "An expression that evaluates to type DOUBLE or that can be cast to DOUBLE ."
        },
        {
            "name": "x",
            "description": "An expression that evaluates to type DOUBLE or that can be cast to DOUBLE ."
        }
    ],
    "returns": "Returns a value of type DOUBLE."
},
{
    "function_name": "REGR_VALX",
    "summary": "Returns NULL if the first argument is NULL; otherwise, returns the second argument.",
    "category": "Conditional expression functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/regr_valx",
    "title": "REGR_VALX",
    "description": "Returns NULL if the first argument is NULL; otherwise, returns the second argument.",
    "syntax": "REGR_VALX( <y> , <x> )",
    "example": "SELECT REGR_VALX(NULL, 10), REGR_VALX(1, NULL), REGR_VALX(1, 10);\n+---------------------+--------------------+------------------+\n| REGR_VALX(NULL, 10) | REGR_VALX(1, NULL) | REGR_VALX(1, 10) |\n|---------------------+--------------------+------------------|\n|                NULL |               NULL |               10 |\n+---------------------+--------------------+------------------+\n\nCREATE TABLE xy (col_x DOUBLE, col_y DOUBLE);\nINSERT INTO xy (col_x, col_y) VALUES\n    (1.0, 2.0),\n    (3.0, NULL),\n    (NULL, 6.0);\n\nSELECT col_y, col_x, REGR_VALX(col_y, col_x), REGR_VALY(col_y, col_x)\n    FROM xy;\n+-------+-------+-------------------------+-------------------------+\n| COL_Y | COL_X | REGR_VALX(COL_Y, COL_X) | REGR_VALY(COL_Y, COL_X) |\n|-------+-------+-------------------------+-------------------------|\n|     2 |     1 |                       1 |                       2 |\n|  NULL |     3 |                    NULL |                    NULL |\n|     6 |  NULL |                    NULL |                    NULL |\n+-------+-------+-------------------------+-------------------------+",
    "arguments": [
        {
            "name": "y",
            "description": "An expression that evaluates to type DOUBLE or that can be cast to DOUBLE ."
        },
        {
            "name": "x",
            "description": "An expression that evaluates to type DOUBLE or that can be cast to DOUBLE ."
        }
    ],
    "returns": "Returns a value of type DOUBLE."
},
{
    "function_name": "REGR_SYY",
    "summary": "Returns REGR_COUNT(y, x) * VAR_POP(y) for non-null pairs.",
    "category": "Aggregate functions , Window function syntax and usage",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/regr_syy",
    "title": "REGR_SYY",
    "description": "Returns REGR_COUNT(y, x) * VAR_POP(y) for non-null pairs.",
    "syntax": "REGR_SYY(y, x)",
    "example": "CREATE OR REPLACE TABLEE aggr(k INT, v DECIMAL(10,2), v2 DECIMAL(10, 2));\nINSERT INTO aggr VALUES(1, 10, null);\nINSERT INTO aggr VALUES(2, 10, 11), (2, 20, 22), (2, 25, null), (2, 30, 35);\n\nSELECT k, REGR_SYY(v, v2) FROM aggr GROUP BY k;\n\n+---+-----------------+\n| k | regr_syy(v, v2) |\n|---+-----------------|\n| 1 | [NULL]          |\n| 2 | 200             |\n+---+-----------------+",
    "arguments": [
        {
            "name": "y",
            "description": "The dependent variable. This must be an expression that can be evaluated to a numeric type."
        },
        {
            "name": "x",
            "description": "The independent variable. This must be an expression that can be evaluated to a numeric type."
        },
        {
            "name": "expr3",
            "description": "This is the optional expression used to group rows into partitions."
        }
    ]
},
{
    "function_name": "REGR_SXY",
    "summary": "Returns REGR_COUNT(expr1, expr2) * COVAR_POP(expr1, expr2) for non-null pairs.",
    "category": "Aggregate functions , Window function syntax and usage",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/regr_sxy",
    "title": "REGR_SXY",
    "description": "Returns REGR_COUNT(expr1, expr2) * COVAR_POP(expr1, expr2) for non-null\npairs.",
    "syntax": "REGR_SXY(y, x)",
    "example": "CREATE OR REPLACE TABLE aggr(k INT, v DECIMAL(10,2), v2 DECIMAL(10, 2));\nINSERT INTO aggr VALUES(1, 10, null);\nINSERT INTO aggr VALUES(2, 10, 11), (2, 20, 22), (2, 25, null), (2, 30, 35);\n\nSELECT k, REGR_SXY(v, v2) FROM aggr GROUP BY k;\n\n+---+-----------------+\n| k | regr_sxy(v, v2) |\n+---+-----------------+\n| 1 | [NULL]          |\n| 2 | 240             |\n+---+-----------------+",
    "arguments": [
        {
            "name": "y",
            "description": "The dependent variable. This must be an expression that can be evaluated to a numeric type."
        },
        {
            "name": "x",
            "description": "The independent variable. This must be an expression that can be evaluated to a numeric type."
        },
        {
            "name": "expr3",
            "description": "This is the optional expression used to group rows into partitions."
        }
    ]
},
{
    "function_name": "REGR_SXX",
    "summary": "Returns REGR_COUNT(y, x) * VAR_POP(x) for non-null pairs.",
    "category": "Aggregate functions , Window function syntax and usage",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/regr_sxx",
    "title": "REGR_SXX",
    "description": "Returns REGR_COUNT(y, x) * VAR_POP(x) for non-null pairs.",
    "syntax": "REGR_SXX(y, x)",
    "example": "CREATE OR REPLACE TABLE aggr(k INT, v DECIMAL(10,2), v2 DECIMAL(10, 2));\nINSERT INTO aggr VALUES(1, 10, null);\nINSERT INTO aggr VALUES(2, 10, 11), (2, 20, 22), (2, 25, null), (2, 30, 35);\n\nSELECT k, REGR_SXX(v, v2) FROM aggr GROUP BY k;\n\n+---+-----------------+\n| k | regr_sxx(v, v2) |\n|---+-----------------|\n| 1 | [NULL]          |\n| 2 | 288.666666667   |\n+---+-----------------+",
    "arguments": [
        {
            "name": "y",
            "description": "The dependent variable. This must be an expression that can be evaluated to a numeric type."
        },
        {
            "name": "x",
            "description": "The independent variable. This must be an expression that can be evaluated to a numeric type."
        },
        {
            "name": "expr3",
            "description": "This is the optional expression used to group rows into partitions."
        }
    ]
},
{
    "function_name": "REGR_SLOPE",
    "summary": "Returns the slope of the linear regression line for non-null pairs in a group.",
    "category": "Aggregate functions , Window function syntax and usage",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/regr_slope",
    "title": "REGR_SLOPE",
    "description": "Returns the slope of the linear regression line for non-null pairs in a group. It is computed for non-null pairs using the following formula:",
    "syntax": "REGR_SLOPE(y, x)",
    "example": "CREATE OR REPLACE TABLE aggr(k INT, v DECIMAL(10,2), v2 DECIMAL(10, 2));\nINSERT INTO aggr VALUES(1, 10, null);\nINSERT INTO aggr VALUES(2, 10, 11), (2, 20, 22), (2, 25, null), (2, 30, 35);\n\nSELECT k, REGR_SLOPE(v, v2) FROM aggr GROUP BY k;\n\n+---+-------------------+\n| k | regr_slope(v, v2) |\n|---+-------------------|\n| 1 | [NULL]            |\n| 2 | 0.831408776       |\n+---+-------------------+",
    "arguments": [
        {
            "name": "y",
            "description": "The dependent variable. This must be an expression that can be evaluated to a numeric type."
        },
        {
            "name": "x",
            "description": "The independent variable. This must be an expression that can be evaluated to a numeric type."
        },
        {
            "name": "expr3",
            "description": "This is the optional expression used to group rows into partitions."
        }
    ],
    "returns": "The data type of the returned value is FLOAT."
},
{
    "function_name": "REGR_R2",
    "summary": "Returns the coefficient of determination for non-null pairs in a group.",
    "category": "Aggregate functions , Window function syntax and usage",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/regr_r2",
    "title": "REGR_R2",
    "description": "Returns the coefficient of determination for non-null pairs in a group. It is computed for non-null pairs using the following formula:",
    "syntax": "REGR_R2(y, x)",
    "example": "CREATE OR REPLACE TABLE aggr(k INT, v DECIMAL(10,2), v2 DECIMAL(10, 2));\nINSERT INTO aggr VALUES(1, 10, null);\nINSERT INTO aggr VALUES(2, 10, 11), (2, 20, 22), (2, 25, null), (2, 30, 35);\n\nSELECT k, REGR_R2(v, v2) FROM aggr GROUP BY k;\n\n+---+----------------+\n| k | regr_r2(v, v2) |\n|---+----------------+\n| 1 | [NULL]         |\n| 2 | 0.9976905312   |\n+---+----------------+",
    "arguments": [
        {
            "name": "y",
            "description": "The dependent variable. This must be an expression that can be evaluated to a numeric type."
        },
        {
            "name": "x",
            "description": "The independent variable. This must be an expression that can be evaluated to a numeric type."
        },
        {
            "name": "expr3",
            "description": "This is the optional expression used to group rows into partitions."
        }
    ]
},
{
    "function_name": "REGR_INTERCEPT",
    "summary": "Returns the intercept of the univariate linear regression line for non-null pairs in a group.",
    "category": "Aggregate functions , Window function syntax and usage",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/regr_intercept",
    "title": "REGR_INTERCEPT",
    "description": "Returns the intercept of the univariate linear regression line for non-null pairs in a group. It is computed for non-null pairs using the following\nformula:",
    "syntax": "REGR_INTERCEPT(y, x)",
    "example": "CREATE OR REPLACE TABLE aggr(k INT, v DECIMAL(10,2), v2 DECIMAL(10, 2));\nINSERT INTO aggr VALUES(1, 10, null);\nINSERT INTO aggr VALUES(2, 10, 11), (2, 20, 22), (2, 25, null), (2, 30, 35);\n\nSELECT k, REGR_INTERCEPT(v, v2) FROM aggr GROUP BY k;\n\n+---+-----------------------+\n| k | regr_intercept(v, v2) |\n|---+-----------------------|\n| 1 | [NULL]                |\n| 2 | 1.154734411           |\n+---+-----------------------+",
    "arguments": [
        {
            "name": "y",
            "description": "The dependent variable. This must be an expression that can be evaluated to a numeric type."
        },
        {
            "name": "x",
            "description": "The independent variable. This must be an expression that can be evaluated to a numeric type."
        },
        {
            "name": "expr3",
            "description": "This is the optional expression used to group rows into partitions."
        }
    ]
},
{
    "function_name": "REGR_COUNT",
    "summary": "Returns the number of non-null number pairs in a group.",
    "category": "Aggregate functions , Window function syntax and usage",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/regr_count",
    "title": "REGR_COUNT",
    "description": "Returns the number of non-null number pairs in a group.",
    "syntax": "REGR_COUNT(y, x)",
    "example": "CREATE OR REPLACE TABLE aggr(k INT, v DECIMAL(10,2), v2 DECIMAL(10, 2));\nINSERT INTO aggr VALUES(1, 10, null);\nINSERT INTO aggr VALUES(2, 10, 11), (2, 20, 22), (2, 25, null), (2, 30, 35);\n\nSELECT k, COUNT(*), REGR_COUNT(v, v2) FROM aggr GROUP BY k;\n\n+---+----------+-------------------+\n| k | count(*) | regr_count(v, v2) |\n|---+----------+-------------------|\n| 1 |      1   |            0      |\n| 2 |      4   |            3      |\n+---+----------+-------------------+",
    "arguments": [
        {
            "name": "y",
            "description": "The dependent variable. This must be an expression that can be evaluated to a numeric type."
        },
        {
            "name": "x",
            "description": "The independent variable. This must be an expression that can be evaluated to a numeric type."
        },
        {
            "name": "expr3",
            "description": "This is the optional expression used to group rows into partitions."
        }
    ]
},
{
    "function_name": "REGR_AVGY",
    "summary": "Returns the average of the dependent variable for non-null pairs in a group, where x is the independent variable and y is the dependent variable.",
    "category": "Aggregate functions , Window functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/regr_avgy",
    "title": "REGR_AVGY",
    "description": "Returns the average of the dependent variable for non-null pairs in a group, where",
    "syntax": "REGR_AVGY(y, x)",
    "example": "create or replace table aggr(k int, v decimal(10,2), v2 decimal(10, 2));\ninsert into aggr values(1, 10, null);\ninsert into aggr values(2, 10, 11), (2, 20, 22), (2, 25,null), (2, 30, 35);\n\nselect k, regr_avgy(v, v2) from aggr group by k;\n\n---+------------------+\n k | regr_avgy(v, v2) |\n---+------------------+\n 1 | [NULL]           |\n 2 | 20               |\n---+------------------+",
    "arguments": [
        {
            "name": "y",
            "description": "The dependent variable. This must be an expression that can be evaluated to a numeric type."
        },
        {
            "name": "x",
            "description": "The independent variable. This must be an expression that can be evaluated to a numeric type."
        },
        {
            "name": "expr3",
            "description": "This is the optional expression used to group rows into partitions."
        }
    ]
},
{
    "function_name": "REGR_AVGX",
    "summary": "Returns the average of the independent variable for non-null pairs in a group, where x is the independent variable and y is the dependent variable.",
    "category": "Aggregate functions , Window functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/regr_avgx",
    "title": "REGR_AVGX",
    "description": "Returns the average of the independent variable for non-null pairs in a group, where",
    "syntax": "REGR_AVGX(y, x)",
    "example": "CREATE OR REPLACE TABLE aggr(k int, v decimal(10,2), v2 decimal(10, 2));\nINSERT INTO aggr VALUES(1, 10, NULL);\nINSERT INTO aggr VALUES(2, 10, 11), (2, 20, 22), (2, 25, NULL), (2, 30, 35);\n\nSELECT k, REGR_AVGX(v, v2) FROM aggr GROUP BY k;\n\n---+------------------+\n k | regr_avgx(v, v2) |\n---+------------------+\n 1 | [NULL]           |\n 2 | 22.666666667     |\n---+------------------+",
    "arguments": [
        {
            "name": "y",
            "description": "The dependent variable. This must be an expression that can be evaluated to a numeric type."
        },
        {
            "name": "x",
            "description": "The independent variable. This must be an expression that can be evaluated to a numeric type."
        },
        {
            "name": "expr3",
            "description": "This is the optional expression used to group rows into partitions."
        }
    ]
},
{
    "function_name": "REGEXP_SUBSTR_ALL",
    "summary": "Returns an ARRAY that contains all substrings that match a regular expression within a string.",
    "category": "String functions (regular expressions)",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/regexp_substr_all",
    "title": "REGEXP_SUBSTR_ALL",
    "description": "Returns an",
    "syntax": "REGEXP_SUBSTR_ALL( <subject> , <pattern> [ , <position> [ , <occurrence> [ , <regex_parameters> [ , <group_num> ] ] ] ] )",
    "example": "SELECT REGEXP_SUBSTR_ALL('a1_a2a3_a4A5a6', 'a[[:digit:]]') AS matches;\n\n+---------+\n| MATCHES |\n|---------|\n| [       |\n|   \"a1\", |\n|   \"a2\", |\n|   \"a3\", |\n|   \"a4\", |\n|   \"a6\"  |\n| ]       |\n+---------+\n\nSELECT REGEXP_SUBSTR_ALL('a1_a2a3_a4A5a6', 'a[[:digit:]]', 2) AS matches;\n\n+---------+\n| MATCHES |\n|---------|\n| [       |\n|   \"a2\", |\n|   \"a3\", |\n|   \"a4\", |\n|   \"a6\"  |\n| ]       |\n+---------+\n\nSELECT REGEXP_SUBSTR_ALL('a1_a2a3_a4A5a6', 'a[[:digit:]]', 1, 3) AS matches;\n\n+---------+\n| MATCHES |\n|---------|\n| [       |\n|   \"a3\", |\n|   \"a4\", |\n|   \"a6\"  |\n| ]       |\n+---------+\n\nSELECT REGEXP_SUBSTR_ALL('a1_a2a3_a4A5a6', 'a[[:digit:]]', 1, 1, 'i') AS matches;\n\n+---------+\n| MATCHES |\n|---------|\n| [       |\n|   \"a1\", |\n|   \"a2\", |\n|   \"a3\", |\n|   \"a4\", |\n|   \"A5\", |\n|   \"a6\"  |\n| ]       |\n+---------+\n\nSELECT REGEXP_SUBSTR_ALL('a1_a2a3_a4A5a6', '(a)([[:digit:]])', 1, 1, 'ie') AS matches;\n\n+---------+\n| MATCHES |\n|---------|\n| [       |\n|   \"a\",  |\n|   \"a\",  |\n|   \"a\",  |\n|   \"a\",  |\n|   \"A\",  |\n|   \"a\"   |\n| ]       |\n+---------+\n\nSELECT REGEXP_SUBSTR_ALL('a1_a2a3_a4A5a6', 'b') AS matches;\n\n+---------+\n| MATCHES |\n|---------|\n| []      |\n+---------+\n\nCREATE OR REPLACE TABLE test_regexp_substr_all (string1 VARCHAR);;\nINSERT INTO test_regexp_substr_all (string1) VALUES ('A MAN A PLAN A CANAL');\n\nSELECT REGEXP_SUBSTR_ALL(string1, 'A\\\\W+(\\\\w+)', 1, 1, 'e', 1) AS result1,\n       REGEXP_SUBSTR_ALL(string1, 'A\\\\W+(\\\\w+)', 1, 2, 'e', 1) AS result2,\n       REGEXP_SUBSTR_ALL(string1, 'A\\\\W+(\\\\w+)', 1, 3, 'e', 1) AS result3\n  FROM test_regexp_substr_all;\n\n+-----------+-----------+-----------+\n| RESULT1   | RESULT2   | RESULT3   |\n|-----------+-----------+-----------|\n| [         | [         | [         |\n|   \"MAN\",  |   \"PLAN\", |   \"CANAL\" |\n|   \"PLAN\", |   \"CANAL\" | ]         |\n|   \"CANAL\" | ]         |           |\n| ]         |           |           |\n+-----------+-----------+-----------+\n\nSELECT REGEXP_SUBSTR_ALL(string1, 'A\\\\W+(\\\\w)(\\\\w)(\\\\w)', 1, 1, 'e', 1) AS result1,\n       REGEXP_SUBSTR_ALL(string1, 'A\\\\W+(\\\\w)(\\\\w)(\\\\w)', 1, 1, 'e', 2) AS result2,\n       REGEXP_SUBSTR_ALL(string1, 'A\\\\W+(\\\\w)(\\\\w)(\\\\w)', 1, 1, 'e', 3) AS result3\n  FROM test_regexp_substr_all;\n\n+---------+---------+---------+\n| RESULT1 | RESULT2 | RESULT3 |\n|---------+---------+---------|\n| [       | [       | [       |\n|   \"M\",  |   \"A\",  |   \"N\",  |\n|   \"P\",  |   \"L\",  |   \"A\",  |\n|   \"C\"   |   \"A\"   |   \"N\"   |\n| ]       | ]       | ]       |\n+---------+---------+---------+",
    "arguments": [
        {
            "name": "subject",
            "description": "The string to search for matches."
        },
        {
            "name": "pattern",
            "description": "Pattern to match. For guidelines on specifying patterns, see String functions (regular expressions) ."
        },
        {
            "name": "position",
            "description": "Number of characters from the beginning of the string where the function starts searching for matches. Default: 1 (the search for a match starts at the first character on the left)"
        },
        {
            "name": "occurrence",
            "description": "Specifies the first occurrence of the pattern from which to start returning matches. The function skips the first occurrence - 1 matches. For example, if there are 5 matches and\nyou specify 3 for the occurrence argument, the function ignores the first two matches and\nreturns the third, fourth, and fifth matches. Default: 1"
        },
        {
            "name": "regex_parameters",
            "description": "String of one or more characters that specifies the parameters used for searching for matches. Supported values: Parameter Description c Case-sensitive matching i Case-insensitive matching m Multi-line mode e Extract submatches s POSIX wildcard character . matches \\n Default: c For more details, see Specifying the parameters for the regular expression . Note By default, REGEXP_SUBSTR_ALL returns the entire matching part of the subject.\nHowever, if the e parameter is specified, REGEXP_SUBSTR_ALL returns the\npart of the subject that matches the first group in the pattern.\nIf e is specified but a group_num is not also specified, then the group_num defaults to 1 (the first group). If there is no sub-expression in the pattern, REGEXP_SUBSTR_ALL behaves as\nif e was not set. For examples that use e , see Examples in this topic."
        },
        {
            "name": "group_num",
            "description": "Specifies which group to extract. Groups are specified by using parentheses in\nthe regular expression. If a group_num is specified, Snowflake allows extraction even if the 'e' option was not\nalso specified. The 'e' is implied. Snowflake supports up to 1024 groups. For examples that use group_num , see the Examples in this topic."
        }
    ],
    "returns": "The function returns a value of type ARRAY. The array contains an element for each matching substring."
},
{
    "function_name": "REGEXP_SUBSTR",
    "summary": "Returns the substring that matches a regular expression within a string.",
    "category": "String functions (regular expressions)",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/regexp_substr",
    "title": "REGEXP_SUBSTR",
    "description": "Returns the substring that matches a regular expression within a string.",
    "syntax": "REGEXP_SUBSTR( <subject> , <pattern> [ , <position> [ , <occurrence> [ , <regex_parameters> [ , <group_num> ] ] ] ] )",
    "example": "CREATE OR REPLACE TABLE demo2 (id INT, string1 VARCHAR);\n\nINSERT INTO demo2 (id, string1) VALUES\n    (2, 'It was the best of times, it was the worst of times.'),\n    (3, 'In    the   string   the   extra   spaces  are   redundant.'),\n    (4, 'A thespian theater is nearby.');\n\nSELECT * FROM demo2;\n\n+----+-------------------------------------------------------------+\n| ID | STRING1                                                     |\n|----+-------------------------------------------------------------|\n|  2 | It was the best of times, it was the worst of times.        |\n|  3 | In    the   string   the   extra   spaces  are   redundant. |\n|  4 | A thespian theater is nearby.                               |\n+----+-------------------------------------------------------------+\n\nSELECT id,\n       REGEXP_SUBSTR(string1, 'the\\\\W+\\\\w+') AS result\n  FROM demo2\n  ORDER BY id;\n\n+----+--------------+\n| ID | RESULT       |\n|----+--------------|\n|  2 | the best     |\n|  3 | the   string |\n|  4 | NULL         |\n+----+--------------+\n\nSELECT id,\n       REGEXP_SUBSTR(string1, 'the\\\\W+\\\\w+', 1, 2) AS result\n  FROM demo2\n  ORDER BY id;\n\n+----+-------------+\n| ID | RESULT      |\n|----+-------------|\n|  2 | the worst   |\n|  3 | the   extra |\n|  4 | NULL        |\n+----+-------------+\n\nSELECT id,\n       REGEXP_SUBSTR(string1, 'the\\\\W+(\\\\w+)', 1, 2, 'e', 1) AS result\n  FROM demo2\n  ORDER BY id;\n\n+----+--------+\n| ID | RESULT |\n|----+--------|\n|  2 | worst  |\n|  3 | extra  |\n|  4 | NULL   |\n+----+--------+\n\nCREATE OR REPLACE TABLE test_regexp_substr (string1 VARCHAR);;\nINSERT INTO test_regexp_substr (string1) VALUES ('A MAN A PLAN A CANAL');\n\nSELECT REGEXP_SUBSTR(string1, 'A\\\\W+(\\\\w+)', 1, 1, 'e', 1) AS result1,\n       REGEXP_SUBSTR(string1, 'A\\\\W+(\\\\w+)', 1, 2, 'e', 1) AS result2,\n       REGEXP_SUBSTR(string1, 'A\\\\W+(\\\\w+)', 1, 3, 'e', 1) AS result3,\n       REGEXP_SUBSTR(string1, 'A\\\\W+(\\\\w+)', 1, 4, 'e', 1) AS result4\n  FROM test_regexp_substr;\n\n+---------+---------+---------+---------+\n| RESULT1 | RESULT2 | RESULT3 | RESULT4 |\n|---------+---------+---------+---------|\n| MAN     | PLAN    | CANAL   | NULL    |\n+---------+---------+---------+---------+\n\nSELECT REGEXP_SUBSTR(string1, 'A\\\\W+(\\\\w)(\\\\w)(\\\\w)', 1, 1, 'e', 1) AS result1,\n       REGEXP_SUBSTR(string1, 'A\\\\W+(\\\\w)(\\\\w)(\\\\w)', 1, 1, 'e', 2) AS result2,\n       REGEXP_SUBSTR(string1, 'A\\\\W+(\\\\w)(\\\\w)(\\\\w)', 1, 1, 'e', 3) AS result3\n  FROM test_regexp_substr;\n\n+---------+---------+---------+\n| RESULT1 | RESULT2 | RESULT3 |\n|---------+---------+---------|\n| M       | A       | N       |\n+---------+---------+---------+\n\nCREATE OR REPLACE TABLE message(body VARCHAR(255));\n\nINSERT INTO message VALUES\n  ('Hellooo World'),\n  ('How are you doing today?'),\n  ('the quick brown fox jumps over the lazy dog'),\n  ('PACK MY BOX WITH FIVE DOZEN LIQUOR JUGS');\n\nSELECT body,\n       REGEXP_SUBSTR(body, '\\\\b\\\\S*o\\\\S*\\\\b') AS result\n  FROM message;\n\n+---------------------------------------------+---------+\n| BODY                                        | RESULT  |\n|---------------------------------------------+---------|\n| Hellooo World                               | Hellooo |\n| How are you doing today?                    | How     |\n| the quick brown fox jumps over the lazy dog | brown   |\n| PACK MY BOX WITH FIVE DOZEN LIQUOR JUGS     | NULL    |\n+---------------------------------------------+---------+\n\nSELECT body,\n       REGEXP_SUBSTR(body, '\\\\b\\\\S*o\\\\S*\\\\b', 3) AS result\n  FROM message;\n\n+---------------------------------------------+--------+\n| BODY                                        | RESULT |\n|---------------------------------------------+--------|\n| Hellooo World                               | llooo  |\n| How are you doing today?                    | you    |\n| the quick brown fox jumps over the lazy dog | brown  |\n| PACK MY BOX WITH FIVE DOZEN LIQUOR JUGS     | NULL   |\n+---------------------------------------------+--------+\n\nSELECT body,\n       REGEXP_SUBSTR(body, '\\\\b\\\\S*o\\\\S*\\\\b', 3, 3) AS result\n  FROM message;\n\n+---------------------------------------------+--------+\n| BODY                                        | RESULT |\n|---------------------------------------------+--------|\n| Hellooo World                               | NULL   |\n| How are you doing today?                    | today  |\n| the quick brown fox jumps over the lazy dog | over   |\n| PACK MY BOX WITH FIVE DOZEN LIQUOR JUGS     | NULL   |\n+---------------------------------------------+--------+\n\nSELECT body,\n       REGEXP_SUBSTR(body, '\\\\b\\\\S*o\\\\S*\\\\b', 3, 3, 'i') AS result\n  FROM message;\n\n+---------------------------------------------+--------+\n| BODY                                        | RESULT |\n|---------------------------------------------+--------|\n| Hellooo World                               | NULL   |\n| How are you doing today?                    | today  |\n| the quick brown fox jumps over the lazy dog | over   |\n| PACK MY BOX WITH FIVE DOZEN LIQUOR JUGS     | LIQUOR |\n+---------------------------------------------+--------+\n\nSELECT body,\n       REGEXP_SUBSTR(body, '(H\\\\S*o\\\\S*\\\\b).*', 1, 1, '') AS result\n  FROM message;\n\n+---------------------------------------------+--------------------------+\n| BODY                                        | RESULT                   |\n|---------------------------------------------+--------------------------|\n| Hellooo World                               | Hellooo World            |\n| How are you doing today?                    | How are you doing today? |\n| the quick brown fox jumps over the lazy dog | NULL                     |\n| PACK MY BOX WITH FIVE DOZEN LIQUOR JUGS     | NULL                     |\n+---------------------------------------------+--------------------------+\n\nCREATE OR REPLACE TABLE overlap (\n  id NUMBER,\n  a STRING);\n\nINSERT INTO overlap VALUES (1, ',abc,def,ghi,jkl,');\nINSERT INTO overlap VALUES (2, ',abc,,def,,ghi,,jkl,');\n\nSELECT * FROM overlap;\n\n+----+----------------------+\n| ID | A                    |\n|----+----------------------|\n|  1 | ,abc,def,ghi,jkl,    |\n|  2 | ,abc,,def,,ghi,,jkl, |\n+----+----------------------+\n\nSELECT id,\n       REGEXP_SUBSTR(a,'[[:punct:]][[:alnum:]]+[[:punct:]]', 1, 2) AS result\n  FROM overlap;\n\n+----+--------+\n| ID | RESULT |\n|----+--------|\n|  1 | ,ghi,  |\n|  2 | ,def,  |\n+----+--------+\n\nCREATE OR REPLACE TABLE test_regexp_log (logs VARCHAR);\n\nINSERT INTO test_regexp_log (logs) VALUES\n  ('127.0.0.1 - - [10/Jan/2018:16:55:36 -0800] \"GET / HTTP/1.0\" 200 2216'),\n  ('192.168.2.20 - - [14/Feb/2018:10:27:10 -0800] \"GET /cgi-bin/try/ HTTP/1.0\" 200 3395');\n\nSELECT * from test_regexp_log\n\n+-------------------------------------------------------------------------------------+\n| LOGS                                                                                |\n|-------------------------------------------------------------------------------------|\n| 127.0.0.1 - - [10/Jan/2018:16:55:36 -0800] \"GET / HTTP/1.0\" 200 2216                |\n| 192.168.2.20 - - [14/Feb/2018:10:27:10 -0800] \"GET /cgi-bin/try/ HTTP/1.0\" 200 3395 |\n+-------------------------------------------------------------------------------------+\n\nSELECT '{ \"ip_addr\":\"'\n       || REGEXP_SUBSTR (logs,'\\\\b\\\\d{1,3}\\.\\\\d{1,3}\\.\\\\d{1,3}\\.\\\\d{1,3}\\\\b')\n       || '\", \"date\":\"'\n       || REGEXP_SUBSTR (logs,'([\\\\w:\\/]+\\\\s[+\\-]\\\\d{4})')\n       || '\", \"request\":\"'\n       || REGEXP_SUBSTR (logs,'\\\"((\\\\S+) (\\\\S+) (\\\\S+))\\\"', 1, 1, 'e')\n       || '\", \"status\":\"'\n       || REGEXP_SUBSTR (logs,'(\\\\d{3}) \\\\d+', 1, 1, 'e')\n       || '\", \"size\":\"'\n       || REGEXP_SUBSTR (logs,'\\\\d{3} (\\\\d+)', 1, 1, 'e')\n       || '\"}' as Apache_HTTP_Server_Access\n  FROM test_regexp_log;\n\n+-----------------------------------------------------------------------------------------------------------------------------------------+\n| APACHE_HTTP_SERVER_ACCESS                                                                                                               |\n|-----------------------------------------------------------------------------------------------------------------------------------------|\n| { \"ip_addr\":\"127.0.0.1\", \"date\":\"10/Jan/2018:16:55:36 -0800\", \"request\":\"GET / HTTP/1.0\", \"status\":\"200\", \"size\":\"2216\"}                |\n| { \"ip_addr\":\"192.168.2.20\", \"date\":\"14/Feb/2018:10:27:10 -0800\", \"request\":\"GET /cgi-bin/try/ HTTP/1.0\", \"status\":\"200\", \"size\":\"3395\"} |\n+-----------------------------------------------------------------------------------------------------------------------------------------+",
    "arguments": [
        {
            "name": "subject",
            "description": "The string to search for matches."
        },
        {
            "name": "pattern",
            "description": "Pattern to match. For guidelines on specifying patterns, see String functions (regular expressions) ."
        },
        {
            "name": "position",
            "description": "Number of characters from the beginning of the string where the function starts searching for matches. Default: 1 (the search for a match starts at the first character on the left)"
        },
        {
            "name": "occurrence",
            "description": "Specifies the first occurrence of the pattern from which to start returning matches. The function skips the first occurrence - 1 matches. For example, if there are 5 matches and\nyou specify 3 for the occurrence argument, the function ignores the first two matches and\nreturns the third, fourth, and fifth matches. Default: 1"
        },
        {
            "name": "regex_parameters",
            "description": "String of one or more characters that specifies the parameters used for searching for matches. Supported values: Parameter Description c Case-sensitive matching i Case-insensitive matching m Multi-line mode e Extract submatches s POSIX wildcard character . matches \\n Default: c For more details, see Specifying the parameters for the regular expression . Note By default, REGEXP_SUBSTR returns the entire matching part of the subject.\nHowever, if the e (for “extract”) parameter is specified, REGEXP_SUBSTR returns the\npart of the subject that matches the first group in the pattern.\nIf e is specified but a group_num is not also specified, then the group_num defaults to 1 (the first group). If there is no sub-expression in the pattern, REGEXP_SUBSTR behaves as\nif e was not set. For examples that use e , see Examples in this topic."
        },
        {
            "name": "group_num",
            "description": "Specifies which group to extract. Groups are specified by using parentheses in\nthe regular expression. If a group_num is specified, Snowflake allows extraction even if the 'e' option was not\nalso specified. The 'e' is implied. Snowflake supports up to 1024 groups. For examples that use group_num , see the Examples in this topic."
        }
    ],
    "returns": "The function returns a value of type VARCHAR that is the matching substring."
},
{
    "function_name": "REGEXP_REPLACE",
    "summary": "Returns the subject with the specified pattern (or all occurrences of the pattern) either removed or replaced by a replacement string.",
    "category": "String functions (regular expressions)",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/regexp_replace",
    "title": "REGEXP_REPLACE",
    "description": "Returns the subject with the specified pattern (or all occurrences of the pattern) either removed or replaced by a replacement string.",
    "syntax": "REGEXP_REPLACE( <subject> , <pattern> [ , <replacement> , <position> , <occurrence> , <parameters> ] )",
    "example": "SELECT REGEXP_REPLACE('It was the best of times, it was the worst of times',\n                      '( ){1,}',\n                      '') AS result;\n\n+------------------------------------------+\n| RESULT                                   |\n|------------------------------------------|\n| Itwasthebestoftimes,itwastheworstoftimes |\n+------------------------------------------+\n\nSELECT REGEXP_REPLACE('It was the best of times, it was the worst of times',\n                      'times',\n                      'days',\n                      1,\n                      2) AS result;\n\n+----------------------------------------------------+\n| RESULT                                             |\n|----------------------------------------------------|\n| It was the best of times, it was the worst of days |\n+----------------------------------------------------+\n\nSELECT REGEXP_REPLACE('firstname middlename lastname',\n                      '(.*) (.*) (.*)',\n                      '\\\\3, \\\\1 \\\\2') AS name_sort;\n\n+--------------------------------+\n| NAME_SORT                      |\n|--------------------------------|\n| lastname, firstname middlename |\n+--------------------------------+",
    "arguments": [
        {
            "name": "subject",
            "description": "The string to search for matches."
        },
        {
            "name": "pattern",
            "description": "Pattern to match. For guidelines on specifying patterns, see String functions (regular expressions) ."
        },
        {
            "name": "replacement",
            "description": "String that replaces the substrings matched by the pattern. If an empty string is specified, the function removes all matched patterns and returns the resulting string. Default: '' (empty string)."
        },
        {
            "name": "position",
            "description": "Number of characters from the beginning of the string where the function starts searching for matches. Default: 1 (the search for a match starts at the first character on the left)"
        },
        {
            "name": "occurrence",
            "description": "Specifies which occurrence of the pattern to replace. If 0 is specified, all occurrences are replaced. Default: 0 (all occurrences)"
        },
        {
            "name": "parameters",
            "description": "String of one or more characters that specifies the parameters used for searching for matches. Supported values: Parameter Description c Case-sensitive matching i Case-insensitive matching m Multi-line mode e Extract submatches s POSIX wildcard character . matches \\n Default: c For more details, see Specifying the parameters for the regular expression ."
        }
    ],
    "returns": "Returns a value of type VARCHAR."
},
{
    "function_name": "REGEXP_LIKE",
    "summary": "Performs a comparison to determine whether a string matches a specified pattern.",
    "category": "String functions (regular expressions)",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/regexp_like",
    "title": "REGEXP_LIKE",
    "description": "Performs a comparison to determine whether a string matches a specified pattern. Both inputs must be text expressions.",
    "syntax": "REGEXP_LIKE( <subject> , <pattern> [ , <parameters> ] )",
    "example": "CREATE OR REPLACE TABLE cities(city varchar(20));\nINSERT INTO cities VALUES\n  ('Sacramento'),\n  ('San Francisco'),\n  ('San Jose'),\n  (null);\n\nSELECT * FROM cities WHERE REGEXP_LIKE(city, 'san.*');\n\n+------+\n| CITY |\n|------|\n+------+\n\nSELECT * FROM cities WHERE REGEXP_LIKE(city, 'san.*', 'i');\n\n+---------------+\n| CITY          |\n|---------------|\n| San Francisco |\n| San Jose      |\n+---------------+",
    "arguments": [
        {
            "name": "subject",
            "description": "The string to search for matches."
        },
        {
            "name": "pattern",
            "description": "Pattern to match. For guidelines on specifying patterns, see String functions (regular expressions) ."
        },
        {
            "name": "parameters",
            "description": "String of one or more characters that specifies the parameters used for searching for matches. Supported values: Parameter Description c Case-sensitive matching i Case-insensitive matching m Multi-line mode e Extract submatches s POSIX wildcard character . matches \\n Default: c For more details, see Specifying the parameters for the regular expression ."
        }
    ],
    "returns": "Returns a BOOLEAN or NULL. The value is TRUE if there is a match. Otherwise, returns FALSE. Returns NULL if any argument is NULL."
},
{
    "function_name": "REGEXP_INSTR",
    "summary": "Returns the position of the specified occurrence of the regular expression pattern in the string subject.",
    "category": "String functions (regular expressions)",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/regexp_instr",
    "title": "REGEXP_INSTR",
    "description": "Returns the position of the specified occurrence of the regular expression pattern in the string subject.",
    "syntax": "REGEXP_INSTR( <subject> , <pattern> [ , <position> [ , <occurrence> [ , <option> [ , <regexp_parameters> [ , <group_num> ] ] ] ] ] )",
    "example": "CREATE OR REPLACE TABLE demo1 (id INT, string1 VARCHAR);\nINSERT INTO demo1 (id, string1) VALUES\n  (1, 'nevermore1, nevermore2, nevermore3.');\n\nSELECT id,\n       string1,\n       REGEXP_SUBSTR(string1, 'nevermore\\\\d') AS substring,\n       REGEXP_INSTR( string1, 'nevermore\\\\d') AS position\n  FROM demo1\n  ORDER BY id;\n\n+----+-------------------------------------+------------+----------+\n| ID | STRING1                             | SUBSTRING  | POSITION |\n|----+-------------------------------------+------------+----------|\n|  1 | nevermore1, nevermore2, nevermore3. | nevermore1 |        1 |\n+----+-------------------------------------+------------+----------+\n\nSELECT id,\n       string1,\n       REGEXP_SUBSTR(string1, 'nevermore\\\\d', 5) AS substring,\n       REGEXP_INSTR( string1, 'nevermore\\\\d', 5) AS position\n  FROM demo1\n  ORDER BY id;\n\n+----+-------------------------------------+------------+----------+\n| ID | STRING1                             | SUBSTRING  | POSITION |\n|----+-------------------------------------+------------+----------|\n|  1 | nevermore1, nevermore2, nevermore3. | nevermore2 |       13 |\n+----+-------------------------------------+------------+----------+\n\nSELECT id,\n       string1,\n       REGEXP_SUBSTR(string1, 'nevermore\\\\d', 1, 3) AS substring,\n       REGEXP_INSTR( string1, 'nevermore\\\\d', 1, 3) AS position\n  FROM demo1\n  ORDER BY id;\n\n+----+-------------------------------------+------------+----------+\n| ID | STRING1                             | SUBSTRING  | POSITION |\n|----+-------------------------------------+------------+----------|\n|  1 | nevermore1, nevermore2, nevermore3. | nevermore3 |       25 |\n+----+-------------------------------------+------------+----------+\n\nSELECT id,\n       string1,\n       REGEXP_SUBSTR(string1, 'nevermore\\\\d', 1, 3) AS substring,\n       REGEXP_INSTR( string1, 'nevermore\\\\d', 1, 3, 0) AS start_position,\n       REGEXP_INSTR( string1, 'nevermore\\\\d', 1, 3, 1) AS after_position\n  FROM demo1\n  ORDER BY id;\n\n+----+-------------------------------------+------------+----------------+----------------+\n| ID | STRING1                             | SUBSTRING  | START_POSITION | AFTER_POSITION |\n|----+-------------------------------------+------------+----------------+----------------|\n|  1 | nevermore1, nevermore2, nevermore3. | nevermore3 |             25 |             35 |\n+----+-------------------------------------+------------+----------------+----------------+\n\nSELECT id,\n       string1,\n       REGEXP_SUBSTR(string1, 'nevermore', 1, 4) AS substring,\n       REGEXP_INSTR( string1, 'nevermore', 1, 4) AS position\n  FROM demo1\n  ORDER BY id;\n\n+----+-------------------------------------+-----------+----------+\n| ID | STRING1                             | SUBSTRING | POSITION |\n|----+-------------------------------------+-----------+----------|\n|  1 | nevermore1, nevermore2, nevermore3. | NULL      |        0 |\n+----+-------------------------------------+-----------+----------+\n\nCREATE OR REPLACE TABLE demo2 (id INT, string1 VARCHAR);\n\nINSERT INTO demo2 (id, string1) VALUES\n    (2, 'It was the best of times, it was the worst of times.'),\n    (3, 'In    the   string   the   extra   spaces  are   redundant.'),\n    (4, 'A thespian theater is nearby.');\n\nSELECT * FROM demo2;\n\n+----+-------------------------------------------------------------+\n| ID | STRING1                                                     |\n|----+-------------------------------------------------------------|\n|  2 | It was the best of times, it was the worst of times.        |\n|  3 | In    the   string   the   extra   spaces  are   redundant. |\n|  4 | A thespian theater is nearby.                               |\n+----+-------------------------------------------------------------+\n\nSELECT id,\n       string1,\n       REGEXP_SUBSTR(string1, 'the\\\\W+\\\\w+') AS substring,\n       REGEXP_INSTR(string1, 'the\\\\W+\\\\w+') AS position\n  FROM demo2\n  ORDER BY id;\n\n+----+-------------------------------------------------------------+--------------+----------+\n| ID | STRING1                                                     | SUBSTRING    | POSITION |\n|----+-------------------------------------------------------------+--------------+----------|\n|  2 | It was the best of times, it was the worst of times.        | the best     |        8 |\n|  3 | In    the   string   the   extra   spaces  are   redundant. | the   string |        7 |\n|  4 | A thespian theater is nearby.                               | NULL         |        0 |\n+----+-------------------------------------------------------------+--------------+----------+\n\nSELECT id,\n       string1,\n       REGEXP_SUBSTR(string1, 'the\\\\W+\\\\w+', 1, 2) AS substring,\n       REGEXP_INSTR(string1, 'the\\\\W+\\\\w+', 1, 2) AS position\n  FROM demo2\n  ORDER BY id;\n\n+----+-------------------------------------------------------------+-------------+----------+\n| ID | STRING1                                                     | SUBSTRING   | POSITION |\n|----+-------------------------------------------------------------+-------------+----------|\n|  2 | It was the best of times, it was the worst of times.        | the worst   |       34 |\n|  3 | In    the   string   the   extra   spaces  are   redundant. | the   extra |       22 |\n|  4 | A thespian theater is nearby.                               | NULL        |        0 |\n+----+-------------------------------------------------------------+-------------+----------+\n\nSELECT id,\n       string1,\n       REGEXP_SUBSTR(string1, 'the\\\\W+(\\\\w+)', 1, 2,    'e', 1) AS substring,\n       REGEXP_INSTR( string1, 'the\\\\W+(\\\\w+)', 1, 2, 0, 'e', 1) AS position\n  FROM demo2\n  ORDER BY id;\n\n+----+-------------------------------------------------------------+-----------+----------+\n| ID | STRING1                                                     | SUBSTRING | POSITION |\n|----+-------------------------------------------------------------+-----------+----------|\n|  2 | It was the best of times, it was the worst of times.        | worst     |       38 |\n|  3 | In    the   string   the   extra   spaces  are   redundant. | extra     |       28 |\n|  4 | A thespian theater is nearby.                               | NULL      |        0 |\n+----+-------------------------------------------------------------+-----------+----------+\n\nSELECT id,\n       string1,\n       REGEXP_SUBSTR(string1, 'the\\\\W+(\\\\w+)', 1, 2,    'e') AS substring,\n       REGEXP_INSTR( string1, 'the\\\\W+(\\\\w+)', 1, 2, 0, 'e') AS position\n  FROM demo2\n  ORDER BY id;\n\n+----+-------------------------------------------------------------+-----------+----------+\n| ID | STRING1                                                     | SUBSTRING | POSITION |\n|----+-------------------------------------------------------------+-----------+----------|\n|  2 | It was the best of times, it was the worst of times.        | worst     |       38 |\n|  3 | In    the   string   the   extra   spaces  are   redundant. | extra     |       28 |\n|  4 | A thespian theater is nearby.                               | NULL      |        0 |\n+----+-------------------------------------------------------------+-----------+----------+\n\nSELECT id,\n       string1,\n       REGEXP_SUBSTR(string1, 'the\\\\W+(\\\\w+)', 1, 2,    '', 1) AS substring,\n       REGEXP_INSTR( string1, 'the\\\\W+(\\\\w+)', 1, 2, 0, '', 1) AS position\n  FROM demo2\n  ORDER BY id;\n\n+----+-------------------------------------------------------------+-----------+----------+\n| ID | STRING1                                                     | SUBSTRING | POSITION |\n|----+-------------------------------------------------------------+-----------+----------|\n|  2 | It was the best of times, it was the worst of times.        | worst     |       38 |\n|  3 | In    the   string   the   extra   spaces  are   redundant. | extra     |       28 |\n|  4 | A thespian theater is nearby.                               | NULL      |        0 |\n+----+-------------------------------------------------------------+-----------+----------+\n\nCREATE TABLE demo3 (id INT, string1 VARCHAR);\nINSERT INTO demo3 (id, string1) VALUES\n  (5, 'A MAN A PLAN A CANAL');\n\nSELECT id,\n       string1,\n       REGEXP_SUBSTR(string1, 'A\\\\W+(\\\\w+)', 1, 1,    'e', 1) AS substring1,\n       REGEXP_INSTR( string1, 'A\\\\W+(\\\\w+)', 1, 1, 0, 'e', 1) AS position1,\n       REGEXP_SUBSTR(string1, 'A\\\\W+(\\\\w+)', 1, 2,    'e', 1) AS substring2,\n       REGEXP_INSTR( string1, 'A\\\\W+(\\\\w+)', 1, 2, 0, 'e', 1) AS position2,\n       REGEXP_SUBSTR(string1, 'A\\\\W+(\\\\w+)', 1, 3,    'e', 1) AS substring3,\n       REGEXP_INSTR( string1, 'A\\\\W+(\\\\w+)', 1, 3, 0, 'e', 1) AS position3,\n       REGEXP_SUBSTR(string1, 'A\\\\W+(\\\\w+)', 1, 4,    'e', 1) AS substring4,\n       REGEXP_INSTR( string1, 'A\\\\W+(\\\\w+)', 1, 4, 0, 'e', 1) AS position4\n  FROM demo3;\n\n+----+----------------------+------------+-----------+------------+-----------+------------+-----------+------------+-----------+\n| ID | STRING1              | SUBSTRING1 | POSITION1 | SUBSTRING2 | POSITION2 | SUBSTRING3 | POSITION3 | SUBSTRING4 | POSITION4 |\n|----+----------------------+------------+-----------+------------+-----------+------------+-----------+------------+-----------|\n|  5 | A MAN A PLAN A CANAL | MAN        |         3 | PLAN       |         9 | CANAL      |        16 | NULL       |         0 |\n+----+----------------------+------------+-----------+------------+-----------+------------+-----------+------------+-----------+\n\nSELECT id,\n       string1,\n       REGEXP_SUBSTR(string1, 'A\\\\W+(\\\\w)(\\\\w)(\\\\w)', 1, 1,    'e', 1) AS substring1,\n       REGEXP_INSTR( string1, 'A\\\\W+(\\\\w)(\\\\w)(\\\\w)', 1, 1, 0, 'e', 1) AS position1,\n       REGEXP_SUBSTR(string1, 'A\\\\W+(\\\\w)(\\\\w)(\\\\w)', 1, 1,    'e', 2) AS substring2,\n       REGEXP_INSTR( string1, 'A\\\\W+(\\\\w)(\\\\w)(\\\\w)', 1, 1, 0, 'e', 2) AS position2,\n       REGEXP_SUBSTR(string1, 'A\\\\W+(\\\\w)(\\\\w)(\\\\w)', 1, 1,    'e', 3) AS substring3,\n       REGEXP_INSTR( string1, 'A\\\\W+(\\\\w)(\\\\w)(\\\\w)', 1, 1, 0, 'e', 3) AS position3\n  FROM demo3;\n\n+----+----------------------+------------+-----------+------------+-----------+------------+-----------+\n| ID | STRING1              | SUBSTRING1 | POSITION1 | SUBSTRING2 | POSITION2 | SUBSTRING3 | POSITION3 |\n|----+----------------------+------------+-----------+------------+-----------+------------+-----------|\n|  5 | A MAN A PLAN A CANAL | M          |         3 | A          |         4 | N          |         5 |\n+----+----------------------+------------+-----------+------------+-----------+------------+-----------+\n\nSELECT REGEXP_INSTR('It was the best of times, it was the worst of times',\n                    '\\\\bwas\\\\b',\n                    1,\n                    1) AS result;\n\n+--------+\n| RESULT |\n|--------|\n|      4 |\n+--------+\n\nSELECT REGEXP_INSTR('It was the best of times, it was the worst of times',\n                    'the\\\\W+(\\\\w+)',\n                    1,\n                    1,\n                    0) AS result;\n\n+--------+\n| RESULT |\n|--------|\n|      8 |\n+--------+\n\nSELECT REGEXP_INSTR('It was the best of times, it was the worst of times',\n                    'the\\\\W+(\\\\w+)',\n                    1,\n                    1,\n                    0,\n                    'e') AS result;\n\n+--------+\n| RESULT |\n|--------|\n|     12 |\n+--------+\n\nSELECT REGEXP_INSTR('It was the best of times, it was the worst of times',\n                    '[[:alpha:]]{2,}st',\n                    15,\n                    1) AS result;\n\n+--------+\n| RESULT |\n|--------|\n|     38 |\n+--------+\n\nCREATE OR REPLACE TABLE message(body VARCHAR(255));\nINSERT INTO message VALUES\n  ('Hellooo World'),\n  ('How are you doing today?'),\n  ('the quick brown fox jumps over the lazy dog'),\n  ('PACK MY BOX WITH FIVE DOZEN LIQUOR JUGS');\n\nSELECT body,\n       REGEXP_INSTR(body, '\\\\b\\\\S*o\\\\S*\\\\b') AS result\n  FROM message;\n\n+---------------------------------------------+--------+\n| BODY                                        | RESULT |\n|---------------------------------------------+--------|\n| Hellooo World                               |      1 |\n| How are you doing today?                    |      1 |\n| the quick brown fox jumps over the lazy dog |     11 |\n| PACK MY BOX WITH FIVE DOZEN LIQUOR JUGS     |      0 |\n+---------------------------------------------+--------+\n\nSELECT body,\n       REGEXP_INSTR(body, '\\\\b\\\\S*o\\\\S*\\\\b', 3) AS result\n  FROM message;\n\n+---------------------------------------------+--------+\n| BODY                                        | RESULT |\n|---------------------------------------------+--------|\n| Hellooo World                               |      3 |\n| How are you doing today?                    |      9 |\n| the quick brown fox jumps over the lazy dog |     11 |\n| PACK MY BOX WITH FIVE DOZEN LIQUOR JUGS     |      0 |\n+---------------------------------------------+--------+\n\nSELECT body, REGEXP_INSTR(body, '\\\\b\\\\S*o\\\\S*\\\\b', 3, 3) AS result\n  FROM message;\n\n+---------------------------------------------+--------+\n| BODY                                        | RESULT |\n|---------------------------------------------+--------|\n| Hellooo World                               |      0 |\n| How are you doing today?                    |     19 |\n| the quick brown fox jumps over the lazy dog |     27 |\n| PACK MY BOX WITH FIVE DOZEN LIQUOR JUGS     |      0 |\n+---------------------------------------------+--------+\n\nSELECT body, REGEXP_INSTR(body, '\\\\b\\\\S*o\\\\S*\\\\b', 3, 3, 1) AS result\n  FROM message;\n\n+---------------------------------------------+--------+\n| BODY                                        | RESULT |\n|---------------------------------------------+--------|\n| Hellooo World                               |      0 |\n| How are you doing today?                    |     24 |\n| the quick brown fox jumps over the lazy dog |     31 |\n| PACK MY BOX WITH FIVE DOZEN LIQUOR JUGS     |      0 |\n+---------------------------------------------+--------+\n\nSELECT body, REGEXP_INSTR(body, '\\\\b\\\\S*o\\\\S*\\\\b', 3, 3, 1, 'i') AS result\n  FROM message;\n\n+---------------------------------------------+--------+\n| BODY                                        | RESULT |\n|---------------------------------------------+--------|\n| Hellooo World                               |      0 |\n| How are you doing today?                    |     24 |\n| the quick brown fox jumps over the lazy dog |     31 |\n| PACK MY BOX WITH FIVE DOZEN LIQUOR JUGS     |     35 |\n+---------------------------------------------+--------+",
    "arguments": [
        {
            "name": "subject",
            "description": "The string to search for matches."
        },
        {
            "name": "pattern",
            "description": "Pattern to match. For guidelines on specifying patterns, see String functions (regular expressions) ."
        },
        {
            "name": "position",
            "description": "Number of characters from the beginning of the string where the function starts searching for matches. Default: 1 (the search for a match starts at the first character on the left)"
        },
        {
            "name": "occurrence",
            "description": "Specifies the first occurrence of the pattern from which to start returning matches. The function skips the first occurrence - 1 matches. For example, if there are 5 matches and\nyou specify 3 for the occurrence argument, the function ignores the first two matches and\nreturns the third, fourth, and fifth matches. Default: 1"
        },
        {
            "name": "option",
            "description": "Specifies whether to return the offset of the first character of the match ( 0 ) or the offset of the first character following the end of the match ( 1 ). Default: 0"
        },
        {
            "name": "regexp_parameters",
            "description": "String of one or more characters that specifies the parameters used for searching for matches. Supported values: Parameter Description c Case-sensitive matching i Case-insensitive matching m Multi-line mode e Extract submatches s POSIX wildcard character . matches \\n Default: c For more details, see Specifying the parameters for the regular expression . Note By default, REGEXP_INSTR returns the begin or end character offset for the entire matching part of the subject.\nHowever, if the e (for “extract”) parameter is specified, REGEXP_INSTR returns the begin or end\ncharacter offset for the part of the subject that matches the first sub-expression in the pattern.\nIf e is specified but a group_num is not also specified, then the group_num defaults to 1 (the first group).  If there is no sub-expression in the pattern, REGEXP_INSTR behaves as\nif e was not set. For examples that use e , see Examples in this topic."
        },
        {
            "name": "group_num",
            "description": "The group_num parameter specifies which group to extract. Groups are specified by using parentheses in\nthe regular expression. If a group_num is specified, Snowflake allows extraction even if the e option was not\nalso specified. The e option is implied. Snowflake supports up to 1024 groups. For examples that use group_num , see Examples of capture groups in this topic."
        }
    ],
    "returns": "Returns a value of type NUMBER."
},
{
    "function_name": "REGEXP_COUNT",
    "summary": "Returns the number of times that a pattern occurs in a string.",
    "category": "String functions (regular expressions)",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/regexp_count",
    "title": "REGEXP_COUNT",
    "description": "Returns the number of times that a pattern occurs in a string.",
    "syntax": "REGEXP_COUNT( <subject> , <pattern> [ , <position> , <parameters> ] )",
    "example": "SELECT REGEXP_COUNT('It was the best of times, it was the worst of times',\n                    '\\\\bwas\\\\b',\n                    1) AS result;\n\n+--------+\n| RESULT |\n|--------|\n|      2 |\n+--------+\n\nCREATE OR REPLACE TABLE overlap (id NUMBER, a STRING);\nINSERT INTO overlap VALUES (1,',abc,def,ghi,jkl,');\nINSERT INTO overlap VALUES (2,',abc,,def,,ghi,,jkl,');\n\nSELECT * FROM overlap;\n\n+----+----------------------+\n| ID | A                    |\n|----+----------------------|\n|  1 | ,abc,def,ghi,jkl,    |\n|  2 | ,abc,,def,,ghi,,jkl, |\n+----+----------------------+\n\nSELECT id,\n       REGEXP_COUNT(a,\n                    '[[:punct:]][[:alnum:]]+[[:punct:]]',\n                    1,\n                    'i') AS result\n  FROM overlap;\n\n+----+--------+\n| ID | RESULT |\n|----+--------|\n|  1 |      2 |\n|  2 |      4 |\n+----+--------+",
    "arguments": [
        {
            "name": "subject",
            "description": "The string to search for matches."
        },
        {
            "name": "pattern",
            "description": "Pattern to match. For guidelines on specifying patterns, see String functions (regular expressions) ."
        },
        {
            "name": "position",
            "description": "Number of characters from the beginning of the string where the function starts searching for matches. Default: 1 (the search for a match starts at the first character on the left)"
        },
        {
            "name": "parameters",
            "description": "String of one or more characters that specifies the parameters used for searching for matches. Supported values: Parameter Description c Case-sensitive matching i Case-insensitive matching m Multi-line mode e Extract submatches s POSIX wildcard character . matches \\n Default: c For more details, see Specifying the parameters for the regular expression ."
        }
    ],
    "returns": "Returns a value of type NUMBER. Returns NULL if any argument is NULL."
},
{
    "function_name": "[ NOT ] REGEXP",
    "summary": "Performs a comparison to determine whether a string matches or does not match a specified pattern.",
    "category": "String functions (regular expressions)",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/regexp",
    "title": "[ NOT ] REGEXP",
    "description": "Performs a comparison to determine whether a string matches or does not match a specified pattern. Both inputs\nmust be text expressions.",
    "syntax": "<subject> [ NOT ] REGEXP <pattern>",
    "example": "CREATE OR REPLACE TABLE strings (v VARCHAR(50));\nINSERT INTO strings (v) VALUES\n  ('San Francisco'),\n  ('San Jose'),\n  ('Santa Clara'),\n  ('Sacramento');\n\nSELECT v\n  FROM strings\n  WHERE v REGEXP 'San* [fF].*'\n  ORDER BY v;\n\n+---------------+\n| V             |\n|---------------|\n| San Francisco |\n+---------------+\n\nINSERT INTO strings (v) VALUES\n  ('Contains embedded single \\\\backslash');\n\nSELECT *\n  FROM strings\n  ORDER BY v;\n\n+-------------------------------------+\n| V                                   |\n|-------------------------------------|\n| Contains embedded single \\backslash |\n| Sacramento                          |\n| San Francisco                       |\n| San Jose                            |\n| Santa Clara                         |\n+-------------------------------------+\n\nSELECT v, v REGEXP 'San\\\\b.*' AS matches\n  FROM strings\n  ORDER BY v;\n\n+-------------------------------------+---------+\n| V                                   | MATCHES |\n|-------------------------------------+---------|\n| Contains embedded single \\backslash | False   |\n| Sacramento                          | False   |\n| San Francisco                       | True    |\n| San Jose                            | True    |\n| Santa Clara                         | False   |\n+-------------------------------------+---------+\n\nSELECT v, v REGEXP '.*\\\\s\\\\\\\\.*' AS matches\n  FROM strings\n  ORDER BY v;\n\n+-------------------------------------+---------+\n| V                                   | MATCHES |\n|-------------------------------------+---------|\n| Contains embedded single \\backslash | True    |\n| Sacramento                          | False   |\n| San Francisco                       | False   |\n| San Jose                            | False   |\n| Santa Clara                         | False   |\n+-------------------------------------+---------+\n\nSELECT v, v REGEXP $$.*\\s\\\\.*$$ AS MATCHES\n  FROM strings\n  ORDER BY v;\n\n+-------------------------------------+---------+\n| V                                   | MATCHES |\n|-------------------------------------+---------|\n| Contains embedded single \\backslash | True    |\n| Sacramento                          | False   |\n| San Francisco                       | False   |\n| San Jose                            | False   |\n| Santa Clara                         | False   |\n+-------------------------------------+---------+",
    "arguments": [
        {
            "name": "subject",
            "description": "The string to search for matches."
        },
        {
            "name": "pattern",
            "description": "Pattern to match. For guidelines on specifying patterns, see String functions (regular expressions) ."
        }
    ],
    "returns": "Returns a BOOLEAN or NULL."
},
{
    "function_name": "REDUCE",
    "summary": "Reduces an array to a single value based on the logic in a lambda expression.",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/reduce",
    "title": "REDUCE",
    "description": "Reduces an",
    "syntax": "REDUCE( <array> , <init> , <lambda_expression> )",
    "example": "SELECT REDUCE([1,2,3],\n              0,\n              (acc, val) -> acc + val)\n  AS sum_of_values;\n\n+---------------+\n| SUM_OF_VALUES |\n|---------------|\n|             6 |\n+---------------+\n\nSELECT REDUCE([1,2,3]::ARRAY(INT),\n              0,\n              (acc, val) -> acc + val)\n  AS sum_of_values_structured;\n\n+--------------------------+\n| SUM_OF_VALUES_STRUCTURED |\n|--------------------------|\n|                        6 |\n+--------------------------+\n\nSELECT REDUCE([1,2,3],\n              10,\n              (acc, val) -> acc + val)\n  AS sum_of_values_plus_10;\n\n+-----------------------+\n| SUM_OF_VALUES_PLUS_10 |\n|-----------------------|\n|                    16 |\n+-----------------------+\n\nSELECT REDUCE([1,2,3],\n              0,\n              (acc, val) -> acc + val * val)\n  AS sum_of_squares;\n\n+----------------+\n| SUM_OF_SQUARES |\n|----------------|\n|             14 |\n+----------------+\n\nSELECT REDUCE([1,NULL,2,NULL,3,4],\n              0,\n              (acc, val) -> acc + ZEROIFNULL(val))\n  AS SUM_OF_VALUES_SKIP_NULL;\n\n+-------------------------+\n| SUM_OF_VALUES_SKIP_NULL |\n|-------------------------|\n|                      10 |\n+-------------------------+\n\nSELECT REDUCE(['a', 'b', 'c'],\n              '',\n              (acc, val) -> acc || ' ' || val)\n  AS string_values;\n\n+---------------+\n| STRING_VALUES |\n|---------------|\n|  a b c        |\n+---------------+\n\nSELECT REDUCE([1, 2, 3, 4],\n              [],\n              (acc, val) -> ARRAY_PREPEND(acc, val))\n  AS reverse_order;\n\n+---------------+\n| REVERSE_ORDER |\n|---------------|\n| [             |\n|   4,          |\n|   3,          |\n|   2,          |\n|   1           |\n| ]             |\n+---------------+\n\nSELECT REDUCE([5,10,15],\n              0,\n              (acc, val) -> IFF(val < 7, acc + val * val, acc + val))\n  AS conditional_logic;\n\n+-------------------+\n| CONDITIONAL_LOGIC |\n|-------------------|\n|                50 |\n+-------------------+\n\nCREATE OR REPLACE TABLE orders AS\n  SELECT 1 AS order_id, '2024-01-01' AS order_date, [\n    {'item':'UHD Monitor', 'quantity':3, 'subtotal':1500},\n    {'item':'Business Printer', 'quantity':1, 'subtotal':1200}\n  ] AS order_detail\n  UNION SELECT 2 AS order_id, '2024-01-02' AS order_date, [\n    {'item':'Laptop', 'quantity':5, 'subtotal':7500},\n    {'item':'Noise-canceling Headphones', 'quantity':5, 'subtotal':1000}\n  ] AS order_detail;\n\nSELECT * FROM orders;\n\n+----------+------------+-------------------------------------------+\n| ORDER_ID | ORDER_DATE | ORDER_DETAIL                              |\n|----------+------------+-------------------------------------------|\n|        1 | 2024-01-01 | [                                         |\n|          |            |   {                                       |\n|          |            |     \"item\": \"UHD Monitor\",                |\n|          |            |     \"quantity\": 3,                        |\n|          |            |     \"subtotal\": 1500                      |\n|          |            |   },                                      |\n|          |            |   {                                       |\n|          |            |     \"item\": \"Business Printer\",           |\n|          |            |     \"quantity\": 1,                        |\n|          |            |     \"subtotal\": 1200                      |\n|          |            |   }                                       |\n|          |            | ]                                         |\n|        2 | 2024-01-02 | [                                         |\n|          |            |   {                                       |\n|          |            |     \"item\": \"Laptop\",                     |\n|          |            |     \"quantity\": 5,                        |\n|          |            |     \"subtotal\": 7500                      |\n|          |            |   },                                      |\n|          |            |   {                                       |\n|          |            |     \"item\": \"Noise-canceling Headphones\", |\n|          |            |     \"quantity\": 5,                        |\n|          |            |     \"subtotal\": 1000                      |\n|          |            |   }                                       |\n|          |            | ]                                         |\n+----------+------------+-------------------------------------------+\n\nSELECT order_id,\n       order_date,\n       REDUCE(o.order_detail,\n              0,\n              (acc, val) -> acc + val:subtotal) subtotal_sum\n  FROM orders o;\n\n+----------+------------+--------------+\n| ORDER_ID | ORDER_DATE | SUBTOTAL_SUM |\n|----------+------------+--------------|\n|        1 | 2024-01-01 |         2700 |\n|        2 | 2024-01-02 |         8500 |\n+----------+------------+--------------+\n\nSELECT order_id,\n       order_date,\n       REDUCE(o.order_detail,\n              '',\n              (acc, val) -> val:item || '\\n' || acc) items_sold\n  FROM orders o;\n\n+----------+------------+-----------------------------+\n| ORDER_ID | ORDER_DATE | ITEMS_SOLD                  |\n|----------+------------+-----------------------------|\n|        1 | 2024-01-01 | Business Printer            |\n|          |            | UHD Monitor                 |\n|          |            |                             |\n|        2 | 2024-01-02 | Noise-canceling Headphones  |\n|          |            | Laptop                      |\n|          |            |                             |\n+----------+------------+-----------------------------+",
    "arguments": [
        {
            "name": "array",
            "description": "The array that contains the elements to be reduced. The array can be semi-structured or structured."
        },
        {
            "name": "init",
            "description": "The initial accumulator value."
        },
        {
            "name": "lambda_expression",
            "description": "A lambda expression that defines the reduce\nlogic on each array element. The lambda expression must be specified in the following syntax: The acc argument is the accumulator, and the value argument is the current element\nbeing processed in the array."
        }
    ],
    "returns": "This function can return a value of any data type."
},
{
    "function_name": "RATIO_TO_REPORT",
    "summary": "Returns the ratio of a value within a group to the sum of the values within the group.",
    "category": "Window functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/ratio_to_report",
    "title": "RATIO_TO_REPORT",
    "description": "Returns the ratio of a value within a group to the sum of the values within the group. If",
    "syntax": "RATIO_TO_REPORT( <expr1> ) [ OVER ( [ PARTITION BY <expr2> ] [ ORDER BY <expr3> ] ) ]",
    "example": "CREATE TABLE store_profit (\n    store_ID INTEGER, \n    province VARCHAR,\n    profit NUMERIC(11, 2));\nINSERT INTO store_profit (store_ID, province, profit) VALUES\n    (1, 'Ontario', 300),\n    (2, 'Saskatchewan', 250),\n    (3, 'Ontario', 450),\n    (4, 'Ontario', NULL)  -- hasn't opened yet, so no profit yet.\n    ;\n\nSELECT \n        store_ID, profit, \n        100 * RATIO_TO_REPORT(profit) OVER () AS percent_profit\n    FROM store_profit\n    ORDER BY store_ID;\n+----------+--------+----------------+\n| STORE_ID | PROFIT | PERCENT_PROFIT |\n|----------+--------+----------------|\n|        1 | 300.00 |    30.00000000 |\n|        2 | 250.00 |    25.00000000 |\n|        3 | 450.00 |    45.00000000 |\n|        4 |   NULL |           NULL |\n+----------+--------+----------------+\n\nSELECT \n        province, store_ID, profit, \n        100 * RATIO_TO_REPORT(profit) OVER (PARTITION BY province) AS percent_profit\n    FROM store_profit\n    ORDER BY province, store_ID;\n+--------------+----------+--------+----------------+\n| PROVINCE     | STORE_ID | PROFIT | PERCENT_PROFIT |\n|--------------+----------+--------+----------------|\n| Ontario      |        1 | 300.00 |    40.00000000 |\n| Ontario      |        3 | 450.00 |    60.00000000 |\n| Ontario      |        4 |   NULL |           NULL |\n| Saskatchewan |        2 | 250.00 |   100.00000000 |\n+--------------+----------+--------+----------------+",
    "arguments": [
        {
            "name": "expr1",
            "description": "This is an expression that evaluates to a numeric data type (INTEGER, FLOAT, DECIMAL, etc.)."
        },
        {
            "name": "expr2",
            "description": "This is the optional expression to partition by."
        },
        {
            "name": "expr3",
            "description": "This is the optional expression to order by within each partition. Note that for this function, the order within\nthe partition does not affect the output. In this function, as in all window functions, this ORDER BY does not control the order of the entire query output."
        }
    ]
},
{
    "function_name": "RANK",
    "summary": "Returns the rank of a value within an ordered group of values.",
    "category": "Window functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/rank",
    "title": "RANK",
    "description": "Returns the rank of a value within an ordered group of values.",
    "syntax": "RANK() OVER ( [ PARTITION BY <expr1> ] ORDER BY <expr2> [ { ASC | DESC } ] [ <window_frame> ] )",
    "example": "-- Create table and load data.\ncreate or replace table corn_production (farmer_ID INTEGER, state varchar, bushels float);\ninsert into corn_production (farmer_ID, state, bushels) values\n    (1, 'Iowa', 100),\n    (2, 'Iowa', 110),\n    (3, 'Kansas', 120),\n    (4, 'Kansas', 130);\n\nSELECT state, bushels,\n        RANK() OVER (ORDER BY bushels DESC),\n        DENSE_RANK() OVER (ORDER BY bushels DESC)\n    FROM corn_production;\n+--------+---------+-------------------------------------+-------------------------------------------+\n| STATE  | BUSHELS | RANK() OVER (ORDER BY BUSHELS DESC) | DENSE_RANK() OVER (ORDER BY BUSHELS DESC) |\n|--------+---------+-------------------------------------+-------------------------------------------|\n| Kansas |     130 |                                   1 |                                         1 |\n| Kansas |     120 |                                   2 |                                         2 |\n| Iowa   |     110 |                                   3 |                                         3 |\n| Iowa   |     100 |                                   4 |                                         4 |\n+--------+---------+-------------------------------------+-------------------------------------------+\n\nSELECT state, bushels,\n        RANK() OVER (PARTITION BY state ORDER BY bushels DESC),\n        DENSE_RANK() OVER (PARTITION BY state ORDER BY bushels DESC)\n    FROM corn_production;\n+--------+---------+--------------------------------------------------------+--------------------------------------------------------------+\n| STATE  | BUSHELS | RANK() OVER (PARTITION BY STATE ORDER BY BUSHELS DESC) | DENSE_RANK() OVER (PARTITION BY STATE ORDER BY BUSHELS DESC) |\n|--------+---------+--------------------------------------------------------+--------------------------------------------------------------|\n| Iowa   |     110 |                                                      1 |                                                            1 |\n| Iowa   |     100 |                                                      2 |                                                            2 |\n| Kansas |     130 |                                                      1 |                                                            1 |\n| Kansas |     120 |                                                      2 |                                                            2 |\n+--------+---------+--------------------------------------------------------+--------------------------------------------------------------+\n\nSELECT state, bushels,\n        RANK() OVER (ORDER BY bushels DESC),\n        DENSE_RANK() OVER (ORDER BY bushels DESC)\n    FROM corn_production;\n+--------+---------+-------------------------------------+-------------------------------------------+\n| STATE  | BUSHELS | RANK() OVER (ORDER BY BUSHELS DESC) | DENSE_RANK() OVER (ORDER BY BUSHELS DESC) |\n|--------+---------+-------------------------------------+-------------------------------------------|\n| Kansas |     130 |                                   1 |                                         1 |\n| Kansas |     120 |                                   2 |                                         2 |\n| Iowa   |     110 |                                   3 |                                         3 |\n| Iowa   |     110 |                                   3 |                                         3 |\n| Iowa   |     100 |                                   5 |                                         4 |\n+--------+---------+-------------------------------------+-------------------------------------------+"
},
{
    "function_name": "RANDSTR",
    "summary": "Returns a random string of specified length.",
    "category": "Data generation functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/randstr",
    "title": "RANDSTR",
    "description": "Returns a random string of specified",
    "syntax": "RANDSTR( <length> , <gen> )",
    "example": "SELECT randstr(5, random()) FROM table(generator(rowCount => 5));\n\n+----------------------+\n| RANDSTR(5, RANDOM()) |\n|----------------------|\n| rM6ep                |\n| nsWJ0                |\n| IQi5H                |\n| VBNvY                |\n| wjk6y                |\n+----------------------+\n\nSELECT randstr(5, 1234) FROM table(generator(rowCount => 5));\n\n+------------------+\n| RANDSTR(5, 1234) |\n|------------------|\n| E5tav            |\n| E5tav            |\n| E5tav            |\n| E5tav            |\n| E5tav            |\n+------------------+\n\nSELECT randstr(abs(random()) % 10, random()) FROM table(generator(rowCount => 5));\n\n+---------------------------------------+\n| RANDSTR(ABS(RANDOM()) % 10, RANDOM()) |\n|---------------------------------------|\n| e                                     |\n| iR                                    |\n| qRwWl7W6                              |\n|                                       |\n| Yg                                    |\n+---------------------------------------+"
},
{
    "function_name": "RANDOM",
    "summary": "Each call returns a pseudo-random 64-bit integer.",
    "category": "Data generation functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/random",
    "title": "RANDOM",
    "description": "Each call returns a pseudo-random 64-bit integer.",
    "syntax": "RANDOM([seed])",
    "example": "SELECT RANDOM() FROM TABLE(GENERATOR(ROWCOUNT => 3));\n\n+----------------------+\n|             RANDOM() |\n|----------------------|\n|  -962378740685764490 |\n|  2115408279841266588 |\n| -3473099493125344079 |\n+----------------------+\n\nSELECT RANDOM(4711) FROM TABLE(GENERATOR(ROWCOUNT => 3));\n\n+----------------------+\n|         RANDOM(4711) |\n|----------------------|\n| -3581185414942383166 |\n|  1570543588041465562 |\n| -6684111782596764647 |\n+----------------------+\n\nSELECT RANDOM(), RANDOM() FROM TABLE(GENERATOR(ROWCOUNT => 3));\n\n+----------------------+----------------------+\n|             RANDOM() |             RANDOM() |\n|----------------------+----------------------|\n|  3150854865719208303 | -5331309978450480587 |\n| -8117961043441270292 |   738998101727879972 |\n|  6683692108700370630 |  7526520486590420231 |\n+----------------------+----------------------+\n\nSELECT RANDOM(4711), RANDOM(4711) FROM TABLE(GENERATOR(ROWCOUNT => 3));\n\n+----------------------+----------------------+\n|         RANDOM(4711) |         RANDOM(4711) |\n|----------------------+----------------------|\n| -3581185414942383166 | -3581185414942383166 |\n|  1570543588041465562 |  1570543588041465562 |\n| -6684111782596764647 | -6684111782596764647 |\n+----------------------+----------------------+",
    "arguments": [
        {
            "name": "seed",
            "description": "The seed is an integer. Different seeds cause RANDOM to produce different output values. If no seed is provided, a random seed is chosen in a platform-specific manner."
        }
    ]
},
{
    "function_name": "RADIANS",
    "summary": "Converts degrees to radians.",
    "category": "Numeric functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/radians",
    "title": "RADIANS",
    "description": "Converts degrees to radians.",
    "syntax": "RADIANS( <real_expr> )",
    "example": "SELECT RADIANS(0), RADIANS(60), RADIANS(180), RADIANS(360), RADIANS(720);\n+------------+-------------+--------------+--------------+--------------+\n| RADIANS(0) | RADIANS(60) | RADIANS(180) | RADIANS(360) | RADIANS(720) |\n|------------+-------------+--------------+--------------+--------------|\n|          0 | 1.047197551 |  3.141592654 |  6.283185307 | 12.566370614 |\n+------------+-------------+--------------+--------------+--------------+"
},
{
    "function_name": "QUERY_HISTORY , QUERY_HISTORY_BY_*",
    "summary": "You can use the QUERY_HISTORY family of table functions to query Snowflake query history along various dimensions.",
    "category": "Information Schema , Table functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/query_history",
    "title": "QUERY_HISTORY , QUERY_HISTORY_BY_*",
    "description": "You can use the QUERY_HISTORY family of table functions to query Snowflake query history along various dimensions:",
    "syntax": "QUERY_HISTORY(\n      [ END_TIME_RANGE_START => <constant_expr> ]\n      [, END_TIME_RANGE_END => <constant_expr> ]\n      [, RESULT_LIMIT => <num> ]\n      [, INCLUDE_CLIENT_GENERATED_STATEMENT => <boolean_expr> ] )\n\nQUERY_HISTORY_BY_SESSION(\n      [ SESSION_ID => <constant_expr> ]\n      [, END_TIME_RANGE_START => <constant_expr> ]\n      [, END_TIME_RANGE_END => <constant_expr> ]\n      [, RESULT_LIMIT => <num> ]\n      [, INCLUDE_CLIENT_GENERATED_STATEMENT => <boolean_expr> ] )\n\nQUERY_HISTORY_BY_USER(\n      [ USER_NAME => '<string>' ]\n      [, END_TIME_RANGE_START => <constant_expr> ]\n      [, END_TIME_RANGE_END => <constant_expr> ]\n      [, RESULT_LIMIT => <num> ]\n      [, INCLUDE_CLIENT_GENERATED_STATEMENT => <boolean_expr> ] )\n\nQUERY_HISTORY_BY_WAREHOUSE(\n      [ WAREHOUSE_NAME => '<string>' ]\n      [, END_TIME_RANGE_START => <constant_expr> ]\n      [, END_TIME_RANGE_END => <constant_expr> ]\n      [, RESULT_LIMIT => <num> ]\n      [, INCLUDE_CLIENT_GENERATED_STATEMENT => <boolean_expr> ] )",
    "example": "SELECT *\n  FROM TABLE(INFORMATION_SCHEMA.QUERY_HISTORY_BY_SESSION())\n  ORDER BY start_time;\n\nSELECT *\n  FROM TABLE(INFORMATION_SCHEMA.QUERY_HISTORY())\n  ORDER BY start_time;\n\nSELECT *\n  FROM TABLE(INFORMATION_SCHEMA.QUERY_HISTORY(DATEADD('hours',-1,CURRENT_TIMESTAMP()),CURRENT_TIMESTAMP()))\n  ORDER BY start_time;\n\nSELECT *\n  FROM TABLE(INFORMATION_SCHEMA.QUERY_HISTORY(\n    END_TIME_RANGE_START=>TO_TIMESTAMP_LTZ('2017-12-4 12:00:00.000 -0700'),\n    END_TIME_RANGE_END=>TO_TIMESTAMP_LTZ('2017-12-4 12:30:00.000 -0700')));\n\nSELECT COUNT(*)\n  FROM TABLE(INFORMATION_SCHEMA.QUERY_HISTORY_BY_WAREHOUSE(\n    WAREHOUSE_NAME => 'my_xsmall_wh',\n    INCLUDE_CLIENT_GENERATED_STATEMENT => TRUE));",
    "arguments": [
        {
            "name": "END_TIME_RANGE_START",
            "description": "Time range (in TIMESTAMP_LTZ format), within the last 7 days, in which the query completed running: If END_TIME_RANGE_END is not specified, the function returns all queries, including those that are still running. If END_TIME_RANGE_END is CURRENT_TIMESTAMP , the function returns only those queries that have completed. If the time range does not fall within the last 7 days, an error is returned. Note If no start or end time is specified, the most recent queries are returned, up to the specified limit."
        },
        {
            "name": "SESSION_ID",
            "description": "Applies only to QUERY_HISTORY_BY_SESSION The numeric identifier for a session or CURRENT_SESSION . Only queries from the specified session are returned. Default: CURRENT_SESSION"
        },
        {
            "name": "USER_NAME",
            "description": "Applies only to QUERY_HISTORY_BY_USER A string specifying a user login name or CURRENT_USER . Only queries run by the specified user are returned. Note that the login name must be enclosed in single quotes. Also, if the\nlogin name contains any spaces, mixed-case characters, or special characters, the name must be double-quoted within the single quotes (e.g. '\"User 1\"' vs 'user1' ).\nYou cannot specify SYSTEM ( USER_NAME =>'SYSTEM' ), which is a background service rather than a user. However, you can filter on user_name='SYSTEM' when you run queries against QUERY_HISTORY table functions. Default: CURRENT_USER"
        },
        {
            "name": "WAREHOUSE_NAME",
            "description": "Applies only to QUERY_HISTORY_BY_WAREHOUSE A string specifying a warehouse name or CURRENT_WAREHOUSE . Only queries executed by that warehouse are returned. Note that the warehouse name must be enclosed in single quotes. Also, if the\nwarehouse name contains any spaces, mixed-case characters, or special characters, the name must be double-quoted within the single quotes (e.g. '\"My Warehouse\"' vs 'mywarehouse' ). Default: CURRENT_WAREHOUSE"
        },
        {
            "name": "RESULT_LIMIT",
            "description": "A number specifying the maximum number of rows returned by the function: If the number of matching rows is greater than this limit, the queries with the most recent end time (or those that are still executing) are returned, up to the specified limit. Range: 1 to 10000 Default: 100 ."
        },
        {
            "name": "INCLUDE_CLIENT_GENERATED_STATEMENT",
            "description": "Specifies whether client-generated statements are included in table function queries (given the value of the is_client_generated_statement column). Default: FALSE . The ACCOUNT_USAGE QUERY_HISTORY view also contains an is_client_generated_statement column, but queries of this view return all statements, whether or not they are client-generated. If necessary, you can filter the query result."
        }
    ]
},
{
    "function_name": "QUERY_ACCELERATION_HISTORY",
    "summary": "The QUERY_ACCELERATION_HISTORY function is used for querying the query acceleration service history within a specified date range.",
    "category": "Information Schema , Table functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/query_acceleration_history",
    "title": "QUERY_ACCELERATION_HISTORY",
    "syntax": "QUERY_ACCELERATION_HISTORY(\n      [ DATE_RANGE_START => <constant_expr> ]\n      [ , DATE_RANGE_END => <constant_expr> ]\n      [ , WAREHOUSE_NAME => '<string>' ] )"
},
{
    "function_name": "PROMPT function",
    "summary": "The PROMPT function constructs a structured OBJECT containing a template string and a list of arguments.",
    "category": "",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/prompt",
    "title": "PROMPT function",
    "syntax": "SELECT PROMPT('<template_string>', <expr_1> [ , <expr_2>, ... ] )\n    FROM <table>;",
    "example": "SELECT PROMPT('Hello, {0}! Today is {1}.', 'Alice', 'Monday');\n\n{\n    'template': 'Hello, {0}! Today is {1}.',\n    'args': ['Alice', 'Monday']\n}\n\nSNOWFLAKE.CORTEX.COMPLETE('claude-3-5-sonnet',\n    PROMPT('Classify the input image {0} in no more than 2 words. Respond in JSON', img_file)) AS image_classification\nFROM image_table;",
    "arguments": [
        {
            "name": "template_string",
            "description": "A string containing numbered placeholders like {0} where the number is at least 0 and less than the number of expressions specified.\nThe first expression is substituted for {0} , the second for {1} , and so on."
        },
        {
            "name": "expr_1",
            "description": "Expressions whose values will eventually be substituted into the template string in place of the numbered\nplaceholders. These can be column names or other expressions. Values can be of any type coercible to a string (for\nexample, VARCHAR, NUMBER, etc.), or FILE."
        }
    ],
    "returns": "A SQL OBJECT with the following structure:"
},
{
    "function_name": "PREVIOUS_DAY",
    "summary": "Returns the date of the first specified day of week (DOW) that occurs before the input date.",
    "category": "Date & time functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/previous_day",
    "title": "PREVIOUS_DAY",
    "description": "Returns the date of the first specified day of week (DOW) that occurs before the input date.",
    "syntax": "PREVIOUS_DAY( <date_or_timetamp_expr> , <dow> )",
    "example": "SELECT CURRENT_DATE() AS \"Today's Date\",\n       PREVIOUS_DAY(\"Today's Date\", 'Friday') AS \"Previous Friday\";\n\n+--------------+-----------------+\n| Today's Date | Previous Friday |\n|--------------+-----------------|\n| 2025-05-06   | 2025-05-02      |\n+--------------+-----------------+",
    "arguments": [
        {
            "name": "date_or_timestamp_expr",
            "description": "A date or a timestamp, or an expression that can be evaluated to a date or a timestamp."
        },
        {
            "name": "dow_string",
            "description": "Specifies the day of week used to calculate the date for the previous day. The value can be a string literal or an expression that returns a string. The string\nmust start with the first two characters (case-insensitive) of the day name: su (Sunday) mo (Monday) tu (Tuesday) we (Wednesday) th (Thursday) fr (Friday) sa (Saturday) Any leading spaces and trailing characters, including spaces, in the string are ignored."
        }
    ],
    "returns": "This function returns a value of type DATE, even if date_or_timetamp_expr is a timestamp."
},
{
    "function_name": "POW, POWER",
    "summary": "Returns a number (x) raised to the specified power (y).",
    "category": "Numeric functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/pow",
    "title": "POW, POWER",
    "description": "Returns a number (x) raised to the specified power (y).",
    "syntax": "POW(x, y)\n\nPOWER (x, y)",
    "example": "SELECT x, y, pow(x, y) FROM tab;\n\n-----+-----+-------------+\n  X  |  Y  |  POW(X, Y)  |\n-----+-----+-------------+\n 0.1 | 2   | 0.01        |\n 2   | 3   | 8           |\n 2   | 0.5 | 1.414213562 |\n 2   | -1  | 0.5         |\n-----+-----+-------------+"
},
{
    "function_name": "POSITION",
    "summary": "Searches for the first occurrence of the first argument in the second argument and, if successful, returns the position (1-based) of the first argument in the second argument.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/position",
    "title": "POSITION",
    "description": "Searches for the first occurrence of the first argument in the second argument and, if successful, returns the position (1-based) of the first argument in the second argument.",
    "syntax": "POSITION( <expr1>, <expr2> [ , <start_pos> ] )\n\nPOSITION( <expr1> IN <expr2> )",
    "example": "SELECT POSITION('an', 'banana', 1);\n\n+-----------------------------+\n| POSITION('AN', 'BANANA', 1) |\n|-----------------------------|\n|                           2 |\n+-----------------------------+\n\nSELECT POSITION('an', 'banana', 3);\n\n+-----------------------------+\n| POSITION('AN', 'BANANA', 3) |\n|-----------------------------|\n|                           4 |\n+-----------------------------+\n\nSELECT n, h, POSITION(n IN h) FROM pos;\n\n+--------+---------------------+------------------+\n| N      | H                   | POSITION(N IN H) |\n|--------+---------------------+------------------|\n|        |                     |                1 |\n|        | sth                 |                1 |\n| 43     | 41424344            |                5 |\n| a      | NULL                |             NULL |\n| dog    | catalog             |                0 |\n| log    | catalog             |                5 |\n| lésine | le péché, la lésine |               14 |\n| nicht  | Ich weiß nicht      |               10 |\n| sth    |                     |                0 |\n| ☃c     | ☃a☃b☃c☃d            |                5 |\n| ☃☃     | bunch of ☃☃☃☃       |               10 |\n| ❄c     | ❄a☃c❄c☃             |                5 |\n| NULL   | a                   |             NULL |\n| NULL   | NULL                |             NULL |\n+--------+---------------------+------------------+\n\nSELECT POSITION(X'EF', X'ABCDEF');\n\n+----------------------------+\n| POSITION(X'EF', X'ABCDEF') |\n|----------------------------|\n|                          3 |\n+----------------------------+\n\nSELECT POSITION(X'BC', X'ABCD');\n\n+--------------------------+\n| POSITION(X'BC', X'ABCD') |\n|--------------------------|\n|                        0 |\n+--------------------------+",
    "arguments": [
        {
            "name": "expr1",
            "description": "A string or binary expression representing the value to look for."
        },
        {
            "name": "expr2",
            "description": "A string or binary expression representing the value to search."
        },
        {
            "name": "start_pos",
            "description": "A number indicating the position at which to start the search (with 1 representing the start of expr2 ). Default: 1"
        }
    ],
    "returns": "This function returns a value of type NUMBER."
},
{
    "function_name": "POLICY_REFERENCES",
    "summary": "Returns a row for each object that has the specified policy assigned to the object or returns a row for each policy assigned to the specified object.",
    "category": "Information Schema , Table functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/policy_references",
    "title": "POLICY_REFERENCES",
    "description": "Returns a row for each object that has the specified policy assigned to the object",
    "syntax": "POLICY_REFERENCES(\n      POLICY_NAME => '<string>' ,\n      POLICY_KIND => 'NETWORK_POLICY'\n      )",
    "example": "use database my_db;\nuse schema information_schema;\nselect *\n  from table(information_schema.policy_references(policy_name => 'my_db.my_schema.ssn_mask'));\n\nuse database my_db;\nuse schema information_schema;\nselect *\n  from table(information_schema.policy_references(ref_entity_name => 'my_db.my_schema.my_table', ref_entity_domain => 'table'));",
    "arguments": [
        {
            "name": "POLICY_NAME",
            "description": "Specifies the policy name. The entire policy name must be enclosed in single quotes. If the policy name is case-sensitive or includes any special characters or spaces, double quotes are required to process the\ncase/characters. The double quotes must be enclosed within the single quotes (i.e. '\"<policy_name>\"' ). Currently, Snowflake supports the following policies when specifying the policy name as an argument: aggregation policies authentication policy masking policy network policy packages policy password policy projection policies row access policy session policy"
        },
        {
            "name": "POLICY_KIND",
            "description": "Use this argument only when the POLICY_NAME value is a network policy. Do not use this argument when you specify the name of\nother kinds of policies."
        },
        {
            "name": "REF_ENTITY_NAME",
            "description": "The name of the object, such as the table name, view name, external table name, or username, on which the policy is set. The entire object name must be enclosed in single quotes. If the object name is case-sensitive or includes any special characters or spaces, double quotes are required to process the\ncase/characters. The double quotes must be enclosed within the single quotes (i.e. '\"<table_name>\"' )."
        },
        {
            "name": "REF_ENTITY_DOMAIN",
            "description": "The object type on which the policy is set. If the object is an external table, use 'TABLE' as the argument value. If the object is a materialized view, use 'VIEW' as the argument value. The supported domains are: 'ACCOUNT' 'INTEGRATION' 'TABLE' 'TAG' 'USER' 'VIEW'"
        }
    ],
    "returns": "The function returns the following columns:"
},
{
    "function_name": "POLICY_CONTEXT",
    "summary": "Simulates the results of a query based upon the value of one or more context functions, which lets you determine how policies affect query results.",
    "category": "Context functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/policy_context",
    "title": "POLICY_CONTEXT",
    "description": "Simulates the results of a query based upon the value of one or more context functions, which lets you determine how policies affect query\nresults. Context functions return a value based on the current context of a query: for example, who is executing the query or the account\nfrom which the query is being executed. Policy bodies often use context functions to determine which value to return from the policy.",
    "syntax": "EXECUTE USING\nPOLICY_CONTEXT( <arg_1> => '<string_literal>' [ , <arg_2> => '<string_literal>' , ... , <arg_n> => '<string_literal>' ] )\nAS\nSELECT <query>",
    "example": "EXECUTE USING POLICY_CONTEXT(CURRENT_ROLE => 'PUBLIC')\n  AS SELECT * FROM empl_info;",
    "arguments": [
        {
            "name": "arg_1",
            "description": "Specifies a context function and its value as a string. Required. You must specify at least one function and its value. Snowflake supports the following context functions and their values as arguments: CURRENT_USER CURRENT_ROLE CURRENT_AVAILABLE_ROLES CURRENT_ACCOUNT To determine the format to use as a string value, execute a query using the function. For example: The string value should be 'JSMITH' . Note that if specifying CURRENT_AVAILABLE_ROLES and multiple role values, such as ROLE1 and ROLE2 , enclose the list of roles in square brackets as follows: ['ROLE1', 'ROLE2']"
        },
        {
            "name": "arg_2",
            "description": "Specifies a comma-separated list of a context function and its value as a string. Optional."
        },
        {
            "name": "query",
            "description": "Specifies the SQL expression to query one or more tables or views. Required."
        }
    ]
},
{
    "function_name": "PIPE_USAGE_HISTORY",
    "summary": "This table function can be used to query the history of data loaded into Snowflake tables using Snowpipe within a specified date range.",
    "category": "Information Schema , Table functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/pipe_usage_history",
    "title": "PIPE_USAGE_HISTORY",
    "description": "This table function can be used to query the history of data loaded into Snowflake tables using",
    "syntax": "PIPE_USAGE_HISTORY(\n      [ DATE_RANGE_START => <constant_expr> ]\n      [, DATE_RANGE_END => <constant_expr> ]\n      [, PIPE_NAME => '<string>' ] )",
    "example": "select *\n  from table(information_schema.pipe_usage_history(\n    date_range_start=>to_timestamp_tz('2017-10-24 12:00:00.000 -0700'),\n    date_range_end=>to_timestamp_tz('2017-10-24 12:30:00.000 -0700')));\n\nselect *\n  from table(information_schema.pipe_usage_history(\n    date_range_start=>dateadd('day',-14,current_date()),\n    date_range_end=>current_date()));\n\nselect *\n  from table(information_schema.pipe_usage_history(\n    date_range_start=>dateadd('hour',-12,current_timestamp()),\n    pipe_name=>'mydb.public.mypipe'));\n\nselect *\n  from table(information_schema.pipe_usage_history(\n    date_range_start=>dateadd('day',-14,current_date()),\n    date_range_end=>current_date(),\n    pipe_name=>'mydb.public.mypipe'));",
    "arguments": [
        {
            "name": "DATE_RANGE_START",
            "description": "The date/time range, within the last 2 weeks, for which to retrieve the data load history: If an end date is not specified, then CURRENT_DATE is used as the end of the range. If a start date is not specified, then the range starts 10 minutes prior to the start of DATE_RANGE_END (i.e. the\ndefault is to show the previous 10 minutes of data load history). For example,\nif DATE_RANGE_END is CURRENT_DATE , then the default DATE_RANGE_START is 11:50 PM on the previous day. History is displayed in increments of 5 minutes, 1 hour, or 24 hours (depending on the length of the specified range). If the range falls outside the last 15 days, an error is returned."
        },
        {
            "name": "PIPE_NAME",
            "description": "A string specifying a pipe. Only data loads that use the specified pipe are returned. If a pipe name is not specified, then the PIPE_NAME column in the results displays NULL. Each row includes the totals for all pipes in use within the time range."
        }
    ]
},
{
    "function_name": "PI",
    "summary": "Returns the value of pi as a floating-point value.",
    "category": "Numeric functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/pi",
    "title": "PI",
    "description": "Returns the value of pi as a floating-point value.",
    "syntax": "PI()",
    "example": "SELECT PI();\n-------------+\n    PI()     |\n-------------+\n 3.141592654 |\n-------------+"
},
{
    "function_name": "PERCENTILE_DISC",
    "summary": "Returns a percentile value based on a discrete distribution of the input column (specified in order_by_expr).",
    "category": "Aggregate functions , Window functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/percentile_disc",
    "title": "PERCENTILE_DISC",
    "description": "Returns a percentile value based on a discrete distribution of the input\ncolumn (specified in",
    "syntax": "PERCENTILE_DISC( <percentile> ) WITHIN GROUP (ORDER BY <order_by_expr> )",
    "example": "create or replace table aggr(k int, v decimal(10,2));\ninsert into aggr (k, v) values\n    (0,  0),\n    (0, 10),\n    (0, 20),\n    (0, 30),\n    (0, 40),\n    (1, 10),\n    (1, 20),\n    (2, 10),\n    (2, 20),\n    (2, 25),\n    (2, 30),\n    (3, 60),\n    (4, NULL);\n\nselect k, percentile_disc(0.25) within group (order by v) \n  from aggr \n  group by k\n  order by k;\n+---+-------------------------------------------------+\n| K | PERCENTILE_DISC(0.25) WITHIN GROUP (ORDER BY V) |\n|---+-------------------------------------------------|\n| 0 |                                           10.00 |\n| 1 |                                           10.00 |\n| 2 |                                           10.00 |\n| 3 |                                           60.00 |\n| 4 |                                            NULL |\n+---+-------------------------------------------------+",
    "arguments": [
        {
            "name": "percentile",
            "description": "The percentile of the value that you want to find. The percentile must be a\nconstant between 0.0 and 1.0. For example, if you want to find the value\nat the 90th percentile, specify 0.9."
        },
        {
            "name": "order_by_expr",
            "description": "The expression (typically a column name) by which to order the values. For\nexample, if you want to want to find the student whose math SAT score is at\nthe 90th percentile, then specify the column containing the math SAT score. Note that this is also implicitly the column from which the returned value\nis chosen. For example, if you order by math SAT scores, then the result\nis one of the math SAT scores. You cannot order by one column and get\na percentile value for a different column."
        },
        {
            "name": "expr3",
            "description": "This is the optional expression used to group rows into partitions."
        }
    ],
    "returns": "Returns the value that is at the specified percentile."
},
{
    "function_name": "PERCENTILE_CONT",
    "summary": "Return a percentile value based on a continuous distribution of the input column (specified in order_by_expr).",
    "category": "Aggregate functions , Window functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/percentile_cont",
    "title": "PERCENTILE_CONT",
    "description": "Return a percentile value based on a continuous distribution of the input\ncolumn (specified in",
    "syntax": "PERCENTILE_CONT( <percentile> ) WITHIN GROUP (ORDER BY <order_by_expr>)",
    "example": "create or replace table aggr(k int, v decimal(10,2));\ninsert into aggr (k, v) values\n    (0,  0),\n    (0, 10),\n    (0, 20),\n    (0, 30),\n    (0, 40),\n    (1, 10),\n    (1, 20),\n    (2, 10),\n    (2, 20),\n    (2, 25),\n    (2, 30),\n    (3, 60),\n    (4, NULL);\n\nselect k, percentile_cont(0.25) within group (order by v) \n  from aggr \n  group by k\n  order by k;\n+---+-------------------------------------------------+\n| K | PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY V) |\n|---+-------------------------------------------------|\n| 0 |                                        10.00000 |\n| 1 |                                        12.50000 |\n| 2 |                                        17.50000 |\n| 3 |                                        60.00000 |\n| 4 |                                            NULL |\n+---+-------------------------------------------------+",
    "arguments": [
        {
            "name": "percentile",
            "description": "The percentile of the value that you want to find. The percentile must be a\nconstant between 0.0 and 1.0. For example, if you want to find the value\nat the 90th percentile, specify 0.9."
        },
        {
            "name": "order_by_expr",
            "description": "The expression (typically a column name) by which to order the values. For\nexample, if you want to want to find the student whose math SAT score is at\nthe 90th percentile, then specify the column containing the math SAT score. Note that this is also implicitly the column from which the returned value\nis chosen. For example, if you order by math SAT scores, then the result\nis one of the math SAT scores. You cannot order by one column and get\na percentile value for a different column."
        },
        {
            "name": "expr3",
            "description": "This is the optional expression used to group rows into partitions."
        }
    ],
    "returns": "Returns the value that is at the specified percentile. If no input row lies\nexactly at the desired percentile, the result is calculated using linear\ninterpolation of the two nearest input values."
},
{
    "function_name": "PERCENT_RANK",
    "summary": "Returns the relative rank of a value within a group of values, specified as a percentage ranging from 0.0 to 1.0.",
    "category": "Window functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/percent_rank",
    "title": "PERCENT_RANK",
    "description": "Returns the relative rank of a value within a group of values, specified as a percentage ranging from 0.0 to 1.0.",
    "syntax": "PERCENT_RANK()\n  OVER ( [ PARTITION BY <expr1> ] ORDER BY <expr2> [ { ASC | DESC } ] [ <fixedRangeFrame> ] )",
    "example": "SELECT\n    exchange,\n    symbol,\n    PERCENT_RANK() OVER (PARTITION BY exchange ORDER BY price) AS percent_rank\n  FROM trades;\n\n+--------+------+------------+\n|exchange|symbol|PERCENT_RANK|\n+--------+------+------------+\n|C       |SPY   |         0.0|\n|C       |AAPL  |         0.5|\n|C       |AAPL  |         1.0|\n|N       |YHOO  |         0.0|\n|N       |QQQ   |         0.2|\n|N       |QQQ   |         0.4|\n|N       |SPY   |         0.6|\n|N       |SPY   |         0.6|\n|N       |AAPL  |         1.0|\n|Q       |YHOO  |         0.0|\n|Q       |YHOO  |         0.2|\n|Q       |MSFT  |         0.4|\n|Q       |MSFT  |         0.6|\n|Q       |QQQ   |         0.8|\n|Q       |QQQ   |         1.0|\n|P       |YHOO  |         0.0|\n|P       |MSFT  |        0.25|\n|P       |MSFT  |         0.5|\n|P       |SPY   |        0.75|\n|P       |AAPL  |         1.0|\n+--------+------+------------+"
},
{
    "function_name": "PARSE_XML",
    "summary": "Interprets an input string as an XML document, producing an OBJECT value.",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/parse_xml",
    "title": "PARSE_XML",
    "description": "Interprets an input string as an",
    "syntax": "PARSE_XML( <string_containing_xml> [ , <disable_auto_convert> ] )",
    "example": "CREATE OR REPLACE TABLE xtab (v OBJECT);\n\nINSERT INTO xtab SELECT PARSE_XML(column1) AS v\n  FROM VALUES ('<a/>'), ('<a attr=\"123\">text</a>'), ('<a><b>X</b><b>Y</b></a>');\n\nSELECT * FROM xtab;\n\n+------------------------+\n| V                      |\n|------------------------|\n| <a></a>                |\n| <a attr=\"123\">text</a> |\n| <a>                    |\n|   <b>X</b>             |\n|   <b>Y</b>             |\n| </a>                   |\n+------------------------+\n\nSELECT PARSE_XML('<test>22257e111</test>'), PARSE_XML('<test>22257e111</test>', TRUE);\n\n+-------------------------------------+-------------------------------------------+\n| PARSE_XML('<TEST>22257E111</TEST>') | PARSE_XML('<TEST>22257E111</TEST>', TRUE) |\n|-------------------------------------+-------------------------------------------|\n| <test>2.225700000000000e+115</test> | <test>22257e111</test>                    |\n+-------------------------------------+-------------------------------------------+\n\nSELECT PARSE_XML(STR => '<test>22257e111</test>', DISABLE_AUTO_CONVERT => TRUE);\n\n+--------------------------------------------------------------------------+\n| PARSE_XML(STR => '<TEST>22257E111</TEST>', DISABLE_AUTO_CONVERT => TRUE) |\n|--------------------------------------------------------------------------|\n| <test>22257e111</test>                                                   |\n+--------------------------------------------------------------------------+",
    "arguments": [
        {
            "name": "string_containing_xml",
            "description": "Specify an expression that evaluates to a VARCHAR value that contains valid XML."
        },
        {
            "name": "disable_auto_convert",
            "description": "A Boolean expression that specifies whether or not the function should attempt to convert numeric and Boolean values in string_containing_xml to Snowflake data types. (For details about this conversion, see Usage Notes below.) If you don’t want the function to convert these values, set this argument to TRUE . This setting\nhas an effect that is similar to the DISABLE_AUTO_CONVERT parameter in CREATE FILE FORMAT . If you want the function to convert these values, set this argument to FALSE or omit this argument. Default: FALSE"
        }
    ],
    "returns": "The data type of the returned value is OBJECT. The OBJECT contains an internal representation of the XML."
},
{
    "function_name": "PARSE_URL",
    "summary": "Returns an OBJECT value that consists of all the components (fragment, host, parameters, path, port, query, scheme) in a valid input URL/URI.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/parse_url",
    "title": "PARSE_URL",
    "description": "Returns an",
    "syntax": "PARSE_URL(<string>, [<permissive>])",
    "example": "CREATE OR REPLACE TABLE parse_url_test (id INT, sample_url VARCHAR);\n\nINSERT INTO parse_url_test VALUES\n  (1, 'mailto:abc@xyz.com'),\n  (2, 'https://www.snowflake.com/'),\n  (3, 'http://USER:PASS@EXAMPLE.INT:4345/HELLO.PHP?USER=1'),\n  (4, NULL);\n\nSELECT * FROM parse_url_test;\n\n+----+----------------------------------------------------+\n| ID | SAMPLE_URL                                         |\n|----+----------------------------------------------------|\n|  1 | mailto:abc@xyz.com                                 |\n|  2 | https://www.snowflake.com/                         |\n|  3 | http://USER:PASS@EXAMPLE.INT:4345/HELLO.PHP?USER=1 |\n|  4 | NULL                                               |\n+----+----------------------------------------------------+\n\nSELECT PARSE_URL(sample_url) FROM parse_url_test;\n\n+------------------------------------+\n| PARSE_URL(SAMPLE_URL)              |\n|------------------------------------|\n| {                                  |\n|   \"fragment\": null,                |\n|   \"host\": null,                    |\n|   \"parameters\": null,              |\n|   \"path\": \"abc@xyz.com\",           |\n|   \"port\": null,                    |\n|   \"query\": null,                   |\n|   \"scheme\": \"mailto\"               |\n| }                                  |\n| {                                  |\n|   \"fragment\": null,                |\n|   \"host\": \"www.snowflake.com\",     |\n|   \"parameters\": null,              |\n|   \"path\": \"\",                      |\n|   \"port\": null,                    |\n|   \"query\": null,                   |\n|   \"scheme\": \"https\"                |\n| }                                  |\n| {                                  |\n|   \"fragment\": null,                |\n|   \"host\": \"USER:PASS@EXAMPLE.INT\", |\n|   \"parameters\": {                  |\n|     \"USER\": \"1\"                    |\n|   },                               |\n|   \"path\": \"HELLO.PHP\",             |\n|   \"port\": \"4345\",                  |\n|   \"query\": \"USER=1\",               |\n|   \"scheme\": \"http\"                 |\n| }                                  |\n| NULL                               |\n+------------------------------------+\n\nSELECT PARSE_URL(sample_url):host FROM parse_url_test;\n\n+----------------------------+\n| PARSE_URL(SAMPLE_URL):HOST |\n|----------------------------|\n| null                       |\n| \"www.snowflake.com\"        |\n| \"USER:PASS@EXAMPLE.INT\"    |\n| NULL                       |\n+----------------------------+\n\nSELECT *\n  FROM parse_url_test\n  WHERE PARSE_URL(sample_url):port = '4345';\n\n+----+----------------------------------------------------+\n| ID | SAMPLE_URL                                         |\n|----+----------------------------------------------------|\n|  3 | http://USER:PASS@EXAMPLE.INT:4345/HELLO.PHP?USER=1 |\n+----+----------------------------------------------------+\n\nSELECT *\n  FROM parse_url_test\n  WHERE PARSE_URL(sample_url):host = 'www.snowflake.com';\n\n+----+----------------------------+\n| ID | SAMPLE_URL                 |\n|----+----------------------------|\n|  2 | https://www.snowflake.com/ |\n+----+----------------------------+\n\nSELECT PARSE_URL('example.int/hello.php?user=12#nofragment', 0);\n\n100139 (22000): Error parsing URL: scheme not specified\n\nSELECT PARSE_URL('example.int/hello.php?user=12#nofragment', 1);\n\n+----------------------------------------------------------+\n| PARSE_URL('EXAMPLE.INT/HELLO.PHP?USER=12#NOFRAGMENT', 1) |\n|----------------------------------------------------------|\n| {                                                        |\n|   \"error\": \"scheme not specified\"                        |\n| }                                                        |\n+----------------------------------------------------------+",
    "arguments": [
        {
            "name": "string",
            "description": "String to parse."
        },
        {
            "name": "permissive",
            "description": "Flag that determines how parse errors are handled: If set to 0 , parse errors cause the function to fail. If set to 1 , parse errors result in an object with the error field set to the respective error message (and no other fields set). Default value is 0 ."
        }
    ],
    "returns": "The function returns a value of type OBJECT."
},
{
    "function_name": "PARSE_JSON",
    "summary": "Interprets an input string as a JSON document, producing a VARIANT value.",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/parse_json",
    "title": "PARSE_JSON",
    "description": "Interprets an input string as a JSON document, producing a",
    "syntax": "PARSE_JSON( <expr> [ , '<parameter>' ] )",
    "example": "CREATE OR REPLACE TABLE vartab (n NUMBER(2), v VARIANT);\n\nINSERT INTO vartab\n  SELECT column1 AS n, PARSE_JSON(column2) AS v\n    FROM VALUES (1, 'null'), \n                (2, null), \n                (3, 'true'),\n                (4, '-17'), \n                (5, '123.12'), \n                (6, '1.912e2'),\n                (7, '\"Om ara pa ca na dhih\"  '), \n                (8, '[-1, 12, 289, 2188, false,]'), \n                (9, '{ \"x\" : \"abc\", \"y\" : false, \"z\": 10} ') \n       AS vals;\n\nSELECT n, v, TYPEOF(v)\n  FROM vartab\n  ORDER BY n;\n\n+---+------------------------+------------+\n| N | V                      | TYPEOF(V)  |\n|---+------------------------+------------|\n| 1 | null                   | NULL_VALUE |\n| 2 | NULL                   | NULL       |\n| 3 | true                   | BOOLEAN    |\n| 4 | -17                    | INTEGER    |\n| 5 | 123.12                 | DECIMAL    |\n| 6 | 1.912000000000000e+02  | DOUBLE     |\n| 7 | \"Om ara pa ca na dhih\" | VARCHAR    |\n| 8 | [                      | ARRAY      |\n|   |   -1,                  |            |\n|   |   12,                  |            |\n|   |   289,                 |            |\n|   |   2188,                |            |\n|   |   false,               |            |\n|   |   undefined            |            |\n|   | ]                      |            |\n| 9 | {                      | OBJECT     |\n|   |   \"x\": \"abc\",          |            |\n|   |   \"y\": false,          |            |\n|   |   \"z\": 10              |            |\n|   | }                      |            |\n+---+------------------------+------------+\n\nINSERT INTO vartab\nSELECT column1 AS n, PARSE_JSON(column2) AS v\n  FROM VALUES (10, '{ \"a\" : \"123\", \"b\" : \"456\", \"a\": \"789\"} ')\n     AS vals;\n\n100069 (22P02): Error parsing JSON: duplicate object attribute \"a\", pos 31\n\nINSERT INTO vartab\nSELECT column1 AS n, PARSE_JSON(column2, 'd') AS v\n  FROM VALUES (10, '{ \"a\" : \"123\", \"b\" : \"456\", \"a\": \"789\"} ')\n     AS vals;\n\n+-------------------------+\n| number of rows inserted |\n|-------------------------|\n|                       1 |\n+-------------------------+\n\nSELECT v\n  FROM vartab\n  WHERE n = 10;\n\n+---------------+\n| V             |\n|---------------|\n| {             |\n|   \"a\": \"789\", |\n|   \"b\": \"456\"  |\n| }             |\n+---------------+\n\nSELECT TO_JSON(NULL), TO_JSON('null'::VARIANT),\n       PARSE_JSON(NULL), PARSE_JSON('null');\n\n+---------------+--------------------------+------------------+--------------------+\n| TO_JSON(NULL) | TO_JSON('NULL'::VARIANT) | PARSE_JSON(NULL) | PARSE_JSON('NULL') |\n|---------------+--------------------------+------------------+--------------------|\n| NULL          | \"null\"                   | NULL             | null               |\n+---------------+--------------------------+------------------+--------------------+\n\nCREATE OR REPLACE TABLE jdemo2 (\n  varchar1 VARCHAR, \n  variant1 VARIANT);\n\nINSERT INTO jdemo2 (varchar1) VALUES ('{\"PI\":3.14}');\n\nUPDATE jdemo2 SET variant1 = PARSE_JSON(varchar1);\n\nSELECT varchar1, \n       PARSE_JSON(varchar1), \n       variant1, \n       TO_JSON(variant1),\n       PARSE_JSON(varchar1) = variant1, \n       TO_JSON(variant1) = varchar1\n  FROM jdemo2;\n\n+-------------+----------------------+--------------+-------------------+---------------------------------+------------------------------+\n| VARCHAR1    | PARSE_JSON(VARCHAR1) | VARIANT1     | TO_JSON(VARIANT1) | PARSE_JSON(VARCHAR1) = VARIANT1 | TO_JSON(VARIANT1) = VARCHAR1 |\n|-------------+----------------------+--------------+-------------------+---------------------------------+------------------------------|\n| {\"PI\":3.14} | {                    | {            | {\"PI\":3.14}       | True                            | True                         |\n|             |   \"PI\": 3.14         |   \"PI\": 3.14 |                   |                                 |                              |\n|             | }                    | }            |                   |                                 |                              |\n+-------------+----------------------+--------------+-------------------+---------------------------------+------------------------------+\n\nSELECT TO_JSON(PARSE_JSON('{\"b\":1,\"a\":2}')),\n       TO_JSON(PARSE_JSON('{\"b\":1,\"a\":2}')) = '{\"b\":1,\"a\":2}',\n       TO_JSON(PARSE_JSON('{\"b\":1,\"a\":2}')) = '{\"a\":2,\"b\":1}';\n\n+--------------------------------------+--------------------------------------------------------+--------------------------------------------------------+\n| TO_JSON(PARSE_JSON('{\"B\":1,\"A\":2}')) | TO_JSON(PARSE_JSON('{\"B\":1,\"A\":2}')) = '{\"B\":1,\"A\":2}' | TO_JSON(PARSE_JSON('{\"B\":1,\"A\":2}')) = '{\"A\":2,\"B\":1}' |\n|--------------------------------------+--------------------------------------------------------+--------------------------------------------------------|\n| {\"a\":2,\"b\":1}                        | False                                                  | True                                                   |\n+--------------------------------------+--------------------------------------------------------+--------------------------------------------------------+\n\nCREATE OR REPLACE TABLE jdemo3 (\n  variant1 VARIANT,\n  variant2 VARIANT);\n\nINSERT INTO jdemo3 (variant1, variant2)\n  SELECT\n    PARSE_JSON('{\"PI\":3.14}'),\n    TO_VARIANT('{\"PI\":3.14}');\n\nSELECT variant1,\n       TYPEOF(variant1),\n       variant2,\n       TYPEOF(variant2),\n       variant1 = variant2\n  FROM jdemo3;\n\n+--------------+------------------+-----------------+------------------+---------------------+\n| VARIANT1     | TYPEOF(VARIANT1) | VARIANT2        | TYPEOF(VARIANT2) | VARIANT1 = VARIANT2 |\n|--------------+------------------+-----------------+------------------+---------------------|\n| {            | OBJECT           | \"{\\\"PI\\\":3.14}\" | VARCHAR          | False               |\n|   \"PI\": 3.14 |                  |                 |                  |                     |\n| }            |                  |                 |                  |                     |\n+--------------+------------------+-----------------+------------------+---------------------+",
    "arguments": [
        {
            "name": "expr",
            "description": "An expression of string type (for example, VARCHAR) that holds valid JSON information."
        },
        {
            "name": "'",
            "description": "String constant that specifies the parameter used to search for matches. Supported values: Parameter Description d Allow duplicate keys in JSON objects. If a JSON object contains a duplicate key, the returned object has a single instance\nof that key with the last value specified for that key. s Don’t allow duplicate keys in JSON objects (strict). This value is the default."
        }
    ],
    "returns": "Returns a value of type VARIANT that contains a JSON document."
},
{
    "function_name": "PARSE_IP",
    "summary": "Returns a JSON object consisting of all the components from a valid INET (Internet Protocol) or CIDR (Classless Internet Domain Routing) IPv4 or IPv6 string.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/parse_ip",
    "title": "PARSE_IP",
    "description": "Returns a JSON object consisting of all the components from a valid INET (Internet Protocol) or CIDR (Classless Internet Domain Routing) IPv4 or IPv6 string.",
    "syntax": "PARSE_IP(<expr>, '<type>' [, <permissive>])",
    "example": "SELECT column1, PARSE_IP(column1, 'INET') FROM VALUES('192.168.242.188/24'), ('192.168.243.189/24');\n--------------------+-----------------------------------+\n COLUMN1            | PARSE_IP(COLUMN1, 'INET')         |\n--------------------+-----------------------------------|\n 192.168.242.188/24 | {                                 |\n                    |   \"family\": 4,                    |\n                    |   \"host\": \"192.168.242.188\",      |\n                    |   \"ip_fields\": [                  |\n                    |     3232297660,                   |\n                    |     0,                            |\n                    |     0,                            |\n                    |     0                             |\n                    |   ],                              |\n                    |   \"ip_type\": \"inet\",              |\n                    |   \"ipv4\": 3232297660,             |\n                    |   \"ipv4_range_end\": 3232297727,   |\n                    |   \"ipv4_range_start\": 3232297472, |\n                    |   \"netmask_prefix_length\": 24,    |\n                    |   \"snowflake$type\": \"ip_address\"  |\n                    | }                                 |\n 192.168.243.189/24 | {                                 |\n                    |   \"family\": 4,                    |\n                    |   \"host\": \"192.168.243.189\",      |\n                    |   \"ip_fields\": [                  |\n                    |     3232297917,                   |\n                    |     0,                            |\n                    |     0,                            |\n                    |     0                             |\n                    |   ],                              |\n                    |   \"ip_type\": \"inet\",              |\n                    |   \"ipv4\": 3232297917,             |\n                    |   \"ipv4_range_end\": 3232297983,   |\n                    |   \"ipv4_range_start\": 3232297728, |\n                    |   \"netmask_prefix_length\": 24,    |\n                    |   \"snowflake$type\": \"ip_address\"  |\n                    | }                                 |\n--------------------+-----------------------------------+\n\nSELECT PARSE_IP('fe80::20c:29ff:fe2c:429/64', 'INET');\n\n----------------------------------------------------------------+\n  PARSE_IP('FE80::20C:29FF:FE2C:429/64', 'INET')                |\n----------------------------------------------------------------|\n  {                                                             |\n    \"family\": 6,                                                |\n    \"hex_ipv6\": \"FE80000000000000020C29FFFE2C0429\",             |\n    \"hex_ipv6_range_end\": \"FE80000000000000FFFFFFFFFFFFFFFF\",   |\n    \"hex_ipv6_range_start\": \"FE800000000000000000000000000000\", |\n    \"host\": \"fe80::20c:29ff:fe2c:429\",                          |\n    \"ip_fields\": [                                              |\n      4269801472,                                               |\n      0,                                                        |\n      34351615,                                                 |\n      4264297513                                                |\n    ],                                                          |\n    \"ip_type\": \"inet\",                                          |\n    \"netmask_prefix_length\": 64,                                |\n    \"snowflake$type\": \"ip_address\"                              |\n  }                                                             |\n----------------------------------------------------------------+\n\nWITH\nlookup AS (\n  SELECT column1 AS tag, PARSE_IP(column2, 'INET') AS obj FROM VALUES('San Francisco', '192.168.242.0/24'), ('New York', '192.168.243.0/24')\n),\nentries AS (\n  SELECT PARSE_IP(column1, 'INET') AS ipv4 FROM VALUES('192.168.242.188/24'), ('192.168.243.189/24')\n)\nSELECT lookup.tag, entries.ipv4:host, entries.ipv4\nFROM lookup, entries\nWHERE lookup.tag = 'San Francisco'\nAND entries.IPv4:ipv4 BETWEEN lookup.obj:ipv4_range_start AND lookup.obj:ipv4_range_end;\n\n---------------+-------------------+-----------------------------------+\n TAG           | ENTRIES.IPV4:HOST | IPV4                              |\n---------------+-------------------+-----------------------------------|\n San Francisco | \"192.168.242.188\" | {                                 |\n               |                   |   \"family\": 4,                    |\n               |                   |   \"host\": \"192.168.242.188\",      |\n               |                   |   \"ip_fields\": [                  |\n               |                   |     3232297660,                   |\n               |                   |     0,                            |\n               |                   |     0,                            |\n               |                   |     0                             |\n               |                   |   ],                              |\n               |                   |   \"ip_type\": \"inet\",              |\n               |                   |   \"ipv4\": 3232297660,             |\n               |                   |   \"ipv4_range_end\": 3232297727,   |\n               |                   |   \"ipv4_range_start\": 3232297472, |\n               |                   |   \"netmask_prefix_length\": 24,    |\n               |                   |   \"snowflake$type\": \"ip_address\"  |\n               |                   | }                                 |\n---------------+-------------------+-----------------------------------+\n\nCREATE OR REPLACE TABLE ipv6_lookup (tag String, obj VARIANT);\n\n-----------------------------------------+\n status                                  |\n-----------------------------------------|\n Table IPV6_LOOKUP successfully created. |\n-----------------------------------------+\n\nINSERT INTO ipv6_lookup\n    SELECT column1 AS tag, parse_ip(column2, 'INET') AS obj\n    FROM VALUES('west', 'fe80:12:20c:29ff::/64'), ('east', 'fe80:12:1:29ff::/64');\n\n-------------------------+\n number of rows inserted |\n-------------------------|\n                       2 |\n-------------------------+\n\nCREATE OR REPLACE TABLE ipv6_entries (obj VARIANT);\n------------------------------------------+\n status                                   |\n------------------------------------------|\n Table IPV6_ENTRIES successfully created. |\n------------------------------------------+\n\nINSERT INTO ipv6_entries\n    SELECT parse_ip(column1, 'INET') as obj\n    FROM VALUES\n        ('fe80:12:20c:29ff:fe2c:430:370:2/64'),\n        ('fe80:12:20c:29ff:fe2c:430:370:00F0/64'),\n        ('fe80:12:20c:29ff:fe2c:430:370:0F00/64'),\n        ('fe80:12:20c:29ff:fe2c:430:370:F000/64'),\n        ('fe80:12:20c:29ff:fe2c:430:370:FFFF/64'),\n        ('fe80:12:1:29ff:fe2c:430:370:FFFF/64'),\n        ('fe80:12:1:29ff:fe2c:430:370:F000/64'),\n        ('fe80:12:1:29ff:fe2c:430:370:0F00/64'),\n        ('fe80:12:1:29ff:fe2c:430:370:00F0/64'),\n        ('fe80:12:1:29ff:fe2c:430:370:2/64');\n\n-------------------------+\n number of rows inserted |\n-------------------------|\n                      10 |\n-------------------------+\n\nSELECT lookup.tag, entries.obj:host\n    FROM ipv6_lookup AS lookup, ipv6_entries AS entries\n    WHERE lookup.tag = 'east'\n    AND entries.obj:hex_ipv6 BETWEEN lookup.obj:hex_ipv6_range_start AND lookup.obj:hex_ipv6_range_end;\n\n------+------------------------------------+\n TAG  | ENTRIES.OBJ:HOST                   |\n------+------------------------------------|\n east | \"fe80:12:1:29ff:fe2c:430:370:FFFF\" |\n east | \"fe80:12:1:29ff:fe2c:430:370:F000\" |\n east | \"fe80:12:1:29ff:fe2c:430:370:0F00\" |\n east | \"fe80:12:1:29ff:fe2c:430:370:00F0\" |\n east | \"fe80:12:1:29ff:fe2c:430:370:2\"    |\n------+------------------------------------+",
    "arguments": [
        {
            "name": "expr",
            "description": "A string expression."
        },
        {
            "name": "type",
            "description": "A string that identifies the type of IP address. Supports either INET or CIDR ; the value is\ncase-insensitive."
        },
        {
            "name": "permissive",
            "description": "Flag that determines how parse errors are handled: If set to 0, parse errors cause the function to fail. If set to 1, parse errors result in an object with the error field set to the respective error message (and no other fields set). Default value is 0."
        }
    ],
    "returns": "OBJECT."
},
{
    "function_name": "PARSE_DOCUMENT (SNOWFLAKE.CORTEX)",
    "summary": "Returns the extracted content from a document on a Snowflake stage as an OBJECT that contains JSON-encoded objects as strings.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/parse_document-snowflake-cortex",
    "title": "PARSE_DOCUMENT (SNOWFLAKE.CORTEX)",
    "syntax": "SNOWFLAKE.CORTEX.PARSE_DOCUMENT( '@<stage>', '<path>', [ { 'mode': '<mode>' }, ] )",
    "example": "SELECT TO_VARCHAR(\n    SNOWFLAKE.CORTEX.PARSE_DOCUMENT(\n        '@PARSE_DOCUMENT.DEMO.documents',\n        'document_1.pdf',\n        {'mode': 'OCR'})\n    ) AS OCR;\n\n{\n    \"content\": \"content of the document\"\n}\n\nSELECT\n  TO_VARCHAR (\n    SNOWFLAKE.CORTEX.PARSE_DOCUMENT (\n        '@PARSE_DOCUMENT.DEMO.documents',\n        'document_1.pdf',\n        {'mode': 'LAYOUT'} ) ) AS LAYOUT;\n\n{\n  \"content\": \"# This is PARSE DOCUMENT example\n     Example table:\n     |Header|Second header|Third Header|\n     |:---:|:---:|:---:|\n     |First row header|Data in first row|Data in first row|\n     |Second row header|Data in second row|Data in second row|\n\n     Some more text.\"\n }",
    "arguments": [
        {
            "name": "stage",
            "description": "Name of the Snowflake stage."
        },
        {
            "name": "path",
            "description": "Relative path to the document on the Snowflake stage."
        },
        {
            "name": "mode",
            "description": "Returns a value of the type OBJECT. In the object, the value for the key content contains the extracted data as a JSON-encoded\nstring. The data can either be formatted or in plain text, depending on the mode specified in the call: If mode is LAYOUT , the data is markdown with structural content including tables. If mode is OCR , the data is the text content. Default: 'OCR'"
        }
    ],
    "returns": "An OBJECT data type that contains the extracted data. The content depends on the mode used in the call:"
},
{
    "function_name": "OCTET_LENGTH",
    "summary": "Returns the length of a string or binary value in bytes.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/octet_length",
    "title": "OCTET_LENGTH",
    "description": "Returns the length of a string or binary value in bytes. This will be the same as LENGTH for ASCII strings and greater than\nLENGTH for strings using Unicode code points. For binary, this is always the same as LENGTH.",
    "syntax": "OCTET_LENGTH(<string_or_binary>)",
    "example": "SELECT OCTET_LENGTH('abc'), OCTET_LENGTH('\\u0392'), OCTET_LENGTH(X'A1B2');\n\n---------------------+------------------------+-----------------------+\n OCTET_LENGTH('ABC') | OCTET_LENGTH('\\U0392') | OCTET_LENGTH(X'A1B2') |\n---------------------+------------------------+-----------------------+\n 3                   | 2                      | 2                     |\n---------------------+------------------------+-----------------------+",
    "arguments": [
        {
            "name": "string_or_binary",
            "description": "The string or binary value for which the length is returned."
        }
    ]
},
{
    "function_name": "OBJECT_PICK",
    "summary": "Returns a new OBJECT containing some of the key-value pairs from an existing object.",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/object_pick",
    "title": "OBJECT_PICK",
    "description": "Returns a new",
    "syntax": "OBJECT_PICK( <object>, <key1> [, <key2>, ... ] )\n\nOBJECT_PICK( <object>, <array> )",
    "example": "SELECT OBJECT_PICK(\n    OBJECT_CONSTRUCT(\n        'a', 1,\n        'b', 2,\n        'c', 3\n    ),\n    'a', 'b'\n) AS new_object;\n+------------+\n| NEW_OBJECT |\n|------------|\n| {          |\n|   \"a\": 1,  |\n|   \"b\": 2   |\n| }          |\n+------------+\n\nSELECT OBJECT_PICK(\n    OBJECT_CONSTRUCT(\n        'a', 1,\n        'b', 2,\n        'c', 3\n    ),\n    ARRAY_CONSTRUCT('a', 'b')\n) AS new_object;\n+------------+\n| NEW_OBJECT |\n|------------|\n| {          |\n|   \"a\": 1,  |\n|   \"b\": 2   |\n| }          |\n+------------+",
    "arguments": [
        {
            "name": "object",
            "description": "The input object."
        },
        {
            "name": "key1",
            "description": "One or more keys identifying the key-value pairs that should be included in the returned object."
        },
        {
            "name": "array",
            "description": "Array of keys identifying the key-value pairs that should be included in the returned object."
        }
    ],
    "returns": "Returns a new OBJECT containing the specified key-value pairs."
},
{
    "function_name": "OBJECT_KEYS",
    "summary": "Returns an array containing the list of keys in the top-most level of the input object.",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/object_keys",
    "title": "OBJECT_KEYS",
    "description": "Returns an array containing the list of keys in the top-most level of the input object.",
    "syntax": "OBJECT_KEYS( <object> )",
    "example": "CREATE TABLE objects_1 (id INTEGER, object1 OBJECT, variant1 VARIANT);\n\nINSERT INTO objects_1 (id, object1, variant1) \n  SELECT\n    1,\n    OBJECT_CONSTRUCT('a', 1, 'b', 2, 'c', 3),\n    TO_VARIANT(OBJECT_CONSTRUCT('a', 1, 'b', 2, 'c', 3))\n    ;\n\nSELECT OBJECT_KEYS(object1), OBJECT_KEYS(variant1) \n    FROM objects_1\n    ORDER BY id;\n+----------------------+-----------------------+\n| OBJECT_KEYS(OBJECT1) | OBJECT_KEYS(VARIANT1) |\n|----------------------+-----------------------|\n| [                    | [                     |\n|   \"a\",               |   \"a\",                |\n|   \"b\",               |   \"b\",                |\n|   \"c\"                |   \"c\"                 |\n| ]                    | ]                     |\n+----------------------+-----------------------+\n\nSELECT OBJECT_KEYS (\n           PARSE_JSON (\n               '{\n                    \"level_1_A\": {\n                                 \"level_2\": \"two\"\n                                 },\n                    \"level_1_B\": \"one\"\n                    }'\n               )\n           ) AS keys\n    ORDER BY 1;\n+----------------+\n| KEYS           |\n|----------------|\n| [              |\n|   \"level_1_A\", |\n|   \"level_1_B\"  |\n| ]              |\n+----------------+",
    "arguments": [
        {
            "name": "object",
            "description": "The value for which you want the keys. The input value must be one of the following: An OBJECT . A VARIANT that contains a value of type OBJECT."
        }
    ],
    "returns": "The function returns an ARRAY containing the keys."
},
{
    "function_name": "OBJECT_INSERT",
    "summary": "Returns an OBJECT value consisting of the input OBJECT value with a new key-value pair inserted (or an existing key updated with a new value).",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/object_insert",
    "title": "OBJECT_INSERT",
    "description": "Returns an",
    "syntax": "OBJECT_INSERT( <object> , <key> , <value> [ , <updateFlag> ] )",
    "example": "CREATE OR REPLACE TABLE object_insert_examples (object_column OBJECT);\n\nINSERT INTO object_insert_examples (object_column)\n  SELECT OBJECT_CONSTRUCT('a', 'value1', 'b', 'value2');\n\nSELECT * FROM object_insert_examples;\n\n+------------------+\n| OBJECT_COLUMN    |\n|------------------|\n| {                |\n|   \"a\": \"value1\", |\n|   \"b\": \"value2\"  |\n| }                |\n+------------------+\n\nUPDATE object_insert_examples\n  SET object_column = OBJECT_INSERT(object_column, 'c', 'value3');\n\nSELECT * FROM object_insert_examples;\n\n+------------------+\n| OBJECT_COLUMN    |\n|------------------|\n| {                |\n|   \"a\": \"value1\", |\n|   \"b\": \"value2\", |\n|   \"c\": \"value3\"  |\n| }                |\n+------------------+\n\nUPDATE object_insert_examples\n  SET object_column = OBJECT_INSERT(object_column, 'd', PARSE_JSON('null'));\n\nUPDATE object_insert_examples\n  SET object_column = OBJECT_INSERT(object_column, 'e', NULL);\n\nUPDATE object_insert_examples\n  SET object_column = OBJECT_INSERT(object_column, 'f', 'null');\n\nSELECT * FROM object_insert_examples;\n\n+------------------+\n| OBJECT_COLUMN    |\n|------------------|\n| {                |\n|   \"a\": \"value1\", |\n|   \"b\": \"value2\", |\n|   \"c\": \"value3\", |\n|   \"d\": null,     |\n|   \"f\": \"null\"    |\n| }                |\n+------------------+\n\nUPDATE object_insert_examples\n  SET object_column = OBJECT_INSERT(object_column, 'b', 'valuex', TRUE);\n\nSELECT * FROM object_insert_examples;\n\n+------------------+\n| OBJECT_COLUMN    |\n|------------------|\n| {                |\n|   \"a\": \"value1\", |\n|   \"b\": \"valuex\", |\n|   \"c\": \"value3\", |\n|   \"d\": null,     |\n|   \"f\": \"null\"    |\n| }                |\n+------------------+",
    "arguments": [
        {
            "name": "object",
            "description": "The source OBJECT value into which the new key-value pair is inserted or in which an existing key-value pair is updated."
        },
        {
            "name": "key",
            "description": "The new key to be inserted into the OBJECT value or an existing key whose value is being updated. The specified key must\nbe different from all existing keys in the OBJECT value, unless updateFlag is set to TRUE."
        },
        {
            "name": "value",
            "description": "The value associated with the key."
        },
        {
            "name": "updateFlag",
            "description": "A Boolean flag that, when set to TRUE, specifies that the input value updates the value of an existing key in the\nOBJECT value, rather than inserting a new key-value pair. The default is FALSE."
        }
    ],
    "returns": "This function returns a value that has the OBJECT data type."
},
{
    "function_name": "OBJECT_DELETE",
    "summary": "Returns an object containing the contents of the input (that is, source) object with one or more keys removed.",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/object_delete",
    "title": "OBJECT_DELETE",
    "description": "Returns an object containing the contents of the input (that is, source) object with\none or more keys removed.",
    "syntax": "OBJECT_DELETE( <object>, <key1> [, <key2>, ... ] )",
    "example": "SELECT OBJECT_DELETE(OBJECT_CONSTRUCT('a', 1, 'b', 2, 'c', 3), 'a', 'b') AS object_returned;\n\n+-----------------+\n| OBJECT_RETURNED |\n|-----------------|\n| {               |\n|   \"c\": 3        |\n| }               |\n+-----------------+\n\nCREATE OR REPLACE TABLE object_delete_example (\n  id INTEGER,\n  ov OBJECT);\n\nINSERT INTO object_delete_example (id, ov)\n  SELECT\n    1,\n    {\n      'employee_id': 1001,\n      'employee_date_of_birth': '12-10-2003',\n      'employee_contact':\n        {\n          'city': 'San Mateo',\n          'state': 'CA',\n          'phone': '800-555‑0100'\n        }\n    };\n\nINSERT INTO object_delete_example (id, ov)\n  SELECT\n    2,\n    {\n      'employee_id': 1002,\n      'employee_date_of_birth': '01-01-1990',\n      'employee_contact':\n        {\n          'city': 'Seattle',\n          'state': 'WA',\n          'phone': '800-555‑0101'\n        }\n    };\n\nSELECT * FROM object_delete_example;\n\n+----+-------------------------------------------+\n| ID | OV                                        |\n|----+-------------------------------------------|\n|  1 | {                                         |\n|    |   \"employee_contact\": {                   |\n|    |     \"city\": \"San Mateo\",                  |\n|    |     \"phone\": \"800-555‑0100\",              |\n|    |     \"state\": \"CA\"                         |\n|    |   },                                      |\n|    |   \"employee_date_of_birth\": \"12-10-2003\", |\n|    |   \"employee_id\": 1001                     |\n|    | }                                         |\n|  2 | {                                         |\n|    |   \"employee_contact\": {                   |\n|    |     \"city\": \"Seattle\",                    |\n|    |     \"phone\": \"800-555‑0101\",              |\n|    |     \"state\": \"WA\"                         |\n|    |   },                                      |\n|    |   \"employee_date_of_birth\": \"01-01-1990\", |\n|    |   \"employee_id\": 1002                     |\n|    | }                                         |\n+----+-------------------------------------------+\n\nSELECT id,\n       OBJECT_DELETE(ov, 'employee_date_of_birth') AS contact_without_date_of_birth\n  FROM object_delete_example;\n\n+----+-------------------------------+\n| ID | CONTACT_WITHOUT_DATE_OF_BIRTH |\n|----+-------------------------------|\n|  1 | {                             |\n|    |   \"employee_contact\": {       |\n|    |     \"city\": \"San Mateo\",      |\n|    |     \"phone\": \"800-555‑0100\",  |\n|    |     \"state\": \"CA\"             |\n|    |   },                          |\n|    |   \"employee_id\": 1001         |\n|    | }                             |\n|  2 | {                             |\n|    |   \"employee_contact\": {       |\n|    |     \"city\": \"Seattle\",        |\n|    |     \"phone\": \"800-555‑0101\",  |\n|    |     \"state\": \"WA\"             |\n|    |   },                          |\n|    |   \"employee_id\": 1002         |\n|    | }                             |\n+----+-------------------------------+\n\nSELECT id,\n       OBJECT_DELETE(ov:\"employee_contact\", 'phone') AS contact_without_phone\n  FROM object_delete_example;\n\n+----+------------------------+\n| ID | CONTACT_WITHOUT_PHONE  |\n|----+------------------------|\n|  1 | {                      |\n|    |   \"city\": \"San Mateo\", |\n|    |   \"state\": \"CA\"        |\n|    | }                      |\n|  2 | {                      |\n|    |   \"city\": \"Seattle\",   |\n|    |   \"state\": \"WA\"        |\n|    | }                      |\n+----+------------------------+",
    "arguments": [
        {
            "name": "object",
            "description": "The source object."
        },
        {
            "name": "key1",
            "description": "Key to be omitted from the returned object."
        }
    ],
    "returns": "This function returns a value of type OBJECT."
},
{
    "function_name": "OBJECT_CONSTRUCT_KEEP_NULL",
    "summary": "Returns an OBJECT constructed from the arguments that retains key-values pairs with NULL values.",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/object_construct_keep_null",
    "title": "OBJECT_CONSTRUCT_KEEP_NULL",
    "description": "Returns an",
    "syntax": "OBJECT_CONSTRUCT_KEEP_NULL( [<key>, <value> [, <key>, <value> , ...]] )\n\nOBJECT_CONSTRUCT_KEEP_NULL(*)",
    "example": "SELECT OBJECT_CONSTRUCT('key_1', 'one', 'key_2', NULL) AS WITHOUT_KEEP_NULL,\n       OBJECT_CONSTRUCT_KEEP_NULL('key_1', 'one', 'key_2', NULL) AS KEEP_NULL_1,\n       OBJECT_CONSTRUCT_KEEP_NULL('key_1', 'one', NULL, 'two') AS KEEP_NULL_2;\n\n+-------------------+-------------------+------------------+\n| WITHOUT_KEEP_NULL | KEEP_NULL_1       | KEEP_NULL_2      |\n|-------------------+-------------------+------------------|\n| {                 | {                 | {                |\n|   \"key_1\": \"one\"  |   \"key_1\": \"one\", |   \"key_1\": \"one\" |\n| }                 |   \"key_2\": null   | }                |\n|                   | }                 |                  |\n+-------------------+-------------------+------------------+\n\nCREATE TABLE demo_table_1_with_nulls (province VARCHAR, created_date DATE);\nINSERT INTO demo_table_1_with_nulls (province, created_date) VALUES\n  ('Manitoba', '2024-01-18'::DATE),\n  ('British Columbia', NULL),\n  ('Alberta', '2024-01-19'::DATE),\n  (NULL, '2024-01-20'::DATE);\n\nSELECT *\n  FROM demo_table_1_with_nulls\n  ORDER BY province;\n\n+------------------+--------------+\n| PROVINCE         | CREATED_DATE |\n|------------------+--------------|\n| Alberta          | 2024-01-19   |\n| British Columbia | NULL         |\n| Manitoba         | 2024-01-18   |\n| NULL             | 2024-01-20   |\n+------------------+--------------+\n\nSELECT OBJECT_CONSTRUCT(*) AS oc,\n       OBJECT_CONSTRUCT_KEEP_NULL(*) AS oc_keep_null\n  FROM demo_table_1_with_nulls\n  ORDER BY oc_keep_null['PROVINCE'];\n\n+----------------------------------+----------------------------------+\n| OC                               | OC_KEEP_NULL                     |\n|----------------------------------+----------------------------------|\n| {                                | {                                |\n|   \"CREATED_DATE\": \"2024-01-19\",  |   \"CREATED_DATE\": \"2024-01-19\",  |\n|   \"PROVINCE\": \"Alberta\"          |   \"PROVINCE\": \"Alberta\"          |\n| }                                | }                                |\n| {                                | {                                |\n|   \"PROVINCE\": \"British Columbia\" |   \"CREATED_DATE\": null,          |\n| }                                |   \"PROVINCE\": \"British Columbia\" |\n|                                  | }                                |\n| {                                | {                                |\n|   \"CREATED_DATE\": \"2024-01-18\",  |   \"CREATED_DATE\": \"2024-01-18\",  |\n|   \"PROVINCE\": \"Manitoba\"         |   \"PROVINCE\": \"Manitoba\"         |\n| }                                | }                                |\n| {                                | {                                |\n|   \"CREATED_DATE\": \"2024-01-20\"   |   \"CREATED_DATE\": \"2024-01-20\",  |\n| }                                |   \"PROVINCE\": null               |\n|                                  | }                                |\n+----------------------------------+----------------------------------+",
    "arguments": [
        {
            "name": "key",
            "description": "The key in a key-value pair. Each key is a VARCHAR value."
        },
        {
            "name": "value",
            "description": "The value that is associated with the key. The value can be any data type."
        },
        {
            "name": "*",
            "description": "When invoked with an asterisk (wildcard), the OBJECT value is constructed from the\nspecified data using the attribute names as keys and the associated values as values.\nSee the examples below. When you pass a wildcard to the function, you can qualify the wildcard with the name or alias for the table.\nFor example, to pass in all of the columns from the table named mytable , specify the following: You can also use the ILIKE and EXCLUDE keywords for filtering: ILIKE filters for column names that match the specified pattern. Only one\npattern is allowed. For example: EXCLUDE filters out column names that don’t match the specified column or columns. For example: Qualifiers are valid when you use these keywords. The following example uses the ILIKE keyword to\nfilter for all of the columns that match the pattern col1% in the table mytable : The ILIKE and EXCLUDE keywords can’t be combined in a single function call. For this function, the ILIKE and EXCLUDE keywords are valid only in a SELECT list or GROUP BY clause. For more information about the ILIKE and EXCLUDE keywords, see the “Parameters” section in SELECT ."
        }
    ],
    "returns": "The data type of the returned value is OBJECT."
},
{
    "function_name": "OBJECT_CONSTRUCT",
    "summary": "Returns an OBJECT constructed from the arguments.",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/object_construct",
    "title": "OBJECT_CONSTRUCT",
    "description": "Returns an",
    "syntax": "OBJECT_CONSTRUCT( [<key>, <value> [, <key>, <value> , ...]] )\n\nOBJECT_CONSTRUCT(*)",
    "example": "SELECT OBJECT_CONSTRUCT('a', 1, 'b', 'BBBB', 'c', NULL);\n\n+--------------------------------------------------+\n| OBJECT_CONSTRUCT('A', 1, 'B', 'BBBB', 'C', NULL) |\n|--------------------------------------------------|\n| {                                                |\n|   \"a\": 1,                                        |\n|   \"b\": \"BBBB\"                                    |\n| }                                                |\n+--------------------------------------------------+\n\nCREATE OR REPLACE TABLE demo_table_1 (province VARCHAR, created_date DATE);\nINSERT INTO demo_table_1 (province, created_date) VALUES\n  ('Manitoba', '2024-01-18'::DATE),\n  ('Alberta', '2024-01-19'::DATE);\n\nSELECT province, created_date\n  FROM demo_table_1\n  ORDER BY province;\n\n+----------+--------------+\n| PROVINCE | CREATED_DATE |\n|----------+--------------|\n| Alberta  | 2024-01-19   |\n| Manitoba | 2024-01-18   |\n+----------+--------------+\n\nSELECT OBJECT_CONSTRUCT(*) AS oc\n  FROM demo_table_1\n  ORDER BY oc['PROVINCE'];\n\n+---------------------------------+\n| OC                              |\n|---------------------------------|\n| {                               |\n|   \"CREATED_DATE\": \"2024-01-19\", |\n|   \"PROVINCE\": \"Alberta\"         |\n| }                               |\n| {                               |\n|   \"CREATED_DATE\": \"2024-01-18\", |\n|   \"PROVINCE\": \"Manitoba\"        |\n| }                               |\n+---------------------------------+\n\nSELECT OBJECT_CONSTRUCT(* ILIKE 'prov%') AS oc\n  FROM demo_table_1\n  ORDER BY oc['PROVINCE'];\n\n+--------------------------+\n| OC                       |\n|--------------------------|\n| {                        |\n|   \"PROVINCE\": \"Alberta\"  |\n| }                        |\n| {                        |\n|   \"PROVINCE\": \"Manitoba\" |\n| }                        |\n+--------------------------+\n\nSELECT OBJECT_CONSTRUCT(* EXCLUDE province) AS oc\n  FROM demo_table_1\n  ORDER BY oc['PROVINCE'];\n\n+--------------------------------+\n| OC                             |\n|--------------------------------|\n| {                              |\n|   \"CREATED_DATE\": \"2024-01-18\" |\n| }                              |\n| {                              |\n|   \"CREATED_DATE\": \"2024-01-19\" |\n| }                              |\n+--------------------------------+\n\nSELECT {* EXCLUDE province} AS oc\n  FROM demo_table_1\n  ORDER BY oc['PROVINCE'];\n\n+--------------------------------+\n| OC                             |\n|--------------------------------|\n| {                              |\n|   \"CREATED_DATE\": \"2024-01-18\" |\n| }                              |\n| {                              |\n|   \"CREATED_DATE\": \"2024-01-19\" |\n| }                              |\n+--------------------------------+\n\nSELECT OBJECT_CONSTRUCT(*) FROM VALUES(1,'x'), (2,'y');\n\n+---------------------+\n| OBJECT_CONSTRUCT(*) |\n|---------------------|\n| {                   |\n|   \"COLUMN1\": 1,     |\n|   \"COLUMN2\": \"x\"    |\n| }                   |\n| {                   |\n|   \"COLUMN1\": 2,     |\n|   \"COLUMN2\": \"y\"    |\n| }                   |\n+---------------------+\n\nSELECT OBJECT_CONSTRUCT(\n  'Key_One', PARSE_JSON('NULL'), \n  'Key_Two', NULL, \n  'Key_Three', 'null') AS obj;\n\n+-----------------------+\n| OBJ                   |\n|-----------------------|\n| {                     |\n|   \"Key_One\": null,    |\n|   \"Key_Three\": \"null\" |\n| }                     |\n+-----------------------+\n\nSELECT OBJECT_CONSTRUCT(\n    'foo', 1234567,\n    'dataset_size', (SELECT COUNT(*) FROM demo_table_1),\n    'distinct_province', (SELECT COUNT(DISTINCT province) FROM demo_table_1),\n    'created_date_seconds', extract(epoch_seconds, created_date)\n  )  AS json_object\n  FROM demo_table_1;\n\n+---------------------------------------+\n| JSON_OBJECT                           |\n|---------------------------------------|\n| {                                     |\n|   \"created_date_seconds\": 1705536000, |\n|   \"dataset_size\": 2,                  |\n|   \"distinct_province\": 2,             |\n|   \"foo\": 1234567                      |\n| }                                     |\n| {                                     |\n|   \"created_date_seconds\": 1705622400, |\n|   \"dataset_size\": 2,                  |\n|   \"distinct_province\": 2,             |\n|   \"foo\": 1234567                      |\n| }                                     |\n+---------------------------------------+",
    "arguments": [
        {
            "name": "key",
            "description": "The key in a key-value pair. Each key is a VARCHAR value."
        },
        {
            "name": "value",
            "description": "The value that is associated with the key. The value can be any data type."
        },
        {
            "name": "*",
            "description": "When invoked with an asterisk (wildcard), the OBJECT value is constructed from the\nspecified data using the attribute names as keys and the associated values as values.\nSee the examples below. When you pass a wildcard to the function, you can qualify the wildcard with the name or alias for the table.\nFor example, to pass in all of the columns from the table named mytable , specify the following: You can also use the ILIKE and EXCLUDE keywords for filtering: ILIKE filters for column names that match the specified pattern. Only one\npattern is allowed. For example: EXCLUDE filters out column names that don’t match the specified column or columns. For example: Qualifiers are valid when you use these keywords. The following example uses the ILIKE keyword to\nfilter for all of the columns that match the pattern col1% in the table mytable : The ILIKE and EXCLUDE keywords can’t be combined in a single function call. You can also specify the wildcard in an object constant . For this function, the ILIKE and EXCLUDE keywords are valid only in a SELECT list or GROUP BY clause. For more information about the ILIKE and EXCLUDE keywords, see the “Parameters” section in SELECT ."
        }
    ],
    "returns": "Returns a value of type OBJECT."
},
{
    "function_name": "OBJECT_AGG",
    "summary": "Returns one OBJECT per group.",
    "category": "Aggregate functions , Window functions , Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/object_agg",
    "title": "OBJECT_AGG",
    "description": "Returns one OBJECT per group. For each (",
    "syntax": "OBJECT_AGG(<key>, <value>)",
    "example": "CREATE OR REPLACE TABLE objectagg_example(g NUMBER, k VARCHAR(30), v VARIANT);\nINSERT INTO objectagg_example SELECT 0, 'name', 'Joe'::VARIANT;\nINSERT INTO objectagg_example SELECT 0, 'age', 21::VARIANT;\nINSERT INTO objectagg_example SELECT 1, 'name', 'Sue'::VARIANT;\nINSERT INTO objectagg_example SELECT 1, 'zip', 94401::VARIANT;\n\nSELECT * FROM objectagg_example;\n\n+---+------+-------+\n| G |  K   |   V   |\n|---+------+-------|\n| 0 | name | \"Joe\" |\n| 0 | age  | 21    |\n| 1 | name | \"Sue\" |\n| 1 | zip  | 94401 |\n+---+------+-------+\n\nSELECT OBJECT_AGG(k, v) FROM objectagg_example GROUP BY g;\n\n+-------------------+\n| OBJECT_AGG(K, V)  |\n|-------------------|\n| {                 |\n|  \"name\": \"Sue\",   |\n|   \"zip\": 94401    |\n| }                 |\n| {                 |\n|  \"age\": 21,       |\n|  \"name\": \"Joe\"    |\n| }                 |\n+-------------------+\n\nSELECT seq, key, value\n  FROM (SELECT object_agg(k, v) o FROM objectagg_example GROUP BY g),\n    LATERAL FLATTEN(input => o);\n\n+-----+------+-------+\n| SEQ | KEY  | VALUE |\n|-----+------+-------|\n|   1 | name | \"Sue\" |\n|   1 | zip  | 94401 |\n|   2 | age  | 21    |\n|   2 | name | \"Joe\" |\n+-----+------+-------+"
},
{
    "function_name": "NVL2",
    "summary": "Returns values depending on whether the first input is NULL.",
    "category": "Conditional expression functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/nvl2",
    "title": "NVL2",
    "description": "Returns values depending on whether the first input is NULL:",
    "syntax": "NVL2( <expr1> , <expr2> , <expr3> )",
    "example": "SELECT a, b, c, NVL2(a, b, c) FROM i2;\n\n--------+--------+--------+---------------+\n   A    |   B    |   C    | NVL2(A, B, C) |\n--------+--------+--------+---------------+\n 0      | 5      | 3      | 5             |\n 0      | 5      | [NULL] | 5             |\n 0      | [NULL] | 3      | [NULL]        |\n 0      | [NULL] | [NULL] | [NULL]        |\n [NULL] | 5      | 3      | 3             |\n [NULL] | 5      | [NULL] | [NULL]        |\n [NULL] | [NULL] | 3      | 3             |\n [NULL] | [NULL] | [NULL] | [NULL]        |\n--------+--------+--------+---------------+",
    "arguments": [
        {
            "name": "expr1",
            "description": "The expression to be checked to see whether it is NULL."
        },
        {
            "name": "expr2",
            "description": "If expr1 is not NULL, this expression will be evaluated and\nits value will be returned."
        },
        {
            "name": "expr3",
            "description": "If expr1 is NULL, this expression will be evaluated and\nits value will be returned."
        }
    ]
},
{
    "function_name": "NVL",
    "summary": "If expr1 is NULL, returns expr2, otherwise returns expr1.",
    "category": "Conditional expression functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/nvl",
    "title": "NVL",
    "description": "If",
    "syntax": "NVL( <expr1> , <expr2> )",
    "example": "CREATE TABLE IF NOT EXISTS suppliers (\n  supplier_id INT PRIMARY KEY,\n  supplier_name VARCHAR(30),\n  phone_region_1 VARCHAR(15),\n  phone_region_2 VARCHAR(15));\n\nINSERT INTO suppliers(supplier_id, supplier_name, phone_region_1, phone_region_2)\n  VALUES(1, 'Company_ABC', NULL, '555-01111'),\n        (2, 'Company_DEF', '555-01222', NULL),\n        (3, 'Company_HIJ', '555-01333', '555-01444'),\n        (4, 'Company_KLM', NULL, NULL);\n\nSELECT supplier_id,\n       supplier_name,\n       phone_region_1,\n       phone_region_2,\n       NVL(phone_region_1, phone_region_2) IF_REGION_1_NULL,\n       NVL(phone_region_2, phone_region_1) IF_REGION_2_NULL\n  FROM suppliers\n  ORDER BY supplier_id;\n\n+-------------+---------------+----------------+----------------+------------------+------------------+\n| SUPPLIER_ID | SUPPLIER_NAME | PHONE_REGION_1 | PHONE_REGION_2 | IF_REGION_1_NULL | IF_REGION_2_NULL |\n|-------------+---------------+----------------+----------------+------------------+------------------|\n|           1 | Company_ABC   | NULL           | 555-01111      | 555-01111        | 555-01111        |\n|           2 | Company_DEF   | 555-01222      | NULL           | 555-01222        | 555-01222        |\n|           3 | Company_HIJ   | 555-01333      | 555-01444      | 555-01333        | 555-01444        |\n|           4 | Company_KLM   | NULL           | NULL           | NULL             | NULL             |\n+-------------+---------------+----------------+----------------+------------------+------------------+",
    "arguments": [
        {
            "name": "expr1",
            "description": "A general expression."
        },
        {
            "name": "expr2",
            "description": "A general expression."
        }
    ],
    "returns": "Returns the data type of the returned expression."
},
{
    "function_name": "NULLIFZERO",
    "summary": "Returns NULL if the argument evaluates to 0; otherwise, returns the argument.",
    "category": "Conditional expression functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/nullifzero",
    "title": "NULLIFZERO",
    "description": "Returns NULL if the argument evaluates to",
    "syntax": "NULLIFZERO( <expr> )",
    "example": "SELECT NULLIFZERO(0);\n+---------------+\n| NULLIFZERO(0) |\n|---------------|\n|          NULL |\n+---------------+\n\nSELECT NULLIFZERO(52);\n+----------------+\n| NULLIFZERO(52) |\n|----------------|\n|             52 |\n+----------------+\n\nSELECT NULLIFZERO(3.14159);\n+---------------------+\n| NULLIFZERO(3.14159) |\n|---------------------|\n|             3.14159 |\n+---------------------+",
    "arguments": [
        {
            "name": "expr",
            "description": "The input should be an expression that evaluates to a numeric value."
        }
    ],
    "returns": "If the value of the input expression is 0, this returns NULL.\nOtherwise, this returns the value of the input expression."
},
{
    "function_name": "NULLIF",
    "summary": "Returns NULL if expr1 is equal to expr2, otherwise returns expr1.",
    "category": "Conditional expression functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/nullif",
    "title": "NULLIF",
    "description": "Returns NULL if",
    "syntax": "NULLIF( <expr1> , <expr2> )",
    "example": "SELECT a, b, NULLIF(a,b) FROM i;\n\n--------+--------+-------------+\n   a    |   b    | nullif(a,b) |\n--------+--------+-------------+\n 0      | 0      | [NULL]      |\n 0      | 1      | 0           |\n 0      | [NULL] | 0           |\n 1      | 0      | 1           |\n 1      | 1      | [NULL]      |\n 1      | [NULL] | 1           |\n [NULL] | 0      | [NULL]      |\n [NULL] | 1      | [NULL]      |\n [NULL] | [NULL] | [NULL]      |\n--------+--------+-------------+",
    "arguments": [
        {
            "name": "expr1",
            "description": "Any general expression of any data type."
        },
        {
            "name": "expr2",
            "description": "Any general expression that evaluates to the same data type as expr1 ."
        }
    ],
    "returns": "The data type of the returned value is the data type of expr1."
},
{
    "function_name": "NTILE",
    "summary": "Divides an ordered data set equally into the number of buckets specified by constant_value.",
    "category": "Window function syntax and usage",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/ntile",
    "title": "NTILE",
    "description": "Divides an ordered data set equally into the number of buckets specified by",
    "syntax": "NTILE( <constant_value> ) OVER ( [ PARTITION BY <expr1> ] ORDER BY <expr2> [ { ASC | DESC } ] )",
    "example": "SELECT\n    exchange,\n    symbol,\n    NTILE(4) OVER (PARTITION BY exchange ORDER BY shares) AS ntile_4\n  FROM trades\n  ORDER BY exchange, NTILE_4;\n\n+--------+------+-------+\n|exchange|symbol|NTILE_4|\n+--------+------+-------+\n|C       |SPY   |      1|\n|C       |AAPL  |      2|\n|C       |AAPL  |      3|\n|N       |SPY   |      1|\n|N       |AAPL  |      1|\n|N       |SPY   |      2|\n|N       |QQQ   |      2|\n|N       |QQQ   |      3|\n|N       |YHOO  |      4|\n|Q       |MSFT  |      1|\n|Q       |YHOO  |      1|\n|Q       |MSFT  |      2|\n|Q       |YHOO  |      2|\n|Q       |QQQ   |      3|\n|Q       |QQQ   |      4|\n|P       |AAPL  |      1|\n|P       |YHOO  |      1|\n|P       |MSFT  |      2|\n|P       |SPY   |      3|\n|P       |MSFT  |      4|\n+--------+------+-------+",
    "arguments": [
        {
            "name": "constant_value",
            "description": "The desired number of buckets; must be a positive integer value."
        },
        {
            "name": "expr1",
            "description": "If you wish to partition the data into groups, specify the criterion\n(usually a column) to partition by. For example, you might partition by\nprovince."
        },
        {
            "name": "expr2",
            "description": "The expression (usually a column) by which to order the rows in the window.\nFor example, you might order by timestamp."
        }
    ]
},
{
    "function_name": "NTH_VALUE",
    "summary": "Returns the nth value (up to 1000) within an ordered group of values.",
    "category": "Window function syntax and usage",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/nth_value",
    "title": "NTH_VALUE",
    "description": "Returns the nth value (up to 1000) within an ordered group of values.",
    "syntax": "NTH_VALUE( <expr> , <n> ) [ FROM { FIRST | LAST } ] [ { IGNORE | RESPECT } NULLS ]\n  OVER ( [ PARTITION BY <expr1> ] ORDER BY <expr2> [ { ASC | DESC } ] [ <window_frame> ] )",
    "example": "SELECT column1,\n       column2,\n       NTH_VALUE(column2, 2) OVER (PARTITION BY column1 ORDER BY column2) AS column2_2nd\n  FROM VALUES\n    (1, 10), (1, 11), (1, 12),\n    (2, 20), (2, 21), (2, 22);\n\n+---------+---------+-------------+\n| COLUMN1 | COLUMN2 | COLUMN2_2ND |\n|---------+---------+-------------|\n|       1 |      10 |          11 |\n|       1 |      11 |          11 |\n|       1 |      12 |          11 |\n|       2 |      20 |          21 |\n|       2 |      21 |          21 |\n|       2 |      22 |          21 |\n+---------+---------+-------------+\n\nCREATE TABLE demo1 (i INTEGER, partition_col INTEGER, order_col INTEGER);\n\nINSERT INTO demo1 (i, partition_col, order_col) VALUES\n  (1, 1, 1),\n  (2, 1, 2),\n  (3, 1, 3),\n  (4, 1, 4),\n  (5, 1, 5),\n  (1, 2, 1),\n  (2, 2, 2),\n  (3, 2, 3),\n  (4, 2, 4);\n\nSELECT partition_col, order_col, i,\n       FIRST_VALUE(i)  OVER (PARTITION BY partition_col ORDER BY order_col\n         ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) AS FIRST_VAL,\n       NTH_VALUE(i, 2) OVER (PARTITION BY partition_col ORDER BY order_col\n         ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) AS NTH_VAL,\n       LAST_VALUE(i)   OVER (PARTITION BY partition_col ORDER BY order_col\n         ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) AS LAST_VAL\n  FROM demo1\n  ORDER BY partition_col, i, order_col;\n\n+---------------+-----------+---+-----------+---------+----------+\n| PARTITION_COL | ORDER_COL | I | FIRST_VAL | NTH_VAL | LAST_VAL |\n|---------------+-----------+---+-----------+---------+----------|\n|             1 |         1 | 1 |         1 |       2 |        2 |\n|             1 |         2 | 2 |         1 |       2 |        3 |\n|             1 |         3 | 3 |         2 |       3 |        4 |\n|             1 |         4 | 4 |         3 |       4 |        5 |\n|             1 |         5 | 5 |         4 |       5 |        5 |\n|             2 |         1 | 1 |         1 |       2 |        2 |\n|             2 |         2 | 2 |         1 |       2 |        3 |\n|             2 |         3 | 3 |         2 |       3 |        4 |\n|             2 |         4 | 4 |         3 |       4 |        4 |\n+---------------+-----------+---+-----------+---------+----------+",
    "arguments": [
        {
            "name": "n",
            "description": "This specifies which value of N to use when looking for the Nth value."
        },
        {
            "name": "expr",
            "description": "The expression that determines the return value."
        },
        {
            "name": "expr1",
            "description": "The expression by which to partition the rows. You can specify a single expression or a comma-separated list of expressions.\nFor example:"
        },
        {
            "name": "expr2",
            "description": "The expression by which to order the rows. You can specify a single expression or a comma-separated list of expressions.\nFor example:"
        },
        {
            "name": "FROM",
            "description": "Whether to ignore or respect NULL values when an expr contains NULL values: FROM FIRST starts from the beginning of the ordered list and moves forward. FROM LAST starts from the end of the ordered list and moves backward. Default: FROM FIRST"
        },
        {
            "name": "{",
            "description": "Whether to ignore or respect NULL values when an expr contains NULL values: IGNORE NULLS skips NULL values in the expression. RESPECT NULLS returns a NULL value if it is the nth value in the expression. Default: RESPECT NULLS"
        }
    ]
},
{
    "function_name": "NOTIFICATION_HISTORY",
    "summary": "This table function can be used to query the history of notifications sent through Snowflake.",
    "category": "Information Schema , Table functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/notification_history",
    "title": "NOTIFICATION_HISTORY",
    "description": "This table function can be used to query the history of notifications sent through Snowflake. These notifications include:",
    "syntax": "NOTIFICATION_HISTORY(\n  [ START_TIME => <constant_expr> ]\n  [, END_TIME => <constant_expr> ]\n  [, INTEGRATION_NAME => '<string>' ]\n  [, RESULT_LIMIT => <integer> ] )",
    "example": "SELECT * FROM TABLE(INFORMATION_SCHEMA.NOTIFICATION_HISTORY());\n\nSELECT * FROM TABLE(INFORMATION_SCHEMA.NOTIFICATION_HISTORY(\n  START_TIME=>DATEADD('hour',-1,CURRENT_TIMESTAMP()),\n  END_TIME=>CURRENT_TIMESTAMP(),\n  RESULT_LIMIT=>100,\n  INTEGRATION_NAME=>'my_integration'));\n\nSELECT id, attempt, created, processed, status\n  FROM TABLE(INFORMATION_SCHEMA.NOTIFICATION_HISTORY());\n\n+-------------------+-------------+-----------------------------------+-----------------------------------+-----------------------+\n|   ID              |   ATTEMPT   |   CREATED                         |   PROCESSED                       |   STATUS              |\n+-------------------+-------------+-----------------------------------+-----------------------------------+-----------------------+\n|   10ae695e-93c3   |   3         |   2023-12-05 15:10:15.194 -0800   |   NULL                            |   QUEUED              |\n|   10ae695e-93c3   |   2         |   2023-12-05 15:10:15.194 -0800   |   2023-12-05 15:11:21.443 -0800   |   RETRIABLE_FAILURE   |\n|   10ae695e-93c3   |   1         |   2023-12-05 15:10:15.194 -0800   |   2023-12-05 15:10:21.443 -0800   |   RETRIABLE_FAILURE   |\n+-------------------+-------------+-----------------------------------+-----------------------------------+-----------------------+\n\nSELECT id, attempt, created, processed, status\n  FROM TABLE(INFORMATION_SCHEMA.NOTIFICATION_HISTORY());\n\n+-------------------+-------------+-----------------------------------+-----------------------------------+-----------------------+\n|   ID              |   ATTEMPT   |   CREATED                         |   PROCESSED                       |   STATUS              |\n+-------------------+-------------+-----------------------------------+-----------------------------------+-----------------------+\n|   10ae695e-93c3   |   3         |   2023-12-05 15:10:15.194 -0800   |   2023-12-05 15:12:21.443 -0800   |   SUCCESS             |\n|   10ae695e-93c3   |   2         |   2023-12-05 15:10:15.194 -0800   |   2023-12-05 15:11:21.443 -0800   |   RETRIABLE_FAILURE   |\n|   10ae695e-93c3   |   1         |   2023-12-05 15:10:15.194 -0800   |   2023-12-05 15:10:21.443 -0800   |   RETRIABLE_FAILURE   |\n+-------------------+-------------+-----------------------------------+-----------------------------------+-----------------------+",
    "arguments": [
        {
            "name": "START_TIME=>",
            "description": "Time range (in TIMESTAMP_LTZ format) when the notification is sent out. If START_TIME is not specified, the range starts 24 hours prior to the END_TIME. If END_TIME is not specified, the default is CURRENT_TIMESTAMP . The maximum time range is 14 days."
        },
        {
            "name": "INTEGRATION_NAME",
            "description": "The fully qualified name of the integration that is tied with the notification. If you omit this argument, the function returns\nall notifications. Default: An empty string."
        },
        {
            "name": "RESULT_LIMIT",
            "description": "A number specifying the maximum number of rows returned by the function. Range: 1 to 10000 Default: 100"
        }
    ]
},
{
    "function_name": "NORMAL",
    "summary": "Generates a normally-distributed pseudo-random floating point number with specified mean and stddev (standard deviation).",
    "category": "Data generation functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/normal",
    "title": "NORMAL",
    "description": "Generates a normally-distributed pseudo-random floating point number with specified",
    "syntax": "NORMAL( <mean> , <stddev> , <gen> )",
    "example": "SELECT normal(0, 1, random()) FROM table(generator(rowCount => 5));\n\n+------------------------+\n| NORMAL(0, 1, RANDOM()) |\n|------------------------|\n|           0.227384164  |\n|           0.9945290748 |\n|          -0.2045078571 |\n|          -1.594607893  |\n|          -0.8213296842 |\n+------------------------+\n\nSELECT normal(0, 1, 1234) FROM table(generator(rowCount => 5));\n\n+--------------------+\n| NORMAL(0, 1, 1234) |\n|--------------------|\n|      -0.6604156716 |\n|      -0.6604156716 |\n|      -0.6604156716 |\n|      -0.6604156716 |\n|      -0.6604156716 |\n+--------------------+",
    "arguments": [
        {
            "name": "mean",
            "description": "A constant specifying the value that the output values should be centered on."
        },
        {
            "name": "stddev",
            "description": "A constant specifying the width of one standard deviation. For example, if you specify a mean of 0.0 and a standard deviation of 1.0,\napproximately 68.2% of returned values from multiple calls will be between\n-1.0 and +1.0 (i.e. within one standard deviation of the mean). Similarly, if you choose a mean of 5.0 and a standard deviation of 2, then\napproximately 68.2% of values will be between 3.0 and 7.0."
        },
        {
            "name": "gen",
            "description": "An expression that serves as a raw source of uniform random numbers,\ntypically the RANDOM function. For more information, see the Data\nGeneration Functions Usage notes ."
        }
    ],
    "returns": "Returns a random floating-point number. The accumulated results of a large\nnumber of repeated calls approximate a normal distribution."
},
{
    "function_name": "NEXT_DAY",
    "summary": "Returns the date of the first specified day of week (DOW) that occurs after the input date.",
    "category": "Date & time functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/next_day",
    "title": "NEXT_DAY",
    "description": "Returns the date of the first specified day of week (DOW) that occurs after the input date.",
    "syntax": "NEXT_DAY( <date_or_timetamp_expr> , <dow_string> )",
    "example": "SELECT CURRENT_DATE() AS \"Today's Date\",\n       NEXT_DAY(\"Today's Date\", 'Friday') AS \"Next Friday\";\n\n+--------------+-------------+\n| Today's Date | Next Friday |\n|--------------+-------------|\n| 2025-05-06   | 2025-05-09  |\n+--------------+-------------+",
    "arguments": [
        {
            "name": "date_or_timestamp_expr",
            "description": "A date or a timestamp, or an expression that can be evaluated to a date or a timestamp."
        },
        {
            "name": "dow_string",
            "description": "Specifies the day of week used to calculate the date for the next day. The value can be a string literal or an expression that returns a string. The string\nmust start with the first two characters (case-insensitive) of the day name: su (Sunday) mo (Monday) tu (Tuesday) we (Wednesday) th (Thursday) fr (Friday) sa (Saturday) Any leading spaces and trailing characters, including spaces, in the string are ignored."
        }
    ],
    "returns": "This function returns a value of type DATE, even if date_or_timetamp_expr is a timestamp."
},
{
    "function_name": "NETWORK_RULE_REFERENCES",
    "summary": "Returns a row for each object with which the specified network rule is associated or returns a row for each network rule associated with the specified container.",
    "category": "Information Schema , Table functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/network_rule_references",
    "title": "NETWORK_RULE_REFERENCES",
    "description": "Returns a row for each object with which the specified network rule is associated",
    "syntax": "NETWORK_RULE_REFERENCES(\n  NETWORK_RULE_NAME => '<string>'\n)\n\nNETWORK_RULE_REFERENCES(\n  CONTAINER_NAME => '<container_name>' ,\n  CONTAINER_TYPE => { 'INTEGRATION' | 'NETWORK_POLICY' }\n)",
    "example": "USE ROLE network_admin;\nUSE DATABASE securitydb;\nSELECT *\n  FROM TABLE(\n    securitydb.INFORMATION_SCHEMA.NETWORK_RULE_REFERENCES(\n      NETWORK_RULE_NAME => 'securitydb.myrules.cloud_rule'\n    )\n  );\n\nUSE ROLE network_admin;\nUSE DATABASE securitydb;\nSELECT *\n  FROM TABLE(\n    securitydb.INFORMATION_SCHEMA.NETWORK_RULE_REFERENCES(\n      CONTAINER_NAME => 'my_network_policy' ,\n      CONTAINER_TYPE => 'NETWORK_POLICY'\n    )\n  );",
    "arguments": [
        {
            "name": "NETWORK_RULE_NAME",
            "description": "Specifies the identifier for the network rule . The entire network rule name must be enclosed in single quotes. If the network rule name is case-sensitive or includes any special characters or spaces, double quotes are required to process the\ncase/characters. The double quotes must be enclosed within the single quotes, such as '\" name \"' ."
        },
        {
            "name": "CONTAINER_NAME",
            "description": "Specifies the name of the external access integration or network policy to which the network rule is associated. The entire network rule name must be enclosed in single quotes. If the object name is case-sensitive or includes any special characters or spaces, double quotes are required to process the\ncase/characters. The double quotes must be enclosed within the single quote, such as '\"<name>\"' ."
        },
        {
            "name": "CONTAINER_TYPE",
            "description": "Specifies the object type (domain) to which the network rule is associated."
        }
    ]
},
{
    "function_name": "MONTHS_BETWEEN",
    "summary": "Returns the number of months between two DATE or TIMESTAMP values.",
    "category": "Date & time functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/months_between",
    "title": "MONTHS_BETWEEN",
    "description": "Returns the number of months between two DATE or TIMESTAMP values.",
    "syntax": "MONTHS_BETWEEN( <date_expr1> , <date_expr2> )",
    "example": "SELECT\n    MONTHS_BETWEEN('2019-03-15'::DATE,\n                   '2019-02-15'::DATE) AS MonthsBetween1,\n    MONTHS_BETWEEN('2019-03-31'::DATE,\n                   '2019-02-28'::DATE) AS MonthsBetween2;\n+----------------+----------------+\n| MONTHSBETWEEN1 | MONTHSBETWEEN2 |\n|----------------+----------------|\n|       1.000000 |       1.000000 |\n+----------------+----------------+\n\nSELECT\n    MONTHS_BETWEEN('2019-03-01'::DATE,\n                   '2019-02-15'::DATE) AS MonthsBetween1,\n    MONTHS_BETWEEN('2019-03-01 02:00:00'::TIMESTAMP,\n                   '2019-02-15 01:00:00'::TIMESTAMP) AS MonthsBetween2,\n    MONTHS_BETWEEN('2019-02-15 02:00:00'::TIMESTAMP,\n                   '2019-02-15 01:00:00'::TIMESTAMP) AS MonthsBetween3\n    ;\n+----------------+----------------+----------------+\n| MONTHSBETWEEN1 | MONTHSBETWEEN2 | MONTHSBETWEEN3 |\n|----------------+----------------+----------------|\n|       0.548387 |       0.549731 |       0.000000 |\n+----------------+----------------+----------------+\n\nSELECT\n    MONTHS_BETWEEN('2019-03-28'::DATE,\n                   '2019-02-28'::DATE) AS MonthsBetween1,\n    MONTHS_BETWEEN('2019-03-30'::DATE,\n                   '2019-02-28'::DATE) AS MonthsBetween2,\n    MONTHS_BETWEEN('2019-03-31'::DATE,\n                   '2019-02-28'::DATE) AS MonthsBetween3\n    ;\n+----------------+----------------+----------------+\n| MONTHSBETWEEN1 | MONTHSBETWEEN2 | MONTHSBETWEEN3 |\n|----------------+----------------+----------------|\n|       1.000000 |       1.064516 |       1.000000 |\n+----------------+----------------+----------------+\n\nSELECT\n    MONTHS_BETWEEN('2019-03-01'::DATE,\n                   '2019-02-01'::DATE) AS MonthsBetween1,\n    MONTHS_BETWEEN('2019-02-01'::DATE,\n                   '2019-03-01'::DATE) AS MonthsBetween2\n    ;\n+----------------+----------------+\n| MONTHSBETWEEN1 | MONTHSBETWEEN2 |\n|----------------+----------------|\n|       1.000000 |      -1.000000 |\n+----------------+----------------+",
    "arguments": [
        {
            "name": "date_expr1",
            "description": "The date to subtract from."
        },
        {
            "name": "date_expr2",
            "description": "The date to subtract."
        }
    ],
    "returns": "A FLOAT representing the number of months between the two dates."
},
{
    "function_name": "MONTHNAME",
    "summary": "Returns the three-letter month name for the specified date or timestamp.",
    "category": "Date & time functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/monthname",
    "title": "MONTHNAME",
    "description": "Returns the three-letter month name for the specified date or timestamp.",
    "syntax": "MONTHNAME( <date_or_timestamp_expr> )",
    "example": "SELECT MONTHNAME(TO_DATE('2025-01-01')) AS month;\n\n+-------+\n| MONTH |\n|-------|\n| Jan   |\n+-------+\n\nSELECT MONTHNAME(TO_TIMESTAMP('2025-04-03 10:00')) AS month;\n\n+-------+\n| MONTH |\n|-------|\n| Apr   |\n+-------+\n\nCREATE OR REPLACE TABLE monthname_function_demo (d DATE);\n\nINSERT INTO monthname_function_demo (d) VALUES\n  ('2024-01-01'::DATE),\n  ('2024-02-02'::DATE),\n  ('2024-03-03'::DATE),\n  ('2024-04-04'::DATE),\n  ('2024-05-05'::DATE),\n  ('2024-06-06'::DATE),\n  ('2024-07-07'::DATE),\n  ('2024-08-08'::DATE),\n  ('2024-09-09'::DATE),\n  ('2024-10-10'::DATE),\n  ('2024-11-11'::DATE),\n  ('2024-12-12'::DATE);\n\nSELECT d,\n       MONTHNAME(d) AS month\n  FROM monthname_function_demo;\n\n+------------+-------+\n| D          | MONTH |\n|------------+-------|\n| 2024-01-01 | Jan   |\n| 2024-02-02 | Feb   |\n| 2024-03-03 | Mar   |\n| 2024-04-04 | Apr   |\n| 2024-05-05 | May   |\n| 2024-06-06 | Jun   |\n| 2024-07-07 | Jul   |\n| 2024-08-08 | Aug   |\n| 2024-09-09 | Sep   |\n| 2024-10-10 | Oct   |\n| 2024-11-11 | Nov   |\n| 2024-12-12 | Dec   |\n+------------+-------+",
    "arguments": [
        {
            "name": "date_or_timestamp_expr",
            "description": "A date or a timestamp, or an expression that can be evaluated to a date or a timestamp."
        }
    ],
    "returns": "This function returns a value of type VARCHAR."
},
{
    "function_name": "MODEL_MONITOR_STAT_METRIC",
    "summary": "Gets count metrics from a model monitor.",
    "category": "Model monitor functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/model-monitor-stat-metric",
    "title": "MODEL_MONITOR_STAT_METRIC",
    "description": "Gets count metrics from a",
    "syntax": "MODEL_MONITOR_STAT_METRIC(<model_monitor_name>, <stat_metric_name>, <column_name>\n    [, <granularity> [, <start_time>  [, <end_time> ] ] ] )",
    "example": "SELECT * FROM TABLE(MODEL_MONITOR_STAT_METRIC(\n'MY_MONITOR', 'COUNT', 'MODEL_PREDICTION', '1 DAY', TO_TIMESTAMP_TZ('2024-01-01')\n, TO_TIMESTAMP_TZ('2024-01-02'))\n)\n\nSELECT * FROM TABLE(MODEL_MONITOR_STAT_METRIC(\n'MY_MONITOR', 'COUNT', 'MODEL_PREDICTION', '1 DAY', DATEADD('DAY', -30, CURRENT_DATE()), CURRENT_DATE())\n)",
    "arguments": [
        {
            "name": "MODEL_MONITOR_NAME",
            "description": "Name of the model monitor used to compute the metric. Valid values: A string that’s the name of the model monitor. It can be a simple or fully qualified name."
        },
        {
            "name": "METRIC_NAME",
            "description": "Name of the metric. Valid values: 'COUNT' 'COUNT_NULL'"
        },
        {
            "name": "COLUMN_NAME",
            "description": "Name of the column used to compute the count. Valid values: Any string that exists as a feature column, prediction column, or actual column in the model monitor."
        },
        {
            "name": "GRANULARITY",
            "description": "Granularity of the time range being queried. The default value is 1 DAY . Valid values: '<num> DAY' '<num> WEEK' '<num> MONTH' '<num> QUARTER' '<num> YEAR' 'ALL' NULL"
        },
        {
            "name": "START_TIME",
            "description": "Start of the time range used to compute the metric. The default value is 60 days before the current time, and is calculated each time you call the function. Valid values: A timestamp expression or NULL ."
        },
        {
            "name": "END_TIME",
            "description": "End of the time range used to compute the metric. The default value is the current time, and is calculated each time you call the function. Valid values: A timestamp expression or NULL ."
        }
    ],
    "returns": "Column"
},
{
    "function_name": "MODEL_MONITOR_PERFORMANCE_METRIC",
    "summary": "Gets performance metrics from a model monitor.",
    "category": "Model monitor functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/model-monitor-performance-metric",
    "title": "MODEL_MONITOR_PERFORMANCE_METRIC",
    "description": "Gets performance metrics from a",
    "syntax": "MODEL_MONITOR_PERFORMANCE_METRIC(<model_monitor_name>, <performance_metric_name>,\n    [, <granularity> [, <start_time>  [, <end_time> ] ] ] )",
    "example": "SELECT * FROM TABLE(MODEL_MONITOR_PERFORMANCE_METRIC(\n'MY_MONITOR', 'RMSE', '1 DAY', TO_TIMESTAMP_TZ('2024-01-01'), TO_TIMESTAMP_TZ('2024-01-02'))\n)\n\nSELECT * FROM TABLE(MODEL_MONITOR_PERFORMANCE_METRIC(\n'MY_MONITOR', 'RMSE', '1 DAY', DATEADD('DAY', -30, CURRENT_DATE()), CURRENT_DATE())\n)",
    "arguments": [
        {
            "name": "MODEL_MONITOR_NAME",
            "description": "Name of the model monitor used to compute the metric. Valid values: A string that’s the name of the model monitor. It can be a simple or fully qualified name."
        },
        {
            "name": "METRIC_NAME",
            "description": "Name of the performance metric. Valid values if the model monitor is attached to a regression model: 'RMSE' 'MAE' 'MAPE' 'MSE' Valid values if the model monitor is attached to a binary classification model: 'ROC_AUC' 'CLASSIFICATION_ACCURACY' 'PRECISION' 'RECALL' 'F1_SCORE'"
        },
        {
            "name": "GRANULARITY",
            "description": "Granularity of the time range being queried. The default value is 1 DAY . Valid values: '<num> DAY' '<num> WEEK' '<num> MONTH' '<num> QUARTER' '<num> YEAR' 'ALL' NULL"
        },
        {
            "name": "START_TIME",
            "description": "Start of the time range used to compute the metric. The default value is 60 days before the current time, and is calculated each time you call the function. Valid values: A timestamp expression or NULL ."
        },
        {
            "name": "END_TIME",
            "description": "End of the time range used to compute the metric. The default value is the current time, and is calculated each time you call the function. Valid values: A timestamp expression or NULL ."
        }
    ],
    "returns": "Column"
},
{
    "function_name": "MODEL_MONITOR_DRIFT_METRIC",
    "summary": "Gets drift metrics from a model monitor.",
    "category": "Model monitor functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/model-monitor-drift-metric",
    "title": "MODEL_MONITOR_DRIFT_METRIC",
    "description": "Gets drift metrics from a",
    "syntax": "MODEL_MONITOR_DRIFT_METRIC(\n  <model_monitor_name>, <drift_metric_name>, <column_name>\n  [ , <granularity> [ , <start_time>  [ , <end_time> ] ] ]\n)",
    "example": "SELECT * FROM TABLE(MODEL_MONITOR_DRIFT_METRIC(\n'MY_MONITOR', 'DIFFERENCE_OF_MEANS', 'MODEL_PREDICTION', '1 DAY', TO_TIMESTAMP_TZ('2024-01-01'), TO_TIMESTAMP_TZ('2024-01-02'))\n)\n\nSELECT * FROM TABLE(MODEL_MONITOR_DRIFT_METRIC(\n'MY_MONITOR', 'JENSEN_SHANNON', 'MODEL_PREDICTION', '1 DAY', DATEADD('DAY', -30, CURRENT_DATE()), CURRENT_DATE())\n)",
    "arguments": [
        {
            "name": "model_monitor_name",
            "description": "Name of the model monitor used to compute the metric. Valid values: A string that’s the name of the model monitor. It can be a simple or fully qualified name."
        },
        {
            "name": "drift_metric_name",
            "description": "Name of the metric. Valid values: 'JENSEN_SHANNON' 'DIFFERENCE_OF_MEANS' 'WASSERSTEIN'"
        },
        {
            "name": "column_name",
            "description": "Name of the column used to compute drift. Valid values: Any string that exists as a feature column, prediction column, or actual column in the model monitor."
        },
        {
            "name": "granularity",
            "description": "Granularity of the time range being queried. Default value is 1 DAY . Valid values: '<num> DAY' '<num> WEEK' '<num> MONTH' '<num> QUARTER' '<num> YEAR' 'ALL' NULL"
        },
        {
            "name": "start_time",
            "description": "Start of the time range used to compute the metric. The default value is 60 days before the current time, and is calculated each time you call the function. Valid values: A timestamp expression or NULL ."
        },
        {
            "name": "end_time",
            "description": "End of the time range used to compute the metric. The default value is the current time, and is calculated each time you call the function. Valid values: A timestamp expression or NULL ."
        }
    ],
    "returns": "Column"
},
{
    "function_name": "MODE",
    "summary": "Returns the most frequent value for the values within expr1.",
    "category": "Aggregate functions , Window functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/mode",
    "title": "MODE",
    "description": "Returns the most frequent value for the values within",
    "syntax": "MODE( <expr1> )",
    "example": "create or replace table aggr(k int, v decimal(10,2));\n\nselect mode(v) from aggr;\n+---------+\n| MODE(V) |\n|---------|\n|    NULL |\n+---------+\n\nINSERT INTO aggr (k, v) VALUES\n    (1, 10), \n    (1, 10), \n    (1, 10), \n    (1, 10), \n    (1, 20), \n    (1, 21);\n\nselect mode(v) from aggr;\n+---------+\n| MODE(V) |\n|---------|\n|   10.00 |\n+---------+\n\nINSERT INTO aggr (k, v) VALUES\n    (2, 20), \n    (2, 20), \n    (2, 25), \n    (2, 30);\n\nselect mode(v) from aggr;\n+---------+\n| MODE(V) |\n|---------|\n|   10.00 |\n+---------+\n\nINSERT INTO aggr (k, v) VALUES (3, null);\n\nselect k, mode(v) \n    from aggr \n    group by k\n    order by k;\n+---+---------+\n| K | MODE(V) |\n|---+---------|\n| 1 |   10.00 |\n| 2 |   20.00 |\n| 3 |    NULL |\n+---+---------+\n\nselect k, v, mode(v) over (partition by k) \n    from aggr \n    order by k, v;\n+---+-------+-------------------------------+\n| K |     V | MODE(V) OVER (PARTITION BY K) |\n|---+-------+-------------------------------|\n| 1 | 10.00 |                         10.00 |\n| 1 | 10.00 |                         10.00 |\n| 1 | 10.00 |                         10.00 |\n| 1 | 10.00 |                         10.00 |\n| 1 | 20.00 |                         10.00 |\n| 1 | 21.00 |                         10.00 |\n| 2 | 20.00 |                         20.00 |\n| 2 | 20.00 |                         20.00 |\n| 2 | 25.00 |                         20.00 |\n| 2 | 30.00 |                         20.00 |\n| 3 |  NULL |                          NULL |\n+---+-------+-------------------------------+",
    "arguments": [
        {
            "name": "expr1",
            "description": "This expression produces the values that are searched to find the most frequent value. The expression can be of any of the following data types: BINARY BOOLEAN DATE FLOAT INTEGER NUMBER TIMESTAMP (TIMESTAMP_LTZ, TIMESTAMP_NTZ, TIMESTAMP_TZ) VARCHAR VARIANT This function does not support the following data types: ARRAY GEOGRAPHY OBJECT"
        },
        {
            "name": "expr2",
            "description": "The optional expression on which to partition the data into groups. The output contains the most frequent\nvalue for each group/partition."
        }
    ],
    "returns": "The data type of the returned value is identical to the data type of the input expression."
},
{
    "function_name": "MOD",
    "summary": "Returns the remainder of input expr1 divided by input expr2.",
    "category": "Numeric functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/mod",
    "title": "MOD",
    "description": "Returns the remainder of input",
    "syntax": "MOD( <expr1> , <expr2> )",
    "example": "SELECT MOD(3, 2) AS mod1, MOD(4.5, 1.2) AS mod2;\n\n+------+------+\n| MOD1 | MOD2 |\n+------+------+\n|    1 |  0.9 |\n+------+------+",
    "arguments": [
        {
            "name": "expr1",
            "description": "A numeric expression."
        },
        {
            "name": "expr2",
            "description": "A numeric expression."
        }
    ],
    "returns": "Returns either an integer or a fixed-point decimal number."
},
{
    "function_name": "MINHASH_COMBINE",
    "summary": "Combines input MinHash states into a single MinHash output state.",
    "category": "Aggregate functions , Window function syntax and usage",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/minhash_combine",
    "title": "MINHASH_COMBINE",
    "description": "Combines input MinHash states into a single MinHash output state. This Minhash state can then be input to the",
    "syntax": "MINHASH_COMBINE( [ DISTINCT ] <state> )",
    "example": "USE SCHEMA snowflake_sample_data.tpch_sf1;\n\nSELECT MINHASH_COMBINE(mh) FROM\n    (\n      (SELECT MINHASH(5, c2) mh FROM orders WHERE c2 <= 10000)\n        UNION\n      (SELECT MINHASH(5, c2) mh FROM orders WHERE c2 > 10000 AND c2 <= 20000)\n        UNION\n      (SELECT MINHASH(5, C2) mh FROM orders WHERE c2 > 20000)\n    );\n\n+-----------------------+\n| MINHASH_COMBINE(MH)   |\n|-----------------------|\n| {                     |\n|   \"state\": [          |\n|     628914288006793,  |\n|     1071764954434168, |\n|     991489123966035,  |\n|     2395105834644106, |\n|     680224867834949   |\n|   ],                  |\n|   \"type\": \"minhash\",  |\n|   \"version\": 1        |\n| }                     |\n+-----------------------+\n\nCREATE TABLE ta (i INTEGER);\nCREATE TABLE tb (i INTEGER);\nCREATE TABLE tc (i INTEGER);\n\n-- Insert values into the 3 tables.\nINSERT INTO ta (i) VALUES (1), (2), (3), (4), (5), (6), (7), (8), (9), (10);\n-- Almost the same as the preceding values.\nINSERT INTO tb (i) VALUES (1), (2), (3), (4), (5), (6), (7), (8), (9), (11);\n-- Different values and different number of values.\nINSERT INTO tc (i) VALUES (-1), (-20), (-300), (-4000);\n\nCREATE TABLE minhash_a_1 (mh) AS SELECT MINHASH(100, i) FROM ta;\nCREATE TABLE minhash_b (mh) AS SELECT MINHASH(100, i) FROM tb;\nCREATE TABLE minhash_c (mh) AS SELECT MINHASH(100, i) FROM tc;\n\nINSERT INTO ta (i) VALUES (12);\n\n-- Record minhash information about only the new rows:\nCREATE TABLE minhash_a_2 (mh) AS SELECT MINHASH(100, i) FROM ta WHERE i > 10;\n\n-- Now combine all the minhash info for the old and new rows in table ta.\nCREATE TABLE minhash_a (mh) AS\n  SELECT MINHASH_COMBINE(mh) FROM\n    (\n      (SELECT mh FROM minhash_a_1)\n      UNION ALL\n      (SELECT mh FROM minhash_a_2)\n    );\n\nSELECT APPROXIMATE_SIMILARITY (mh) FROM\n  (\n    (SELECT mh FROM minhash_a)\n    UNION ALL\n    (SELECT mh FROM minhash_b)\n  );\n+-----------------------------+\n| APPROXIMATE_SIMILARITY (MH) |\n|-----------------------------|\n|                        0.75 |\n+-----------------------------+\n\nSELECT APPROXIMATE_SIMILARITY (mh) FROM\n  (\n    (SELECT mh FROM minhash_a)\n    UNION ALL\n    (SELECT mh FROM minhash_c)\n  );\n+-----------------------------+\n| APPROXIMATE_SIMILARITY (MH) |\n|-----------------------------|\n|                           0 |\n+-----------------------------+"
},
{
    "function_name": "MINHASH",
    "summary": "Returns a MinHash state containing an array of size k constructed by applying k number of different hash functions to the input rows and keeping the minimum of each hash function.",
    "category": "Aggregate functions , Window function syntax and usage",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/minhash",
    "title": "MINHASH",
    "description": "Returns a MinHash state containing an array of size",
    "syntax": "MINHASH( <k> , [ DISTINCT ] expr+ )\n\nMINHASH( <k> , * )",
    "example": "USE SCHEMA snowflake_sample_data.tpch_sf1;\n\nSELECT MINHASH(5, *) FROM orders;\n\n+----------------------+\n| MINHASH(5, *)        |\n|----------------------|\n| {                    |\n|   \"state\": [         |\n|     78678383574307,  |\n|     586952033158539, |\n|     525995912623966, |\n|     508991839383217, |\n|     492677003405678  |\n|   ],                 |\n|   \"type\": \"minhash\", |\n|   \"version\": 1       |\n| }                    |\n+----------------------+\n\nCREATE TABLE ta (i INTEGER);\nCREATE TABLE tb (i INTEGER);\nCREATE TABLE tc (i INTEGER);\n\n-- Insert values into the 3 tables.\nINSERT INTO ta (i) VALUES (1), (2), (3), (4), (5), (6), (7), (8), (9), (10);\n-- Almost the same as the preceding values.\nINSERT INTO tb (i) VALUES (1), (2), (3), (4), (5), (6), (7), (8), (9), (11);\n-- Different values and different number of values.\nINSERT INTO tc (i) VALUES (-1), (-20), (-300), (-4000);\n\nCREATE TABLE minhash_a_1 (mh) AS SELECT MINHASH(100, i) FROM ta;\nCREATE TABLE minhash_b (mh) AS SELECT MINHASH(100, i) FROM tb;\nCREATE TABLE minhash_c (mh) AS SELECT MINHASH(100, i) FROM tc;\n\nINSERT INTO ta (i) VALUES (12);\n\n-- Record minhash information about only the new rows:\nCREATE TABLE minhash_a_2 (mh) AS SELECT MINHASH(100, i) FROM ta WHERE i > 10;\n\n-- Now combine all the minhash info for the old and new rows in table ta.\nCREATE TABLE minhash_a (mh) AS\n  SELECT MINHASH_COMBINE(mh) FROM\n    (\n      (SELECT mh FROM minhash_a_1)\n      UNION ALL\n      (SELECT mh FROM minhash_a_2)\n    );\n\nSELECT APPROXIMATE_SIMILARITY (mh) FROM\n  (\n    (SELECT mh FROM minhash_a)\n    UNION ALL\n    (SELECT mh FROM minhash_b)\n  );\n+-----------------------------+\n| APPROXIMATE_SIMILARITY (MH) |\n|-----------------------------|\n|                        0.75 |\n+-----------------------------+\n\nSELECT APPROXIMATE_SIMILARITY (mh) FROM\n  (\n    (SELECT mh FROM minhash_a)\n    UNION ALL\n    (SELECT mh FROM minhash_c)\n  );\n+-----------------------------+\n| APPROXIMATE_SIMILARITY (MH) |\n|-----------------------------|\n|                           0 |\n+-----------------------------+"
},
{
    "function_name": "MIN_BY",
    "summary": "Finds the row(s) containing the minimum value for a column and returns the value of another column in that row.",
    "category": "Aggregate functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/min_by",
    "title": "MIN_BY",
    "description": "Finds the row(s) containing the minimum value for a column and returns the value of another column in that row.",
    "syntax": "MIN_BY( <col_to_return>, <col_containing_mininum> [ , <maximum_number_of_values_to_return> ] )",
    "example": "CREATE OR REPLACE TABLE employees(employee_id NUMBER, department_id NUMBER, salary NUMBER);\n\nINSERT INTO employees VALUES\n  (1001, 10, 10000),\n  (1020, 10, 9000),\n  (1030, 10, 8000),\n  (900, 20, 15000),\n  (2000, 20, NULL),\n  (2010, 20, 15000),\n  (2020, 20, 8000);\n\nSELECT * FROM employees;\n\n+-------------+---------------+--------+\n| EMPLOYEE_ID | DEPARTMENT_ID | SALARY |\n|-------------+---------------+--------|\n|        1001 |            10 |  10000 |\n|        1020 |            10 |   9000 |\n|        1030 |            10 |   8000 |\n|         900 |            20 |  15000 |\n|        2000 |            20 |   NULL |\n|        2010 |            20 |  15000 |\n|        2020 |            20 |   8000 |\n+-------------+---------------+--------+\n\nSELECT MIN_BY(employee_id, salary) FROM employees;\n\n+-----------------------------+\n| MIN_BY(EMPLOYEE_ID, SALARY) |\n|-----------------------------|\n|                        1030 |\n+-----------------------------+\n\nSELECT MIN_BY(employee_id, salary, 3) FROM employees;\n\n+--------------------------------+\n| MIN_BY(EMPLOYEE_ID, SALARY, 3) |\n|--------------------------------|\n| [                              |\n|   1030,                        |\n|   2020,                        |\n|   1020                         |\n| ]                              |\n+--------------------------------+",
    "arguments": [
        {
            "name": "col_to_return",
            "description": "Column containing the value to return."
        },
        {
            "name": "col_containing_mininum",
            "description": "Column containing the minimum value."
        },
        {
            "name": "maximum_number_of_values_to_return",
            "description": "Constant integer specifying the maximum number of values to return. You must specify a positive number. The maximum number that\nyou can specify is 1000 ."
        }
    ],
    "returns": "If maximum_number_of_values_to_return is not specified, the function returns a value of the same type as\ncol_to_return."
},
{
    "function_name": "MIN",
    "summary": "Returns the minimum value for the records within expr.",
    "category": "Aggregate functions , Window functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/min",
    "title": "MIN",
    "description": "Returns the minimum value for the records within",
    "syntax": "MIN( <expr> )",
    "example": "CREATE OR REPLACE TABLE sample_table(k CHAR(4), d CHAR(4));\n\nINSERT INTO sample_table VALUES\n    ('1', '1'), ('1', '5'), ('1', '3'),\n    ('2', '2'), ('2', NULL),\n    ('3', NULL),\n    (NULL, '7'), (NULL, '1');\n\nSELECT k, d\n    FROM sample_table\n    ORDER BY k, d;\n\n+------+------+\n| K    | D    |\n|------+------|\n| 1    | 1    |\n| 1    | 3    |\n| 1    | 5    |\n| 2    | 2    |\n| 2    | NULL |\n| 3    | NULL |\n| NULL | 1    |\n| NULL | 7    |\n+------+------+\n\nSELECT MIN(d) FROM sample_table;\n\n+--------+                                                                      \n| MIN(D) |\n|--------|\n| 1      |\n+--------+\n\nSELECT k, MIN(d)\n  FROM sample_table \n  GROUP BY k\n  ORDER BY k;\n\n+------+--------+                                                               \n| K    | MIN(D) |\n|------+--------|\n| 1    | 1      |\n| 2    | 2      |\n| 3    | NULL   |\n| NULL | 1      |\n+------+--------+\n\nSELECT k, d, MIN(d) OVER (PARTITION BY k)\n  FROM sample_table\n  ORDER BY k, d;\n\n+------+------+------------------------------+                                  \n| K    | D    | MIN(D) OVER (PARTITION BY K) |\n|------+------+------------------------------|\n| 1    | 1    | 1                            |\n| 1    | 3    | 1                            |\n| 1    | 5    | 1                            |\n| 2    | 2    | 2                            |\n| 2    | NULL | 2                            |\n| 3    | NULL | NULL                         |\n| NULL | 1    | 1                            |\n| NULL | 7    | 1                            |\n+------+------+------------------------------+\n\nSELECT k, d, MIN(d) OVER (ORDER BY k, d ROWS BETWEEN 1 PRECEDING AND CURRENT ROW)\n  FROM sample_table\n  ORDER BY k, d;\n\n+------+------+----------------------------------------------------------------------+\n| K    | D    | MIN(D) OVER (ORDER BY K, D ROWS BETWEEN 1 PRECEDING AND CURRENT ROW) |\n|------+------+----------------------------------------------------------------------|\n| 1    | 1    | 1                                                                    |\n| 1    | 3    | 1                                                                    |\n| 1    | 5    | 3                                                                    |\n| 2    | 2    | 2                                                                    |\n| 2    | NULL | 2                                                                    |\n| 3    | NULL | NULL                                                                 |\n| NULL | 1    | 1                                                                    |\n| NULL | 7    | 1                                                                    |\n+------+------+----------------------------------------------------------------------+",
    "returns": "The data type of the returned value is the same as the data type of the input values."
},
{
    "function_name": "MEDIAN",
    "summary": "Determines the median of a set of values.",
    "category": "Aggregate functions , Window functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/median",
    "title": "MEDIAN",
    "description": "Determines the median of a set of values.",
    "syntax": "MEDIAN( <expr> )",
    "example": "CREATE OR REPLACE TABLE aggr(k int, v decimal(10,2));\n\nSELECT MEDIAN (v) FROM aggr;\n+------------+\n| MEDIAN (V) |\n|------------|\n|       NULL |\n+------------+\n\nINSERT INTO aggr VALUES(1, 10), (1,20), (1, 21);\nINSERT INTO aggr VALUES(2, 10), (2, 20), (2, 25), (2, 30);\nINSERT INTO aggr VALUES(3, NULL);\n\nSELECT k, MEDIAN(v) FROM aggr GROUP BY k ORDER BY k;\n+---+-----------+\n| K | MEDIAN(V) |\n|---+-----------|\n| 1 |  20.00000 |\n| 2 |  22.50000 |\n| 3 |      NULL |\n+---+-----------+",
    "returns": "Returns a FLOAT or DECIMAL (fixed-point) number, depending upon the\ninput."
},
{
    "function_name": "MD5_NUMBER_UPPER64",
    "summary": "Calculates the 128-bit MD5 message digest, interprets it as a signed 128-bit big endian number, and returns the upper 64 bits of the number as an unsigned integer.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/md5_number_upper64",
    "title": "MD5_NUMBER_UPPER64",
    "description": "Calculates the 128-bit MD5 message digest, interprets it as a signed 128-bit big endian number, and returns the upper 64 bits of\nthe number as an unsigned integer. This representation is useful for maximally efficient storage and comparison of MD5 digests.",
    "syntax": "MD5_NUMBER_UPPER64(<msg>)",
    "example": "select md5_number_upper64('Snowflake');\n\n+---------------------------------+\n| MD5_NUMBER_UPPER64('SNOWFLAKE') |\n|---------------------------------|\n|            17145559544104499780 |\n+---------------------------------+",
    "arguments": [
        {
            "name": "msg",
            "description": "A string expression, the message to be hashed."
        }
    ],
    "returns": "A 64 bit unsigned integer that represents the upper 64 bits of the message digest."
},
{
    "function_name": "MD5_NUMBER_LOWER64",
    "summary": "Calculates the 128-bit MD5 message digest, interprets it as a signed 128-bit big endian number, and returns the lower 64 bits of the number as an unsigned integer.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/md5_number_lower64",
    "title": "MD5_NUMBER_LOWER64",
    "description": "Calculates the 128-bit MD5 message digest, interprets it as a signed 128-bit big endian number, and returns the lower 64 bits of\nthe number as an unsigned integer. This representation is useful for maximally efficient storage and comparison of MD5 digests.",
    "syntax": "MD5_NUMBER_LOWER64(<msg>)",
    "example": "select md5_number_lower64('Snowflake');\n\n+---------------------------------+\n| MD5_NUMBER_LOWER64('SNOWFLAKE') |\n|---------------------------------|\n|             9203306159527282910 |\n+---------------------------------+",
    "arguments": [
        {
            "name": "msg",
            "description": "A string expression, the message to be hashed."
        }
    ],
    "returns": "A 64 bit unsigned integer that represents the lower 64 bits of the message digest."
},
{
    "function_name": "MD5_NUMBER — Obsoleted",
    "summary": "Returns the 128-bit MD5 message digest interpreted as a signed 128-bit big endian number.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/md5_number",
    "title": "MD5_NUMBER —",
    "syntax": "MD5_NUMBER(<msg>)",
    "example": "SELECT md5_number('Snowflake');\n\n-----------------------------------------+\n         MD5_NUMBER('SNOWFLAKE')         |\n-----------------------------------------+\n -24002618010294540563082926240470284066 |\n-----------------------------------------+",
    "arguments": [
        {
            "name": "msg",
            "description": "A string expression, the message to be hashed."
        }
    ],
    "returns": "A signed integer (NUMERIC(38, 0))."
},
{
    "function_name": "MD5_BINARY",
    "summary": "Returns a 16-byte BINARY value containing the 128-bit MD5 message digest.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/md5_binary",
    "title": "MD5_BINARY",
    "description": "Returns a 16-byte",
    "syntax": "MD5_BINARY(<msg>)",
    "example": "SELECT md5_binary('Snowflake');\n+----------------------------------+\n| MD5_BINARY('SNOWFLAKE')          |\n|----------------------------------|\n| EDF1439075A83A447FB8B630DDC9C8DE |\n+----------------------------------+\n\nCREATE TABLE binary_demo (b BINARY);\nINSERT INTO binary_demo (b) SELECT MD5_BINARY('Snowflake');\n\nSELECT TO_VARCHAR(b, 'HEX') AS hex_representation\n    FROM binary_demo;\n+----------------------------------+\n| HEX_REPRESENTATION               |\n|----------------------------------|\n| EDF1439075A83A447FB8B630DDC9C8DE |\n+----------------------------------+",
    "arguments": [
        {
            "name": "msg",
            "description": "A string expression, the message to be hashed."
        }
    ],
    "returns": "Returns a 16-byte BINARY value containing the MD5 message digest."
},
{
    "function_name": "MD5 , MD5_HEX",
    "summary": "Returns a 32-character hex-encoded string containing the 128-bit MD5 message digest.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/md5",
    "title": "MD5 , MD5_HEX",
    "description": "Returns a 32-character hex-encoded string containing the 128-bit MD5\nmessage digest.",
    "syntax": "MD5(<msg>)\n\nMD5_HEX(<msg>)",
    "example": "SELECT md5('Snowflake');\n\n----------------------------------+\n         MD5('SNOWFLAKE')         |\n----------------------------------+\n edf1439075a83a447fb8b630ddc9c8de |\n----------------------------------+",
    "arguments": [
        {
            "name": "msg",
            "description": "A string expression, the message to be hashed."
        }
    ],
    "returns": "Returns a 32-character hex-encoded string."
},
{
    "function_name": "MAX_BY",
    "summary": "Finds the row(s) containing the maximum value for a column and returns the value of another column in that row.",
    "category": "Aggregate functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/max_by",
    "title": "MAX_BY",
    "description": "Finds the row(s) containing the maximum value for a column and returns the value of another column in that row.",
    "syntax": "MAX_BY( <col_to_return>, <col_containing_maximum> [ , <maximum_number_of_values_to_return> ] )",
    "example": "CREATE OR REPLACE TABLE employees(employee_id NUMBER, department_id NUMBER, salary NUMBER);\n\nINSERT INTO employees VALUES\n  (1001, 10, 10000),\n  (1020, 10, 9000),\n  (1030, 10, 8000),\n  (900, 20, 15000),\n  (2000, 20, NULL),\n  (2010, 20, 15000),\n  (2020, 20, 8000);\n\nSELECT * FROM employees;\n\n+-------------+---------------+--------+\n| EMPLOYEE_ID | DEPARTMENT_ID | SALARY |\n|-------------+---------------+--------|\n|        1001 |            10 |  10000 |\n|        1020 |            10 |   9000 |\n|        1030 |            10 |   8000 |\n|         900 |            20 |  15000 |\n|        2000 |            20 |   NULL |\n|        2010 |            20 |  15000 |\n|        2020 |            20 |   8000 |\n+-------------+---------------+--------+\n\nSELECT MAX_BY(employee_id, salary) FROM employees;\n\n+-----------------------------+\n| MAX_BY(EMPLOYEE_ID, SALARY) |\n|-----------------------------|\n|                         900 |\n+-----------------------------+\n\nSELECT MAX_BY(employee_id, salary, 3) from employees;\n\n+--------------------------------+\n| MAX_BY(EMPLOYEE_ID, SALARY, 3) |\n|--------------------------------|\n| [                              |\n|   900,                         |\n|   2010,                        |\n|   1001                         |\n| ]                              |\n+--------------------------------+",
    "arguments": [
        {
            "name": "col_to_return",
            "description": "Column containing the value to return."
        },
        {
            "name": "col_containing_maximum",
            "description": "Column containing the maximum value."
        },
        {
            "name": "maximum_number_of_values_to_return",
            "description": "Constant integer specifying the maximum number of values to return. You must specify a positive number. The maximum number that\nyou can specify is 1000 ."
        }
    ],
    "returns": "If maximum_number_of_values_to_return is not specified, the function returns a value of the same type as\ncol_to_return."
},
{
    "function_name": "MAX",
    "summary": "Returns the maximum value for the records within expr.",
    "category": "Aggregate functions , Window functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/max",
    "title": "MAX",
    "description": "Returns the maximum value for the records within",
    "syntax": "MAX( <expr> )",
    "example": "CREATE OR REPLACE TABLE sample_table(k CHAR(4), d CHAR(4));\n\nINSERT INTO sample_table VALUES\n    ('1', '1'), ('1', '5'), ('1', '3'),\n    ('2', '2'), ('2', NULL),\n    ('3', NULL),\n    (NULL, '7'), (NULL, '1');\n\nSELECT k, d\n    FROM sample_table\n    ORDER BY k, d;\n\n+------+------+\n| K    | D    |\n|------+------|\n| 1    | 1    |\n| 1    | 3    |\n| 1    | 5    |\n| 2    | 2    |\n| 2    | NULL |\n| 3    | NULL |\n| NULL | 1    |\n| NULL | 7    |\n+------+------+\n\nSELECT MAX(d) FROM sample_table;\n\n+--------+                                                                      \n| MAX(D) |\n|--------|\n| 7      |\n+--------+\n\nSELECT k, MAX(d)\n  FROM sample_table \n  GROUP BY k\n  ORDER BY k;\n\n+------+--------+                                                               \n| K    | MAX(D) |\n|------+--------|\n| 1    | 5      |\n| 2    | 2      |\n| 3    | NULL   |\n| NULL | 7      |\n+------+--------+\n\nSELECT k, d, MAX(d) OVER (PARTITION BY k)\n  FROM sample_table\n  ORDER BY k, d;\n\n+------+------+------------------------------+                                  \n| K    | D    | MAX(D) OVER (PARTITION BY K) |\n|------+------+------------------------------|\n| 1    | 1    | 5                            |\n| 1    | 3    | 5                            |\n| 1    | 5    | 5                            |\n| 2    | 2    | 2                            |\n| 2    | NULL | 2                            |\n| 3    | NULL | NULL                         |\n| NULL | 1    | 7                            |\n| NULL | 7    | 7                            |\n+------+------+------------------------------+\n\nSELECT k, d, MAX(d) OVER (ORDER BY k, d ROWS BETWEEN 1 PRECEDING AND CURRENT ROW)\n  FROM sample_table\n  ORDER BY k, d;\n\n+------+------+----------------------------------------------------------------------+\n| K    | D    | MAX(D) OVER (ORDER BY K, D ROWS BETWEEN 1 PRECEDING AND CURRENT ROW) |\n|------+------+----------------------------------------------------------------------|\n| 1    | 1    | 1                                                                    |\n| 1    | 3    | 3                                                                    |\n| 1    | 5    | 5                                                                    |\n| 2    | 2    | 5                                                                    |\n| 2    | NULL | 2                                                                    |\n| 3    | NULL | NULL                                                                 |\n| NULL | 1    | 1                                                                    |\n| NULL | 7    | 7                                                                    |\n+------+------+----------------------------------------------------------------------+",
    "returns": "The data type of the returned value is the same as the data type of the input values."
},
{
    "function_name": "MATERIALIZED_VIEW_REFRESH_HISTORY",
    "summary": "This table function is used for querying the materialized views refresh history for a specified materialized view within a specified date range.",
    "category": "Information Schema , Table functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/materialized_view_refresh_history",
    "title": "MATERIALIZED_VIEW_REFRESH_HISTORY",
    "syntax": "MATERIALIZED_VIEW_REFRESH_HISTORY(\n      [ DATE_RANGE_START => <constant_expr> ]\n      [ , DATE_RANGE_END => <constant_expr> ]\n      [ , MATERIALIZED_VIEW_NAME => '<string>' ] )",
    "example": "select *\n  from table(information_schema.materialized_view_refresh_history(\n    date_range_start=>'2019-05-22 19:00:00.000',\n    date_range_end=>'2019-05-22 20:00:00.000'));\n\n+-------------------------------+-------------------------------+--------------+-----------------------------------------+\n| START_TIME                    | END_TIME                      | CREDITS_USED | MATERIALIZED_VIEW_NAME                  |\n|-------------------------------+-------------------------------+--------------+-----------------------------------------|\n| 2019-05-22 19:00:00.000 -0700 | 2019-05-22 20:00:00.000 -0700 |  0.223276651 | TEST_DB.TEST_SCHEMA.MATERIALIZED_VIEW_1 |\n+-------------------------------+-------------------------------+--------------+-----------------------------------------+\n\nselect *\n  from table(information_schema.materialized_view_refresh_history(\n    date_range_start=>dateadd(H, -12, current_timestamp)));\n\nselect *\n  from table(information_schema.materialized_view_refresh_history(\n    date_range_start=>dateadd(D, -7, current_date),\n    date_range_end=>current_date));\n\nselect *\n  from table(information_schema.materialized_view_refresh_history(\n    date_range_start=>dateadd(D, -7, current_date),\n    date_range_end=>current_date,\n    materialized_view_name=>'mydb.myschema.my_materialized_view'));",
    "arguments": [
        {
            "name": "DATE_RANGE_START",
            "description": "The date/time range to display the materialized view maintenance history.\nFor example, if you specify that the start date is 2019-04-03 and the end date is 2019-04-05, then you get data for\nApril 3, April 4, and April 5. (The endpoints are included.) If neither a start date nor an end date is specified, the default will be the last 12 hours. If an end date is not specified, but a start date is specified, then CURRENT_DATE at midnight is used as the end of the range. If a start date is not specified, but an end date is specified, then the range starts 12 hours prior to the start\nof DATE_RANGE_END ."
        },
        {
            "name": "MATERIALIZED_VIEW_NAME",
            "description": "Materialized view name. If specified, only shows the history for the specified materialized view. The name can include the schema name and the database\nname. If a name is not specified, then the results includes the data for each materialized\nview maintained within the specified time range."
        }
    ]
},
{
    "function_name": "MAP_SIZE",
    "summary": "Returns the size of a MAP.",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/map_size",
    "title": "MAP_SIZE",
    "description": "Returns the size of a",
    "syntax": "MAP_SIZE( <map> )",
    "example": "SELECT MAP_SIZE({'a':1,'b':2,'c':3}::MAP(VARCHAR,NUMBER))\n  AS map_size;\n\n+----------+\n| MAP_SIZE |\n|----------|\n|        3 |\n+----------+",
    "arguments": [
        {
            "name": "map",
            "description": "The input map."
        }
    ],
    "returns": "Returns the number of entries in the map."
},
{
    "function_name": "MAP_PICK",
    "summary": "Returns a new MAP containing the specified key-value pairs from an existing MAP.",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/map_pick",
    "title": "MAP_PICK",
    "description": "Returns a new",
    "syntax": "MAP_PICK( <map>, <key1> [, <key2>, ... ] )\n\nMAP_PICK( <map>, <array> )",
    "example": "SELECT MAP_PICK({'a':1,'b':2,'c':3}::MAP(VARCHAR,NUMBER),'a', 'b')\n  AS new_map;\n\n+-----------+\n| NEW_MAP   |\n|-----------|\n| {         |\n|   \"a\": 1, |\n|   \"b\": 2  |\n| }         |\n+-----------+\n\nSELECT MAP_PICK({'a':1,'b':2,'c':3}::MAP(VARCHAR,NUMBER), ['a', 'b'])\n  AS new_map;\n\n+-----------+\n| NEW_MAP   |\n|-----------|\n| {         |\n|   \"a\": 1, |\n|   \"b\": 2  |\n| }         |\n+-----------+",
    "arguments": [
        {
            "name": "map",
            "description": "The input map."
        },
        {
            "name": "key1",
            "description": "One or more keys that identify the key-value pairs to be included in the returned map."
        },
        {
            "name": "array",
            "description": "An array of keys that identify the key-value pairs to be included in the returned map. You can specify a semi-structured ARRAY\nor a structured ARRAY."
        }
    ],
    "returns": "Returns a new MAP containing some of the key-value pairs from an existing MAP."
},
{
    "function_name": "MAP_KEYS",
    "summary": "Returns the keys in a MAP.",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/map_keys",
    "title": "MAP_KEYS",
    "description": "Returns the keys in a",
    "syntax": "MAP_KEYS( <map> )",
    "example": "SELECT MAP_KEYS({'a':1,'b':2,'c':3}::MAP(VARCHAR,NUMBER))\n  AS map_keys;\n\n+----------+\n| MAP_KEYS |\n|----------|\n| [        |\n|   \"a\",   |\n|   \"b\",   |\n|   \"c\"    |\n| ]        |\n+----------+",
    "arguments": [
        {
            "name": "map",
            "description": "The input map."
        }
    ],
    "returns": "Returns a structured ARRAY containing the keys in the MAP. The order of the keys is undefined."
},
{
    "function_name": "MAP_INSERT",
    "summary": "Returns a new MAP consisting of the input MAP with a new key-value pair inserted (an existing key updated with a new value).",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/map_insert",
    "title": "MAP_INSERT",
    "description": "Returns a new",
    "syntax": "MAP_INSERT( <map> , <key> , <value> [ , <updateFlag> ] )",
    "example": "SELECT MAP_INSERT({'a':1,'b':2}::MAP(VARCHAR,NUMBER),'c',3);\n\n+------------------------------------------------------+\n| MAP_INSERT({'A':1,'B':2}::MAP(VARCHAR,NUMBER),'C',3) |\n|------------------------------------------------------|\n| {                                                    |\n|   \"a\": 1,                                            |\n|   \"b\": 2,                                            |\n|   \"c\": 3                                             |\n| }                                                    |\n+------------------------------------------------------+\n\nSELECT MAP_INSERT(MAP_INSERT(MAP_INSERT({}::MAP(VARCHAR,VARCHAR),\n  'Key_One', PARSE_JSON('NULL')), 'Key_Two', NULL), 'Key_Three', 'null');\n\n+---------------------------------------------------------------------------+\n| MAP_INSERT(MAP_INSERT(MAP_INSERT({}::MAP(VARCHAR,VARCHAR),                |\n|    'KEY_ONE', PARSE_JSON('NULL')), 'KEY_TWO', NULL), 'KEY_THREE', 'NULL') |\n|---------------------------------------------------------------------------|\n| {                                                                         |\n|   \"Key_One\": null,                                                        |\n|   \"Key_Three\": \"null\",                                                    |\n|   \"Key_Two\": null                                                         |\n| }                                                                         |\n+---------------------------------------------------------------------------+\n\nSELECT MAP_INSERT({'k1':100}::MAP(VARCHAR,VARCHAR), 'k1', 'string-value', TRUE) AS map;\n\n+------------------------+\n| MAP                    |\n|------------------------|\n| {                      |\n|   \"k1\": \"string-value\" |\n| }                      |\n+------------------------+",
    "arguments": [
        {
            "name": "map",
            "description": "The source map into which the new key-value pair is inserted."
        },
        {
            "name": "key",
            "description": "The new key to insert into the map. Must be different from all existing keys in the map, unless updateFlag is set to\nTRUE."
        },
        {
            "name": "value",
            "description": "The value associated with the key."
        },
        {
            "name": "updateFlag",
            "description": "A Boolean flag that, when set to TRUE, specifies the input value is used to update/overwrite an existing key in the map,\nrather than inserting a new key-value pair. The default is FALSE."
        }
    ],
    "returns": "Returns a MAP consisting of the input MAP with a new key-value pair inserted or an existing key\nupdated with a new value."
},
{
    "function_name": "MAP_DELETE",
    "summary": "Returns a MAP based on an existing MAP with one or more keys removed..",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/map_delete",
    "title": "MAP_DELETE",
    "description": "Returns a",
    "syntax": "MAP_DELETE( <map>, <key1> [, <key2>, ... ] )",
    "example": "SELECT MAP_DELETE({'a':1,'b':2,'c':3}::MAP(VARCHAR,NUMBER),'a','b');\n\n+--------------------------------------------------------------+\n| MAP_DELETE({'A':1,'B':2,'C':3}::MAP(VARCHAR,NUMBER),'A','B') |\n|--------------------------------------------------------------|\n| {                                                            |\n|   \"c\": 3                                                     |\n| }                                                            |\n+--------------------------------------------------------------+",
    "arguments": [
        {
            "name": "map",
            "description": "The map that contains the key to remove."
        },
        {
            "name": "keyN",
            "description": "The key to be omitted from the returned map."
        }
    ],
    "returns": "Returns a MAP that contains the contents of the input (source) map with one or more keys removed."
},
{
    "function_name": "MAP_CONTAINS_KEY",
    "summary": "Determines whether the specified MAP contains the specified key.",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/map_contains_key",
    "title": "MAP_CONTAINS_KEY",
    "description": "Determines whether the specified",
    "syntax": "MAP_CONTAINS_KEY( <key> , <map> )",
    "example": "SELECT MAP_CONTAINS_KEY(\n  'k1',{'k1':'v1','k2':'v2','k3':'v3'}::MAP(VARCHAR,VARCHAR))\n  AS contains_key;\n\n+--------------+\n| CONTAINS_KEY |\n|--------------|\n| True         |\n+--------------+\n\nSELECT MAP_CONTAINS_KEY(\n  'k1',{'ka':'va','kb':'vb','kc':'vc'}::MAP(VARCHAR,VARCHAR))\n  AS contains_key;\n\n+--------------+\n| CONTAINS_KEY |\n|--------------|\n| False        |\n+--------------+\n\nSELECT MAP_CONTAINS_KEY(\n  'k1',{'1':'va','2':'vb','3':'vc'}::MAP(NUMBER,VARCHAR))\n  AS contains_key;\n\n001065 (22023): SQL compilation error:\nFunction MAP_CONTAINS_KEY cannot be used with arguments of types VARCHAR(2) and MAP(NUMBER(38,0), VARCHAR(134217728))",
    "arguments": [
        {
            "name": "key",
            "description": "The key to find."
        },
        {
            "name": "map",
            "description": "The map to be searched."
        }
    ],
    "returns": "Returns TRUE if the specified map contains the specified key."
},
{
    "function_name": "MAP_CAT",
    "summary": "Returns the concatenatation of two MAPs.",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/map_cat",
    "title": "MAP_CAT",
    "description": "Returns the concatenatation of two",
    "syntax": "MAP_CAT( <map1> , <map2> )",
    "example": "SELECT MAP_CAT(\n  {'map1key1':'map1value1','map1key2':'map1value2'}::MAP(VARCHAR,VARCHAR),\n  {'map2key1':'map2value1','map2key2':'map2value2'}::MAP(VARCHAR,VARCHAR))\n  AS concatenated_maps;\n\n+-----------------------------+\n| CONCATENATED_MAPS           |\n|-----------------------------|\n| {                           |\n|   \"map1key1\": \"map1value1\", |\n|   \"map1key2\": \"map1value2\", |\n|   \"map2key1\": \"map2value1\", |\n|   \"map2key2\": \"map2value2\"  |\n| }                           |\n+-----------------------------+",
    "arguments": [
        {
            "name": "map1",
            "description": "The source MAP."
        },
        {
            "name": "map2",
            "description": "The MAP to be appended to map1 ."
        }
    ],
    "returns": "The return type of this function is the type of map1. map2 is coerced into the map1 type following the coercion rules. For information about coercion rules, see Implicit casting a value (coercion)."
},
{
    "function_name": "LTRIM",
    "summary": "Removes leading characters, including whitespace, from a string.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/ltrim",
    "title": "LTRIM",
    "description": "Removes leading characters, including whitespace, from a string.",
    "syntax": "LTRIM( <expr> [, <characters> ] )",
    "example": "SELECT LTRIM('#000000123', '0#');\n\n+---------------------------+\n| LTRIM('#000000123', '0#') |\n|---------------------------|\n| 123                       |\n+---------------------------+\n\nCREATE OR REPLACE TABLE test_ltrim_function(column1 VARCHAR);\n\nINSERT INTO test_ltrim_function VALUES ('  #Leading Spaces');\n\nSELECT CONCAT('>', CONCAT(column1, '<')) AS original_value,\n       CONCAT('>', CONCAT(LTRIM(column1), '<')) AS trimmed_value\n  FROM test_ltrim_function;\n\n+---------------------+-------------------+\n| ORIGINAL_VALUE      | TRIMMED_VALUE     |\n|---------------------+-------------------|\n| >  #Leading Spaces< | >#Leading Spaces< |\n+---------------------+-------------------+\n\nSELECT CONCAT('>', CONCAT(column1, '<')) AS original_value,\n       CONCAT('>', CONCAT(LTRIM(column1, ' #'), '<')) AS trimmed_value\n  FROM test_ltrim_function;\n\n+---------------------+------------------+\n| ORIGINAL_VALUE      | TRIMMED_VALUE    |\n|---------------------+------------------|\n| >  #Leading Spaces< | >Leading Spaces< |\n+---------------------+------------------+",
    "arguments": [
        {
            "name": "expr",
            "description": "The string expression to be trimmed."
        },
        {
            "name": "characters",
            "description": "One or more characters to remove from the left side of expr . The default value is ' ' (a single blank space character).\nIf no characters are specified, only blank spaces are removed."
        }
    ],
    "returns": "This function returns a value of VARCHAR data type or NULL. If either argument is NULL, returns NULL."
},
{
    "function_name": "LPAD",
    "summary": "Left-pads a string with characters from another string, or left-pads a binary value with bytes from another binary value.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/lpad",
    "title": "LPAD",
    "description": "Left-pads a string with characters from another string, or left-pads a binary value with bytes from another binary value.",
    "syntax": "LPAD( <base>, <length_expr> [, <pad>] )",
    "example": "CREATE OR REPLACE TABLE demo_lpad_ids (id VARCHAR);\n\nINSERT INTO demo_lpad_ids VALUES\n  ('5'),\n  ('50'),\n  ('500');\n\nSELECT id, LPAD(id, 8, '0') AS padded_ids\n  FROM demo_lpad_ids;\n\n+-----+------------+\n| ID  | PADDED_IDS |\n|-----+------------|\n| 5   | 00000005   |\n| 50  | 00000050   |\n| 500 | 00000500   |\n+-----+------------+\n\nCREATE OR REPLACE TABLE padding_example (v VARCHAR, b BINARY);\n\nINSERT INTO padding_example (v, b)\n  SELECT\n    'Hi',\n    HEX_ENCODE('Hi');\n\nINSERT INTO padding_example (v, b)\n  SELECT\n    '-123.00',\n    HEX_ENCODE('-123.00');\n\nINSERT INTO padding_example (v, b)\n  SELECT\n    'Twelve Dollars',\n    TO_BINARY(HEX_ENCODE('Twelve Dollars'), 'HEX');\n\nSELECT * FROM padding_example;\n\n+----------------+------------------------------+\n| V              | B                            |\n|----------------+------------------------------|\n| Hi             | 4869                         |\n| -123.00        | 2D3132332E3030               |\n| Twelve Dollars | 5477656C766520446F6C6C617273 |\n+----------------+------------------------------+\n\nSELECT v,\n       LPAD(v, 10, ' ') AS pad_with_blank,\n       LPAD(v, 10, '$') AS pad_with_dollar_sign\n  FROM padding_example\n  ORDER BY v;\n\n+----------------+----------------+----------------------+\n| V              | PAD_WITH_BLANK | PAD_WITH_DOLLAR_SIGN |\n|----------------+----------------+----------------------|\n| -123.00        |    -123.00     | $$$-123.00           |\n| Hi             |         Hi     | $$$$$$$$Hi           |\n| Twelve Dollars | Twelve Dol     | Twelve Dol           |\n+----------------+----------------+----------------------+\n\nSELECT b,\n       LPAD(b, 10, TO_BINARY(HEX_ENCODE(' '))) AS pad_with_blank,\n       LPAD(b, 10, TO_BINARY(HEX_ENCODE('$'))) AS pad_with_dollar_sign\n  FROM padding_example\n  ORDER BY b;\n\n+------------------------------+----------------------+----------------------+\n| B                            | PAD_WITH_BLANK       | PAD_WITH_DOLLAR_SIGN |\n|------------------------------+----------------------+----------------------|\n| 2D3132332E3030               | 2020202D3132332E3030 | 2424242D3132332E3030 |\n| 4869                         | 20202020202020204869 | 24242424242424244869 |\n| 5477656C766520446F6C6C617273 | 5477656C766520446F6C | 5477656C766520446F6C |\n+------------------------------+----------------------+----------------------+\n\nSELECT LPAD('123.50', 19, '*_');\n\n+--------------------------+\n| LPAD('123.50', 19, '*_') |\n|--------------------------|\n| *_*_*_*_*_*_*123.50      |\n+--------------------------+",
    "arguments": [
        {
            "name": "base",
            "description": "A VARCHAR or BINARY value."
        },
        {
            "name": "length_expr",
            "description": "An expression that evaluates to an integer. It specifies: The number of UTF-8 characters to return if the input is VARCHAR. The number of bytes to return if the input is BINARY."
        },
        {
            "name": "pad",
            "description": "A VARCHAR or BINARY value. The type must match the data type of the base argument.\nCharacters (or bytes) from this argument are used to pad the base ."
        }
    ],
    "returns": "The data type of the returned value is the same as the data type of the base input value (VARCHAR or BINARY)."
},
{
    "function_name": "LOWER",
    "summary": "Returns the input string with all characters converted to lowercase.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/lower",
    "title": "LOWER",
    "description": "Returns the input string with all characters converted to lowercase.",
    "syntax": "LOWER( <expr> )",
    "example": "SELECT v, LOWER(v) FROM lu;\n\n+----------------------------------+----------------------------------+\n|                v                 |             lower(v)             |\n+----------------------------------+----------------------------------+\n|                                  |                                  |\n| The Quick Gray Fox               | the quick gray fox               |\n| LAUGHING ALL THE WAY             | laughing all the way             |\n| OVER the River 2 Times           | over the river 2 times           |\n| UuVvWwXxYyZz                     | uuvvwwxxyyzz                     |\n| ÁáÄäÉéÍíÓóÔôÚúÝý                 | ááääééííóóôôúúýý                 |\n| ÄäÖößÜü                          | ääöößüü                          |\n| ÉéÀàÈèÙùÂâÊêÎîÔôÛûËëÏïÜüŸÿÇçŒœÆæ | ééààèèùùââêêîîôôûûëëïïüüÿÿççœœææ |\n| ĄąĆćĘęŁłŃńÓóŚśŹźŻż               | ąąććęęłłńńóóśśźźżż               |\n| ČčĎďĹĺĽľŇňŔŕŠšŤťŽž               | ččďďĺĺľľňňŕŕššťťžž               |\n| АаБбВвГгДдЕеЁёЖжЗзИиЙй           | ааббввггддееёёжжззиийй           |\n| КкЛлМмНнОоПпРрСсТтУуФф           | ккллммннооппррссттууфф           |\n| ХхЦцЧчШшЩщЪъЫыЬьЭэЮюЯя           | ххццччшшщщъъыыььээююяя           |\n| [NULL]                           | [NULL]                           |\n+----------------------------------+----------------------------------+\n\nSELECT LOWER('I' COLLATE 'tr');\n\n+-------------------------+\n| LOWER('I' COLLATE 'TR') |\n|-------------------------|\n| ı                       |\n+-------------------------+",
    "arguments": [
        {
            "name": "expr",
            "description": "The string expression."
        }
    ],
    "returns": "This function returns a value of type VARCHAR."
},
{
    "function_name": "LOGIN_HISTORY , LOGIN_HISTORY_BY_USER",
    "summary": "The LOGIN_HISTORY family of table functions can be used to query login attempts by Snowflake users along various dimensions.",
    "category": "Information Schema , Table functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/login_history",
    "title": "LOGIN_HISTORY , LOGIN_HISTORY_BY_USER",
    "description": "The LOGIN_HISTORY family of table functions can be used to query login attempts by Snowflake users along various dimensions:",
    "syntax": "LOGIN_HISTORY(\n      [  TIME_RANGE_START => <constant_expr> ]\n      [, TIME_RANGE_END => <constant_expr> ]\n      [, RESULT_LIMIT => <num> ] )\n\nLOGIN_HISTORY_BY_USER(\n      [  USER_NAME => '<string>' ]\n      [, TIME_RANGE_START => <constant_expr> ]\n      [, TIME_RANGE_END => <constant_expr> ]\n      [, RESULT_LIMIT => <num> ] )",
    "example": "select *\nfrom table(information_schema.login_history_by_user())\norder by event_timestamp;\n\nselect *\nfrom table(information_schema.login_history_by_user(USER_NAME => 'USER1', result_limit => 1000))\norder by event_timestamp;\n\nselect *\nfrom table(information_schema.login_history(TIME_RANGE_START => dateadd('hours',-1,current_timestamp()),current_timestamp()))\norder by event_timestamp;",
    "arguments": [
        {
            "name": "TIME_RANGE_START",
            "description": "Time range (in TIMESTAMP_LTZ format), within the last 7 days, in which the login event occurred. If TIME_RANGE_END is not specified, the function returns the most recent login events. If the time range does not fall within the last 7 days, an error is returned."
        },
        {
            "name": "USER_NAME",
            "description": "Applies only to LOGIN_HISTORY_BY_USER A string specifying a user name or CURRENT_USER . Only login events for the specified user are returned. Note that the login name must be enclosed in single quotes. Also, if the\nlogin name contains any spaces, mixed-case characters, or special characters, the name must be double-quoted within the single quotes (e.g. '\"User 1\"' vs 'user1' ). Default: CURRENT_USER"
        },
        {
            "name": "RESULT_LIMIT",
            "description": "A number specifying the maximum number of rows returned by the function. If the number of matching rows is greater than this limit, the login events with the most recent timestamp are returned, up to the specified limit. Range: 1 to 10000 Default: 100 ."
        }
    ]
},
{
    "function_name": "LOG",
    "summary": "Returns the logarithm of a numeric expression.",
    "category": "Numeric functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/log",
    "title": "LOG",
    "description": "Returns the logarithm of a numeric expression.",
    "syntax": "LOG(<base>, <expr>)",
    "example": "SELECT x, y, log(x, y) FROM tab;\n\n--------+--------+-------------+\n   X    |   Y    |  LOG(X, Y)  |\n--------+--------+-------------+\n 2      | 0.5    | -1          |\n 2      | 1      | 0           |\n 2      | 8      | 3           |\n 2      | 16     | 4           |\n 10     | 10     | 1           |\n 10     | 20     | 1.301029996 |\n 10     | [NULL] | [NULL]      |\n [NULL] | 10     | [NULL]      |\n [NULL] | [NULL] | [NULL]      |\n--------+--------+-------------+",
    "arguments": [
        {
            "name": "base",
            "description": "The “base” to use (e.g. 10 for base 10 arithmetic). This can be of any numeric data type (INTEGER, fixed-point, or floating\npoint). base should be greater than 0. base should not be exactly 1.0."
        },
        {
            "name": "expr",
            "description": "The value for which you want to know the log. This can be of any numeric data type (INTEGER, fixed-point, or floating\npoint). expr should be greater than 0."
        }
    ],
    "returns": "Always returns a floating point number, even if one or more of the input\nexpressions are of type integer or fixed-point."
},
{
    "function_name": "LOCALTIMESTAMP",
    "summary": "Returns the current timestamp for the system in the local time zone.",
    "category": "Context functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/localtimestamp",
    "title": "LOCALTIMESTAMP",
    "description": "Returns the current timestamp for the system in the local time zone.",
    "syntax": "LOCALTIMESTAMP( [ <fract_sec_precision> ] )\n\nLOCALTIMESTAMP",
    "example": "SELECT LOCALTIME(), LOCALTIMESTAMP();\n\n+-------------+-------------------------------+\n| LOCALTIME() | LOCALTIMESTAMP()              |\n|-------------+-------------------------------|\n| 07:58:09    | 2024-04-18 07:58:09.848 -0700 |\n+-------------+-------------------------------+",
    "arguments": [
        {
            "name": "fract_sec_precision",
            "description": "This optional argument indicates the precision with which to report the\ntime. For example, a value of 3 says to use 3 digits after the decimal\npoint (i.e. to specify the time with a precision of milliseconds). The default precision is 9 (nanoseconds). Valid values range from 0 - 9. However, most platforms do not support true\nnanosecond precision; the precision that you get might be less than the\nprecision you specify. In practice, precision is usually approximately\nmilliseconds (3 digits) at most. Note Fractional seconds are only displayed if they have been explicitly set in the TIMESTAMP_OUTPUT_FORMAT parameter for the session (e.g. 'YYYY-MM-DD HH24:MI:SS.FF' )."
        }
    ],
    "returns": "Returns the current system time. The data type of the returned value is\nTIMESTAMP_LTZ."
},
{
    "function_name": "LOCALTIME",
    "summary": "Returns the current time for the system.",
    "category": "Context functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/localtime",
    "title": "LOCALTIME",
    "description": "Returns the current time for the system.",
    "syntax": "LOCALTIME()\n\nLOCALTIME",
    "example": "SELECT LOCALTIME(), LOCALTIMESTAMP();\n\n+-------------+-------------------------------+\n| LOCALTIME() | LOCALTIMESTAMP()              |\n|-------------+-------------------------------|\n| 15:32:45    | 2024-04-17 15:32:45.775 -0700 |\n+-------------+-------------------------------+",
    "returns": "Returns a value of type TIME."
},
{
    "function_name": "LN",
    "summary": "Returns the natural logarithm of a numeric expression.",
    "category": "Numeric functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/ln",
    "title": "LN",
    "description": "Returns the natural logarithm of a numeric expression.",
    "syntax": "LN(<expr>)",
    "example": "SELECT x, ln(x) FROM tab;\n\n--------+-------------+\n   X    |    LN(X)    |\n--------+-------------+\n 1      | 0           |\n 10     | 2.302585093 |\n 100    | 4.605170186 |\n [NULL] | [NULL]      |\n--------+-------------+"
},
{
    "function_name": "LISTING_REFRESH_HISTORY",
    "summary": "Returns the past 14 days of refresh history for a cross-cloud auto-fulfillment listing.",
    "category": "Information Schema , Table functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/listing_refresh_history",
    "title": "LISTING_REFRESH_HISTORY",
    "description": "Returns the past 14 days of refresh history for a cross-cloud auto-fulfillment listing.\nThe information returned contains replication details for refresh events where the listing is\nsynchronized to a specified target region.",
    "syntax": "LISTING_REFRESH_HISTORY(\n  LISTING_NAME => '<listing_name>'\n  [ , SNOWFLAKE_REGION => '<snowflake_region>' ]\n  [ , REGION_GROUP => '<region_group>' ] )",
    "example": "select * from table(information_schema.listing_refresh_history(listing_name=>'my_listing',snowflake_region=>'AWS_US_EAST_1))",
    "arguments": [
        {
            "name": "LISTING_NAME",
            "description": "SQL identifier of a cross-cloud auto-fulfillment listing in this account. The SQL identifier for\nlistings can be found in the name column returned by show listings in data exchange <exchange_name>.\nSimilarly, the SQL identifier for data exchanges can be found in the name column returned by show data exchanges ."
        },
        {
            "name": "SNOWFLAKE_REGION",
            "description": "The Snowflake region group to which the listing is replicated, where you can view the refresh history for that replication. This follows\nthe same formatting as the column snowflake_region returned by SHOW REGIONS . If no region is specified, the\nhistory for all target regions is displayed."
        },
        {
            "name": "REGION_GROUP",
            "description": "The Snowflake region group to which the listing is replicated, for which you can view the refresh history. PUBLIC by default. This argument only needs to be specified if the target region being monitored\nis in a US government or Virtual Private Snowflake region."
        }
    ]
},
{
    "function_name": "LISTAGG",
    "summary": "Returns the concatenated input values, separated by the delimiter string.",
    "category": "Aggregate functions , Window function syntax and usage",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/listagg",
    "title": "LISTAGG",
    "description": "Returns the concatenated input values, separated by the",
    "syntax": "LISTAGG( [ DISTINCT ] <expr1> [, <delimiter> ] )\n    [ WITHIN GROUP ( <orderby_clause> ) ]",
    "example": "USE SCHEMA snowflake_sample_data.tpch_sf1;\n\nSELECT LISTAGG(DISTINCT o_orderkey, ' ')\n  FROM orders\n  WHERE o_totalprice > 520000;\n\n+-------------------------------------------------+\n| LISTAGG(DISTINCT O_ORDERKEY, ' ')               |\n|-------------------------------------------------|\n| 2232932 1750466 3043270 4576548 4722021 3586919 |\n+-------------------------------------------------+\n\nSELECT LISTAGG(DISTINCT o_orderstatus, '|')\n  FROM orders\n  WHERE o_totalprice > 520000;\n\n+--------------------------------------+\n| LISTAGG(DISTINCT O_ORDERSTATUS, '|') |\n|--------------------------------------|\n| O|F                                  |\n+--------------------------------------+\n\nSELECT o_orderstatus,\n   LISTAGG(o_clerk, ', ')\n     WITHIN GROUP (ORDER BY o_totalprice DESC)\n  FROM orders\n  WHERE o_totalprice > 520000\n  GROUP BY o_orderstatus;\n\n+---------------+---------------------------------------------------+\n| O_ORDERSTATUS | LISTAGG(O_CLERK, ', ')                            |\n|               |      WITHIN GROUP (ORDER BY O_TOTALPRICE DESC)    |\n|---------------+---------------------------------------------------|\n| O             | Clerk#000000699, Clerk#000000336, Clerk#000000245 |\n| F             | Clerk#000000040, Clerk#000000230, Clerk#000000924 |\n+---------------+---------------------------------------------------+\n\nCREATE OR REPLACE TABLE collation_demo (\n  spanish_phrase VARCHAR COLLATE 'es');\n\nINSERT INTO collation_demo (spanish_phrase) VALUES\n  ('piña colada'),\n  ('Pinatubo (Mount)'),\n  ('pint'),\n  ('Pinta');\n\nSELECT LISTAGG(spanish_phrase, '|')\n    WITHIN GROUP (ORDER BY COLLATE(spanish_phrase, 'es')) AS es_collation\n  FROM collation_demo;\n\n+-----------------------------------------+\n| ES_COLLATION                            |\n|-----------------------------------------|\n| Pinatubo (Mount)|pint|Pinta|piña colada |\n+-----------------------------------------+\n\nSELECT LISTAGG(spanish_phrase, '|')\n    WITHIN GROUP (ORDER BY COLLATE(spanish_phrase, 'utf8')) AS utf8_collation\n  FROM collation_demo;\n\n+-----------------------------------------+\n| UTF8_COLLATION                          |\n|-----------------------------------------|\n| Pinatubo (Mount)|Pinta|pint|piña colada |\n+-----------------------------------------+",
    "returns": "Returns a string that includes all of the non-NULL input values, separated by the delimiter."
},
{
    "function_name": "LIKE ANY",
    "summary": "Performs a case-sensitive comparison to match a string against any of one or more specified patterns.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/like_any",
    "title": "LIKE ANY",
    "description": "Performs a case-sensitive comparison to match a string against any of one or more specified patterns.\nUse this function in a WHERE clause to filter for matches. For case-insensitive matching, use ILIKE ANY\ninstead.",
    "syntax": "<subject> LIKE ANY (<pattern1> [, <pattern2> ... ] ) [ ESCAPE <escape_char> ]",
    "example": "CREATE OR REPLACE TABLE like_example(name VARCHAR(20));\nINSERT INTO like_example VALUES\n    ('John  Dddoe'),\n    ('Joe   Doe'),\n    ('John_down'),\n    ('Joe down'),\n    ('Tom   Doe'),\n    ('Tim down'),\n    (null);\n\nSELECT * \n  FROM like_example \n  WHERE name LIKE ANY ('%Jo%oe%','T%e')\n  ORDER BY name;\n\n+-------------+                                                                 \n| NAME        |\n|-------------|\n| Joe   Doe   |\n| John  Dddoe |\n| Tom   Doe   |\n+-------------+\n\nSELECT * \n  FROM like_example \n  WHERE name LIKE ANY ('%J%h%^_do%', 'T%^%e') ESCAPE '^'\n  ORDER BY name;\n\n+-----------+                                                                   \n| NAME      |\n|-----------|\n| John_down |\n+-----------+",
    "arguments": [
        {
            "name": "subject",
            "description": "The string to compare to the pattern(s)."
        },
        {
            "name": "pattern#",
            "description": "The pattern(s) that the string is to be compared to. You must specify at least one pattern."
        },
        {
            "name": "escape_char",
            "description": "Character(s) inserted in front of a wildcard character to indicate that the wildcard should\nbe interpreted as a regular character rather than as a wildcard."
        }
    ],
    "returns": "Returns a BOOLEAN or NULL. The value is TRUE if there is a match. Otherwise, returns FALSE. Returns NULL if any argument is NULL."
},
{
    "function_name": "LIKE ALL",
    "summary": "Performs a case-sensitive comparison to match a string against all of one or more specified patterns.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/like_all",
    "title": "LIKE ALL",
    "description": "Performs a case-sensitive comparison to match a string against all of one or more specified patterns.\nUse this function in a WHERE clause to filter for matches.",
    "syntax": "<subject> LIKE ALL (<pattern1> [, <pattern2> ... ] ) [ ESCAPE <escape_char> ]",
    "example": "CREATE OR REPLACE TABLE like_all_example(name VARCHAR(20));\nINSERT INTO like_all_example VALUES\n    ('John  Dddoe'),\n    ('Joe   Doe'),\n    ('John_do%wn'),\n    ('Joe down'),\n    ('Tom   Doe'),\n    ('Tim down'),\n    (null);\n\nSELECT * \n  FROM like_all_example \n  WHERE name LIKE ALL ('%Jo%oe%','J%e')\n  ORDER BY name;\n\n+-------------+                                                                 \n| NAME        |\n|-------------|\n| Joe   Doe   |\n| John  Dddoe |\n+-------------+\n\nSELECT * \n  FROM like_all_example \n  WHERE name LIKE ALL ('%Jo%oe%','J%n')\n  ORDER BY name;\n\n+------+                                                                        \n| NAME |\n|------|\n+------+\n\nSELECT * \n  FROM like_all_example \n  WHERE name LIKE ALL ('%J%h%^_do%', 'J%^%wn') ESCAPE '^'\n  ORDER BY name;\n\n+------------+                                                                  \n| NAME       |\n|------------|\n| John_do%wn |\n+------------+",
    "arguments": [
        {
            "name": "subject",
            "description": "The string to compare to the pattern(s)."
        },
        {
            "name": "pattern#",
            "description": "The pattern(s) that the string is to be compared to. You must specify at least one pattern."
        },
        {
            "name": "escape_char",
            "description": "Character(s) inserted in front of a wildcard character to indicate that the wildcard should\nbe interpreted as a regular character rather than as a wildcard."
        }
    ],
    "returns": "Returns a BOOLEAN or NULL. The value is TRUE if there is a match. Otherwise, returns FALSE. Returns NULL if any argument is NULL."
},
{
    "function_name": "[ NOT ] LIKE",
    "summary": "Performs a case-sensitive comparison to determine whether a string matches or does not match a specified pattern.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/like",
    "title": "[ NOT ] LIKE",
    "description": "Performs a case-sensitive comparison to determine whether a string matches or does not match a specified pattern.\nFor case-insensitive matching, use ILIKE instead.",
    "syntax": "<subject> [ NOT ] LIKE <pattern> [ ESCAPE <escape> ]\n\nLIKE( <subject> , <pattern> [ , <escape> ] )",
    "example": "CREATE OR REPLACE TABLE like_ex(name VARCHAR(20));\nINSERT INTO like_ex VALUES\n  ('John  Dddoe'),\n  ('John \\'alias\\' Doe'),\n  ('Joe   Doe'),\n  ('John_down'),\n  ('Joe down'),\n  ('Elaine'),\n  (''),    -- empty string\n  (null);\n\nSELECT name\n  FROM like_ex\n  WHERE name LIKE '%Jo%oe%'\n  ORDER BY name;\n\n+------------------+\n| NAME             |\n|------------------|\n| Joe   Doe        |\n| John  Dddoe      |\n| John 'alias' Doe |\n+------------------+\n\nSELECT name\n  FROM like_ex\n  WHERE name NOT LIKE '%Jo%oe%'\n  ORDER BY name;\n\n+-----------+\n| NAME      |\n|-----------|\n|           |\n| Elaine    |\n| Joe down  |\n| John_down |\n+-----------+\n\nSELECT name\n  FROM like_ex\n  WHERE name NOT LIKE 'John%'\n  ORDER BY name;\n\n+-----------+                                                                   \n| NAME      |\n|-----------|\n|           |\n| Elaine    |\n| Joe   Doe |\n| Joe down  |\n+-----------+\n\nSELECT name\n  FROM like_ex\n  WHERE name NOT LIKE ''\n  ORDER BY name;\n\n+------------------+\n| NAME             |\n|------------------|\n| Elaine           |\n| Joe   Doe        |\n| Joe down         |\n| John  Dddoe      |\n| John 'alias' Doe |\n| John_down        |\n+------------------+\n\nSELECT name\n  FROM like_ex\n  WHERE name LIKE '%\\'%'\n  ORDER BY name;\n\n+------------------+\n| NAME             |\n|------------------|\n| John 'alias' Doe |\n+------------------+\n\nSELECT name\n  FROM like_ex\n  WHERE name LIKE '%J%h%^_do%' ESCAPE '^'\n  ORDER BY name;\n\n+-----------+                                                                   \n| NAME      |\n|-----------|\n| John_down |\n+-----------+\n\nINSERT INTO like_ex (name) VALUES \n  ('100 times'),\n  ('1000 times'),\n  ('100%');\n\nSELECT * FROM like_ex WHERE name LIKE '100%'\n  ORDER BY 1;\n\n+------------+                                                                  \n| NAME       |\n|------------|\n| 100 times  |\n| 100%       |\n| 1000 times |\n+------------+\n\nSELECT * FROM like_ex WHERE name LIKE '100^%' ESCAPE '^'\n  ORDER BY 1;\n\n+------+                                                                        \n| NAME |\n|------|\n| 100% |\n+------+\n\nSELECT * FROM like_ex WHERE name LIKE '100\\\\%' ESCAPE '\\\\'\n  ORDER BY 1;\n\n+------+                                                                        \n| NAME |\n|------|\n| 100% |\n+------+",
    "arguments": [
        {
            "name": "subject",
            "description": "Subject to match. This is typically a VARCHAR, although some other data\ntypes can be used."
        },
        {
            "name": "pattern",
            "description": "Pattern to match. This is typically a VARCHAR, although some other data\ntypes can be used."
        },
        {
            "name": "escape",
            "description": "Character(s) inserted in front of a wildcard character to indicate that the wildcard should\nbe interpreted as a regular character and not as a wildcard."
        }
    ],
    "returns": "Returns a BOOLEAN or NULL."
},
{
    "function_name": "LENGTH, LEN",
    "summary": "Returns the length of an input string or binary value.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/length",
    "title": "LENGTH, LEN",
    "description": "Returns the length of an input",
    "syntax": "LENGTH( <expression> )\n\nLEN( <expression> )",
    "example": "CREATE OR REPLACE TABLE length_function_demo (s VARCHAR);\n\nINSERT INTO length_function_demo VALUES\n  (''),\n  ('Joyeux Noël'),\n  ('Merry Christmas'),\n  ('Veselé Vianoce'),\n  ('Wesołych Świąt'),\n  ('圣诞节快乐'),\n  (NULL);\n\nSELECT s, LENGTH(s) FROM length_function_demo;\n\n+-----------------+-----------+\n| S               | LENGTH(S) |\n|-----------------+-----------|\n|                 |         0 |\n| Joyeux Noël     |        11 |\n| Merry Christmas |        15 |\n| Veselé Vianoce  |        14 |\n| Wesołych Świąt  |        14 |\n| 圣诞节快乐        |         5 |\n| NULL            |      NULL |\n+-----------------+-----------+\n\nCREATE OR REPLACE TABLE binary_demo_table (\n  v VARCHAR,\n  b_hex BINARY,\n  b_base64 BINARY,\n  b_utf8 BINARY);\n\nINSERT INTO binary_demo_table (v) VALUES ('hello');\n\nUPDATE binary_demo_table SET\n  b_hex    = TO_BINARY(HEX_ENCODE(v), 'HEX'),\n  b_base64 = TO_BINARY(BASE64_ENCODE(v), 'BASE64'),\n  b_utf8   = TO_BINARY(v, 'UTF-8');\n\nSELECT * FROM binary_demo_table;\n\n+-------+------------+------------+------------+\n| V     | B_HEX      | B_BASE64   | B_UTF8     |\n|-------+------------+------------+------------|\n| hello | 68656C6C6F | 68656C6C6F | 68656C6C6F |\n+-------+------------+------------+------------+\n\nSELECT v, LENGTH(v),\n       TO_VARCHAR(b_hex, 'HEX') AS b_hex, LENGTH(b_hex),\n       TO_VARCHAR(b_base64, 'BASE64') AS b_base64, LENGTH(b_base64),\n       TO_VARCHAR(b_utf8, 'UTF-8') AS b_utf8, LENGTH(b_utf8)\n  FROM binary_demo_table;\n\n+-------+-----------+------------+---------------+----------+------------------+--------+----------------+\n| V     | LENGTH(V) | B_HEX      | LENGTH(B_HEX) | B_BASE64 | LENGTH(B_BASE64) | B_UTF8 | LENGTH(B_UTF8) |\n|-------+-----------+------------+---------------+----------+------------------+--------+----------------|\n| hello |         5 | 68656C6C6F |             5 | aGVsbG8= |                5 | hello  |              5 |\n+-------+-----------+------------+---------------+----------+------------------+--------+----------------+",
    "arguments": [
        {
            "name": "expression",
            "description": "The input expression must be a string or binary value."
        }
    ],
    "returns": "The returned data type is INTEGER (more precisely, NUMBER(18, 0))."
},
{
    "function_name": "LEFT",
    "summary": "Returns a leftmost substring of its input.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/left",
    "title": "LEFT",
    "description": "Returns a leftmost substring of its input.",
    "syntax": "LEFT( <string_expr> , <length_expr> )",
    "example": "SELECT LEFT('ABCDEF', 3);\n\n+-------------------+\n| LEFT('ABCDEF', 3) |\n|-------------------|\n| ABC               |\n+-------------------+\n\nCREATE OR REPLACE TABLE customer_contact_example (\n    cust_id INT,\n    cust_email VARCHAR,\n    cust_phone VARCHAR,\n    activation_date VARCHAR)\n  AS SELECT\n    column1,\n    column2,\n    column3,\n    column4\n  FROM\n    VALUES\n      (1, 'some_text@example.com', '800-555-0100', '20210320'),\n      (2, 'some_other_text@example.org', '800-555-0101', '20240509'),\n      (3, 'some_different_text@example.net', '800-555-0102', '20191017');\n\nSELECT * from customer_contact_example;\n\n+---------+---------------------------------+--------------+-----------------+\n| CUST_ID | CUST_EMAIL                      | CUST_PHONE   | ACTIVATION_DATE |\n|---------+---------------------------------+--------------+-----------------|\n|       1 | some_text@example.com           | 800-555-0100 | 20210320        |\n|       2 | some_other_text@example.org     | 800-555-0101 | 20240509        |\n|       3 | some_different_text@example.net | 800-555-0102 | 20191017        |\n+---------+---------------------------------+--------------+-----------------+\n\nSELECT cust_id,\n       cust_email,\n       LEFT(cust_email, POSITION('@' IN cust_email) - 1) AS username\n  FROM customer_contact_example;\n\n+---------+---------------------------------+---------------------+\n| CUST_ID | CUST_EMAIL                      | USERNAME            |\n|---------+---------------------------------+---------------------|\n|       1 | some_text@example.com           | some_text           |\n|       2 | some_other_text@example.org     | some_other_text     |\n|       3 | some_different_text@example.net | some_different_text |\n+---------+---------------------------------+---------------------+\n\nSELECT cust_id,\n       cust_phone,\n       LEFT(cust_phone, 3) AS area_code\n  FROM customer_contact_example;\n\n+---------+--------------+-----------+\n| CUST_ID | CUST_PHONE   | AREA_CODE |\n|---------+--------------+-----------|\n|       1 | 800-555-0100 | 800       |\n|       2 | 800-555-0101 | 800       |\n|       3 | 800-555-0102 | 800       |\n+---------+--------------+-----------+\n\nSELECT cust_id,\n       activation_date,\n       LEFT(activation_date, 4) AS year\n  FROM customer_contact_example;\n\n+---------+-----------------+------+\n| CUST_ID | ACTIVATION_DATE | YEAR |\n|---------+-----------------+------|\n|       1 | 20210320        | 2021 |\n|       2 | 20240509        | 2024 |\n|       3 | 20191017        | 2019 |\n+---------+-----------------+------+",
    "arguments": [
        {
            "name": "string_expr",
            "description": "An expression that evaluates to a VARCHAR or BINARY value."
        },
        {
            "name": "length_expr",
            "description": "An expression that evaluates to an integer. It specifies: The number of UTF-8 characters to return if the input is a VARCHAR value. The number of bytes to return if the input is a BINARY value. Specify a length that is greater than or equal to zero. If the length is a negative number, the function returns an\nempty string."
        }
    ],
    "returns": "The data type of the returned value is the same as the data type of the string_expr (VARCHAR or BINARY)."
},
{
    "function_name": "LEAST_IGNORE_NULLS",
    "summary": "Returns the smallest non-NULL value from a list of expressions.",
    "category": "Conditional expression functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/least_ignore_nulls",
    "title": "LEAST_IGNORE_NULLS",
    "description": "Returns the smallest non-NULL value from a list of expressions. LEAST_IGNORE_NULLS supports all data types,\nincluding VARIANT.",
    "syntax": "LEAST_IGNORE_NULLS( <expr1> [ , <expr2> ... ] )",
    "example": "CREATE TABLE test_least_ignore_nulls (\n  col_1 INTEGER,\n  col_2 INTEGER,\n  col_3 INTEGER,\n  col_4 FLOAT);\n\nINSERT INTO test_least_ignore_nulls (col_1, col_2, col_3, col_4) VALUES\n  (1, 2,    3,  4.25),\n  (2, 4,   -1,  NULL),\n  (3, 6, NULL,  -2.75);\n\nSELECT col_1,\n       col_2,\n       col_3,\n       col_4,\n       LEAST_IGNORE_NULLS(col_1, col_2, col_3, col_4) AS least_ignore_nulls\n FROM test_least_ignore_nulls\n ORDER BY col_1;\n\n+-------+-------+-------+-------+--------------------+\n| COL_1 | COL_2 | COL_3 | COL_4 | LEAST_IGNORE_NULLS |\n|-------+-------+-------+-------+--------------------|\n|     1 |     2 |     3 |  4.25 |               1    |\n|     2 |     4 |    -1 |  NULL |              -1    |\n|     3 |     6 |  NULL | -2.75 |              -2.75 |\n+-------+-------+-------+-------+--------------------+",
    "arguments": [
        {
            "name": "exprN",
            "description": "The arguments must include at least one expression. All the expressions\nshould be of the same type or compatible types."
        }
    ],
    "returns": "The first argument determines the return type:"
},
{
    "function_name": "LEAST",
    "summary": "Returns the smallest value from a list of expressions.",
    "category": "Conditional expression functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/least",
    "title": "LEAST",
    "description": "Returns the smallest value from a list of expressions. LEAST supports all data types, including VARIANT.",
    "syntax": "LEAST(( <expr1> [ , <expr2> ... ] )",
    "example": "SELECT LEAST(1, 3, 0, 4);\n\n+-------------------+\n| LEAST(1, 3, 0, 4) |\n|-------------------|\n|                 0 |\n+-------------------+\n\nSELECT col_1,\n       col_2,\n       col_3,\n       LEAST(col_1, col_2, col_3) AS least\n  FROM (SELECT 1 AS col_1, 2 AS col_2, 3 AS col_3\n    UNION ALL\n    SELECT 2, 4, -1\n    UNION ALL\n    SELECT 3, 6, NULL);\n\n+-------+-------+-------+-------+\n| COL_1 | COL_2 | COL_3 | LEAST |\n|-------+-------+-------+-------|\n|     1 |     2 |     3 |     1 |\n|     2 |     4 |    -1 |    -1 |\n|     3 |     6 |  NULL |  NULL |\n+-------+-------+-------+-------+",
    "arguments": [
        {
            "name": "exprN",
            "description": "The arguments must include at least one expression. All the expressions\nshould be of the same type or compatible types."
        }
    ],
    "returns": "The first argument determines the return type:"
},
{
    "function_name": "LEAD",
    "summary": "Accesses data in a subsequent row in the same result set without having to join the table to itself.",
    "category": "Window function syntax and usage",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/lead",
    "title": "LEAD",
    "description": "Accesses data in a subsequent row in the same result set without having to join the table to itself.",
    "syntax": "LEAD ( <expr> [ , <offset> , <default> ] ) [ { IGNORE | RESPECT } NULLS ]\n  OVER ( [ PARTITION BY <expr1> ] ORDER BY <expr2> [ { ASC | DESC } ] )",
    "example": "CREATE OR REPLACE TABLE sales(\n  emp_id INTEGER,\n  year INTEGER,\n  revenue DECIMAL(10,2));\n\nINSERT INTO sales VALUES\n  (0, 2010, 1000),\n  (0, 2011, 1500),\n  (0, 2012, 500),\n  (0, 2013, 750);\nINSERT INTO sales VALUES\n  (1, 2010, 10000),\n  (1, 2011, 12500),\n  (1, 2012, 15000),\n  (1, 2013, 20000);\nINSERT INTO sales VALUES\n  (2, 2012, 500),\n  (2, 2013, 800);\n\nSELECT emp_id,\n       year,\n       revenue,\n       LEAD(revenue) OVER (PARTITION BY emp_id ORDER BY year) - revenue AS diff_to_next\n  FROM sales\n  ORDER BY emp_id, year;\n\n+--------+------+----------+--------------+\n| EMP_ID | YEAR |  REVENUE | DIFF_TO_NEXT |\n|--------+------+----------+--------------|\n|      0 | 2010 |  1000.00 |       500.00 |\n|      0 | 2011 |  1500.00 |     -1000.00 |\n|      0 | 2012 |   500.00 |       250.00 |\n|      0 | 2013 |   750.00 |         NULL |\n|      1 | 2010 | 10000.00 |      2500.00 |\n|      1 | 2011 | 12500.00 |      2500.00 |\n|      1 | 2012 | 15000.00 |      5000.00 |\n|      1 | 2013 | 20000.00 |         NULL |\n|      2 | 2012 |   500.00 |       300.00 |\n|      2 | 2013 |   800.00 |         NULL |\n+--------+------+----------+--------------+\n\nCREATE OR REPLACE TABLE t1 (\n  c1 NUMBER,\n  c2 NUMBER);\n\nINSERT INTO t1 VALUES\n  (1,5),\n  (2,4),\n  (3,NULL),\n  (4,2),\n  (5,NULL),\n  (6,NULL),\n  (7,6);\n\nSELECT c1,\n       c2,\n       LEAD(c2) IGNORE NULLS OVER (ORDER BY c1)\n  FROM t1;\n\n+----+------+------------------------------------------+\n| C1 | C2   | LEAD(C2) IGNORE NULLS OVER (ORDER BY C1) |\n|----+------+------------------------------------------|\n|  1 |  5   |                                        4 |\n|  2 |  4   |                                        2 |\n|  3 | NULL |                                        2 |\n|  4 |  2   |                                        6 |\n|  5 | NULL |                                        6 |\n|  6 | NULL |                                        6 |\n|  7 |  6   |                                     NULL |\n+----+------+------------------------------------------+",
    "arguments": [
        {
            "name": "expr",
            "description": "The string expression to be returned."
        },
        {
            "name": "offset",
            "description": "The number of rows forward from the current row from which to obtain a value. For example, an offset of 2 returns the expr value with an interval of 2 rows. Note that setting a negative offset has the same effect as using the LAG function. Default is 1. If IGNORE NULLS is specified, maximum is 1,000,000."
        },
        {
            "name": "default",
            "description": "The expression to return when the offset goes out of the bounds of the window. Supports any expression whose type is compatible with expr . Default is NULL."
        },
        {
            "name": "{",
            "description": "Whether to ignore or respect NULL values when an expr contains NULL values: IGNORE NULLS excludes any row whose expression evaluates to NULL when offset rows are counted. RESPECT NULLS includes any row whose expression evaluates to NULL when offset rows are counted. Default: RESPECT NULLS"
        }
    ]
},
{
    "function_name": "LAST_VALUE",
    "summary": "Returns the last value within an ordered group of values.",
    "category": "Window function syntax and usage",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/last_value",
    "title": "LAST_VALUE",
    "description": "Returns the last value within an ordered group of values.",
    "syntax": "LAST_VALUE( <expr> ) [ { IGNORE | RESPECT } NULLS ]\n  OVER ( [ PARTITION BY <expr1> ] ORDER BY <expr2> [ { ASC | DESC } ] [ NULLS { FIRST | LAST } ] [ <window_frame> ] )",
    "example": "SELECT\n    column1,\n    column2,\n    LAST_VALUE(column2) OVER (PARTITION BY column1 ORDER BY column2) AS column2_last\n  FROM VALUES\n    (1, 10), (1, 11), (1, 12),\n    (2, 20), (2, 21), (2, 22);\n\n+---------+---------+--------------+\n| COLUMN1 | COLUMN2 | COLUMN2_LAST |\n|---------+---------+--------------|\n|       1 |      10 |           12 |\n|       1 |      11 |           12 |\n|       1 |      12 |           12 |\n|       2 |      20 |           22 |\n|       2 |      21 |           22 |\n|       2 |      22 |           22 |\n+---------+---------+--------------+\n\nCREATE TABLE demo1 (i INTEGER, partition_col INTEGER, order_col INTEGER);\n\nINSERT INTO demo1 (i, partition_col, order_col) VALUES\n  (1, 1, 1),\n  (2, 1, 2),\n  (3, 1, 3),\n  (4, 1, 4),\n  (5, 1, 5),\n  (1, 2, 1),\n  (2, 2, 2),\n  (3, 2, 3),\n  (4, 2, 4);\n\nSELECT partition_col, order_col, i,\n       FIRST_VALUE(i)  OVER (PARTITION BY partition_col ORDER BY order_col\n         ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) AS FIRST_VAL,\n       NTH_VALUE(i, 2) OVER (PARTITION BY partition_col ORDER BY order_col\n         ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) AS NTH_VAL,\n       LAST_VALUE(i)   OVER (PARTITION BY partition_col ORDER BY order_col\n         ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) AS LAST_VAL\n  FROM demo1\n  ORDER BY partition_col, i, order_col;\n\n+---------------+-----------+---+-----------+---------+----------+\n| PARTITION_COL | ORDER_COL | I | FIRST_VAL | NTH_VAL | LAST_VAL |\n|---------------+-----------+---+-----------+---------+----------|\n|             1 |         1 | 1 |         1 |       2 |        2 |\n|             1 |         2 | 2 |         1 |       2 |        3 |\n|             1 |         3 | 3 |         2 |       3 |        4 |\n|             1 |         4 | 4 |         3 |       4 |        5 |\n|             1 |         5 | 5 |         4 |       5 |        5 |\n|             2 |         1 | 1 |         1 |       2 |        2 |\n|             2 |         2 | 2 |         1 |       2 |        3 |\n|             2 |         3 | 3 |         2 |       3 |        4 |\n|             2 |         4 | 4 |         3 |       4 |        4 |\n+---------------+-----------+---+-----------+---------+----------+",
    "arguments": [
        {
            "name": "expr",
            "description": "The expression that determines the return value."
        },
        {
            "name": "expr1",
            "description": "The expression by which to partition the rows. You can specify a single expression or a comma-separated list of expressions.\nFor example:"
        },
        {
            "name": "expr2",
            "description": "The expression by which to order the rows. You can specify a single expression or a comma-separated list of expressions.\nFor example:"
        },
        {
            "name": "{",
            "description": "Whether to ignore or respect NULL values when an expr contains NULL values: IGNORE NULLS returns the last non-NULL value. RESPECT NULLS returns a NULL value if it is the last value in the expression. Default: RESPECT NULLS"
        }
    ]
},
{
    "function_name": "LAST_TRANSACTION",
    "summary": "Returns the transaction ID of the last transaction that was either committed or rolled back in the current session.",
    "category": "Context functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/last_transaction",
    "title": "LAST_TRANSACTION",
    "description": "Returns the transaction ID of the last transaction that was either committed or rolled back in the current session.",
    "syntax": "LAST_TRANSACTION()",
    "example": "SELECT LAST_TRANSACTION();\n\n+---------------------+\n| LAST_TRANSACTION()  |\n|---------------------|\n| 1661899308790000000 |\n+---------------------+"
},
{
    "function_name": "LAST_SUCCESSFUL_SCHEDULED_TIME",
    "summary": "Returns the timestamp representing the scheduled time for the most recent successful evaluation of the alert condition, where no errors occurred when executing the action.",
    "category": "Date & time functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/last_successful_scheduled_time",
    "title": "LAST_SUCCESSFUL_SCHEDULED_TIME",
    "description": "Returns the timestamp representing the scheduled time for the most recent successful evaluation of the alert condition, where no\nerrors occurred when executing the action. (In the",
    "syntax": "SNOWFLAKE.ALERT.LAST_SUCCESSFUL_SCHEDULED_TIME()",
    "returns": "TIMESTAMP_LTZ value that represents when the most recent successful evaluation of the alert condition was scheduled, or NULL\nif there are no recent successful evaluations of the alert condition."
},
{
    "function_name": "LAST_QUERY_ID",
    "summary": "Returns the ID of a specified query in the current session.",
    "category": "Context functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/last_query_id",
    "title": "LAST_QUERY_ID",
    "description": "Returns the ID of a specified query in the current session. If no query is specified, the most recent\nquery is returned.",
    "syntax": "LAST_QUERY_ID( [ <num> ] )",
    "example": "SELECT LAST_QUERY_ID();\n\nSELECT LAST_QUERY_ID(1);",
    "arguments": [
        {
            "name": "num",
            "description": "Specifies the query to return, based on the position of the query (within the session). Default: -1"
        }
    ]
},
{
    "function_name": "LAST_DAY",
    "summary": "Returns the last day of the specified date part for a date or timestamp.",
    "category": "Date & time functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/last_day",
    "title": "LAST_DAY",
    "description": "Returns the last day of the specified date part for a date or timestamp. This function is commonly used to return the\nlast day of the month for a date or timestamp.",
    "syntax": "LAST_DAY( <date_or_timetamp_expr> [ , <date_part> ] )",
    "example": "SELECT TO_DATE('2025-05-08T23:39:20.123-07:00') AS \"DATE\",\n       LAST_DAY(\"DATE\") AS \"LAST DAY OF MONTH\";\n\n+------------+-------------------+\n| DATE       | LAST DAY OF MONTH |\n|------------+-------------------|\n| 2025-05-08 | 2025-05-31        |\n+------------+-------------------+\n\nSELECT TO_DATE('2024-05-08T23:39:20.123-07:00') AS \"DATE\",\n       LAST_DAY(\"DATE\", 'year') AS \"LAST DAY OF YEAR\";\n\n+------------+------------------+\n| DATE       | LAST DAY OF YEAR |\n|------------+------------------|\n| 2024-05-08 | 2024-12-31       |\n+------------+------------------+",
    "arguments": [
        {
            "name": "date_or_timestamp_expr",
            "description": "A date or a timestamp, or an expression that can be evaluated to a date or a timestamp."
        },
        {
            "name": "date_part",
            "description": "The date part for which the last day is returned. Possible values are year , quarter , month ,\nor week (or any of their supported variations). For more information, see Supported date and time parts . When date_part is week (or any of its variations), the output is controlled by the WEEK_START session parameter. For more details, including examples, see Calendar weeks and weekdays . For more information, including examples, see Calendar weeks and weekdays . Default: month"
        }
    ],
    "returns": "This function returns a value of type DATE, even if date_or_timetamp_expr is a timestamp."
},
{
    "function_name": "LAG",
    "summary": "Accesses data in a previous row in the same result set without having to join the table to itself.",
    "category": "Window function syntax and usage",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/lag",
    "title": "LAG",
    "description": "Accesses data in a previous row in the same result set without having to join the table to itself.",
    "syntax": "LAG ( <expr> [ , <offset> , <default> ] ) [ { IGNORE | RESPECT } NULLS ]\n    OVER ( [ PARTITION BY <expr1> ] ORDER BY <expr2> [ { ASC | DESC } ] )",
    "example": "CREATE OR REPLACE TABLE sales(\n  emp_id INTEGER,\n  year INTEGER,\n  revenue DECIMAL(10,2));\n\nINSERT INTO sales VALUES\n  (0, 2010, 1000),\n  (0, 2011, 1500),\n  (0, 2012, 500),\n  (0, 2013, 750);\nINSERT INTO sales VALUES\n  (1, 2010, 10000),\n  (1, 2011, 12500),\n  (1, 2012, 15000),\n  (1, 2013, 20000);\nINSERT INTO sales VALUES\n  (2, 2012, 500),\n  (2, 2013, 800);\n\nSELECT emp_id, year, revenue,\n       revenue - LAG(revenue, 1, 0) OVER (PARTITION BY emp_id ORDER BY year) AS diff_to_prev\n  FROM sales\n  ORDER BY emp_id, year;\n\n+--------+------+----------+--------------+\n| EMP_ID | YEAR |  REVENUE | DIFF_TO_PREV |\n|--------+------+----------+--------------|\n|      0 | 2010 |  1000.00 |      1000.00 |\n|      0 | 2011 |  1500.00 |       500.00 |\n|      0 | 2012 |   500.00 |     -1000.00 |\n|      0 | 2013 |   750.00 |       250.00 |\n|      1 | 2010 | 10000.00 |     10000.00 |\n|      1 | 2011 | 12500.00 |      2500.00 |\n|      1 | 2012 | 15000.00 |      2500.00 |\n|      1 | 2013 | 20000.00 |      5000.00 |\n|      2 | 2012 |   500.00 |       500.00 |\n|      2 | 2013 |   800.00 |       300.00 |\n+--------+------+----------+--------------+\n\nCREATE OR REPLACE TABLE t1 (\n  col_1 NUMBER,\n  col_2 NUMBER);\n\nINSERT INTO t1 VALUES\n  (1, 5),\n  (2, 4),\n  (3, NULL),\n  (4, 2),\n  (5, NULL),\n  (6, NULL),\n  (7, 6);\n\nSELECT col_1,\n       col_2,\n       LAG(col_2) IGNORE NULLS OVER (ORDER BY col_1)\n  FROM t1\n  ORDER BY col_1;\n\n+-------+-------+-----------------------------------------------+\n| COL_1 | COL_2 | LAG(COL_2) IGNORE NULLS OVER (ORDER BY COL_1) |\n|-------+-------+-----------------------------------------------|\n|     1 |     5 |                                          NULL |\n|     2 |     4 |                                             5 |\n|     3 |  NULL |                                             4 |\n|     4 |     2 |                                             4 |\n|     5 |  NULL |                                             2 |\n|     6 |  NULL |                                             2 |\n|     7 |     6 |                                             2 |\n+-------+-------+-----------------------------------------------+",
    "arguments": [
        {
            "name": "expr",
            "description": "The expression to be returned based on the specified offset."
        },
        {
            "name": "offset",
            "description": "The number of rows backward from the current row from which to obtain a value. For example, an offset of 2 returns\nthe expr value with an interval of 2 rows. Note that setting a negative offset has the same effect as using the LEAD function. Default is 1."
        },
        {
            "name": "default",
            "description": "The expression to return when the offset goes out of the bounds of the window. Supports any expression whose type is compatible with expr . Default is NULL."
        },
        {
            "name": "{",
            "description": "Whether to ignore or respect NULL values when an expr contains NULL values: IGNORE NULLS excludes any row whose expression evaluates to NULL when offset rows are counted. RESPECT NULLS includes any row whose expression evaluates to NULL when offset rows are counted. Default: RESPECT NULLS"
        }
    ]
},
{
    "function_name": "KURTOSIS",
    "summary": "Returns the population excess kurtosis of non-NULL records.",
    "category": "Aggregate functions , Window function syntax and usage",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/kurtosis",
    "title": "KURTOSIS",
    "description": "Returns the population excess kurtosis of non-NULL records. If all records inside a group are NULL, the function returns NULL.",
    "syntax": "KURTOSIS( <expr> )",
    "example": "create or replace table aggr(k int, v decimal(10,2), v2 decimal(10, 2));\n\ninsert into aggr values\n    (1, 10, null),\n    (2, 10, 12),\n    (2, 20, 22),\n    (2, 25, null),\n    (2, 30, 35);\n\nselect *\n    from aggr\n    order by k, v;\n+---+-------+-------+\n| K |     V |    V2 |\n|---+-------+-------|\n| 1 | 10.00 |  NULL |\n| 2 | 10.00 | 12.00 |\n| 2 | 20.00 | 22.00 |\n| 2 | 25.00 |  NULL |\n| 2 | 30.00 | 35.00 |\n+---+-------+-------+\n\nselect KURTOSIS(K), KURTOSIS(V), KURTOSIS(V2) \n    from aggr;\n+----------------+-----------------+--------------+\n|    KURTOSIS(K) |     KURTOSIS(V) | KURTOSIS(V2) |\n|----------------+-----------------+--------------|\n| 5.000000000000 | -2.324218750000 |         NULL |\n+----------------+-----------------+--------------+",
    "arguments": [
        {
            "name": "expr",
            "description": "This is an expression that evaluates to a numeric data type (INTEGER, FLOAT, DECIMAL, etc.)."
        },
        {
            "name": "expr2",
            "description": "The expression that defines the individual groups or windows."
        }
    ],
    "returns": "Returns DOUBLE if the input data type is DOUBLE/FLOAT."
},
{
    "function_name": "JSON_EXTRACT_PATH_TEXT",
    "summary": "Parses the first argument as a JSON string and returns the value of the element pointed to by the path in the second argument.",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/json_extract_path_text",
    "title": "JSON_EXTRACT_PATH_TEXT",
    "description": "Parses the first argument as a JSON string and returns the value of the element pointed to by the path in the second\nargument. This is equivalent to",
    "syntax": "JSON_EXTRACT_PATH_TEXT( <column_identifier> , '<path_name>' )",
    "example": "CREATE TABLE demo1 (id INTEGER, json_data VARCHAR);\nINSERT INTO demo1 SELECT\n   1, '{\"level_1_key\": \"level_1_value\"}';\nINSERT INTO demo1 SELECT\n   2, '{\"level_1_key\": {\"level_2_key\": \"level_2_value\"}}';\nINSERT INTO demo1 SELECT\n   3, '{\"level_1_key\": {\"level_2_key\": [\"zero\", \"one\", \"two\"]}}';\n\nSELECT \n        TO_VARCHAR(GET_PATH(PARSE_JSON(json_data), 'level_1_key')) \n            AS OLD_WAY,\n        JSON_EXTRACT_PATH_TEXT(json_data, 'level_1_key')\n            AS JSON_EXTRACT_PATH_TEXT\n    FROM demo1\n    ORDER BY id;\n+--------------------------------------+--------------------------------------+\n| OLD_WAY                              | JSON_EXTRACT_PATH_TEXT               |\n|--------------------------------------+--------------------------------------|\n| level_1_value                        | level_1_value                        |\n| {\"level_2_key\":\"level_2_value\"}      | {\"level_2_key\":\"level_2_value\"}      |\n| {\"level_2_key\":[\"zero\",\"one\",\"two\"]} | {\"level_2_key\":[\"zero\",\"one\",\"two\"]} |\n+--------------------------------------+--------------------------------------+\n\nSELECT \n        TO_VARCHAR(GET_PATH(PARSE_JSON(json_data), 'level_1_key.level_2_key'))\n            AS OLD_WAY,\n        JSON_EXTRACT_PATH_TEXT(json_data, 'level_1_key.level_2_key')\n            AS JSON_EXTRACT_PATH_TEXT\n    FROM demo1\n    ORDER BY id;\n+----------------------+------------------------+\n| OLD_WAY              | JSON_EXTRACT_PATH_TEXT |\n|----------------------+------------------------|\n| NULL                 | NULL                   |\n| level_2_value        | level_2_value          |\n| [\"zero\",\"one\",\"two\"] | [\"zero\",\"one\",\"two\"]   |\n+----------------------+------------------------+\n\nSELECT \n      TO_VARCHAR(GET_PATH(PARSE_JSON(json_data), 'level_1_key.level_2_key[1]'))\n          AS OLD_WAY,\n      JSON_EXTRACT_PATH_TEXT(json_data, 'level_1_key.level_2_key[1]')\n          AS JSON_EXTRACT_PATH_TEXT\n    FROM demo1\n    ORDER BY id;\n+---------+------------------------+\n| OLD_WAY | JSON_EXTRACT_PATH_TEXT |\n|---------+------------------------|\n| NULL    | NULL                   |\n| NULL    | NULL                   |\n| one     | one                    |\n+---------+------------------------+",
    "arguments": [
        {
            "name": "column_identifier",
            "description": "The name of the column with the data that you want to extract."
        },
        {
            "name": "path_name",
            "description": "A string that contains the path to the element that you want to extract."
        }
    ],
    "returns": "The data type of the returned value is VARCHAR."
},
{
    "function_name": "JAROWINKLER_SIMILARITY",
    "summary": "Computes the Jaro-Winkler similarity between two input strings.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/jarowinkler_similarity",
    "title": "JAROWINKLER_SIMILARITY",
    "description": "Computes the",
    "syntax": "JAROWINKLER_SIMILARITY( <string_expr1> , <string_expr2> )",
    "example": "SELECT s, t, JAROWINKLER_SIMILARITY(s, t), JAROWINKLER_SIMILARITY(t, s) FROM ed;\n\n----------------+-----------------+------------------------------+------------------------------+\n      S         |        T        | JAROWINKLER_SIMILARITY(S, T) | JAROWINKLER_SIMILARITY(T, S) |\n----------------+-----------------+------------------------------+------------------------------+\n                |                 | 0                            | 0                            |\n Gute nacht     | Ich weis nicht  | 56                           | 56                           |\n Ich weiß nicht | Ich wei? nicht  | 98                           | 98                           |\n Ich weiß nicht | Ich weiss nicht | 97                           | 97                           |\n Ich weiß nicht | [NULL]          | [NULL]                       | [NULL]                       |\n Snowflake      | Oracle          | 61                           | 61                           |\n święta         | swieta          | 77                           | 77                           |\n [NULL]         |                 | [NULL]                       | [NULL]                       |\n [NULL]         | [NULL]          | [NULL]                       | [NULL]                       |\n----------------+-----------------+------------------------------+------------------------------+",
    "arguments": [
        {
            "name": "string_expr1",
            "description": "The input strings."
        }
    ]
},
{
    "function_name": "IS_TIMESTAMP_*",
    "summary": "Verifies whether a VARIANT argument contains the respective timestamp value.",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/is_timestamp",
    "title": "IS_TIMESTAMP_*",
    "description": "Verifies whether a",
    "syntax": "IS_TIMESTAMP_LTZ( <variant_expr> )\n\nIS_TIMESTAMP_NTZ( <variant_expr> )\n\nIS_TIMESTAMP_TZ( <variant_expr> )",
    "example": "CREATE OR REPLACE TABLE vardttm (v VARIANT);\n\nINSERT INTO vardttm SELECT TO_VARIANT(TO_DATE('2024-02-24'));\nINSERT INTO vardttm SELECT TO_VARIANT(TO_TIME('20:57:01.123456789+07:00'));\nINSERT INTO vardttm SELECT TO_VARIANT(TO_TIMESTAMP('2023-02-24 12:00:00.456'));\nINSERT INTO vardttm SELECT TO_VARIANT(TO_TIMESTAMP_LTZ('2022-02-24 13:00:00.123 +01:00'));\nINSERT INTO vardttm SELECT TO_VARIANT(TO_TIMESTAMP_NTZ('2021-02-24 14:00:00.123 +01:00'));\nINSERT INTO vardttm SELECT TO_VARIANT(TO_TIMESTAMP_TZ('2020-02-24 15:00:00.123 +01:00'));\n\nSELECT v, TYPEOF(v) AS type FROM vardttm;\n\n+---------------------------------+---------------+\n| V                               | TYPE          |\n|---------------------------------+---------------|\n| \"2024-02-24\"                    | DATE          |\n| \"20:57:01\"                      | TIME          |\n| \"2023-02-24 12:00:00.456\"       | TIMESTAMP_NTZ |\n| \"2022-02-24 04:00:00.123 -0800\" | TIMESTAMP_LTZ |\n| \"2021-02-24 14:00:00.123\"       | TIMESTAMP_NTZ |\n| \"2020-02-24 15:00:00.123 +0100\" | TIMESTAMP_TZ  |\n+---------------------------------+---------------+\n\nSELECT * FROM vardttm WHERE IS_TIMESTAMP_NTZ(v);\n\n+---------------------------+\n| V                         |\n|---------------------------|\n| \"2023-02-24 12:00:00.456\" |\n| \"2021-02-24 14:00:00.123\" |\n+---------------------------+\n\nSELECT * FROM vardttm WHERE IS_TIMESTAMP_LTZ(v);\n\n+---------------------------------+\n| V                               |\n|---------------------------------|\n| \"2022-02-24 04:00:00.123 -0800\" |\n+---------------------------------+\n\nSELECT * FROM vardttm WHERE IS_TIMESTAMP_TZ(v);\n\n+---------------------------------+\n| V                               |\n|---------------------------------|\n| \"2020-02-24 15:00:00.123 +0100\" |\n+---------------------------------+",
    "arguments": [
        {
            "name": "variant_expr",
            "description": "An expression that evaluates to a value of type VARIANT."
        }
    ],
    "returns": "Returns a BOOLEAN value or NULL."
},
{
    "function_name": "IS_TIME",
    "summary": "Verifies whether a VARIANT argument contains a TIME value.",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/is_time",
    "title": "IS_TIME",
    "description": "Verifies whether a",
    "syntax": "IS_TIME( <variant_expr> )",
    "example": "CREATE OR REPLACE TABLE vardttm (v VARIANT);\n\nINSERT INTO vardttm SELECT TO_VARIANT(TO_DATE('2024-02-24'));\nINSERT INTO vardttm SELECT TO_VARIANT(TO_TIME('20:57:01.123456789+07:00'));\nINSERT INTO vardttm SELECT TO_VARIANT(TO_TIMESTAMP('2023-02-24 12:00:00.456'));\nINSERT INTO vardttm SELECT TO_VARIANT(TO_TIMESTAMP_LTZ('2022-02-24 13:00:00.123 +01:00'));\nINSERT INTO vardttm SELECT TO_VARIANT(TO_TIMESTAMP_NTZ('2021-02-24 14:00:00.123 +01:00'));\nINSERT INTO vardttm SELECT TO_VARIANT(TO_TIMESTAMP_TZ('2020-02-24 15:00:00.123 +01:00'));\n\nSELECT v, TYPEOF(v) AS type FROM vardttm;\n\n+---------------------------------+---------------+\n| V                               | TYPE          |\n|---------------------------------+---------------|\n| \"2024-02-24\"                    | DATE          |\n| \"20:57:01\"                      | TIME          |\n| \"2023-02-24 12:00:00.456\"       | TIMESTAMP_NTZ |\n| \"2022-02-24 04:00:00.123 -0800\" | TIMESTAMP_LTZ |\n| \"2021-02-24 14:00:00.123\"       | TIMESTAMP_NTZ |\n| \"2020-02-24 15:00:00.123 +0100\" | TIMESTAMP_TZ  |\n+---------------------------------+---------------+\n\nSELECT v FROM vardttm WHERE IS_TIME(v);\n\n+------------+\n| V          |\n|------------|\n| \"20:57:01\" |\n+------------+",
    "arguments": [
        {
            "name": "variant_expr",
            "description": "An expression that evaluates to a value of type VARIANT."
        }
    ],
    "returns": "Returns a BOOLEAN value or NULL."
},
{
    "function_name": "IS_ROLE_IN_SESSION",
    "summary": "Verifies whether the specified account role is in the currently active primary or secondary role hierarchy.",
    "category": "Context functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/is_role_in_session",
    "title": "IS_ROLE_IN_SESSION",
    "description": "Verifies whether the specified account role is in the currently active primary or secondary role hierarchy.",
    "syntax": "IS_ROLE_IN_SESSION( '<string_literal>' )",
    "example": "SELECT IS_ROLE_IN_SESSION('ANALYST');\n\n+-------------------------------+\n| IS_ROLE_IN_SESSION('ANALYST') |\n|-------------------------------|\n| True                          |\n+-------------------------------+\n\nSELECT *\nFROM d1.s1.t1\nWHERE IS_ROLE_IN_SESSION(t1.role_name);\n\nCREATE OR REPLACE MASKING POLICY allow_analyst AS (val string)\nRETURNS string ->\nCASE\n  WHEN IS_ROLE_IN_SESSION('ANALYST') THEN val\n  ELSE '*******'\nEND;\n\nCREATE OR REPLACE MASKING POLICY allow_tag_role AS (val string)\nRETURNS string ->\nCASE\n  WHEN IS_ROLE_IN_SESSION(SYSTEM$GET_TAG_ON_CURRENT_TABLE('D1.S1.ALLOWED_ROLE')) THEN val\n  ELSE '*******'\nEND;\n\nCREATE OR REPLACE ROW ACCESS POLICY rap_authz_role AS (authz_role string)\nRETURNS boolean ->\nIS_ROLE_IN_SESSION(authz_role);\n\nALTER TABLE allowed_roles\n  ADD ROW ACCESS POLICY rap_authz_role ON (authz_role);\n\nCREATE OR REPLACE ROW ACCESS POLICY rap_authz_role_map AS (authz_role string)\nRETURNS boolean ->\nEXISTS (\n  SELECT 1 FROM mapping_table m\n  WHERE authz_role = m.key and IS_ROLE_IN_SESSION(m.role_name)\n);\n\nALTER TABLE allowed_roles\n  ADD ROW ACCESS POLICY rap_authz_role_map ON (authz_role);",
    "arguments": [
        {
            "name": "'",
            "description": "The name of the role."
        },
        {
            "name": "expr",
            "description": "An expression that returns the name of the role."
        },
        {
            "name": "column_name",
            "description": "The column name in a table or view that contains the name of the role."
        }
    ],
    "returns": "For a string literal or expression argument, the current user’s active\nprimary role or secondary roles in the session inherit the privileges of the specified\nrole."
},
{
    "function_name": "IS_ORGANIZATION_USER_GROUP_IN_SESSION",
    "summary": "Assuming a role was imported from an organization user group, verifies whether the role is in the user’s active primary or secondary role hierarchy for the session.",
    "category": "Context functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/is_organization_user_group_in_session",
    "title": "IS_ORGANIZATION_USER_GROUP_IN_SESSION",
    "syntax": "IS_ORGANIZATION_USER_GROUP_IN_SESSION( '<string_literal>' )",
    "example": "SELECT IS_ORGANIZATION_USER_GROUP_IN_SESSION('ANALYST');",
    "arguments": [
        {
            "name": "'",
            "description": "The name of an role."
        }
    ],
    "returns": "The current user’s active primary role or secondary roles in the session inherit the\nprivileges of the specified role."
},
{
    "function_name": "IS_ORGANIZATION_USER_GROUP",
    "summary": "Returns TRUE if the specified role was created when an administrator added an organization user group to the account.",
    "category": "",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/is_organization_user_group",
    "title": "IS_ORGANIZATION_USER_GROUP",
    "syntax": "IS_ORGANIZATION_USER_GROUP( '<role>' )",
    "example": "SELECT IS_ORGANIZATION_USER_GROUP('data_stewards');",
    "arguments": [
        {
            "name": "'",
            "description": "Role in the current account."
        }
    ],
    "returns": "Returns TRUE if the specified role was created from or linked to an organization user group."
},
{
    "function_name": "IS_ORGANIZATION_USER",
    "summary": "Returns TRUE if the argument is a Snowflake user who is an organization user.",
    "category": "",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/is_organization_user",
    "title": "IS_ORGANIZATION_USER",
    "syntax": "IS_ORGANIZATION_USER( <exp> )",
    "example": "SELECT IS_ORGANIZATION_USER('joe');\n\nSELECT IS_ORGANIZATION_USER(CURRENT_USER());",
    "arguments": [
        {
            "name": "exp",
            "description": "Expression that resolves to the name of a Snowflake user object. If passing in the literal name of a user, surround it with single quotes (for example, 'joe' )."
        }
    ],
    "returns": "Returns TRUE if the argument is an organization user."
},
{
    "function_name": "IS_OBJECT",
    "summary": "Returns TRUE if its VARIANT argument contains an OBJECT value.",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/is_object",
    "title": "IS_OBJECT",
    "description": "Returns TRUE if its",
    "syntax": "IS_OBJECT( <variant_expr> )",
    "example": "CREATE OR REPLACE TABLE vartab (n NUMBER(2), v VARIANT);\n\nINSERT INTO vartab\n  SELECT column1 AS n, PARSE_JSON(column2) AS v\n    FROM VALUES (1, 'null'), \n                (2, null), \n                (3, 'true'),\n                (4, '-17'), \n                (5, '123.12'), \n                (6, '1.912e2'),\n                (7, '\"Om ara pa ca na dhih\"  '), \n                (8, '[-1, 12, 289, 2188, false,]'), \n                (9, '{ \"x\" : \"abc\", \"y\" : false, \"z\": 10} ') \n       AS vals;\n\nSELECT n, v, TYPEOF(v)\n  FROM vartab\n  ORDER BY n;\n\n+---+------------------------+------------+\n| N | V                      | TYPEOF(V)  |\n|---+------------------------+------------|\n| 1 | null                   | NULL_VALUE |\n| 2 | NULL                   | NULL       |\n| 3 | true                   | BOOLEAN    |\n| 4 | -17                    | INTEGER    |\n| 5 | 123.12                 | DECIMAL    |\n| 6 | 1.912000000000000e+02  | DOUBLE     |\n| 7 | \"Om ara pa ca na dhih\" | VARCHAR    |\n| 8 | [                      | ARRAY      |\n|   |   -1,                  |            |\n|   |   12,                  |            |\n|   |   289,                 |            |\n|   |   2188,                |            |\n|   |   false,               |            |\n|   |   undefined            |            |\n|   | ]                      |            |\n| 9 | {                      | OBJECT     |\n|   |   \"x\": \"abc\",          |            |\n|   |   \"y\": false,          |            |\n|   |   \"z\": 10              |            |\n|   | }                      |            |\n+---+------------------------+------------+\n\nSELECT * FROM vartab WHERE IS_OBJECT(v);\n\n+---+---------------+\n| N | V             |\n|---+---------------|\n| 9 | {             |\n|   |   \"x\": \"abc\", |\n|   |   \"y\": false, |\n|   |   \"z\": 10     |\n|   | }             |\n+---+---------------+\n\nCREATE OR REPLACE TABLE multiple_types (\n  array1 VARIANT,\n  array2 VARIANT,\n  boolean1 VARIANT,\n  varchar1 VARIANT,\n  varchar2 VARIANT,\n  decimal1 VARIANT,\n  double1 VARIANT,\n  integer1 VARIANT,\n  object1 VARIANT);\n\nINSERT INTO multiple_types\n    (array1, array2, boolean1, varchar1, varchar2,\n     decimal1, double1, integer1, object1)\n  SELECT\n    TO_VARIANT(TO_ARRAY('Example')),\n    TO_VARIANT(ARRAY_CONSTRUCT('Array-like', 'example')),\n    TO_VARIANT(TRUE),\n    TO_VARIANT('X'),\n    TO_VARIANT('I am a real character'),\n    TO_VARIANT(1.23::DECIMAL(6, 3)),\n    TO_VARIANT(3.21::DOUBLE),\n    TO_VARIANT(15),\n    TO_VARIANT(TO_OBJECT(PARSE_JSON('{\"Tree\": \"Pine\"}')));\n\nSELECT TYPEOF(array1),\n       TYPEOF(array2),\n       TYPEOF(boolean1),\n       TYPEOF(varchar1),\n       TYPEOF(varchar2),\n       TYPEOF(decimal1),\n       TYPEOF(double1),\n       TYPEOF(integer1),\n       TYPEOF(object1)\n  FROM multiple_types;\n\n+----------------+----------------+------------------+------------------+------------------+------------------+-----------------+------------------+-----------------+\n| TYPEOF(ARRAY1) | TYPEOF(ARRAY2) | TYPEOF(BOOLEAN1) | TYPEOF(VARCHAR1) | TYPEOF(VARCHAR2) | TYPEOF(DECIMAL1) | TYPEOF(DOUBLE1) | TYPEOF(INTEGER1) | TYPEOF(OBJECT1) |\n|----------------+----------------+------------------+------------------+------------------+------------------+-----------------+------------------+-----------------|\n| ARRAY          | ARRAY          | BOOLEAN          | VARCHAR          | VARCHAR          | DECIMAL          | DOUBLE          | INTEGER          | OBJECT          |\n+----------------+----------------+------------------+------------------+------------------+------------------+-----------------+------------------+-----------------+\n\nSELECT IS_OBJECT(array1),\n       IS_OBJECT(boolean1),\n       IS_OBJECT(object1)\n  FROM multiple_types;\n\n+-------------------+---------------------+--------------------+\n| IS_OBJECT(ARRAY1) | IS_OBJECT(BOOLEAN1) | IS_OBJECT(OBJECT1) |\n|-------------------+---------------------+--------------------|\n| False             | False               | True               |\n+-------------------+---------------------+--------------------+",
    "arguments": [
        {
            "name": "variant_expr",
            "description": "An expression that evaluates to a value of type VARIANT."
        }
    ],
    "returns": "Returns a BOOLEAN value or NULL."
},
{
    "function_name": "IS_NULL_VALUE",
    "summary": "Returns TRUE if its VARIANT argument is a JSON null value.",
    "category": "Conditional expression functions , Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/is_null_value",
    "title": "IS_NULL_VALUE",
    "description": "Returns TRUE if its",
    "syntax": "IS_NULL_VALUE( <variant_expr> )",
    "example": "CREATE OR REPLACE TABLE test_is_null_value_function (\n  variant_value VARIANT);\n\nINSERT INTO test_is_null_value_function (variant_value)\n  (SELECT PARSE_JSON('\"string value\"'));\n\nINSERT INTO test_is_null_value_function (variant_value)\n  (SELECT PARSE_JSON('null'));\n\nINSERT INTO test_is_null_value_function (variant_value)\n  (SELECT PARSE_JSON('{}'));\n\nINSERT INTO test_is_null_value_function (variant_value)\n  (SELECT PARSE_JSON('{\"x\": null}'));\n\nINSERT INTO test_is_null_value_function (variant_value)\n  (SELECT PARSE_JSON('{\"x\": \"foo\"}'));\n\nINSERT INTO test_is_null_value_function (variant_value)\n  (SELECT PARSE_JSON(NULL));\n\nSELECT variant_value,\n       variant_value:x value_of_x,\n       IS_NULL_VALUE(variant_value) is_variant_value_a_json_null,\n       IS_NULL_VALUE(variant_value:x) is_x_a_json_null,\n       IS_NULL_VALUE(variant_value:y) is_y_a_json_null\n  FROM test_is_null_value_function;\n\n+----------------+------------+------------------------------+------------------+------------------+\n| VARIANT_VALUE  | VALUE_OF_X | IS_VARIANT_VALUE_A_JSON_NULL | IS_X_A_JSON_NULL | IS_Y_A_JSON_NULL |\n|----------------+------------+------------------------------+------------------+------------------|\n| \"string value\" | NULL       | False                        | NULL             | NULL             |\n| null           | NULL       | True                         | NULL             | NULL             |\n| {}             | NULL       | False                        | NULL             | NULL             |\n| {              | null       | False                        | True             | NULL             |\n|   \"x\": null    |            |                              |                  |                  |\n| }              |            |                              |                  |                  |\n| {              | \"foo\"      | False                        | False            | NULL             |\n|   \"x\": \"foo\"   |            |                              |                  |                  |\n| }              |            |                              |                  |                  |\n| NULL           | NULL       | NULL                         | NULL             | NULL             |\n+----------------+------------+------------------------------+------------------+------------------+",
    "arguments": [
        {
            "name": "variant_expr",
            "description": "An expression that evaluates to a value of type VARIANT."
        }
    ],
    "returns": "This function returns a value of type BOOLEAN or NULL:"
},
{
    "function_name": "IS_INTEGER",
    "summary": "Returns TRUE if its VARIANT argument contains an integer value.",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/is_integer",
    "title": "IS_INTEGER",
    "description": "Returns TRUE if its",
    "syntax": "IS_INTEGER( <variant_expr> )",
    "example": "CREATE OR REPLACE TABLE vartab (n NUMBER(2), v VARIANT);\n\nINSERT INTO vartab\n  SELECT column1 AS n, PARSE_JSON(column2) AS v\n    FROM VALUES (1, 'null'), \n                (2, null), \n                (3, 'true'),\n                (4, '-17'), \n                (5, '123.12'), \n                (6, '1.912e2'),\n                (7, '\"Om ara pa ca na dhih\"  '), \n                (8, '[-1, 12, 289, 2188, false,]'), \n                (9, '{ \"x\" : \"abc\", \"y\" : false, \"z\": 10} ') \n       AS vals;\n\nSELECT n, v, TYPEOF(v)\n  FROM vartab\n  ORDER BY n;\n\n+---+------------------------+------------+\n| N | V                      | TYPEOF(V)  |\n|---+------------------------+------------|\n| 1 | null                   | NULL_VALUE |\n| 2 | NULL                   | NULL       |\n| 3 | true                   | BOOLEAN    |\n| 4 | -17                    | INTEGER    |\n| 5 | 123.12                 | DECIMAL    |\n| 6 | 1.912000000000000e+02  | DOUBLE     |\n| 7 | \"Om ara pa ca na dhih\" | VARCHAR    |\n| 8 | [                      | ARRAY      |\n|   |   -1,                  |            |\n|   |   12,                  |            |\n|   |   289,                 |            |\n|   |   2188,                |            |\n|   |   false,               |            |\n|   |   undefined            |            |\n|   | ]                      |            |\n| 9 | {                      | OBJECT     |\n|   |   \"x\": \"abc\",          |            |\n|   |   \"y\": false,          |            |\n|   |   \"z\": 10              |            |\n|   | }                      |            |\n+---+------------------------+------------+\n\nSELECT * FROM vartab WHERE IS_INTEGER(v);\n\n+---+-----+\n| N | V   |\n|---+-----|\n| 4 | -17 |\n+---+-----+\n\nCREATE OR REPLACE TABLE multiple_types (\n  array1 VARIANT,\n  array2 VARIANT,\n  boolean1 VARIANT,\n  varchar1 VARIANT,\n  varchar2 VARIANT,\n  decimal1 VARIANT,\n  double1 VARIANT,\n  integer1 VARIANT,\n  object1 VARIANT);\n\nINSERT INTO multiple_types\n    (array1, array2, boolean1, varchar1, varchar2,\n     decimal1, double1, integer1, object1)\n  SELECT\n    TO_VARIANT(TO_ARRAY('Example')),\n    TO_VARIANT(ARRAY_CONSTRUCT('Array-like', 'example')),\n    TO_VARIANT(TRUE),\n    TO_VARIANT('X'),\n    TO_VARIANT('I am a real character'),\n    TO_VARIANT(1.23::DECIMAL(6, 3)),\n    TO_VARIANT(3.21::DOUBLE),\n    TO_VARIANT(15),\n    TO_VARIANT(TO_OBJECT(PARSE_JSON('{\"Tree\": \"Pine\"}')));\n\nSELECT TYPEOF(array1),\n       TYPEOF(array2),\n       TYPEOF(boolean1),\n       TYPEOF(varchar1),\n       TYPEOF(varchar2),\n       TYPEOF(decimal1),\n       TYPEOF(double1),\n       TYPEOF(integer1),\n       TYPEOF(object1)\n  FROM multiple_types;\n\n+----------------+----------------+------------------+------------------+------------------+------------------+-----------------+------------------+-----------------+\n| TYPEOF(ARRAY1) | TYPEOF(ARRAY2) | TYPEOF(BOOLEAN1) | TYPEOF(VARCHAR1) | TYPEOF(VARCHAR2) | TYPEOF(DECIMAL1) | TYPEOF(DOUBLE1) | TYPEOF(INTEGER1) | TYPEOF(OBJECT1) |\n|----------------+----------------+------------------+------------------+------------------+------------------+-----------------+------------------+-----------------|\n| ARRAY          | ARRAY          | BOOLEAN          | VARCHAR          | VARCHAR          | DECIMAL          | DOUBLE          | INTEGER          | OBJECT          |\n+----------------+----------------+------------------+------------------+------------------+------------------+-----------------+------------------+-----------------+\n\nSELECT IS_INTEGER(decimal1),\n       IS_INTEGER(double1),\n       IS_INTEGER(integer1)\n  FROM multiple_types;\n\n+----------------------+---------------------+----------------------+\n| IS_INTEGER(DECIMAL1) | IS_INTEGER(DOUBLE1) | IS_INTEGER(INTEGER1) |\n|----------------------+---------------------+----------------------|\n| False                | False               | True                 |\n+----------------------+---------------------+----------------------+",
    "arguments": [
        {
            "name": "variant_expr",
            "description": "An expression that evaluates to a value of type VARIANT."
        }
    ],
    "returns": "Returns a BOOLEAN value or NULL."
},
{
    "function_name": "IS_INSTANCE_ROLE_IN_SESSION",
    "summary": "Verifies whether the user’s active primary or secondary role hierarchy for the session inherits the specified instance role.",
    "category": "Context functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/is_instance_role_in_session",
    "title": "IS_INSTANCE_ROLE_IN_SESSION",
    "description": "Verifies whether the user’s active primary or secondary role hierarchy for the session inherits the specified instance role.",
    "syntax": "IS_INSTANCE_ROLE_IN_SESSION( '<instance_name>' , '<instance_role_name>' )",
    "example": "USE ROLE my_role;\n\nSELECT IS_INSTANCE_ROLE_IN_SESSION('my_db.my_schema.my_anomaly_detector', 'user');\n\n+----------------------------------------------------------------------------+\n| IS_INSTANCE_ROLE_IN_SESSION('MY_DB.MY_SCHEMA.MY_ANOMALY_DETECTOR', 'USER') |\n+----------------------------------------------------------------------------+\n| TRUE                                                                       |\n+----------------------------------------------------------------------------+",
    "arguments": [
        {
            "name": "'",
            "description": "Specifies the name of the instance."
        },
        {
            "name": "'",
            "description": "Specifies the name of the instance role."
        }
    ],
    "returns": "TRUE if the current user’s active primary role or secondary roles in the session\ninherit the specified instance role."
},
{
    "function_name": "IS_GRANTED_TO_INVOKER_ROLE",
    "summary": "Returns TRUE if the role returned by the INVOKER_ROLE function inherits the privileges of the specified role in the argument based on the context in which the function is called.",
    "category": "Context functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/is_granted_to_invoker_role",
    "title": "IS_GRANTED_TO_INVOKER_ROLE",
    "description": "Returns TRUE if the role returned by the INVOKER_ROLE function inherits the privileges of the specified role in the argument based on the\ncontext in which the function is called.",
    "syntax": "IS_GRANTED_TO_INVOKER_ROLE( '<string_literal>' )",
    "arguments": [
        {
            "name": "'",
            "description": "The name of the role."
        }
    ]
},
{
    "function_name": "IS_DOUBLE , IS_REAL",
    "summary": "Returns TRUE if its VARIANT argument contains a floating-point number, fixed-point number, or integer value.",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/is_double-real",
    "title": "IS_DOUBLE , IS_REAL",
    "description": "Returns TRUE if its",
    "syntax": "IS_DOUBLE( <variant_expr> )\n\nIS_REAL( <variant_expr> )",
    "example": "CREATE OR REPLACE TABLE vartab (n NUMBER(2), v VARIANT);\n\nINSERT INTO vartab\n  SELECT column1 AS n, PARSE_JSON(column2) AS v\n    FROM VALUES (1, 'null'), \n                (2, null), \n                (3, 'true'),\n                (4, '-17'), \n                (5, '123.12'), \n                (6, '1.912e2'),\n                (7, '\"Om ara pa ca na dhih\"  '), \n                (8, '[-1, 12, 289, 2188, false,]'), \n                (9, '{ \"x\" : \"abc\", \"y\" : false, \"z\": 10} ') \n       AS vals;\n\nSELECT n, v, TYPEOF(v)\n  FROM vartab\n  ORDER BY n;\n\n+---+------------------------+------------+\n| N | V                      | TYPEOF(V)  |\n|---+------------------------+------------|\n| 1 | null                   | NULL_VALUE |\n| 2 | NULL                   | NULL       |\n| 3 | true                   | BOOLEAN    |\n| 4 | -17                    | INTEGER    |\n| 5 | 123.12                 | DECIMAL    |\n| 6 | 1.912000000000000e+02  | DOUBLE     |\n| 7 | \"Om ara pa ca na dhih\" | VARCHAR    |\n| 8 | [                      | ARRAY      |\n|   |   -1,                  |            |\n|   |   12,                  |            |\n|   |   289,                 |            |\n|   |   2188,                |            |\n|   |   false,               |            |\n|   |   undefined            |            |\n|   | ]                      |            |\n| 9 | {                      | OBJECT     |\n|   |   \"x\": \"abc\",          |            |\n|   |   \"y\": false,          |            |\n|   |   \"z\": 10              |            |\n|   | }                      |            |\n+---+------------------------+------------+\n\nSELECT * FROM vartab WHERE IS_DOUBLE(v);\n\n+---+-----------------------+\n| N | V                     |\n|---+-----------------------|\n| 4 | -17                   |\n| 5 | 123.12                |\n| 6 | 1.912000000000000e+02 |\n+---+-----------------------+\n\nCREATE OR REPLACE TABLE multiple_types (\n  array1 VARIANT,\n  array2 VARIANT,\n  boolean1 VARIANT,\n  varchar1 VARIANT,\n  varchar2 VARIANT,\n  decimal1 VARIANT,\n  double1 VARIANT,\n  integer1 VARIANT,\n  object1 VARIANT);\n\nINSERT INTO multiple_types\n    (array1, array2, boolean1, varchar1, varchar2,\n     decimal1, double1, integer1, object1)\n  SELECT\n    TO_VARIANT(TO_ARRAY('Example')),\n    TO_VARIANT(ARRAY_CONSTRUCT('Array-like', 'example')),\n    TO_VARIANT(TRUE),\n    TO_VARIANT('X'),\n    TO_VARIANT('I am a real character'),\n    TO_VARIANT(1.23::DECIMAL(6, 3)),\n    TO_VARIANT(3.21::DOUBLE),\n    TO_VARIANT(15),\n    TO_VARIANT(TO_OBJECT(PARSE_JSON('{\"Tree\": \"Pine\"}')));\n\nSELECT TYPEOF(array1),\n       TYPEOF(array2),\n       TYPEOF(boolean1),\n       TYPEOF(varchar1),\n       TYPEOF(varchar2),\n       TYPEOF(decimal1),\n       TYPEOF(double1),\n       TYPEOF(integer1),\n       TYPEOF(object1)\n  FROM multiple_types;\n\n+----------------+----------------+------------------+------------------+------------------+------------------+-----------------+------------------+-----------------+\n| TYPEOF(ARRAY1) | TYPEOF(ARRAY2) | TYPEOF(BOOLEAN1) | TYPEOF(VARCHAR1) | TYPEOF(VARCHAR2) | TYPEOF(DECIMAL1) | TYPEOF(DOUBLE1) | TYPEOF(INTEGER1) | TYPEOF(OBJECT1) |\n|----------------+----------------+------------------+------------------+------------------+------------------+-----------------+------------------+-----------------|\n| ARRAY          | ARRAY          | BOOLEAN          | VARCHAR          | VARCHAR          | DECIMAL          | DOUBLE          | INTEGER          | OBJECT          |\n+----------------+----------------+------------------+------------------+------------------+------------------+-----------------+------------------+-----------------+\n\nSELECT IS_DOUBLE(boolean1),\n       IS_DOUBLE(decimal1),\n       IS_DOUBLE(double1),\n       IS_DOUBLE(integer1)\n  FROM multiple_types;\n\n+---------------------+---------------------+--------------------+---------------------+\n| IS_DOUBLE(BOOLEAN1) | IS_DOUBLE(DECIMAL1) | IS_DOUBLE(DOUBLE1) | IS_DOUBLE(INTEGER1) |\n|---------------------+---------------------+--------------------+---------------------|\n| False               | True                | True               | True                |\n+---------------------+---------------------+--------------------+---------------------+",
    "arguments": [
        {
            "name": "variant_expr",
            "description": "An expression that evaluates to a value of type VARIANT."
        }
    ],
    "returns": "Returns a BOOLEAN value or NULL."
},
{
    "function_name": "IS_DECIMAL",
    "summary": "Returns TRUE if its VARIANT argument contains a fixed-point number or integer value.",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/is_decimal",
    "title": "IS_DECIMAL",
    "description": "Returns TRUE if its",
    "syntax": "IS_DECIMAL( <variant_expr> )",
    "example": "CREATE OR REPLACE TABLE vartab (n NUMBER(2), v VARIANT);\n\nINSERT INTO vartab\n  SELECT column1 AS n, PARSE_JSON(column2) AS v\n    FROM VALUES (1, 'null'), \n                (2, null), \n                (3, 'true'),\n                (4, '-17'), \n                (5, '123.12'), \n                (6, '1.912e2'),\n                (7, '\"Om ara pa ca na dhih\"  '), \n                (8, '[-1, 12, 289, 2188, false,]'), \n                (9, '{ \"x\" : \"abc\", \"y\" : false, \"z\": 10} ') \n       AS vals;\n\nSELECT n, v, TYPEOF(v)\n  FROM vartab\n  ORDER BY n;\n\n+---+------------------------+------------+\n| N | V                      | TYPEOF(V)  |\n|---+------------------------+------------|\n| 1 | null                   | NULL_VALUE |\n| 2 | NULL                   | NULL       |\n| 3 | true                   | BOOLEAN    |\n| 4 | -17                    | INTEGER    |\n| 5 | 123.12                 | DECIMAL    |\n| 6 | 1.912000000000000e+02  | DOUBLE     |\n| 7 | \"Om ara pa ca na dhih\" | VARCHAR    |\n| 8 | [                      | ARRAY      |\n|   |   -1,                  |            |\n|   |   12,                  |            |\n|   |   289,                 |            |\n|   |   2188,                |            |\n|   |   false,               |            |\n|   |   undefined            |            |\n|   | ]                      |            |\n| 9 | {                      | OBJECT     |\n|   |   \"x\": \"abc\",          |            |\n|   |   \"y\": false,          |            |\n|   |   \"z\": 10              |            |\n|   | }                      |            |\n+---+------------------------+------------+\n\nSELECT * FROM vartab WHERE IS_DECIMAL(v);\n\n+---+--------+\n| N | V      |\n|---+--------|\n| 4 | -17    |\n| 5 | 123.12 |\n+---+--------+\n\nCREATE OR REPLACE TABLE multiple_types (\n  array1 VARIANT,\n  array2 VARIANT,\n  boolean1 VARIANT,\n  varchar1 VARIANT,\n  varchar2 VARIANT,\n  decimal1 VARIANT,\n  double1 VARIANT,\n  integer1 VARIANT,\n  object1 VARIANT);\n\nINSERT INTO multiple_types\n    (array1, array2, boolean1, varchar1, varchar2,\n     decimal1, double1, integer1, object1)\n  SELECT\n    TO_VARIANT(TO_ARRAY('Example')),\n    TO_VARIANT(ARRAY_CONSTRUCT('Array-like', 'example')),\n    TO_VARIANT(TRUE),\n    TO_VARIANT('X'),\n    TO_VARIANT('I am a real character'),\n    TO_VARIANT(1.23::DECIMAL(6, 3)),\n    TO_VARIANT(3.21::DOUBLE),\n    TO_VARIANT(15),\n    TO_VARIANT(TO_OBJECT(PARSE_JSON('{\"Tree\": \"Pine\"}')));\n\nSELECT TYPEOF(array1),\n       TYPEOF(array2),\n       TYPEOF(boolean1),\n       TYPEOF(varchar1),\n       TYPEOF(varchar2),\n       TYPEOF(decimal1),\n       TYPEOF(double1),\n       TYPEOF(integer1),\n       TYPEOF(object1)\n  FROM multiple_types;\n\n+----------------+----------------+------------------+------------------+------------------+------------------+-----------------+------------------+-----------------+\n| TYPEOF(ARRAY1) | TYPEOF(ARRAY2) | TYPEOF(BOOLEAN1) | TYPEOF(VARCHAR1) | TYPEOF(VARCHAR2) | TYPEOF(DECIMAL1) | TYPEOF(DOUBLE1) | TYPEOF(INTEGER1) | TYPEOF(OBJECT1) |\n|----------------+----------------+------------------+------------------+------------------+------------------+-----------------+------------------+-----------------|\n| ARRAY          | ARRAY          | BOOLEAN          | VARCHAR          | VARCHAR          | DECIMAL          | DOUBLE          | INTEGER          | OBJECT          |\n+----------------+----------------+------------------+------------------+------------------+------------------+-----------------+------------------+-----------------+\n\nSELECT IS_DECIMAL(decimal1),\n       IS_DECIMAL(double1),\n       IS_DECIMAL(integer1)\n  FROM multiple_types;\n\n+----------------------+---------------------+----------------------+\n| IS_DECIMAL(DECIMAL1) | IS_DECIMAL(DOUBLE1) | IS_DECIMAL(INTEGER1) |\n|----------------------+---------------------+----------------------|\n| True                 | False               | True                 |\n+----------------------+---------------------+----------------------+",
    "arguments": [
        {
            "name": "variant_expr",
            "description": "An expression that evaluates to a value of type VARIANT."
        }
    ],
    "returns": "Returns a BOOLEAN value or NULL."
},
{
    "function_name": "IS_DATE , IS_DATE_VALUE",
    "summary": "Returns TRUE if its VARIANT argument contains a DATE value.",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/is_date-value",
    "title": "IS_DATE , IS_DATE_VALUE",
    "description": "Returns TRUE if its",
    "syntax": "IS_DATE( <variant_expr> )\n\nIS_DATE_VALUE( <variant_expr> )",
    "example": "CREATE OR REPLACE TABLE vardttm (v VARIANT);\n\nINSERT INTO vardttm SELECT TO_VARIANT(TO_DATE('2024-02-24'));\nINSERT INTO vardttm SELECT TO_VARIANT(TO_TIME('20:57:01.123456789+07:00'));\nINSERT INTO vardttm SELECT TO_VARIANT(TO_TIMESTAMP('2023-02-24 12:00:00.456'));\nINSERT INTO vardttm SELECT TO_VARIANT(TO_TIMESTAMP_LTZ('2022-02-24 13:00:00.123 +01:00'));\nINSERT INTO vardttm SELECT TO_VARIANT(TO_TIMESTAMP_NTZ('2021-02-24 14:00:00.123 +01:00'));\nINSERT INTO vardttm SELECT TO_VARIANT(TO_TIMESTAMP_TZ('2020-02-24 15:00:00.123 +01:00'));\n\nSELECT v, TYPEOF(v) AS type FROM vardttm;\n\n+---------------------------------+---------------+\n| V                               | TYPE          |\n|---------------------------------+---------------|\n| \"2024-02-24\"                    | DATE          |\n| \"20:57:01\"                      | TIME          |\n| \"2023-02-24 12:00:00.456\"       | TIMESTAMP_NTZ |\n| \"2022-02-24 04:00:00.123 -0800\" | TIMESTAMP_LTZ |\n| \"2021-02-24 14:00:00.123\"       | TIMESTAMP_NTZ |\n| \"2020-02-24 15:00:00.123 +0100\" | TIMESTAMP_TZ  |\n+---------------------------------+---------------+\n\nSELECT v FROM vardttm WHERE IS_DATE(v);\n\n+--------------+\n| V            |\n|--------------|\n| \"2024-02-24\" |\n+--------------+",
    "arguments": [
        {
            "name": "variant_expr",
            "description": "An expression that evaluates to a value of type VARIANT."
        }
    ],
    "returns": "Returns a BOOLEAN value or NULL."
},
{
    "function_name": "IS_DATABASE_ROLE_IN_SESSION",
    "summary": "Verifies whether the database role is in the user’s active primary or secondary role hierarchy for the current session or if the specified column contains a database role that is in the user’s active primary or secondary role hierarchy for the current session.",
    "category": "Context functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/is_database_role_in_session",
    "title": "IS_DATABASE_ROLE_IN_SESSION",
    "description": "Verifies whether the database role is in the user’s active primary or secondary role hierarchy for the current session or if the specified\ncolumn contains a database role that is in the user’s active primary or secondary role hierarchy for the current session.",
    "syntax": "IS_DATABASE_ROLE_IN_SESSION( '<string_literal>' )",
    "example": "SELECT IS_DATABASE_ROLE_IN_SESSION('R1');\n\n+-----------------------------------+\n| IS_DATABASE_ROLE_IN_SESSION('R1') |\n+-----------------------------------+\n| True                              |\n+-----------------------------------+\n\nSELECT *\nFROM myb.s1.t1\nWHERE IS_DATABASE_ROLE_IN_SESSION(role_name);",
    "arguments": [
        {
            "name": "'",
            "description": "The name of the database role. Specify the relative name of the database role. The function evaluates to False if you specify the fully qualified name."
        },
        {
            "name": "column_name",
            "description": "The column name in a table or view."
        }
    ],
    "returns": "For a literal argument (database role name), the current user’s active\nprimary role or secondary roles in the session inherits the privileges of the\nspecified database role."
},
{
    "function_name": "IS_CHAR , IS_VARCHAR",
    "summary": "Returns TRUE if its VARIANT argument contains a string value.",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/is_char-varchar",
    "title": "IS_CHAR , IS_VARCHAR",
    "description": "Returns TRUE if its",
    "syntax": "IS_CHAR( <variant_expr> )\n\nIS_VARCHAR( <variant_expr> )",
    "example": "CREATE OR REPLACE TABLE vartab (n NUMBER(2), v VARIANT);\n\nINSERT INTO vartab\n  SELECT column1 AS n, PARSE_JSON(column2) AS v\n    FROM VALUES (1, 'null'), \n                (2, null), \n                (3, 'true'),\n                (4, '-17'), \n                (5, '123.12'), \n                (6, '1.912e2'),\n                (7, '\"Om ara pa ca na dhih\"  '), \n                (8, '[-1, 12, 289, 2188, false,]'), \n                (9, '{ \"x\" : \"abc\", \"y\" : false, \"z\": 10} ') \n       AS vals;\n\nSELECT n, v, TYPEOF(v)\n  FROM vartab\n  ORDER BY n;\n\n+---+------------------------+------------+\n| N | V                      | TYPEOF(V)  |\n|---+------------------------+------------|\n| 1 | null                   | NULL_VALUE |\n| 2 | NULL                   | NULL       |\n| 3 | true                   | BOOLEAN    |\n| 4 | -17                    | INTEGER    |\n| 5 | 123.12                 | DECIMAL    |\n| 6 | 1.912000000000000e+02  | DOUBLE     |\n| 7 | \"Om ara pa ca na dhih\" | VARCHAR    |\n| 8 | [                      | ARRAY      |\n|   |   -1,                  |            |\n|   |   12,                  |            |\n|   |   289,                 |            |\n|   |   2188,                |            |\n|   |   false,               |            |\n|   |   undefined            |            |\n|   | ]                      |            |\n| 9 | {                      | OBJECT     |\n|   |   \"x\": \"abc\",          |            |\n|   |   \"y\": false,          |            |\n|   |   \"z\": 10              |            |\n|   | }                      |            |\n+---+------------------------+------------+\n\nSELECT * FROM vartab WHERE IS_VARCHAR(v);\n\n+---+------------------------+\n| N | V                      |\n|---+------------------------|\n| 7 | \"Om ara pa ca na dhih\" |\n+---+------------------------+\n\nCREATE OR REPLACE TABLE multiple_types (\n  array1 VARIANT,\n  array2 VARIANT,\n  boolean1 VARIANT,\n  varchar1 VARIANT,\n  varchar2 VARIANT,\n  decimal1 VARIANT,\n  double1 VARIANT,\n  integer1 VARIANT,\n  object1 VARIANT);\n\nINSERT INTO multiple_types\n    (array1, array2, boolean1, varchar1, varchar2,\n     decimal1, double1, integer1, object1)\n  SELECT\n    TO_VARIANT(TO_ARRAY('Example')),\n    TO_VARIANT(ARRAY_CONSTRUCT('Array-like', 'example')),\n    TO_VARIANT(TRUE),\n    TO_VARIANT('X'),\n    TO_VARIANT('I am a real character'),\n    TO_VARIANT(1.23::DECIMAL(6, 3)),\n    TO_VARIANT(3.21::DOUBLE),\n    TO_VARIANT(15),\n    TO_VARIANT(TO_OBJECT(PARSE_JSON('{\"Tree\": \"Pine\"}')));\n\nSELECT TYPEOF(array1),\n       TYPEOF(array2),\n       TYPEOF(boolean1),\n       TYPEOF(varchar1),\n       TYPEOF(varchar2),\n       TYPEOF(decimal1),\n       TYPEOF(double1),\n       TYPEOF(integer1),\n       TYPEOF(object1)\n  FROM multiple_types;\n\n+----------------+----------------+------------------+------------------+------------------+------------------+-----------------+------------------+-----------------+\n| TYPEOF(ARRAY1) | TYPEOF(ARRAY2) | TYPEOF(BOOLEAN1) | TYPEOF(VARCHAR1) | TYPEOF(VARCHAR2) | TYPEOF(DECIMAL1) | TYPEOF(DOUBLE1) | TYPEOF(INTEGER1) | TYPEOF(OBJECT1) |\n|----------------+----------------+------------------+------------------+------------------+------------------+-----------------+------------------+-----------------|\n| ARRAY          | ARRAY          | BOOLEAN          | VARCHAR          | VARCHAR          | DECIMAL          | DOUBLE          | INTEGER          | OBJECT          |\n+----------------+----------------+------------------+------------------+------------------+------------------+-----------------+------------------+-----------------+\n\nSELECT IS_VARCHAR(varchar1),\n       IS_VARCHAR(boolean1)\n  FROM multiple_types;\n\n+----------------------+----------------------+\n| IS_VARCHAR(VARCHAR1) | IS_VARCHAR(BOOLEAN1) |\n|----------------------+----------------------|\n| True                 | False                |\n+----------------------+----------------------+",
    "arguments": [
        {
            "name": "variant_expr",
            "description": "An expression that evaluates to a value of type VARIANT."
        }
    ],
    "returns": "Returns a BOOLEAN value or NULL."
},
{
    "function_name": "IS_BOOLEAN",
    "summary": "Returns TRUE if its VARIANT argument contains a BOOLEAN value.",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/is_boolean",
    "title": "IS_BOOLEAN",
    "description": "Returns TRUE if its",
    "syntax": "IS_BOOLEAN( <variant_expr> )",
    "example": "CREATE OR REPLACE TABLE vartab (n NUMBER(2), v VARIANT);\n\nINSERT INTO vartab\n  SELECT column1 AS n, PARSE_JSON(column2) AS v\n    FROM VALUES (1, 'null'), \n                (2, null), \n                (3, 'true'),\n                (4, '-17'), \n                (5, '123.12'), \n                (6, '1.912e2'),\n                (7, '\"Om ara pa ca na dhih\"  '), \n                (8, '[-1, 12, 289, 2188, false,]'), \n                (9, '{ \"x\" : \"abc\", \"y\" : false, \"z\": 10} ') \n       AS vals;\n\nSELECT n, v, TYPEOF(v)\n  FROM vartab\n  ORDER BY n;\n\n+---+------------------------+------------+\n| N | V                      | TYPEOF(V)  |\n|---+------------------------+------------|\n| 1 | null                   | NULL_VALUE |\n| 2 | NULL                   | NULL       |\n| 3 | true                   | BOOLEAN    |\n| 4 | -17                    | INTEGER    |\n| 5 | 123.12                 | DECIMAL    |\n| 6 | 1.912000000000000e+02  | DOUBLE     |\n| 7 | \"Om ara pa ca na dhih\" | VARCHAR    |\n| 8 | [                      | ARRAY      |\n|   |   -1,                  |            |\n|   |   12,                  |            |\n|   |   289,                 |            |\n|   |   2188,                |            |\n|   |   false,               |            |\n|   |   undefined            |            |\n|   | ]                      |            |\n| 9 | {                      | OBJECT     |\n|   |   \"x\": \"abc\",          |            |\n|   |   \"y\": false,          |            |\n|   |   \"z\": 10              |            |\n|   | }                      |            |\n+---+------------------------+------------+\n\nSELECT * FROM vartab WHERE IS_BOOLEAN(v);\n\n+---+------+\n| N | V    |\n|---+------|\n| 3 | true |\n+---+------+\n\nCREATE OR REPLACE TABLE multiple_types (\n  array1 VARIANT,\n  array2 VARIANT,\n  boolean1 VARIANT,\n  varchar1 VARIANT,\n  varchar2 VARIANT,\n  decimal1 VARIANT,\n  double1 VARIANT,\n  integer1 VARIANT,\n  object1 VARIANT);\n\nINSERT INTO multiple_types\n    (array1, array2, boolean1, varchar1, varchar2,\n     decimal1, double1, integer1, object1)\n  SELECT\n    TO_VARIANT(TO_ARRAY('Example')),\n    TO_VARIANT(ARRAY_CONSTRUCT('Array-like', 'example')),\n    TO_VARIANT(TRUE),\n    TO_VARIANT('X'),\n    TO_VARIANT('I am a real character'),\n    TO_VARIANT(1.23::DECIMAL(6, 3)),\n    TO_VARIANT(3.21::DOUBLE),\n    TO_VARIANT(15),\n    TO_VARIANT(TO_OBJECT(PARSE_JSON('{\"Tree\": \"Pine\"}')));\n\nSELECT TYPEOF(array1),\n       TYPEOF(array2),\n       TYPEOF(boolean1),\n       TYPEOF(varchar1),\n       TYPEOF(varchar2),\n       TYPEOF(decimal1),\n       TYPEOF(double1),\n       TYPEOF(integer1),\n       TYPEOF(object1)\n  FROM multiple_types;\n\n+----------------+----------------+------------------+------------------+------------------+------------------+-----------------+------------------+-----------------+\n| TYPEOF(ARRAY1) | TYPEOF(ARRAY2) | TYPEOF(BOOLEAN1) | TYPEOF(VARCHAR1) | TYPEOF(VARCHAR2) | TYPEOF(DECIMAL1) | TYPEOF(DOUBLE1) | TYPEOF(INTEGER1) | TYPEOF(OBJECT1) |\n|----------------+----------------+------------------+------------------+------------------+------------------+-----------------+------------------+-----------------|\n| ARRAY          | ARRAY          | BOOLEAN          | VARCHAR          | VARCHAR          | DECIMAL          | DOUBLE          | INTEGER          | OBJECT          |\n+----------------+----------------+------------------+------------------+------------------+------------------+-----------------+------------------+-----------------+\n\nSELECT IS_BOOLEAN(boolean1),\n       IS_BOOLEAN(array1)\n  FROM multiple_types;\n\n+----------------------+--------------------+\n| IS_BOOLEAN(BOOLEAN1) | IS_BOOLEAN(ARRAY1) |\n|----------------------+--------------------|\n| True                 | False              |\n+----------------------+--------------------+",
    "arguments": [
        {
            "name": "variant_expr",
            "description": "An expression that evaluates to a value of type VARIANT."
        }
    ],
    "returns": "Returns a BOOLEAN value or NULL."
},
{
    "function_name": "IS_BINARY",
    "summary": "Returns TRUE if its VARIANT argument contains a binary string value.",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/is_binary",
    "title": "IS_BINARY",
    "description": "Returns TRUE if its",
    "syntax": "IS_BINARY( <variant_expr> )",
    "example": "CREATE OR REPLACE TABLE varbin (v VARIANT);\n\nINSERT INTO varbin SELECT TO_VARIANT(TO_BINARY('snow', 'utf-8'));\n\nSELECT v AS hex_encoded_binary_value\n  FROM varbin\n  WHERE IS_BINARY(v);\n\n+--------------------------+\n| HEX_ENCODED_BINARY_VALUE |\n|--------------------------|\n| \"736E6F77\"               |\n+--------------------------+",
    "arguments": [
        {
            "name": "variant_expr",
            "description": "An expression that evaluates to a value of type VARIANT."
        }
    ],
    "returns": "Returns a BOOLEAN value or NULL."
},
{
    "function_name": "IS_ARRAY",
    "summary": "Returns TRUE if its VARIANT argument contains an ARRAY value.",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/is_array",
    "title": "IS_ARRAY",
    "description": "Returns TRUE if its",
    "syntax": "IS_ARRAY( <variant_expr> )",
    "example": "CREATE OR REPLACE TABLE vartab (n NUMBER(2), v VARIANT);\n\nINSERT INTO vartab\n  SELECT column1 AS n, PARSE_JSON(column2) AS v\n    FROM VALUES (1, 'null'), \n                (2, null), \n                (3, 'true'),\n                (4, '-17'), \n                (5, '123.12'), \n                (6, '1.912e2'),\n                (7, '\"Om ara pa ca na dhih\"  '), \n                (8, '[-1, 12, 289, 2188, false,]'), \n                (9, '{ \"x\" : \"abc\", \"y\" : false, \"z\": 10} ') \n       AS vals;\n\nSELECT n, v, TYPEOF(v)\n  FROM vartab\n  ORDER BY n;\n\n+---+------------------------+------------+\n| N | V                      | TYPEOF(V)  |\n|---+------------------------+------------|\n| 1 | null                   | NULL_VALUE |\n| 2 | NULL                   | NULL       |\n| 3 | true                   | BOOLEAN    |\n| 4 | -17                    | INTEGER    |\n| 5 | 123.12                 | DECIMAL    |\n| 6 | 1.912000000000000e+02  | DOUBLE     |\n| 7 | \"Om ara pa ca na dhih\" | VARCHAR    |\n| 8 | [                      | ARRAY      |\n|   |   -1,                  |            |\n|   |   12,                  |            |\n|   |   289,                 |            |\n|   |   2188,                |            |\n|   |   false,               |            |\n|   |   undefined            |            |\n|   | ]                      |            |\n| 9 | {                      | OBJECT     |\n|   |   \"x\": \"abc\",          |            |\n|   |   \"y\": false,          |            |\n|   |   \"z\": 10              |            |\n|   | }                      |            |\n+---+------------------------+------------+\n\nSELECT * FROM vartab WHERE IS_ARRAY(v);\n\n+---+-------------+\n| N | V           |\n|---+-------------|\n| 8 | [           |\n|   |   -1,       |\n|   |   12,       |\n|   |   289,      |\n|   |   2188,     |\n|   |   false,    |\n|   |   undefined |\n|   | ]           |\n+---+-------------+\n\nCREATE OR REPLACE TABLE multiple_types (\n  array1 VARIANT,\n  array2 VARIANT,\n  boolean1 VARIANT,\n  varchar1 VARIANT,\n  varchar2 VARIANT,\n  decimal1 VARIANT,\n  double1 VARIANT,\n  integer1 VARIANT,\n  object1 VARIANT);\n\nINSERT INTO multiple_types\n    (array1, array2, boolean1, varchar1, varchar2,\n     decimal1, double1, integer1, object1)\n  SELECT\n    TO_VARIANT(TO_ARRAY('Example')),\n    TO_VARIANT(ARRAY_CONSTRUCT('Array-like', 'example')),\n    TO_VARIANT(TRUE),\n    TO_VARIANT('X'),\n    TO_VARIANT('I am a real character'),\n    TO_VARIANT(1.23::DECIMAL(6, 3)),\n    TO_VARIANT(3.21::DOUBLE),\n    TO_VARIANT(15),\n    TO_VARIANT(TO_OBJECT(PARSE_JSON('{\"Tree\": \"Pine\"}')));\n\nSELECT TYPEOF(array1),\n       TYPEOF(array2),\n       TYPEOF(boolean1),\n       TYPEOF(varchar1),\n       TYPEOF(varchar2),\n       TYPEOF(decimal1),\n       TYPEOF(double1),\n       TYPEOF(integer1),\n       TYPEOF(object1)\n  FROM multiple_types;\n\n+----------------+----------------+------------------+------------------+------------------+------------------+-----------------+------------------+-----------------+\n| TYPEOF(ARRAY1) | TYPEOF(ARRAY2) | TYPEOF(BOOLEAN1) | TYPEOF(VARCHAR1) | TYPEOF(VARCHAR2) | TYPEOF(DECIMAL1) | TYPEOF(DOUBLE1) | TYPEOF(INTEGER1) | TYPEOF(OBJECT1) |\n|----------------+----------------+------------------+------------------+------------------+------------------+-----------------+------------------+-----------------|\n| ARRAY          | ARRAY          | BOOLEAN          | VARCHAR          | VARCHAR          | DECIMAL          | DOUBLE          | INTEGER          | OBJECT          |\n+----------------+----------------+------------------+------------------+------------------+------------------+-----------------+------------------+-----------------+\n\nSELECT IS_ARRAY(array1),\n       IS_ARRAY(array2),\n       IS_ARRAY(boolean1)\n  FROM multiple_types;\n\n+------------------+------------------+--------------------+\n| IS_ARRAY(ARRAY1) | IS_ARRAY(ARRAY2) | IS_ARRAY(BOOLEAN1) |\n|------------------+------------------+--------------------|\n| True             | True             | False              |\n+------------------+------------------+--------------------+",
    "arguments": [
        {
            "name": "variant_expr",
            "description": "An expression that evaluates to a value of type VARIANT."
        }
    ],
    "returns": "Returns a BOOLEAN value or NULL."
},
{
    "function_name": "IS_APPLICATION_ROLE_IN_SESSION",
    "summary": "Verifies whether the application role is activated in the consumer’s current session.",
    "category": "Context functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/is_application_role_in_session",
    "title": "IS_APPLICATION_ROLE_IN_SESSION",
    "description": "Verifies whether the application role is activated in the consumer’s current session.",
    "syntax": "IS_APPLICATION_ROLE_IN_SESSION( '<string_literal>' )",
    "example": "SELECT IS_APPLICATION_ROLE_IN_SESSION('ANALYST');\n\n+-------------------------------------------+\n| IS_APPLICATION_ROLE_IN_SESSION('ANALYST') |\n+-------------------------------------------+\n| FALSE                                     |\n+-------------------------------------------+",
    "arguments": [
        {
            "name": "'",
            "description": "The application role name."
        }
    ],
    "returns": "TRUE when the specified role name is activated in the consumer’s current session."
},
{
    "function_name": "IS_<object_type>",
    "summary": "This family of functions serves as Boolean predicates that can be used to determine the data type of a value stored in a VARIANT column.",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/is",
    "title": "IS_",
    "description": "This family of functions serves as Boolean predicates that can be used to determine the data type of a value stored in a VARIANT column:",
    "example": "CREATE OR REPLACE TABLE vartab (n NUMBER(2), v VARIANT);\n\nINSERT INTO vartab\n  SELECT column1 AS n, PARSE_JSON(column2) AS v\n    FROM VALUES (1, 'null'), \n                (2, null), \n                (3, 'true'),\n                (4, '-17'), \n                (5, '123.12'), \n                (6, '1.912e2'),\n                (7, '\"Om ara pa ca na dhih\"  '), \n                (8, '[-1, 12, 289, 2188, false,]'), \n                (9, '{ \"x\" : \"abc\", \"y\" : false, \"z\": 10} ') \n       AS vals;\n\nSELECT n, v, TYPEOF(v)\n  FROM vartab\n  ORDER BY n;\n\n+---+------------------------+------------+\n| N | V                      | TYPEOF(V)  |\n|---+------------------------+------------|\n| 1 | null                   | NULL_VALUE |\n| 2 | NULL                   | NULL       |\n| 3 | true                   | BOOLEAN    |\n| 4 | -17                    | INTEGER    |\n| 5 | 123.12                 | DECIMAL    |\n| 6 | 1.912000000000000e+02  | DOUBLE     |\n| 7 | \"Om ara pa ca na dhih\" | VARCHAR    |\n| 8 | [                      | ARRAY      |\n|   |   -1,                  |            |\n|   |   12,                  |            |\n|   |   289,                 |            |\n|   |   2188,                |            |\n|   |   false,               |            |\n|   |   undefined            |            |\n|   | ]                      |            |\n| 9 | {                      | OBJECT     |\n|   |   \"x\": \"abc\",          |            |\n|   |   \"y\": false,          |            |\n|   |   \"z\": 10              |            |\n|   | }                      |            |\n+---+------------------------+------------+\n\nSELECT COUNT(*) FROM vartab WHERE IS_VARCHAR(v);\n\n+----------+\n| COUNT(*) |\n|----------|\n|        1 |\n+----------+\n\nSELECT * FROM vartab WHERE IS_NULL_VALUE(v);\n\n+---+------+\n| N | V    |\n|---+------|\n| 1 | null |\n+---+------+\n\nSELECT * FROM vartab WHERE IS_BOOLEAN(v);\n\n+---+------+\n| N | V    |\n|---+------|\n| 3 | true |\n+---+------+\n\nSELECT * FROM vartab WHERE IS_INTEGER(v);\n\n+---+-----+\n| N | V   |\n|---+-----|\n| 4 | -17 |\n+---+-----+\n\nSELECT * FROM vartab WHERE IS_DECIMAL(v);\n\n+---+--------+\n| N | V      |\n|---+--------|\n| 4 | -17    |\n| 5 | 123.12 |\n+---+--------+\n\nSELECT * FROM vartab WHERE IS_DOUBLE(v);\n\n+---+-----------------------+\n| N | V                     |\n|---+-----------------------|\n| 4 | -17                   |\n| 5 | 123.12                |\n| 6 | 1.912000000000000e+02 |\n+---+-----------------------+\n\nSELECT * FROM vartab WHERE IS_VARCHAR(v);\n\n+---+------------------------+\n| N | V                      |\n|---+------------------------|\n| 7 | \"Om ara pa ca na dhih\" |\n+---+------------------------+\n\nSELECT * FROM vartab WHERE IS_ARRAY(v);\n\n+---+-------------+\n| N | V           |\n|---+-------------|\n| 8 | [           |\n|   |   -1,       |\n|   |   12,       |\n|   |   289,      |\n|   |   2188,     |\n|   |   false,    |\n|   |   undefined |\n|   | ]           |\n+---+-------------+\n\nSELECT * FROM vartab WHERE IS_OBJECT(v);\n\n+---+---------------+\n| N | V             |\n|---+---------------|\n| 9 | {             |\n|   |   \"x\": \"abc\", |\n|   |   \"y\": false, |\n|   |   \"z\": 10     |\n|   | }             |\n+---+---------------+"
},
{
    "function_name": "IS [ NOT ] NULL",
    "summary": "Determines whether an expression is NULL or is not NULL.",
    "category": "Conditional expression functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/is-null",
    "title": "IS [ NOT ] NULL",
    "description": "Determines whether an expression is NULL or is not NULL.",
    "syntax": "<expr> IS [ NOT ] NULL",
    "example": "CREATE OR REPLACE TABLE test_is_not_null (id NUMBER, col1 NUMBER, col2 NUMBER);\nINSERT INTO test_is_not_null (id, col1, col2) VALUES \n  (1, 0, 5), \n  (2, 0, NULL), \n  (3, NULL, 5), \n  (4, NULL, NULL);\n\nSELECT * \n  FROM test_is_not_null\n  ORDER BY id;\n\n+----+------+------+\n| ID | COL1 | COL2 |\n|----+------+------|\n|  1 |    0 |    5 |\n|  2 |    0 | NULL |\n|  3 | NULL |    5 |\n|  4 | NULL | NULL |\n+----+------+------+\n\nSELECT * \n  FROM test_is_not_null \n  WHERE col1 IS NOT NULL\n  ORDER BY id;\n\n+----+------+------+\n| ID | COL1 | COL2 |\n|----+------+------|\n|  1 |    0 |    5 |\n|  2 |    0 | NULL |\n+----+------+------+\n\nSELECT * \n  FROM test_is_not_null \n  WHERE col2 IS NULL\n  ORDER BY id;\n\n+----+------+------+\n| ID | COL1 | COL2 |\n|----+------+------|\n|  2 |    0 | NULL |\n|  4 | NULL | NULL |\n+----+------+------+\n\nSELECT * \n  FROM test_is_not_null \n  WHERE col1 IS NOT NULL OR col2 IS NULL\n  ORDER BY id;\n\n+----+------+------+\n| ID | COL1 | COL2 |\n|----+------+------|\n|  1 |    0 |    5 |\n|  2 |    0 | NULL |\n|  4 | NULL | NULL |\n+----+------+------+\n\nSELECT *\n  FROM test_is_not_null\n  WHERE col1 IS NOT NULL AND col2 IS NULL\n  ORDER BY id;\n\n+----+------+------+\n| ID | COL1 | COL2 |\n|----+------+------|\n|  2 |    0 | NULL |\n+----+------+------+",
    "returns": "Returns a BOOLEAN."
},
{
    "function_name": "IS [ NOT ] DISTINCT FROM",
    "summary": "Compares whether two expressions are equal (or not equal).",
    "category": "Conditional expression functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/is-distinct-from",
    "title": "IS [ NOT ] DISTINCT FROM",
    "description": "Compares whether two expressions are equal (or not equal). The function is NULL-safe, meaning it treats NULLs as known values for comparing equality. Note that this is different from the EQUAL",
    "syntax": "<expr1> IS [ NOT ] DISTINCT FROM <expr2>",
    "example": "CREATE OR REPLACE TABLE x (i number);\nINSERT INTO x values\n    (1), \n    (2), \n    (null);\n\nSELECT x1.i x1_i, x2.i x2_i \n    FROM x x1, x x2\n    ORDER BY x1.i, x2.i;\n+------+------+\n| X1_I | X2_I |\n|------+------|\n|    1 |    1 |\n|    1 |    2 |\n|    1 | NULL |\n|    2 |    1 |\n|    2 |    2 |\n|    2 | NULL |\n| NULL |    1 |\n| NULL |    2 |\n| NULL | NULL |\n+------+------+\n\nSELECT x1.i x1_i, x2.i x2_i \n    FROM x x1, x x2 \n    WHERE x1.i=x2.i;\n+------+------+\n| X1_I | X2_I |\n|------+------|\n|    1 |    1 |\n|    2 |    2 |\n+------+------+\n\nSELECT x1.i x1_i, x2.i x2_i \n    FROM x x1, x x2 \n    WHERE x1.i IS NOT DISTINCT FROM x2.i\n    ORDER BY x1.i;\n+------+------+\n| X1_I | X2_I |\n|------+------|\n|    1 |    1 |\n|    2 |    2 |\n| NULL | NULL |\n+------+------+\n\nSELECT x1.i x1_i, \n       x2.i x2_i,\n       x1.i=x2.i, \n       iff(x1.i=x2.i, 'Selected', 'Not') \"SELECT IF X1.I=X2.I\",\n       x1.i<>x2.i, \n       iff(not(x1.i=x2.i), 'Selected', 'Not') \"SELECT IF X1.I<>X2.I\"\n    FROM x x1, x x2;\n+------+------+-----------+---------------------+------------+----------------------+\n| X1_I | X2_I | X1.I=X2.I | SELECT IF X1.I=X2.I | X1.I<>X2.I | SELECT IF X1.I<>X2.I |\n|------+------+-----------+---------------------+------------+----------------------|\n|    1 |    1 | True      | Selected            | False      | Not                  |\n|    1 |    2 | False     | Not                 | True       | Selected             |\n|    1 | NULL | NULL      | Not                 | NULL       | Not                  |\n|    2 |    1 | False     | Not                 | True       | Selected             |\n|    2 |    2 | True      | Selected            | False      | Not                  |\n|    2 | NULL | NULL      | Not                 | NULL       | Not                  |\n| NULL |    1 | NULL      | Not                 | NULL       | Not                  |\n| NULL |    2 | NULL      | Not                 | NULL       | Not                  |\n| NULL | NULL | NULL      | Not                 | NULL       | Not                  |\n+------+------+-----------+---------------------+------------+----------------------+\n\nSELECT x1.i x1_i, x2.i x2_i,\n               x1.i IS NOT DISTINCT FROM x2.i, iff(x1.i IS NOT DISTINCT FROM x2.i, 'Selected', 'Not') \"SELECT IF X1.I IS NOT DISTINCT FROM X2.I\",\n               x1.i IS DISTINCT FROM x2.i, iff(x1.i IS DISTINCT FROM x2.i, 'Selected', 'Not') \"SELECT IF X1.I IS DISTINCT FROM X2.I\"\n        FROM x x1, x x2\n        ORDER BY x1.i, x2.i;\n+------+------+--------------------------------+------------------------------------------+----------------------------+--------------------------------------+\n| X1_I | X2_I | X1.I IS NOT DISTINCT FROM X2.I | SELECT IF X1.I IS NOT DISTINCT FROM X2.I | X1.I IS DISTINCT FROM X2.I | SELECT IF X1.I IS DISTINCT FROM X2.I |\n|------+------+--------------------------------+------------------------------------------+----------------------------+--------------------------------------|\n|    1 |    1 | True                           | Selected                                 | False                      | Not                                  |\n|    1 |    2 | False                          | Not                                      | True                       | Selected                             |\n|    1 | NULL | False                          | Not                                      | True                       | Selected                             |\n|    2 |    1 | False                          | Not                                      | True                       | Selected                             |\n|    2 |    2 | True                           | Selected                                 | False                      | Not                                  |\n|    2 | NULL | False                          | Not                                      | True                       | Selected                             |\n| NULL |    1 | False                          | Not                                      | True                       | Selected                             |\n| NULL |    2 | False                          | Not                                      | True                       | Selected                             |\n| NULL | NULL | True                           | Selected                                 | False                      | Not                                  |\n+------+------+--------------------------------+------------------------------------------+----------------------------+--------------------------------------+"
},
{
    "function_name": "INVOKER_SHARE",
    "summary": "Returns the name of the share that directly accessed the table or view where the INVOKER_SHARE function is invoked, otherwise the function returns NULL.",
    "category": "Context functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/invoker_share",
    "title": "INVOKER_SHARE",
    "description": "Returns the name of the share that directly accessed the table or view where the INVOKER_SHARE function is invoked, otherwise the function returns NULL.",
    "syntax": "INVOKER_SHARE()",
    "example": "create or replace masking policy mask_share\nas (val string) returns string ->\ncase\n  when invoker_share() in ('SHARE1') then mask1_function(val)\n  when invoker_share() in ('SHARE2') then mask2_function(val)\n  else '***MASKED***'\nend;"
},
{
    "function_name": "INVOKER_ROLE",
    "summary": "Returns the name of the account-level role of the object executing the query or NULL if the name of the role is a database role.",
    "category": "Context functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/invoker_role",
    "title": "INVOKER_ROLE",
    "description": "Returns the name of the account-level role of the object executing the query or NULL if the name of the role is a database role.",
    "syntax": "INVOKER_ROLE()",
    "example": "CREATE OR REPLACE MASKING POLICY mask_string AS\n(val string) RETURNS string ->\nCASE\n  WHEN INVOKER_ROLE() IN ('ANALYST') THEN val\n  ELSE NULL\nEND;\n\nCREATE OR REPLACE MASKING POLICY mask_string AS\n(val string) RETURNS string ->\nCASE\n  WHEN INVOKER_ROLE() IN ('ANALYST') THEN val\n  ELSE '********'\nEND;\n\nCREATE OR REPLACE MASKING POLICY mask_string AS\n(val string) RETURNS string ->\nCASE\n  WHEN INVOKER_ROLE() IN ('ANALYST') THEN val\n  ELSE SHA2(val)\nEND;"
},
{
    "function_name": "INTEGRATION",
    "summary": "Returns a JSON object that specifies the notification integration to use to send a message.",
    "category": "Notification functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/integration",
    "title": "INTEGRATION",
    "description": "Returns a JSON object that specifies the notification integration to use to send a message. This is a helper function that you\nuse to construct an integration configuration object for the",
    "syntax": "SNOWFLAKE.NOTIFICATION.INTEGRATION( '<integration_name>' )",
    "arguments": [
        {
            "name": "'",
            "description": "Name of the notification integration to use."
        }
    ],
    "returns": "A JSON-formatted string that specifies a notification integration for the\nSYSTEM$SEND_SNOWFLAKE_NOTIFICATION stored procedure to send."
},
{
    "function_name": "INSERT",
    "summary": "Replaces a substring of the specified length, starting at the specified position, with a new string or binary value.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/insert",
    "title": "INSERT",
    "description": "Replaces a substring of the specified length, starting at the specified\nposition, with a new string or binary value.",
    "syntax": "INSERT( <base_expr>, <pos>, <len>, <insert_expr> )",
    "example": "SELECT INSERT('abc', 1, 2, 'Z') as STR;\n+-----+\n| STR |\n|-----|\n| Zc  |\n+-----+\n\nSELECT INSERT('abcdef', 3, 2, 'zzz') as STR;\n+---------+\n| STR     |\n|---------|\n| abzzzef |\n+---------+\n\nSELECT INSERT('abc', 2, 1, '') as STR;\n+-----+\n| STR |\n|-----|\n| ac  |\n+-----+\n\nSELECT INSERT('abc', 4, 0, 'Z') as STR;\n+------+\n| STR  |\n|------|\n| abcZ |\n+------+\n\nSELECT INSERT(NULL, 1, 2, 'Z') as STR;\n+------+\n| STR  |\n|------|\n| NULL |\n+------+\n\nSELECT INSERT('abc', NULL, 2, 'Z') as STR;\n+------+\n| STR  |\n|------|\n| NULL |\n+------+\n\nSELECT INSERT('abc', 1, NULL, 'Z') as STR;\n+------+\n| STR  |\n|------|\n| NULL |\n+------+\n\nSELECT INSERT('abc', 1, 2, NULL) as STR;\n+------+\n| STR  |\n|------|\n| NULL |\n+------+",
    "arguments": [
        {
            "name": "base_expr",
            "description": "The string or BINARY expression for which you want to insert/replace\ncharacters."
        },
        {
            "name": "pos",
            "description": "The offset at which to start inserting characters. This is 1-based,\nnot 0-based. In other words, the first character in the string is\nconsidered to be at position 1, not position 0. For example, to insert\nat the beginning of the string, set pos to 1. Valid values are between 1 and one more than the length of the string\n(inclusive). Setting pos to one more than the length of the string\nmakes the operation equivalent to an append. (This also requires that the len parameter be 0 because you should not try to delete any\ncharacters past the last character.)"
        },
        {
            "name": "len",
            "description": "The number of characters (starting at pos ) that you want\nto replace. Valid values range from 0 to the number of characters between pos and the end of the string. If this is 0, it means add the\nnew characters without deleting any existing characters."
        },
        {
            "name": "insert_expr",
            "description": "The string to insert into the base_expr . If this string\nis empty, and if len is greater than zero, then effectively the\noperation becomes a delete (some characters are deleted, and none are added)."
        }
    ],
    "returns": "Returns a string or BINARY that is equivalent to making a copy of\nbase_expr, deleting len characters starting at\npos, and then inserting insert_expr at pos."
},
{
    "function_name": "INITCAP",
    "summary": "Returns the input string with the first letter of each word in uppercase and the subsequent letters in lowercase.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/initcap",
    "title": "INITCAP",
    "description": "Returns the input string with the first letter of each word in uppercase and the subsequent letters in lowercase.",
    "syntax": "INITCAP( <expr> [ , '<delimiters>' ] )",
    "example": "SELECT v, INITCAP(v) FROM testinit;\n\n+---------------------------------+---------------------------------+\n| C1                              | INITCAP(C1)                     |\n|---------------------------------+---------------------------------|\n| The Quick Gray Fox              | The Quick Gray Fox              |\n| the sky is blue                 | The Sky Is Blue                 |\n| OVER the River 2 Times          | Over The River 2 Times          |\n| WE CAN HANDLE THIS              | We Can Handle This              |\n| HelL0_hi+therE                  | Hell0_Hi+There                  |\n| νησί του ποταμού                | Νησί Του Ποταμού                |\n| ÄäÖößÜü                         | Ääöößüü                         |\n| Hi,are?you!there                | Hi,Are?You!There                |\n| to je dobré                     | To Je Dobré                     |\n| ÉéÀàè]çÂâ ÊêÎÔô ÛûËÏ ïÜŸÇç ŒœÆæ | Ééààè]Çââ Êêîôô Ûûëï Ïüÿçç Œœææ |\n| ĄąĆ ćĘęŁ łŃńÓ óŚśŹźŻż           | Ąąć Ćęęł Łńńó Óśśźźżż           |\n| АаБб ВвГгД дЕеЁёЖ жЗзИиЙй       | Аабб Ввггд Дееёёж Жззиийй       |\n| ХхЦц ЧчШш ЩщЪъ ЫыЬь ЭэЮ юЯя     | Ххцц Ччшш Щщъъ Ыыьь Ээю Юяя     |\n| NULL                            | NULL                            |\n+---------------------------------+---------------------------------+\n\nSELECT INITCAP('this is the new Frame+work', '') AS initcap_result;\n\n+----------------------------+\n| INITCAP_RESULT             |\n|----------------------------|\n| This is the new frame+work |\n+----------------------------+\n\nSELECT INITCAP('iqamqinterestedqinqthisqtopic','q') AS initcap_result;\n\n+-------------------------------+\n| INITCAP_RESULT                |\n|-------------------------------|\n| IqAmqInterestedqInqThisqTopic |\n+-------------------------------+\n\nSELECT INITCAP('lion☂fRog potato⨊cLoUD', '⨊☂') AS initcap_result;\n\n+------------------------+\n| INITCAP_RESULT         |\n|------------------------|\n| Lion☂Frog potato⨊Cloud |\n+------------------------+\n\nSELECT INITCAP('apple is僉sweetandballIsROUND', '僉a b') AS initcap_result;\n\n+-------------------------------+\n| INITCAP_RESULT                |\n|-------------------------------|\n| aPple Is僉SweetaNdbaLlisround |\n+-------------------------------+",
    "arguments": [
        {
            "name": "expr",
            "description": "The string expression."
        },
        {
            "name": "'",
            "description": "A string of one or more characters that INITCAP uses as separators for words in the input expression: If delimiters isn’t specified, any of the following characters in the input expressions are\ntreated as word separators: If delimiters is specified, the specified value overrides all of the characters listed above. Supports any UTF-8 characters, including whitespace characters, and is case-sensitive. Must be enclosed in single quotes, for example ', ' (delimiters in this example are , and blank spaces). When specified as an empty string (that is, '' ), INITCAP ignores all delimiters, including whitespace characters,\nin the input expression. The input expression is treated as a single, continuous word. The resulting output is\na string with the first character capitalized (if the first character is a letter) and all other letters in lowercase."
        }
    ],
    "returns": "This function returns a value of type VARCHAR."
},
{
    "function_name": "INFER_SCHEMA",
    "summary": "Automatically detects the file metadata schema in a set of staged data files that contain semi-structured data and retrieves the column definitions.",
    "category": "Table functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/infer_schema",
    "title": "INFER_SCHEMA",
    "description": "Automatically detects the file metadata schema in a set of staged data files that contain semi-structured data and retrieves the column\ndefinitions.",
    "syntax": "INFER_SCHEMA(\n  LOCATION => '{ internalStage | externalStage }'\n  , FILE_FORMAT => '<file_format_name>'\n  , FILES => ( '<file_name>' [ , '<file_name>' ] [ , ... ] )\n  , IGNORE_CASE => TRUE | FALSE\n  , MAX_FILE_COUNT => <num>\n  , MAX_RECORDS_PER_FILE => <num>\n  , KIND => '<kind_name>'\n)",
    "example": "-- Create a file format that sets the file type as Parquet.\nCREATE FILE FORMAT my_parquet_format\n  TYPE = parquet;\n\n-- Query the INFER_SCHEMA function.\nSELECT *\n  FROM TABLE(\n    INFER_SCHEMA(\n      LOCATION=>'@mystage'\n      , FILE_FORMAT=>'my_parquet_format'\n      )\n    );\n\n+-------------+---------+----------+---------------------+--------------------------+----------+\n| COLUMN_NAME | TYPE    | NULLABLE | EXPRESSION          | FILENAMES                | ORDER_ID |\n|-------------+---------+----------+---------------------+--------------------------|----------+\n| continent   | TEXT    | True     | $1:continent::TEXT  | geography/cities.parquet | 0        |\n| country     | VARIANT | True     | $1:country::VARIANT | geography/cities.parquet | 1        |\n| COUNTRY     | VARIANT | True     | $1:COUNTRY::VARIANT | geography/cities.parquet | 2        |\n+-------------+---------+----------+---------------------+--------------------------+----------+\n\n-- Query the INFER_SCHEMA function.\nSELECT *\n  FROM TABLE(\n    INFER_SCHEMA(\n      LOCATION=>'@mystage/geography/cities.parquet'\n      , FILE_FORMAT=>'my_parquet_format'\n      )\n    );\n\n+-------------+---------+----------+---------------------+--------------------------+----------+\n| COLUMN_NAME | TYPE    | NULLABLE | EXPRESSION          | FILENAMES                | ORDER_ID |\n|-------------+---------+----------+---------------------+--------------------------|----------+\n| continent   | TEXT    | True     | $1:continent::TEXT  | geography/cities.parquet | 0        |\n| country     | VARIANT | True     | $1:country::VARIANT | geography/cities.parquet | 1        |\n| COUNTRY     | VARIANT | True     | $1:COUNTRY::VARIANT | geography/cities.parquet | 2        |\n+-------------+---------+----------+---------------------+--------------------------+----------+\n\n-- Query the INFER_SCHEMA function.\nSELECT *\n  FROM TABLE(\n    INFER_SCHEMA(\n      LOCATION=>'@mystage'\n      , FILE_FORMAT=>'my_parquet_format'\n      , IGNORE_CASE=>TRUE\n      )\n    );\n\n+-------------+---------+----------+----------------------------------------+--------------------------+----------+\n| COLUMN_NAME | TYPE    | NULLABLE | EXPRESSION                             | FILENAMES                | ORDER_ID |\n|-------------+---------+----------+---------------------+---------------------------------------------|----------+\n| CONTINENT   | TEXT    | True     | GET_IGNORE_CASE ($1, CONTINENT)::TEXT  | geography/cities.parquet | 0        |\n| COUNTRY     | VARIANT | True     | GET_IGNORE_CASE ($1, COUNTRY)::VARIANT | geography/cities.parquet | 1        |\n+-------------+---------+----------+---------------------+---------------------------------------------+----------+\n\n-- Create a file format that sets the file type as JSON.\nCREATE FILE FORMAT my_json_format\n  TYPE = json;\n\n-- Query the INFER_SCHEMA function.\nSELECT *\n  FROM TABLE(\n    INFER_SCHEMA(\n      LOCATION=>'@mystage/json/'\n      , FILE_FORMAT=>'my_json_format'\n      )\n    );\n\n+-------------+---------------+----------+---------------------------+--------------------------+----------+\n| COLUMN_NAME | TYPE          | NULLABLE | EXPRESSION                | FILENAMES                | ORDER_ID |\n|-------------+---------------+----------+---------------------------+--------------------------|----------+\n| col_bool    | BOOLEAN       | True     | $1:col_bool::BOOLEAN      | json/schema_A_1.json     | 0        |\n| col_date    | DATE          | True     | $1:col_date::DATE         | json/schema_A_1.json     | 1        |\n| col_ts      | TIMESTAMP_NTZ | True     | $1:col_ts::TIMESTAMP_NTZ  | json/schema_A_1.json     | 2        |\n+-------------+---------------+----------+---------------------------+--------------------------+----------+\n\nCREATE TABLE mytable\n  USING TEMPLATE (\n    SELECT ARRAY_AGG(OBJECT_CONSTRUCT(*))\n      FROM TABLE(\n        INFER_SCHEMA(\n          LOCATION=>'@mystage/json/',\n          FILE_FORMAT=>'my_json_format'\n        )\n      ));\n\n-- Create a file format that sets the file type as CSV.\nCREATE FILE FORMAT my_csv_format\n  TYPE = csv\n  PARSE_HEADER = true;\n\n-- Query the INFER_SCHEMA function.\nSELECT *\n  FROM TABLE(\n    INFER_SCHEMA(\n      LOCATION=>'@mystage/csv/'\n      , FILE_FORMAT=>'my_csv_format'\n      )\n    );\n\n+-------------+---------------+----------+---------------------------+--------------------------+----------+\n| COLUMN_NAME | TYPE          | NULLABLE | EXPRESSION                | FILENAMES                | ORDER_ID |\n|-------------+---------------+----------+---------------------------+--------------------------|----------+\n| col_bool    | BOOLEAN       | True     | $1:col_bool::BOOLEAN      | json/schema_A_1.csv      | 0        |\n| col_date    | DATE          | True     | $1:col_date::DATE         | json/schema_A_1.csv      | 1        |\n| col_ts      | TIMESTAMP_NTZ | True     | $1:col_ts::TIMESTAMP_NTZ  | json/schema_A_1.csv      | 2        |\n+-------------+---------------+----------+---------------------------+--------------------------+----------+\n\n-- Load the CSV file using MATCH_BY_COLUMN_NAME.\nCOPY INTO mytable FROM @mystage/csv/\n  FILE_FORMAT = (\n    FORMAT_NAME= 'my_csv_format'\n  )\n  MATCH_BY_COLUMN_NAME=CASE_INSENSITIVE;\n\n-- Create a file format that sets the file type as Parquet.\n  CREATE OR REPLACE FILE FORMAT my_parquet_format\n    TYPE = PARQUET\n    USE_VECTORIZED_SCANNER = TRUE;\n\n-- Query the INFER_SCHEMA function.\nSELECT *\nFROM TABLE(\n  INFER_SCHEMA(\n    LOCATION=>'@mystage'\n    , FILE_FORMAT=>'my_parquet_format'\n    , KIND => 'ICEBERG'\n    )\n  );\n\n+-------------+---------+----------+---------------------+--------------------------+----------+\n| COLUMN_NAME | TYPE    | NULLABLE | EXPRESSION          | FILENAMES                | ORDER_ID |\n|-------------+---------+----------+---------------------+--------------------------|----------+\n| id          | INT     | False    | $1:id::INT          | sales/customers.parquet   | 0       |\n| custnum     | INT     | False    | $1:custnum::INT     | sales/customers.parquet   | 1       |\n+-------------+---------+----------+---------------------+--------------------------+----------+\n\n-- Create a file format that sets the file type as Parquet.\n CREATE OR REPLACE FILE FORMAT my_parquet_format\n   TYPE = PARQUET\n   USE_VECTORIZED_SCANNER = TRUE;\n\n-- Create an Iceberg table.\nCREATE ICEBERG TABLE myicebergtable\n  USING TEMPLATE (\n    SELECT ARRAY_AGG(OBJECT_CONSTRUCT(*))\n    WITHIN GROUP (ORDER BY order_id)\n      FROM TABLE(\n        INFER_SCHEMA(\n          LOCATION=>'@mystage',\n          FILE_FORMAT=>'my_parquet_format',\n          KIND => 'ICEBERG'\n        )\n      ))\n... {rest of the ICEBERG options}\n;",
    "arguments": [
        {
            "name": "LOCATION",
            "description": "Name of the internal or external stage where the files are stored. Optionally include a path to one or more files in the cloud storage\nlocation; otherwise, the INFER_SCHEMA function scans files in all subdirectories in the stage: @[ namespace .] int_stage_name [/ path ][/ filename ] Files are in the specified named internal stage. @[ namespace .] ext_stage_name [/ path ][/ filename ] Files are in the specified named external stage. @~[/ path ][/ filename ] Files are in the stage for the current user. Note This SQL function supports named stages (internal or external) and user stages only. It does not support table stages."
        },
        {
            "name": "FILES",
            "description": "Specifies a list of one or more files (separated by commas) in a set of staged files that contain semi-structured data.  The files must already have been staged in either the Snowflake internal location or external location specified in the command. If any of the specified files cannot be found, the query will be aborted. The maximum number of files names that can be specified is 1000. Note For external stages only (Amazon S3, Google Cloud Storage, or Microsoft Azure), the file path is set by concatenating the URL in the stage definition and the list of resolved file names. However, Snowflake doesn’t insert a separator implicitly between the path and file names. You must explicitly include a separator ( / ) either at the end of the URL in the stage\ndefinition or at the beginning of each file name specified in this parameter."
        },
        {
            "name": "FILE_FORMAT",
            "description": "Name of the file format object that describes the data contained in the staged files. For more information, see CREATE FILE FORMAT ."
        },
        {
            "name": "IGNORE_CASE",
            "description": "Specifies whether column names detected from stage files are treated as case sensitive. By default, the value is FALSE, which means that Snowflake preserves the case of alphabetic characters when retrieving column names. If you specify the value as TRUE, column names are treated as case-insensitive and all column names are retrieved as uppercase letters."
        },
        {
            "name": "MAX_FILE_COUNT",
            "description": "Specifies the maximum number of files scanned from stage. This option is recommended for large number of files that have identical schema across files. This option cannot determine which files are scanned. If you want to scan specific files, use the FILES option instead."
        },
        {
            "name": "MAX_RECORDS_PER_FILE",
            "description": "Specifies the maximum number of records scanned per file. This option only applies to CSV and JSON files. We recommend that you use this option for large files. This option might affect the accuracy of schema detection."
        },
        {
            "name": "KIND",
            "description": "Specifies the kind of file metadata schema that can be scanned from the stage. By default, the value is STANDARD , which means that\nthe file metadata schema that can be scanned from the stage is for Snowflake tables and the output is Snowflake data types. If you specify\nthe value as ICEBERG , the schema is for Apache Iceberg tables and the output is Iceberg data types. Note If you’re inferring Parquet files to create Iceberg tables, we strongly recommend that you set KIND => 'ICEBERG' . Otherwise, the\ncolumn definitions returned by the function might be incorrect."
        }
    ]
},
{
    "function_name": "[ NOT ] IN",
    "summary": "Tests whether its argument is or is not one of the members of an explicit list or the result of a subquery.",
    "category": "Conditional expression functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/in",
    "title": "[ NOT ] IN",
    "description": "Tests whether its argument is or is not one of the members of an explicit list or the result of a subquery.",
    "syntax": "<value> [ NOT ] IN ( <value_1> [ , <value_2> ...  ] )",
    "example": "SELECT 1 IN (1, 2, 3) AS RESULT;\n\n+--------+\n| RESULT |\n|--------|\n| True   |\n+--------+\n\nSELECT 4 NOT IN (1, 2, 3) AS RESULT;\n\n+--------+\n| RESULT |\n|--------|\n| True   |\n+--------+\n\nSELECT 'a' IN (\n  SELECT column1 FROM VALUES ('b'), ('c'), ('d')\n  ) AS RESULT;\n\n+--------+\n| RESULT |\n|--------|\n| False  |\n+--------+\n\nCREATE OR REPLACE TABLE in_function_demo (\n  col_1 INTEGER,\n  col_2 INTEGER,\n  col_3 INTEGER);\n\nINSERT INTO in_function_demo (col_1, col_2, col_3) VALUES\n  (1, 1, 1),\n  (1, 2, 3),\n  (4, 5, NULL);\n\nSELECT col_1, col_2, col_3\n  FROM in_function_demo\n  WHERE (col_1) IN (1, 10, 100, 1000)\n  ORDER BY col_1, col_2, col_3;\n\n+-------+-------+-------+\n| COL_1 | COL_2 | COL_3 |\n|-------+-------+-------|\n|     1 |     1 |     1 |\n|     1 |     2 |     3 |\n+-------+-------+-------+\n\nSELECT col_1, col_2, col_3\n  FROM in_function_demo\n  WHERE (col_1, col_2, col_3) IN (\n    (1,2,3),\n    (4,5,6));\n\n+-------+-------+-------+\n| COL_1 | COL_2 | COL_3 |\n|-------+-------+-------|\n|     1 |     2 |     3 |\n+-------+-------+-------+\n\nSELECT (1, 2, 3) IN (\n  SELECT col_1, col_2, col_3 FROM in_function_demo\n  ) AS RESULT;\n\n+--------+\n| RESULT |\n|--------|\n| True   |\n+--------+\n\nSELECT NULL IN (1, 2, NULL) AS RESULT;\n\n+--------+\n| RESULT |\n|--------|\n| NULL   |\n+--------+\n\nSELECT (4, 5, NULL) IN ( (4, 5, NULL), (7, 8, 9) ) AS RESULT;\n\n+--------+\n| RESULT |\n|--------|\n| NULL   |\n+--------+"
},
{
    "function_name": "ILIKE ANY",
    "summary": "Performs a case-insensitive comparison to match a string against any of one or more specified patterns.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/ilike_any",
    "title": "ILIKE ANY",
    "description": "Performs a case-insensitive comparison to match a string against any of one or more specified patterns.\nUse this function in a WHERE clause to filter for matches. For case-sensitive matching, use LIKE ANY\ninstead.",
    "syntax": "<subject> ILIKE ANY (<pattern1> [, <pattern2> ... ] ) [ ESCAPE <escape_char> ]",
    "example": "CREATE OR REPLACE TABLE ilike_example(name VARCHAR(20));\nINSERT INTO ilike_example VALUES\n    ('jane doe'),\n    ('Jane Doe'),\n    ('JANE DOE'),\n    ('John Doe'),\n    ('John Smith');\n\nSELECT * \n  FROM ilike_example \n  WHERE name ILIKE ANY ('jane%', '%SMITH')\n  ORDER BY name;\n\n+------------+                                                                  \n| NAME       |\n|------------|\n| JANE DOE   |\n| Jane Doe   |\n| John Smith |\n| jane doe   |\n+------------+",
    "arguments": [
        {
            "name": "subject",
            "description": "The string to compare to the pattern(s)."
        },
        {
            "name": "pattern#",
            "description": "The pattern(s) that the string is to be compared to. You must specify at least one pattern."
        },
        {
            "name": "escape_char",
            "description": "Character(s) inserted in front of a wildcard character to indicate that the wildcard should\nbe interpreted as a regular character rather than as a wildcard."
        }
    ],
    "returns": "Returns a BOOLEAN or NULL. The value is TRUE if there is a match. Otherwise, returns FALSE. Returns NULL if any argument is NULL."
},
{
    "function_name": "[ NOT ] ILIKE",
    "summary": "Performs a case-insensitive comparison to determine whether a string matches or does not match a specified pattern.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/ilike",
    "title": "[ NOT ] ILIKE",
    "description": "Performs a case-insensitive comparison to determine whether a string matches or does not match a specified pattern.\nFor case-sensitive matching, use LIKE instead.",
    "syntax": "<subject> [ NOT ] ILIKE <pattern> [ ESCAPE <escape> ]\n\nILIKE( <subject> , <pattern> [ , <escape> ] )",
    "example": "CREATE OR REPLACE TABLE ilike_ex(name VARCHAR(20));\nINSERT INTO ilike_ex VALUES\n  ('John  Dddoe'),\n  ('Joe   Doe'),\n  ('John_down'),\n  ('Joe down'),\n  (null);\n\nSELECT * \n  FROM ilike_ex \n  WHERE name ILIKE '%j%h%do%'\n  ORDER BY 1;\n\n+-------------+                                                                 \n| NAME        |\n|-------------|\n| John  Dddoe |\n| John_down   |\n+-------------+\n\nSELECT *\n  FROM ilike_ex\n  WHERE name NOT ILIKE '%j%h%do%'\n  ORDER BY 1;\n\n+-----------+\n| NAME      |\n|-----------|\n| Joe   Doe |\n| Joe down  |\n+-----------+\n\nSELECT * \n  FROM ilike_ex \n  WHERE name ILIKE '%j%h%^_do%' ESCAPE '^'\n  ORDER BY 1;\n\n+-----------+                                                                   \n| NAME      |\n|-----------|\n| John_down |\n+-----------+",
    "arguments": [
        {
            "name": "subject",
            "description": "Subject to match."
        },
        {
            "name": "pattern",
            "description": "Pattern to match."
        },
        {
            "name": "escape",
            "description": "Character(s) inserted in front of a wildcard character to indicate that the wildcard should\nbe interpreted as a regular character and not as a wildcard."
        }
    ],
    "returns": "Returns a BOOLEAN or NULL."
},
{
    "function_name": "IFNULL",
    "summary": "If expr1 is NULL, returns expr2, otherwise returns expr1.",
    "category": "Conditional expression functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/ifnull",
    "title": "IFNULL",
    "description": "If",
    "syntax": "IFNULL( <expr1> , <expr2> )",
    "example": "CREATE TABLE IF NOT EXISTS suppliers (\n  supplier_id INT PRIMARY KEY,\n  supplier_name VARCHAR(30),\n  phone_region_1 VARCHAR(15),\n  phone_region_2 VARCHAR(15));\n\nINSERT INTO suppliers(supplier_id, supplier_name, phone_region_1, phone_region_2)\n  VALUES(1, 'Company_ABC', NULL, '555-01111'),\n        (2, 'Company_DEF', '555-01222', NULL),\n        (3, 'Company_HIJ', '555-01333', '555-01444'),\n        (4, 'Company_KLM', NULL, NULL);\n\nSELECT supplier_id,\n       supplier_name,\n       phone_region_1,\n       phone_region_2,\n       IFNULL(phone_region_1, phone_region_2) IF_REGION_1_NULL,\n       IFNULL(phone_region_2, phone_region_1) IF_REGION_2_NULL\n  FROM suppliers\n  ORDER BY supplier_id;\n\n+-------------+---------------+----------------+----------------+------------------+------------------+\n| SUPPLIER_ID | SUPPLIER_NAME | PHONE_REGION_1 | PHONE_REGION_2 | IF_REGION_1_NULL | IF_REGION_2_NULL |\n|-------------+---------------+----------------+----------------+------------------+------------------|\n|           1 | Company_ABC   | NULL           | 555-01111      | 555-01111        | 555-01111        |\n|           2 | Company_DEF   | 555-01222      | NULL           | 555-01222        | 555-01222        |\n|           3 | Company_HIJ   | 555-01333      | 555-01444      | 555-01333        | 555-01444        |\n|           4 | Company_KLM   | NULL           | NULL           | NULL             | NULL             |\n+-------------+---------------+----------------+----------------+------------------+------------------+",
    "arguments": [
        {
            "name": "expr1",
            "description": "A general expression."
        },
        {
            "name": "expr2",
            "description": "A general expression."
        }
    ],
    "returns": "Returns the data type of the returned expression."
},
{
    "function_name": "IFF",
    "summary": "Returns one of two values depending on whether a Boolean expression evaluates to true or false.",
    "category": "Conditional expression functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/iff",
    "title": "IFF",
    "description": "Returns one of two values depending on whether a Boolean expression evaluates to true or false.\nThis function is similar to a single-level",
    "syntax": "IFF( <condition> , <expr1> , <expr2> )",
    "example": "SELECT IFF(TRUE, 'true', 'false');\n\n+----------------------------+\n| IFF(TRUE, 'TRUE', 'FALSE') |\n|----------------------------|\n| true                       |\n+----------------------------+\n\nSELECT IFF(FALSE, 'true', 'false');\n\n+-----------------------------+\n| IFF(FALSE, 'TRUE', 'FALSE') |\n|-----------------------------|\n| false                       |\n+-----------------------------+\n\nSELECT IFF(NULL, 'true', 'false');\n\n+----------------------------+\n| IFF(NULL, 'TRUE', 'FALSE') |\n|----------------------------|\n| false                      |\n+----------------------------+\n\nSELECT IFF(TRUE, NULL, 'false');\n\n+--------------------------+\n| IFF(TRUE, NULL, 'FALSE') |\n|--------------------------|\n| NULL                     |\n+--------------------------+\n\nSELECT value, IFF(value::INT = value, 'integer', 'non-integer')\n  FROM ( SELECT column1 AS value\n           FROM VALUES(1.0), (1.1), (-3.1415), (-5.000), (NULL) )\n  ORDER BY value DESC;\n\n+---------+---------------------------------------------------+\n|   VALUE | IFF(VALUE::INT = VALUE, 'INTEGER', 'NON-INTEGER') |\n|---------+---------------------------------------------------|\n|    NULL | non-integer                                       |\n|  1.1000 | non-integer                                       |\n|  1.0000 | integer                                           |\n| -3.1415 | non-integer                                       |\n| -5.0000 | integer                                           |\n+---------+---------------------------------------------------+\n\nSELECT value, IFF(value > 50, 'High', 'Low')\nFROM ( SELECT column1 AS value\n         FROM VALUES(22), (63), (5), (99), (NULL) );\n\n+-------+--------------------------------+\n| VALUE | IFF(VALUE > 50, 'HIGH', 'LOW') |\n|-------+--------------------------------|\n|    22 | Low                            |\n|    63 | High                           |\n|     5 | Low                            |\n|    99 | High                           |\n|  NULL | Low                            |\n+-------+--------------------------------+",
    "arguments": [
        {
            "name": "condition",
            "description": "The condition is an expression that should evaluate to a BOOLEAN value\n(TRUE, FALSE, or NULL). If condition evaluates to TRUE, returns expr1 , otherwise\nreturns expr2 ."
        },
        {
            "name": "expr1",
            "description": "A general expression. The function returns this value if the condition is true."
        },
        {
            "name": "expr2",
            "description": "A general expression. The function returns this value if the condition is not true (that is, if it is false or NULL)."
        }
    ],
    "returns": "This function can return a value of any type. The function can return NULL if the value of the\nexpression that is returned is NULL."
},
{
    "function_name": "ICEBERG_TABLE_SNAPSHOT_REFRESH_HISTORY",
    "summary": "Returns metadata and snapshot information about the most recent refresh history for a specified externally managed",
    "category": "iceberg-tm",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/iceberg_table_snapshot_refresh_history",
    "title": "ICEBERG_TABLE_SNAPSHOT_REFRESH_HISTORY",
    "description": "Returns metadata and",
    "syntax": "ICEBERG_TABLE_SNAPSHOT_REFRESH_HISTORY(\n  TABLE_NAME => '<table_name>'\n)",
    "example": "SELECT *\n  FROM TABLE(INFORMATION_SCHEMA.ICEBERG_TABLE_SNAPSHOT_REFRESH_HISTORY(\n    TABLE_NAME => 'my_iceberg_table'\n  ));\n\n+-------------------------------+----------------------------------------------------------------------------------+---------------------+-----------------+-------------------+--------------------------------------+---------------------+---------------------------------+\n| REFRESHED_ON                  | METADATA_FILE_NAME                                                               | SNAPSHOT_ID         | SEQUENCE_NUMBER | ICEBERG_SCHEMA_ID | QUERY_ID                             | IS_CURRENT_SNAPSHOT | SNAPSHOT_SUMMARY                |\n|-------------------------------+----------------------------------------------------------------------------------+---------------------+-----------------+-------------------+--------------------------------------+---------------------+---------------------------------|\n| 2024-12-09 11:00:50.506 -0800 | s3://my-bucket/metadata/00000-e3bf7230-283f-4626-a770-fe97a3ca239e.metadata.json | NULL                | NULL            | 0                 | 01b8ebb4-0002-3a10-0000-012903c7e42a | False               | NULL                            |\n| 2024-12-09 11:01:35.543 -0800 | s3://my-bucket/metadata/00001-bf116652-b5b0-479a-947e-6c799e4ca124.metadata.json | 6201065399847600377 | NULL            | 0                 | 01b8ebb5-0002-3a14-0000-012903c7f336 | True                | {                               |\n|                               |                                                                                  |                     |                 |                   |                                      |                     |   \"added-data-files\": \"4\",      |\n|                               |                                                                                  |                     |                 |                   |                                      |                     |   \"added-files-size\": \"144896\", |\n|                               |                                                                                  |                     |                 |                   |                                      |                     |   \"added-records\": \"150000\",    |\n|                               |                                                                                  |                     |                 |                   |                                      |                     |   \"manifests-created\": \"1\",     |\n|                               |                                                                                  |                     |                 |                   |                                      |                     |   \"manifests-kept\": \"0\",        |\n|                               |                                                                                  |                     |                 |                   |                                      |                     |   \"manifests-replaced\": \"0\",    |\n|                               |                                                                                  |                     |                 |                   |                                      |                     |   \"total-data-files\": \"4\",      |\n|                               |                                                                                  |                     |                 |                   |                                      |                     |   \"total-files-size\": \"144896\", |\n|                               |                                                                                  |                     |                 |                   |                                      |                     |   \"total-records\": \"150000\"     |\n|                               |                                                                                  |                     |                 |                   |                                      |                     | }                               |\n+-------------------------------+----------------------------------------------------------------------------------+---------------------+-----------------+-------------------+--------------------------------------+---------------------+---------------------------------+",
    "arguments": [
        {
            "name": "TABLE_NAME",
            "description": "The name of the externally managed Iceberg table for which you want to retrieve the snapshot refresh history."
        }
    ]
},
{
    "function_name": "ICEBERG_TABLE_FILES",
    "summary": "Returns information about the data files registered to an externally managed",
    "category": "iceberg-tm",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/iceberg_table_files",
    "title": "ICEBERG_TABLE_FILES",
    "description": "Returns information about the data files registered to an externally managed Apache Iceberg™ table at a specified\npoint in time.",
    "syntax": "ICEBERG_TABLE_FILES(\n  TABLE_NAME => '<table_name>'\n  [, AT => '<timestamp_ltz>']\n)",
    "example": "SELECT *\n  FROM TABLE(\n    INFORMATION_SCHEMA.ICEBERG_TABLE_FILES(\n      TABLE_NAME => 'my_iceberg_table'\n    )\n  );\n\n+-------------------------------------------------------+--------------------------------+------------+--------------------------------+------------+------------------+-----------------------------------+-----------------------------------+\n| FILE_NAME                                             | REGISTERED_ON                  | FILE_SIZE  | LAST_MODIFIED_ON               | ROW_COUNT  | ROW_GROUP_COUNT  | ETAG                              | MD5                              |\n| data/87/snow_D9zlAoeipII_AODxT1uXDxg_0_1_003.parquet  | 1969-12-31 16:00:00.000 -0800  | 27136      | 2024-12-09 11:00:41.000 -0800  | 30000      | 1                | 5cae923b13581f87cf6397ec491fb5d5  | 5cae923b13581f87cf6397ec491fb5d5 |\n| data/08/snow_D9zlAoeipII_AODxT1uXDxg_0_1_006.parquet  | 1969-12-31 16:00:00.000 -0800  | 45568      | 2024-12-09 11:00:41.000 -0800  | 45000      | 1                | 3659cb341fec3a57309480d2e1bb7fc3  | 3659cb341fec3a57309480d2e1bb7fc3 |\n| data/94/snow_D9zlAoeipII_AODxT1uXDxg_0_1_008.parquet  | 1969-12-31 16:00:00.000 -0800  | 45056      | 2024-12-09 11:00:41.000 -0800  | 45000      | 1                | 5bee899fa8ee60fa668329acae0ed215  | 5bee899fa8ee60fa668329acae0ed215 |\n| data/24/snow_D9zlAoeipII_AODxT1uXDxg_0_1_004.parquet  | 1969-12-31 16:00:00.000 -0800  | 27136      | 2024-12-09 11:00:41.000 -0800  | 30000      | 1                | 43a489e450831c717d909a5c79ab9388  | 43a489e450831c717d909a5c79ab9388 |\n+-------------------------------------------------------+--------------------------------+------------+--------------------------------+------------+------------------+-----------------------------------+-----------------------------------+\n\nSELECT file_name, file_size, row_count, row_group_count, etag, md5\n  FROM TABLE(\n    INFORMATION_SCHEMA.ICEBERG_TABLE_FILES(\n      TABLE_NAME => 'my_iceberg_table',\n      AT => CAST('2024-12-09 11:02:00' AS TIMESTAMP_LTZ)\n    )\n  );\n\n+------------------------------------------------------+-----------+-----------+-----------------+----------------------------------+----------------------------------+\n| FILE_NAME                                            | FILE_SIZE | ROW_COUNT | ROW_GROUP_COUNT | ETAG                             | MD5                              |\n|------------------------------------------------------+-----------+-----------+-----------------+----------------------------------+----------------------------------|\n| data/87/snow_D9zlAoeipII_AODxT1uXDxg_0_1_003.parquet |     27136 |     30000 |               1 | 5cae923b13581f87cf6397ec491fb5d5 | 5cae923b13581f87cf6397ec491fb5d5 |\n| data/08/snow_D9zlAoeipII_AODxT1uXDxg_0_1_006.parquet |     45568 |     45000 |               1 | 3659cb341fec3a57309480d2e1bb7fc3 | 3659cb341fec3a57309480d2e1bb7fc3 |\n| data/94/snow_D9zlAoeipII_AODxT1uXDxg_0_1_008.parquet |     45056 |     45000 |               1 | 5bee899fa8ee60fa668329acae0ed215 | 5bee899fa8ee60fa668329acae0ed215 |\n| data/24/snow_D9zlAoeipII_AODxT1uXDxg_0_1_004.parquet |     27136 |     30000 |               1 | 43a489e450831c717d909a5c79ab9388 | 43a489e450831c717d909a5c79ab9388 |\n+------------------------------------------------------+-----------+-----------+-----------------+----------------------------------+----------------------------------+\n4 Row(s) produced. Time Elapsed: 1.502s",
    "arguments": [
        {
            "name": "TABLE_NAME",
            "description": "The name of the externally managed Iceberg table for which you want to retrieve the data file information."
        },
        {
            "name": "AT",
            "description": "Specifies an exact date and time to use for retrieving the file information. The value must be explicitly cast to a\nTIMESTAMP_LTZ data type. For information, see Date & time data types . If not specified, the function returns information about the table files for the current snapshot ."
        }
    ]
},
{
    "function_name": "HOUR / MINUTE / SECOND",
    "summary": "Extracts the corresponding time part from a time or timestamp value.",
    "category": "Date & time functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/hour-minute-second",
    "title": "HOUR / MINUTE / SECOND",
    "description": "Extracts the corresponding time part from a time or timestamp value.",
    "syntax": "HOUR( <time_or_timestamp_expr> )\n\nMINUTE( <time_or_timestamp_expr> )\n\nSECOND( <time_or_timestamp_expr> )",
    "example": "SELECT '2025-04-08T23:39:20.123-07:00'::TIMESTAMP AS tstamp,\n       HOUR(tstamp) AS \"HOUR\",\n       MINUTE(tstamp) AS \"MINUTE\",\n       SECOND(tstamp) AS \"SECOND\";\n\n+-------------------------+------+--------+--------+\n| TSTAMP                  | HOUR | MINUTE | SECOND |\n|-------------------------+------+--------+--------|\n| 2025-04-08 23:39:20.123 |   23 |     39 |     20 |\n+-------------------------+------+--------+--------+",
    "arguments": [
        {
            "name": "time_or_timestamp_expr",
            "description": "A time or a timestamp, or an expression that can be evaluated to a time or a timestamp."
        }
    ],
    "returns": "This function returns a value of type NUMBER."
},
{
    "function_name": "HLL_IMPORT",
    "summary": "Converts input in OBJECT format to BINARY format.",
    "category": "Aggregate functions , Window function syntax and usage",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/hll_import",
    "title": "HLL_IMPORT",
    "description": "Converts input in OBJECT format to BINARY format.",
    "syntax": "HLL_IMPORT(obj)"
},
{
    "function_name": "HLL_EXPORT",
    "summary": "Converts input in BINARY format to OBJECT format.",
    "category": "Aggregate functions , Window function syntax and usage",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/hll_export",
    "title": "HLL_EXPORT",
    "description": "Converts input in BINARY format to OBJECT format.",
    "syntax": "HLL_EXPORT( <binary_expr> )",
    "example": "SELECT HLL(o_orderdate), HLL_ESTIMATE(HLL_IMPORT(HLL_EXPORT(HLL_ACCUMULATE(o_orderdate))))\nFROM orders;\n\n------------------+-------------------------------------------------------------------+\n HLL(O_ORDERDATE) | HLL_ESTIMATE(HLL_IMPORT(HLL_EXPORT(HLL_ACCUMULATE(O_ORDERDATE)))) |\n------------------+-------------------------------------------------------------------+\n 2398             | 2398                                                              |\n------------------+-------------------------------------------------------------------+"
},
{
    "function_name": "HLL_ESTIMATE",
    "summary": "Returns the cardinality estimate for the given HyperLogLog state.",
    "category": "Aggregate functions , Window function syntax and usage",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/hll_estimate",
    "title": "HLL_ESTIMATE",
    "description": "Returns the cardinality estimate for the given HyperLogLog state.",
    "syntax": "HLL_ESTIMATE( <state> )",
    "example": "-- Create a sequence to use to generate values for the table.\nCREATE OR REPLACE SEQUENCE seq92;\nCREATE OR REPLACE TABLE sequence_demo (c1 INTEGER DEFAULT seq92.nextval, dummy SMALLINT);\nINSERT INTO sequence_demo (dummy) VALUES (0);\n\n-- Double the number of rows a few times, until there are 8 rows:\nINSERT INTO sequence_demo (dummy) SELECT dummy FROM sequence_demo;\nINSERT INTO sequence_demo (dummy) SELECT dummy FROM sequence_demo;\nINSERT INTO sequence_demo (dummy) SELECT dummy FROM sequence_demo;\n\nCREATE OR REPLACE TABLE resultstate1 AS (\n     SELECT hll_accumulate(c1) AS rs1\n        FROM sequence_demo);\n\nCREATE OR REPLACE TABLE test_table2 (c1 INTEGER);\n-- Insert data.\nINSERT INTO test_table2 (c1) SELECT c1 + 4 FROM sequence_demo;\n\nCREATE OR REPLACE TABLE resultstate2 AS \n  (SELECT hll_accumulate(c1) AS rs1 \n     FROM test_table2);\n\nCREATE OR REPLACE TABLE combined_resultstate (c1) AS \n  SELECT hll_combine(rs1) AS apc1\n    FROM (\n        SELECT rs1 FROM resultstate1\n        UNION ALL\n        SELECT rs1 FROM resultstate2\n      )\n      ;\n\nSELECT hll_estimate(c1) FROM combined_resultstate;\n\n+------------------+\n| HLL_ESTIMATE(C1) |\n|------------------|\n|               12 |\n+------------------+",
    "arguments": [
        {
            "name": "state",
            "description": "An expression that contains state information generated\nby a call to HLL_ACCUMULATE or HLL_COMBINE ."
        }
    ]
},
{
    "function_name": "HLL_COMBINE",
    "summary": "Combines (merges) input states into a single output state.",
    "category": "Aggregate functions , Window function syntax and usage",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/hll_combine",
    "title": "HLL_COMBINE",
    "description": "Combines (merges) input states into a single output state.",
    "syntax": "HLL_COMBINE( [ DISTINCT ] <state> )",
    "example": "-- Create a sequence to use to generate values for the table.\nCREATE OR REPLACE SEQUENCE seq92;\nCREATE OR REPLACE TABLE sequence_demo (c1 INTEGER DEFAULT seq92.nextval, dummy SMALLINT);\nINSERT INTO sequence_demo (dummy) VALUES (0);\n\n-- Double the number of rows a few times, until there are 8 rows:\nINSERT INTO sequence_demo (dummy) SELECT dummy FROM sequence_demo;\nINSERT INTO sequence_demo (dummy) SELECT dummy FROM sequence_demo;\nINSERT INTO sequence_demo (dummy) SELECT dummy FROM sequence_demo;\n\nCREATE OR REPLACE TABLE resultstate1 AS (\n     SELECT hll_accumulate(c1) AS rs1\n        FROM sequence_demo);\n\nCREATE OR REPLACE TABLE test_table2 (c1 INTEGER);\n-- Insert data.\nINSERT INTO test_table2 (c1) SELECT c1 + 4 FROM sequence_demo;\n\nCREATE OR REPLACE TABLE resultstate2 AS \n  (SELECT hll_accumulate(c1) AS rs1 \n     FROM test_table2);\n\nCREATE OR REPLACE TABLE combined_resultstate (c1) AS \n  SELECT hll_combine(rs1) AS apc1\n    FROM (\n        SELECT rs1 FROM resultstate1\n        UNION ALL\n        SELECT rs1 FROM resultstate2\n      )\n      ;\n\nSELECT hll_estimate(c1) FROM combined_resultstate;\n\n+------------------+\n| HLL_ESTIMATE(C1) |\n|------------------|\n|               12 |\n+------------------+",
    "arguments": [
        {
            "name": "state",
            "description": "An expression that contains state information generated\nby a call to HLL_ACCUMULATE ."
        }
    ]
},
{
    "function_name": "HLL_ACCUMULATE",
    "summary": "Returns the HyperLogLog state at the end of aggregation.",
    "category": "Aggregate functions , Window function syntax and usage",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/hll_accumulate",
    "title": "HLL_ACCUMULATE",
    "description": "Returns the HyperLogLog state at the end of aggregation.",
    "syntax": "HLL_ACCUMULATE( [ DISTINCT ] <expr> )\n\nHLL_ACCUMULATE(*)",
    "example": "CREATE TABLE temporary_hll_state_for_manitoba AS\n SELECT HLL_ACCUMULATE(postal_code) as h_a_p_c\n  FROM postal_data\n  WHERE province = 'Manitoba'\n  ;\n\n-- Create a sequence to use to generate values for the table.\nCREATE OR REPLACE SEQUENCE seq92;\nCREATE OR REPLACE TABLE sequence_demo (c1 INTEGER DEFAULT seq92.nextval, dummy SMALLINT);\nINSERT INTO sequence_demo (dummy) VALUES (0);\n\n-- Double the number of rows a few times, until there are 8 rows:\nINSERT INTO sequence_demo (dummy) SELECT dummy FROM sequence_demo;\nINSERT INTO sequence_demo (dummy) SELECT dummy FROM sequence_demo;\nINSERT INTO sequence_demo (dummy) SELECT dummy FROM sequence_demo;\n\nCREATE OR REPLACE TABLE resultstate1 AS (\n     SELECT hll_accumulate(c1) AS rs1\n        FROM sequence_demo);\n\nCREATE OR REPLACE TABLE test_table2 (c1 INTEGER);\n-- Insert data.\nINSERT INTO test_table2 (c1) SELECT c1 + 4 FROM sequence_demo;\n\nCREATE OR REPLACE TABLE resultstate2 AS \n  (SELECT hll_accumulate(c1) AS rs1 \n     FROM test_table2);\n\nCREATE OR REPLACE TABLE combined_resultstate (c1) AS \n  SELECT hll_combine(rs1) AS apc1\n    FROM (\n        SELECT rs1 FROM resultstate1\n        UNION ALL\n        SELECT rs1 FROM resultstate2\n      )\n      ;\n\nSELECT hll_estimate(c1) FROM combined_resultstate;\n\n+------------------+\n| HLL_ESTIMATE(C1) |\n|------------------|\n|               12 |\n+------------------+",
    "arguments": [
        {
            "name": "expr",
            "description": "The expression for which you want to estimate cardinality (number of\ndistinct values). This is typically a column name, but can be a more\ngeneral expression."
        }
    ]
},
{
    "function_name": "HLL",
    "summary": "Uses HyperLogLog to return an approximation of the distinct cardinality of the input (i.e. HLL(col1, col2, ... ) returns an approximation of COUNT(DISTINCT col1, col2, ... )).",
    "category": "Aggregate functions , Window functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/hll",
    "title": "HLL",
    "description": "Uses HyperLogLog to return an approximation of the distinct cardinality of the input (i.e.",
    "syntax": "HLL( [ DISTINCT ] <expr1> [ , ... ] )\n\nHLL(*)",
    "example": "SELECT COUNT(i), COUNT(DISTINCT i), APPROX_COUNT_DISTINCT(i), HLL(i)\n  FROM sequence_demo;",
    "arguments": [
        {
            "name": "expr1",
            "description": "This is the expression for which you want to know the number of distinct values."
        },
        {
            "name": "expr2",
            "description": "This is the optional expression used to group rows into partitions."
        }
    ],
    "returns": "The data type of the returned value is INTEGER."
},
{
    "function_name": "HEX_ENCODE",
    "summary": "Encodes the input using hexadecimal (also ‘hex’ or ‘base16’) encoding.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/hex_encode",
    "title": "HEX_ENCODE",
    "description": "Encodes the input using hexadecimal (also ‘hex’ or ‘base16’) encoding.\nThe result is comprised of 16 different symbols: The numbers ‘0’ to ‘9’ as\nwell as the letters ‘A’ to ‘F’ (or ‘a’ to ‘f’, see below).",
    "syntax": "HEX_ENCODE(<input> [, <case>])",
    "example": "SELECT HEX_ENCODE('Snowflake');\n\n-------------------------+\n HEX_ENCODE('SNOWFLAKE') |\n-------------------------+\n 536E6F77666C616B65      |\n-------------------------+\n\nSELECT HEX_ENCODE('Snowflake',0);\n\n---------------------------+\n HEX_ENCODE('SNOWFLAKE',0) |\n---------------------------+\n 536e6f77666c616b65        |\n---------------------------+",
    "arguments": [
        {
            "name": "input",
            "description": "A binary or string expression to be encoded."
        },
        {
            "name": "case",
            "description": "This optional boolean argument controls the case of the letters\n(‘A’, ‘B’, ‘C’, ‘D’, ‘E’ and ‘F’) used in the encoding.\nThe default value is 1 and indicates that uppercase\nletters are used. The value 0 indicates that lowercase\nletters are used. All other values are illegal and result\nin an error."
        }
    ],
    "returns": "This returns a string that contains only hexadecimal digits."
},
{
    "function_name": "HEX_DECODE_STRING",
    "summary": "Decodes a hex-encoded string to a string.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/hex_decode_string",
    "title": "HEX_DECODE_STRING",
    "description": "Decodes a hex-encoded string to a string.",
    "syntax": "HEX_DECODE_STRING(<input>)",
    "example": "SELECT HEX_DECODE_STRING('536E6F77666C616B65');\n\n-----------------------------------------+\n HEX_DECODE_STRING('536E6F77666C616B65') |\n-----------------------------------------+\n Snowflake                               |\n-----------------------------------------+\n\nSELECT HEX_DECODE_STRING('536e6f77666c616b65');\n\n-----------------------------------------+\n HEX_DECODE_STRING('536E6F77666C616B65') |\n-----------------------------------------+\n Snowflake                               |\n-----------------------------------------+\n\nCREATE TABLE binary_table (v VARCHAR, b BINARY);\nINSERT INTO binary_table (v, b) \n    SELECT 'HELLO', HEX_DECODE_BINARY(HEX_ENCODE('HELLO'));\n\nSELECT v, b, HEX_DECODE_STRING(TO_VARCHAR(b)) FROM binary_table;\n+-------+------------+----------------------------------+\n| V     | B          | HEX_DECODE_STRING(TO_VARCHAR(B)) |\n|-------+------------+----------------------------------|\n| HELLO | 48454C4C4F | HELLO                            |\n+-------+------------+----------------------------------+",
    "arguments": [
        {
            "name": "input",
            "description": "A hex-encoded string expression. Typically the input was created by a\ncall to HEX_ENCODE ."
        }
    ],
    "returns": "The returned value is a string (VARCHAR)."
},
{
    "function_name": "HEX_DECODE_BINARY",
    "summary": "Decodes a hex-encoded string to a binary.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/hex_decode_binary",
    "title": "HEX_DECODE_BINARY",
    "description": "Decodes a hex-encoded string to a binary.",
    "syntax": "HEX_DECODE_BINARY(<input>)",
    "example": "CREATE TABLE binary_table (v VARCHAR, b BINARY);\nINSERT INTO binary_table (v, b) \n    SELECT 'HELLO', HEX_DECODE_BINARY(HEX_ENCODE('HELLO'));\n\nSELECT v, b, HEX_DECODE_STRING(TO_VARCHAR(b)) FROM binary_table;\n+-------+------------+----------------------------------+\n| V     | B          | HEX_DECODE_STRING(TO_VARCHAR(B)) |\n|-------+------------+----------------------------------|\n| HELLO | 48454C4C4F | HELLO                            |\n+-------+------------+----------------------------------+\n\nSELECT HEX_DECODE_BINARY(HEX_ENCODE(MD5_BINARY('Snowflake')));\n\n--------------------------------------------------------+\n HEX_DECODE_BINARY(HEX_ENCODE(MD5_BINARY('SNOWFLAKE'))) |\n--------------------------------------------------------+\n EDF1439075A83A447FB8B630DDC9C8DE                       |\n--------------------------------------------------------+",
    "arguments": [
        {
            "name": "input",
            "description": "A string expression containing only hexadecimal digits. Typically, this\ninput string is generated by calling the function HEX_ENCODE ."
        }
    ],
    "returns": "A BINARY value that can, for example, be inserted into a column of type\nBINARY."
},
{
    "function_name": "HAVERSINE",
    "summary": "Calculates the great-circle distance in kilometers between two points on the Earth’s surface, using the Haversine formula.",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/haversine",
    "title": "HAVERSINE",
    "description": "Calculates the great-circle distance in kilometers between two points on the\nEarth’s surface, using the",
    "syntax": "HAVERSINE( <lat1>, <lon1>, <lat2>, <lon2> )",
    "arguments": [
        {
            "name": "lat1",
            "description": "The latitude of the first point in decimal degrees."
        },
        {
            "name": "lon1",
            "description": "The longitude of the first point in decimal degrees."
        },
        {
            "name": "lat2",
            "description": "The latitude of the second point in decimal degrees."
        },
        {
            "name": "lon2",
            "description": "The longitude of the second point in decimal degrees."
        }
    ]
},
{
    "function_name": "HASH_AGG",
    "summary": "Returns an aggregate signed 64-bit hash value over the (unordered) set of input rows.",
    "category": "Aggregate functions , Window functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/hash_agg",
    "title": "HASH_AGG",
    "description": "Returns an aggregate signed 64-bit hash value over the (unordered) set of input rows. HASH_AGG never returns NULL, even if no input is provided. Empty input “hashes” to",
    "syntax": "HASH_AGG( [ DISTINCT ] <expr> [ , <expr2> ... ] )\n\nHASH_AGG(*)",
    "example": "SELECT HASH_AGG(NULL), HASH_AGG(NULL, NULL), HASH_AGG(NULL, NULL, NULL);\n\n+----------------------+----------------------+----------------------------+\n|       HASH_AGG(NULL) | HASH_AGG(NULL, NULL) | HASH_AGG(NULL, NULL, NULL) |\n|----------------------+----------------------+----------------------------|\n| -5089618745711334219 |  2405106413361157177 |       -5970411136727777524 |\n+----------------------+----------------------+----------------------------+\n\nSELECT HASH_AGG(NULL) WHERE 0 = 1;\n\n+----------------+\n| HASH_AGG(NULL) |\n|----------------|\n|              0 |\n+----------------+\n\nSELECT HASH_AGG(*) FROM orders;\n\n+---------------------+\n|     HASH_AGG(*)     |\n|---------------------|\n| 1830986524994392080 |\n+---------------------+\n\nSELECT YEAR(o_orderdate), HASH_AGG(*)\n  FROM ORDERS GROUP BY 1 ORDER BY 1;\n\n+-------------------+----------------------+\n| YEAR(O_ORDERDATE) |     HASH_AGG(*)      |\n|-------------------+----------------------|\n| 1992              | 4367993187952496263  |\n| 1993              | 7016955727568565995  |\n| 1994              | -2863786208045652463 |\n| 1995              | 1815619282444629659  |\n| 1996              | -4747088155740927035 |\n| 1997              | 7576942849071284554  |\n| 1998              | 4299551551435117762  |\n+-------------------+----------------------+\n\nSELECT YEAR(o_orderdate), HASH_AGG(o_custkey, o_orderdate)\n  FROM orders GROUP BY 1 ORDER BY 1;\n\n+-------------------+----------------------------------+\n| YEAR(O_ORDERDATE) | HASH_AGG(O_CUSTKEY, O_ORDERDATE) |\n|-------------------+----------------------------------|\n| 1992              | 5686635209456450692              |\n| 1993              | -6250299655507324093             |\n| 1994              | 6630860688638434134              |\n| 1995              | 6010861038251393829              |\n| 1996              | -767358262659738284              |\n| 1997              | 6531729365592695532              |\n| 1998              | 2105989674377706522              |\n+-------------------+----------------------------------+\n\nSELECT YEAR(o_orderdate), HASH_AGG(DISTINCT o_custkey, o_orderdate)\n  FROM orders GROUP BY 1 ORDER BY 1;\n\n+-------------------+-------------------------------------------+\n| YEAR(O_ORDERDATE) | HASH_AGG(DISTINCT O_CUSTKEY, O_ORDERDATE) |\n|-------------------+-------------------------------------------|\n| 1992              | -8416988862307613925                      |\n| 1993              | 3646533426281691479                       |\n| 1994              | -7562910554240209297                      |\n| 1995              | 6413920023502140932                       |\n| 1996              | -3176203653000722750                      |\n| 1997              | 4811642075915950332                       |\n| 1998              | 1919999828838507836                       |\n+-------------------+-------------------------------------------+\n\nSELECT COUNT(DISTINCT o_orderdate) FROM orders;\n\n+-----------------------------+\n| COUNT(DISTINCT O_ORDERDATE) |\n|-----------------------------|\n| 2406                        |\n+-----------------------------+\n\nSELECT COUNT(o_orderdate)\n  FROM (SELECT o_orderdate, HASH_AGG(DISTINCT o_custkey)\n    FROM orders\n    WHERE o_orderstatus <> 'F'\n    GROUP BY 1\n    INTERSECT\n      SELECT o_orderdate, HASH_AGG(DISTINCT o_custkey)\n        FROM orders\n        WHERE o_orderstatus <> 'P'\n        GROUP BY 1);\n\n+--------------------+\n| COUNT(O_ORDERDATE) |\n|--------------------|\n| 1143               |\n+--------------------+",
    "arguments": [
        {
            "name": "exprN",
            "description": "The expression can be a general expression of any Snowflake data type, except GEOGRAPHY and GEOMETRY ."
        },
        {
            "name": "expr2",
            "description": "You can include additional expressions."
        },
        {
            "name": "expr3",
            "description": "The column to partition on, if you want the result to be split into multiple\nwindows."
        },
        {
            "name": "*",
            "description": "Returns an aggregated hash value over all columns for all records, including records with\nNULL values. You can specify the wildcard for both the aggregate function and the window\nfunction. When you pass a wildcard to the function, you can qualify the wildcard with the name or alias for the table.\nFor example, to pass in all of the columns from the table named mytable , specify the following: You can also use the ILIKE and EXCLUDE keywords for filtering: ILIKE filters for column names that match the specified pattern. Only one\npattern is allowed. For example: EXCLUDE filters out column names that don’t match the specified column or columns. For example: Qualifiers are valid when you use these keywords. The following example uses the ILIKE keyword to\nfilter for all of the columns that match the pattern col1% in the table mytable : The ILIKE and EXCLUDE keywords can’t be combined in a single function call. For this function, the ILIKE and EXCLUDE keywords are valid only in a SELECT list or GROUP BY clause. For more information about the ILIKE and EXCLUDE keywords, see the “Parameters” section in SELECT ."
        }
    ],
    "returns": "Returns a signed 64-bit value as NUMBER(19,0)."
},
{
    "function_name": "HASH",
    "summary": "Returns a signed 64-bit hash value.",
    "category": "Hash functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/hash",
    "title": "HASH",
    "description": "Returns a signed 64-bit hash value. Note that HASH never returns NULL, even for NULL inputs.",
    "syntax": "HASH( <expr> [ , <expr> ... ] )\n\nHASH(*)",
    "example": "SELECT HASH(SEQ8()) FROM TABLE(GENERATOR(rowCount=>10));\n\n+----------------------+\n|         HASH(SEQ8()) |\n|----------------------|\n| -6076851061503311999 |\n| -4730168494964875235 |\n| -3690131753453205264 |\n| -7287585996956442977 |\n| -1285360004004520191 |\n|  4801857165282451853 |\n| -2112898194861233169 |\n|  1885958945512144850 |\n| -3994946021335987898 |\n| -3559031545629922466 |\n+----------------------+\n\nSELECT HASH(10), HASH(10::number(38,0)), HASH(10::number(5,3)), HASH(10::float);\n\n+---------------------+------------------------+-----------------------+---------------------+\n|            HASH(10) | HASH(10::NUMBER(38,0)) | HASH(10::NUMBER(5,3)) |     HASH(10::FLOAT) |\n|---------------------+------------------------+-----------------------+---------------------|\n| 1599627706822963068 |    1599627706822963068 |   1599627706822963068 | 1599627706822963068 |\n+---------------------+------------------------+-----------------------+---------------------+\n\nSELECT HASH(10), HASH('10');\n\n+---------------------+---------------------+\n|            HASH(10) |          HASH('10') |\n|---------------------+---------------------|\n| 1599627706822963068 | 3622494980440108984 |\n+---------------------+---------------------+\n\nSELECT HASH(null), HASH(null, null), HASH(null, null, null);\n\n+---------------------+--------------------+------------------------+\n|          HASH(NULL) |   HASH(NULL, NULL) | HASH(NULL, NULL, NULL) |\n|---------------------+--------------------+------------------------|\n| 8817975702393619368 | 953963258351104160 |    2941948363845684412 |\n+---------------------+--------------------+------------------------+\n\nCREATE TABLE orders (order_ID INTEGER, customer_ID INTEGER, order_date ...);\n\n...\n\nSELECT HASH(*) FROM orders LIMIT 10;\n\n+-----------------------+\n|        HASH(*)        |\n|-----------------------|\n|  -3527903796973745449 |\n|  6296330861892871310  |\n|  6918165900200317484  |\n|  -2762842444336053314 |\n|  -2340602249668223387 |\n|  5248970923485160358  |\n|  -5807737826218607124 |\n|  428973568495579456   |\n|  2583438210124219420  |\n|  4041917286051184231  |\n+ ----------------------+",
    "arguments": [
        {
            "name": "expr",
            "description": "The expression can be a general expression of any Snowflake data type."
        },
        {
            "name": "*",
            "description": "Returns a single hashed value based on all columns in each record,\nincluding records with NULL values. When you pass a wildcard to the function, you can qualify the wildcard with the name or alias for the table.\nFor example, to pass in all of the columns from the table named mytable , specify the following: You can also use the ILIKE and EXCLUDE keywords for filtering: ILIKE filters for column names that match the specified pattern. Only one\npattern is allowed. For example: EXCLUDE filters out column names that don’t match the specified column or columns. For example: Qualifiers are valid when you use these keywords. The following example uses the ILIKE keyword to\nfilter for all of the columns that match the pattern col1% in the table mytable : The ILIKE and EXCLUDE keywords can’t be combined in a single function call. For this function, the ILIKE and EXCLUDE keywords are valid only in a SELECT list or GROUP BY clause. For more information about the ILIKE and EXCLUDE keywords, see the “Parameters” section in SELECT ."
        }
    ],
    "returns": "Returns a signed 64-bit value as NUMBER(19,0)."
},
{
    "function_name": "H3_UNCOMPACT_CELLS_STRINGS",
    "summary": "Returns an array of VARIANT values that contain the VARCHAR hexadecimal IDs of H3 cells at the specified resolution that cover the same area as the H3 cells in the input.",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/h3_uncompact_cells_strings",
    "title": "H3_UNCOMPACT_CELLS_STRINGS",
    "description": "Returns an",
    "syntax": "H3_UNCOMPACT_CELLS_STRINGS( <array_of_cell_ids> , <target_resolution> )",
    "example": "SELECT H3_UNCOMPACT_CELLS_STRINGS(\n  [\n    '8a2a1072339ffff',\n    '892a1072377ffff'\n  ],\n  10\n) AS uncompacted;\n\n+----------------------+\n| UNCOMPACTED          |\n|----------------------|\n| [                    |\n|   \"8a2a1072339ffff\", |\n|   \"8a2a10723747fff\", |\n|   \"8a2a1072374ffff\", |\n|   \"8a2a10723757fff\", |\n|   \"8a2a1072375ffff\", |\n|   \"8a2a10723767fff\", |\n|   \"8a2a1072376ffff\", |\n|   \"8a2a10723777fff\"  |\n| ]                    |\n+----------------------+",
    "arguments": [
        {
            "name": "array_of_cell_ids",
            "description": "An array of VARIANT values that contain VARCHAR hexadecimal values that represent H3 cell IDs ( indexes )."
        },
        {
            "name": "target_resolution",
            "description": "An INTEGER value between 0 and 15 (inclusive) specifying the H3 resolution that you want to use for the returned H3 cells. Specifying any other INTEGER value results in an error."
        }
    ],
    "returns": "Returns a value of the ARRAY data type or NULL."
},
{
    "function_name": "H3_UNCOMPACT_CELLS",
    "summary": "Returns an array of VARIANT values that contain the INTEGER IDs of H3 cells at the specified resolution that cover the same area as the H3 cells in the input.",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/h3_uncompact_cells",
    "title": "H3_UNCOMPACT_CELLS",
    "description": "Returns an",
    "syntax": "H3_UNCOMPACT_CELLS( <array_of_cell_ids> , <target_resolution> )",
    "example": "SELECT H3_UNCOMPACT_CELLS(\n  [\n    622236750558396415,\n    617733150935089151\n  ],\n  10\n) AS uncompacted;\n\n+-----------------------+\n| UNCOMPACTED           |\n|-----------------------|\n| [                     |\n|   622236750558396415, |\n|   622236750562230271, |\n|   622236750562263039, |\n|   622236750562295807, |\n|   622236750562328575, |\n|   622236750562361343, |\n|   622236750562394111, |\n|   622236750562426879  |\n| ]                     |\n+-----------------------+",
    "arguments": [
        {
            "name": "array_of_cell_ids",
            "description": "An array of VARIANT values that contain INTEGER values that represent H3 cell IDs ( indexes )."
        },
        {
            "name": "target_resolution",
            "description": "An INTEGER value between 0 and 15 (inclusive) specifying the H3 resolution that you want to use for the returned H3 cells. Specifying any other INTEGER value results in an error."
        }
    ],
    "returns": "Returns a value of the ARRAY data type or NULL."
},
{
    "function_name": "H3_TRY_POLYGON_TO_CELLS_STRINGS",
    "summary": "A special version of H3_POLYGON_TO_CELLS_STRINGS that returns NULL if an error occurs when it attempts to return an array of VARCHAR values of the hexadecimal IDs of H3 cells that have centroids contained by a Polygon (specified by a GEOGRAPHY object).",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/h3_try_polygon_to_cells_strings",
    "title": "H3_TRY_POLYGON_TO_CELLS_STRINGS",
    "description": "A special version of",
    "syntax": "H3_TRY_POLYGON_TO_CELLS_STRINGS( <geography_polygon> , <target_resolution> )",
    "example": "SELECT H3_TRY_POLYGON_TO_CELLS_STRINGS(\n  TO_GEOGRAPHY('POLYGON((-108.959 40.948,\n                         -109.015 37.077,\n                         -102.117 36.956,\n                         -102.134 40.953,\n                         -108.959 40.948))'\n              ), 15) AS h3_cells_in_polygon;\n\n+---------------------+\n| H3_CELLS_IN_POLYGON |\n|---------------------|\n| NULL                |\n+---------------------+",
    "arguments": [
        {
            "name": "geography_polygon",
            "description": "A GEOGRAPHY object that represents a Polygon."
        },
        {
            "name": "target_resolution",
            "description": "An INTEGER between 0 and 15 (inclusive) that specifies the H3 resolution that you want to use for the returned H3 cells. Specifying any other INTEGER value results in an error."
        }
    ],
    "returns": "Returns an array of VARCHAR values or NULL."
},
{
    "function_name": "H3_TRY_POLYGON_TO_CELLS",
    "summary": "A special version of H3_POLYGON_TO_CELLS that returns NULL if an error occurs when it attempts to return an array of INTEGER values of the IDs of H3 cells that have centroids contained by a Polygon (specified by a GEOGRAPHY object).",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/h3_try_polygon_to_cells",
    "title": "H3_TRY_POLYGON_TO_CELLS",
    "description": "A special version of",
    "syntax": "H3_TRY_POLYGON_TO_CELLS( <geography_polygon> , <target_resolution> )",
    "example": "SELECT H3_TRY_POLYGON_TO_CELLS(\n  TO_GEOGRAPHY('POLYGON((-108.959 40.948,\n                         -109.015 37.077,\n                         -102.117 36.956,\n                         -102.134 40.953,\n                         -108.959 40.948))'\n              ), 15) AS h3_cells_in_polygon;\n\n+---------------------+\n| H3_CELLS_IN_POLYGON |\n|---------------------|\n| NULL                |\n+---------------------+",
    "arguments": [
        {
            "name": "geography_polygon",
            "description": "A GEOGRAPHY object that represents a Polygon."
        },
        {
            "name": "target_resolution",
            "description": "An INTEGER between 0 and 15 (inclusive) that specifies the H3 resolution that you want to use for the returned H3 cells. Specifying any other INTEGER value results in an error."
        }
    ],
    "returns": "Returns an array of INTEGER values or NULL."
},
{
    "function_name": "H3_TRY_GRID_PATH",
    "summary": "A special version of H3_GRID_PATH that returns NULL if an error occurs when it attempts to return an array of VARIANT values that contain the IDs of the H3 cells that represent the line between two cells.",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/h3_try_grid_path",
    "title": "H3_TRY_GRID_PATH",
    "description": "A special version of",
    "syntax": "H3_TRY_GRID_PATH( <cell_id_1> , <cell_id_2> )",
    "example": "SELECT H3_TRY_GRID_PATH('813d7ffffffffff', '81343ffffffffff');\n\n+--------------------------------------------------------+\n| H3_TRY_GRID_PATH('813D7FFFFFFFFFF', '81343FFFFFFFFFF') |\n|--------------------------------------------------------|\n| NULL                                                   |\n+--------------------------------------------------------+",
    "arguments": [
        {
            "name": "cell_id_1",
            "description": "An INTEGER value that represents the H3 cell ID ( index ), or a VARCHAR value that represents the cell ID\nin hexadecimal format."
        },
        {
            "name": "cell_id_2",
            "description": "An INTEGER value that represents the H3 cell ID ( index ), or a VARCHAR value that represents the cell ID\nin hexadecimal format."
        }
    ],
    "returns": "Returns a value of the ARRAY data type or NULL."
},
{
    "function_name": "H3_TRY_GRID_DISTANCE",
    "summary": "A special version of H3_GRID_DISTANCE that returns NULL if an error occurs when it attempts to return the distance between two H3 cells.",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/h3_try_grid_distance",
    "title": "H3_TRY_GRID_DISTANCE",
    "description": "A special version of",
    "syntax": "H3_TRY_GRID_DISTANCE( <cell_id_1> , <cell_id_2> )",
    "example": "SELECT H3_TRY_GRID_DISTANCE(582046271372525567, 581883543651614719);\n\n+--------------------------------------------------------------+\n| H3_TRY_GRID_DISTANCE(582046271372525567, 581883543651614719) |\n|--------------------------------------------------------------|\n|                                                         NULL |\n+--------------------------------------------------------------+",
    "arguments": [
        {
            "name": "cell_id_1",
            "description": "An INTEGER value that represents the H3 cell ID ( index ), or a VARCHAR value that represents the cell ID\nin hexadecimal format."
        },
        {
            "name": "cell_id_2",
            "description": "An INTEGER value that represents the H3 cell ID ( index ), or a VARCHAR value that represents the cell ID\nin hexadecimal format."
        }
    ],
    "returns": "Returns an INTEGER value or NULL."
},
{
    "function_name": "H3_TRY_COVERAGE_STRINGS",
    "summary": "A special version of H3_COVERAGE_STRINGS that returns NULL if an error occurs when it attempts to return an array of hexadecimal IDs (as VARCHAR values) identifying the minimal set of H3 cells that completely cover a shape (specified by a GEOGRAPHY object).",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/h3_try_coverage_strings",
    "title": "H3_TRY_COVERAGE_STRINGS",
    "description": "A special version of",
    "syntax": "H3_TRY_COVERAGE_STRINGS( <geography_expression> , <target_resolution> )",
    "example": "SELECT H3_TRY_COVERAGE_STRINGS(\n  TO_GEOGRAPHY('POLYGON((-108.959 40.948,\n                         -109.015 37.077,\n                         -102.117 36.956,\n                         -102.134 40.953,\n                         -108.959 40.948))'\n              ), 15) AS set_of_h3_cells_covering_polygon;\n\n+----------------------------------+\n| SET_OF_H3_CELLS_COVERING_POLYGON |\n|----------------------------------|\n| NULL                             |\n+----------------------------------+",
    "arguments": [
        {
            "name": "geography_expression",
            "description": "A GEOGRAPHY object."
        },
        {
            "name": "target_resolution",
            "description": "An INTEGER between 0 and 15 (inclusive) specifying the H3 resolution that you want to use for the returned H3 cells. Specifying any other INTEGER value results in an error."
        }
    ],
    "returns": "Returns an array of VARCHAR values or NULL."
},
{
    "function_name": "H3_TRY_COVERAGE",
    "summary": "A special version of H3_COVERAGE that returns NULL if an error occurs when it attempts to return an array of IDs (as INTEGER values) identifying the minimal set of H3 cells that completely cover a shape (specified by a GEOGRAPHY object).",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/h3_try_coverage",
    "title": "H3_TRY_COVERAGE",
    "description": "A special version of",
    "syntax": "H3_TRY_COVERAGE( <geography_expression> , <target_resolution> )",
    "example": "SELECT H3_TRY_COVERAGE(\n  TO_GEOGRAPHY('POLYGON((-108.959 40.948,\n                         -109.015 37.077,\n                         -102.117 36.956,\n                         -102.134 40.953,\n                         -108.959 40.948))'\n              ), 15) AS set_of_h3_cells_covering_polygon;\n\n+----------------------------------+\n| SET_OF_H3_CELLS_COVERING_POLYGON |\n|----------------------------------|\n| NULL                             |\n+----------------------------------+",
    "arguments": [
        {
            "name": "geography_expression",
            "description": "A GEOGRAPHY object."
        },
        {
            "name": "target_resolution",
            "description": "An INTEGER between 0 and 15 (inclusive) specifying the H3 resolution that you want to use for the returned H3 cells. Specifying any other INTEGER value results in an error."
        }
    ],
    "returns": "Returns an array of INTEGER values or NULL."
},
{
    "function_name": "H3_STRING_TO_INT",
    "summary": "Converts an H3 cell ID in hexadecimal format to an INTEGER value.",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/h3_string_to_int",
    "title": "H3_STRING_TO_INT",
    "description": "Converts an",
    "syntax": "H3_STRING_TO_INT( <cell_id> )",
    "example": "SELECT H3_STRING_TO_INT('89283087033FFFF');\n\n+------------------------------------------------+\n|            H3_STRING_TO_INT('89283087033FFFF') |\n|------------------------------------------------|\n|                             617700171168612351 |\n+------------------------------------------------+",
    "arguments": [
        {
            "name": "cell_id",
            "description": "A VARCHAR that represents the cell ID ( index ) in hexadecimal format."
        }
    ],
    "returns": "Returns an INTEGER value that represents the H3 cell ID."
},
{
    "function_name": "H3_POLYGON_TO_CELLS_STRINGS",
    "summary": "Returns an array of VARCHAR values of the hexadecimal IDs of H3 cells that have centroids contained by a Polygon (specified by a GEOGRAPHY object).",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/h3_polygon_to_cells_strings",
    "title": "H3_POLYGON_TO_CELLS_STRINGS",
    "description": "Returns an",
    "syntax": "H3_POLYGON_TO_CELLS_STRINGS( <geography_polygon> , <target_resolution> )",
    "example": "SELECT H3_POLYGON_TO_CELLS_STRINGS(\n  TO_GEOGRAPHY(\n    'POLYGON((-122.481889 37.826683,-122.479487 37.808548,-122.474150 37.808904,-122.476510 37.826935,-122.481889 37.826683))'),\n  9) AS h3_cells_in_polygon;\n\n+----------------------+\n| H3_CELLS_IN_POLYGON  |\n|----------------------|\n| [                    |\n|   \"8928308715bffff\", |\n|   \"89283087397ffff\", |\n|   \"89283087023ffff\", |\n|   \"892830870abffff\", |\n|   \"89283087027ffff\", |\n|   \"89283087033ffff\", |\n|   \"8928308702fffff\", |\n|   \"892830870bbffff\", |\n|   \"89283087037ffff\"  |\n| ]                    |\n+----------------------+",
    "arguments": [
        {
            "name": "geography_polygon",
            "description": "A GEOGRAPHY object that represents a Polygon."
        },
        {
            "name": "target_resolution",
            "description": "An INTEGER between 0 and 15 (inclusive) that specifies the H3 resolution that you want to use for the returned H3 cells. Specifying any other INTEGER value results in an error."
        }
    ],
    "returns": "Returns an array of VARCHAR values for the hexadecimal IDs of the H3 cells that have centroids contained in the specified input\nPolygon."
},
{
    "function_name": "H3_POLYGON_TO_CELLS",
    "summary": "Returns an array of INTEGER values of the IDs of H3 cells that have centroids contained by a Polygon (specified by a GEOGRAPHY object).",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/h3_polygon_to_cells",
    "title": "H3_POLYGON_TO_CELLS",
    "description": "Returns an",
    "syntax": "H3_POLYGON_TO_CELLS( <geography_polygon> , <target_resolution> )",
    "example": "SELECT H3_POLYGON_TO_CELLS(\n  TO_GEOGRAPHY(\n    'POLYGON((-122.481889 37.826683,-122.479487 37.808548,-122.474150 37.808904,-122.476510 37.826935,-122.481889 37.826683))'\n  ),\n  9) AS h3_cells_in_polygon;\n\n+-----------------------+\n| H3_CELLS_IN_POLYGON   |\n|-----------------------|\n| [                     |\n|   617700171176476671, |\n|   617700171168874495, |\n|   617700171177525247, |\n|   617700171167563775, |\n|   617700171225497599, |\n|   617700171188011007, |\n|   617700171168350207, |\n|   617700171168612351, |\n|   617700171167825919  |\n| ]                     |\n+-----------------------+",
    "arguments": [
        {
            "name": "geography_polygon",
            "description": "A GEOGRAPHY object that represents a Polygon."
        },
        {
            "name": "target_resolution",
            "description": "An INTEGER between 0 and 15 (inclusive) that specifies the H3 resolution that you want to use for the returned H3 cells. Specifying any other INTEGER value results in an error."
        }
    ],
    "returns": "Returns an array of INTEGER values for the IDs of the H3 cells that have centroids contained in the specified input Polygon."
},
{
    "function_name": "H3_POINT_TO_CELL_STRING",
    "summary": "Returns the hexadecimal value of an H3 cell ID for a Point (specified by a GEOGRAPHY object) at a given resolution.",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/h3_point_to_cell_string",
    "title": "H3_POINT_TO_CELL_STRING",
    "description": "Returns the hexadecimal value of an",
    "syntax": "H3_POINT_TO_CELL_STRING( <geography_point> , <target_resolution> )",
    "example": "SELECT H3_POINT_TO_CELL_STRING(ST_POINT(13.377704, 52.516262), 8);\n\n+------------------------------------------------------------+\n| H3_POINT_TO_CELL_STRING(ST_POINT(13.377704, 52.516262), 8) |\n|------------------------------------------------------------|\n|  881F1D4887FFFFF                                           |\n+------------------------------------------------------------+\n\nSELECT H3_POINT_TO_CELL_STRING(ST_POINT(13.377704, 52.516262), 18);\n\n100410 (P0000): Invalid H3 resolution value: 18. Resolution must be between 0 (coarsest) and 15 (finest).",
    "arguments": [
        {
            "name": "geography_point",
            "description": "A GEOGRAPHY object that represents a Point."
        },
        {
            "name": "target_resolution",
            "description": "An INTEGER between 0 and 15 (inclusive) that specifies the H3 resolution that you want to use for the returned H3 cell. Specifying any other INTEGER value results in an error."
        }
    ],
    "returns": "Returns an VARCHAR value that corresponds to the hexadecimal H3 cell ID for the given location and resolution."
},
{
    "function_name": "H3_POINT_TO_CELL",
    "summary": "Returns the INTEGER value of an H3 cell ID for a Point (specified by a GEOGRAPHY object) at a given resolution.",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/h3_point_to_cell",
    "title": "H3_POINT_TO_CELL",
    "description": "Returns the INTEGER value of an",
    "syntax": "H3_POINT_TO_CELL( <geography_point> , <target_resolution> )",
    "example": "SELECT H3_POINT_TO_CELL(ST_POINT(13.377704, 52.516262), 8);\n\n+-----------------------------------------------------+\n| H3_POINT_TO_CELL(ST_POINT(13.377704, 52.516262), 8) |\n|-----------------------------------------------------|\n|                                  613036919424548863 |\n+-----------------------------------------------------+\n\nSELECT H3_POINT_TO_CELL(ST_POINT(13.377704, 52.516262), 18);\n\n100410 (P0000): Invalid H3 resolution value: 18. Resolution must be between 0 (coarsest) and 15 (finest).",
    "arguments": [
        {
            "name": "geography_point",
            "description": "A GEOGRAPHY object that represents a Point."
        },
        {
            "name": "target_resolution",
            "description": "An INTEGER between 0 and 15 (inclusive) that specifies the H3 resolution that you want to use for the returned H3 cell. Specifying any other INTEGER value results in an error."
        }
    ],
    "returns": "Returns an INTEGER value that corresponds to the H3 cell ID for the given location and resolution."
},
{
    "function_name": "H3_LATLNG_TO_CELL_STRING",
    "summary": "Returns the H3 cell ID in hexadecimal format (as a VARCHAR value) for a given latitude, longitude, and resolution.",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/h3_latlng_to_cell_string",
    "title": "H3_LATLNG_TO_CELL_STRING",
    "description": "Returns the",
    "syntax": "H3_LATLNG_TO_CELL_STRING( <latitude> , <longitude> , <target_resolution> )",
    "example": "SELECT H3_LATLNG_TO_CELL_STRING(52.516262, 13.377704, 8);\n\n+---------------------------------------------------+\n| H3_LATLNG_TO_CELL_STRING(52.516262, 13.377704, 8) |\n|---------------------------------------------------|\n|  881F1D4887FFFFF                                  |\n+---------------------------------------------------+\n\nSELECT H3_LATLNG_TO_CELL_STRING(52.516262, 373.377704, 8);\n\n+---------------------------------------------------+\n| H3_LATLNG_TO_CELL_STRING(52.516262, 13.377704, 8) |\n|---------------------------------------------------|\n|  881F1D4887FFFFF                                  |\n+---------------------------------------------------+\n\nSELECT H3_LATLNG_TO_CELL_STRING(52.516262, 373.377704, 18);\n\n100410 (P0000): Invalid H3 resolution value: 18. Resolution must be between 0 (coarsest) and 15 (finest).",
    "arguments": [
        {
            "name": "latitude",
            "description": "A FLOAT that represents the latitude. Values outside the standard latitude range are wrapped to the range [-90, 90]."
        },
        {
            "name": "longitude",
            "description": "A FLOAT that represents the longitude. Values outside the standard longitude range are wrapped to the range [-180, 180]."
        },
        {
            "name": "target_resolution",
            "description": "An INTEGER between 0 and 15 (inclusive) that specifies the H3 resolution that you want to use for the returned H3 cell. Specifying any other INTEGER value results in an error."
        }
    ],
    "returns": "Returns a VARCHAR value that corresponds to the hexadecimal H3 cell ID for the given location and resolution."
},
{
    "function_name": "H3_LATLNG_TO_CELL",
    "summary": "Returns the INTEGER value of the H3 cell ID for a given latitude, longitude, and resolution.",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/h3_latlng_to_cell",
    "title": "H3_LATLNG_TO_CELL",
    "description": "Returns the INTEGER value of the",
    "syntax": "H3_LATLNG_TO_CELL( <latitude> , <longitude> , <target_resolution> )",
    "example": "SELECT H3_LATLNG_TO_CELL(52.516262, 13.377704, 8);\n\n+--------------------------------------------+\n| H3_LATLNG_TO_CELL(52.516262, 13.377704, 8) |\n|--------------------------------------------|\n|                         613036919424548863 |\n+--------------------------------------------+\n\nSELECT H3_LATLNG_TO_CELL(52.516262, 373.377704, 8);\n\n+---------------------------------------------+\n| H3_LATLNG_TO_CELL(52.516262, 373.377704, 8) |\n|---------------------------------------------|\n|                          613036919424548863 |\n+---------------------------------------------+\n\nSELECT H3_LATLNG_TO_CELL(52.516262, 373.377704, 18);\n\n100410 (P0000): Invalid H3 resolution value: 18. Resolution must be between 0 (coarsest) and 15 (finest).",
    "arguments": [
        {
            "name": "latitude",
            "description": "A FLOAT that represents the latitude. Values outside the standard latitude range are wrapped to the range [-90, 90]."
        },
        {
            "name": "longitude",
            "description": "A FLOAT that represents the longitude. Values outside the standard longitude range are wrapped to the range [-180, 180]."
        },
        {
            "name": "target_resolution",
            "description": "An INTEGER between 0 and 15 (inclusive) specifying the H3 resolution that you want to use for the returned H3 cell. Specifying any other INTEGER value results in an error."
        }
    ],
    "returns": "Returns an INTEGER value that corresponds to the H3 cell ID for the given location and resolution."
},
{
    "function_name": "H3_IS_VALID_CELL",
    "summary": "Returns TRUE if the input represents a valid H3 cell.",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/h3_is_valid_cell",
    "title": "H3_IS_VALID_CELL",
    "description": "Returns TRUE if the input represents a valid",
    "syntax": "H3_IS_VALID_CELL( <cell_id> )",
    "example": "SELECT H3_IS_VALID_CELL(613036919424548863);\n\n+--------------------------------------+\n| H3_IS_VALID_CELL(613036919424548863) |\n|--------------------------------------|\n| True                                 |\n+--------------------------------------+\n\nSELECT H3_IS_VALID_CELL('Invalid Cell');\n\n+----------------------------------+\n| H3_IS_VALID_CELL('INVALID CELL') |\n|----------------------------------|\n| False                            |\n+----------------------------------+",
    "arguments": [
        {
            "name": "cell_id",
            "description": "An INTEGER value that represents the H3 cell ID ( index ), or a VARCHAR value that represents the cell ID\nin hexadecimal format."
        }
    ],
    "returns": "Returns a BOOLEAN or NULL."
},
{
    "function_name": "H3_IS_PENTAGON",
    "summary": "Returns TRUE if the boundary of an H3 cell represents a pentagon.",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/h3_is_pentagon",
    "title": "H3_IS_PENTAGON",
    "description": "Returns TRUE if the boundary of an",
    "syntax": "H3_IS_PENTAGON( <cell_id> )",
    "example": "SELECT H3_IS_PENTAGON(613036919424548863);\n\n+------------------------------------+\n| H3_IS_PENTAGON(613036919424548863) |\n|------------------------------------|\n| False                              |\n+------------------------------------+\n\nSELECT H3_IS_PENTAGON('804dfffffffffff');\n\n+-----------------------------------+\n| H3_IS_PENTAGON('804DFFFFFFFFFFF') |\n|-----------------------------------|\n| True                              |\n+-----------------------------------+",
    "arguments": [
        {
            "name": "cell_id",
            "description": "An INTEGER value that represents the H3 cell ID ( index ), or a VARCHAR value that represents the cell ID\nin hexadecimal format."
        }
    ],
    "returns": "Returns a BOOLEAN or NULL."
},
{
    "function_name": "H3_INT_TO_STRING",
    "summary": "Converts the INTEGER value of an H3 cell ID to hexadecimal format.",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/h3_int_to_string",
    "title": "H3_INT_TO_STRING",
    "description": "Converts the INTEGER value of an",
    "syntax": "H3_INT_TO_STRING( <cell_id> )",
    "example": "SELECT H3_INT_TO_STRING(617700171168612351);\n\n+------------------------------------------------+\n|          H3_INT_TO_STRING(617700171168612351)  |\n|------------------------------------------------|\n|                                89283087033FFFF |\n+------------------------------------------------+",
    "arguments": [
        {
            "name": "cell_id",
            "description": "An INTEGER value that represents the cell ID ( index )."
        }
    ],
    "returns": "Returns the H3 cell ID in hexadecimal format."
},
{
    "function_name": "H3_GRID_PATH",
    "summary": "Returns an array of the IDs of the H3 cells that represent the line between two cells.",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/h3_grid_path",
    "title": "H3_GRID_PATH",
    "description": "Returns an",
    "syntax": "H3_GRID_PATH( <cell_id_1> , <cell_id_2> )",
    "example": "SELECT H3_GRID_PATH(617540519103561727, 617540519052967935);\n\n+------------------------------------------------------+\n| H3_GRID_PATH(617540519103561727, 617540519052967935) |\n|------------------------------------------------------|\n| [                                                    |\n|   617540519103561727,                                |\n|   617540519046414335,                                |\n|   617540519047462911,                                |\n|   617540519044055039,                                |\n|   617540519045103615,                                |\n|   617540519052967935                                 |\n| ]                                                    |\n+------------------------------------------------------+\n\nSELECT H3_GRID_PATH('891f1d48b93ffff', '891f1d4888fffff');\n\n+----------------------------------------------------+\n| H3_GRID_PATH('891F1D48B93FFFF', '891F1D4888FFFFF') |\n|----------------------------------------------------|\n| [                                                  |\n|   \"891f1d48b93ffff\",                               |\n|   \"891f1d4882bffff\",                               |\n|   \"891f1d4883bffff\",                               |\n|   \"891f1d48807ffff\",                               |\n|   \"891f1d48817ffff\",                               |\n|   \"891f1d4888fffff\"                                |\n| ]                                                  |\n+----------------------------------------------------+",
    "arguments": [
        {
            "name": "cell_id_1",
            "description": "An INTEGER that represents the H3 cell ID ( index ), or a VARCHAR that represents the cell ID in hexadecimal format."
        },
        {
            "name": "cell_id_2",
            "description": "An INTEGER that represents the H3 cell ID ( index ), or a VARCHAR that represents the cell ID in hexadecimal format."
        }
    ],
    "returns": "Returns an ARRAY of the IDs of H3 cells that represent the line between the cells specified by cell_id_1 and\ncell_id_2. The IDs are in one of the following formats:"
},
{
    "function_name": "H3_GRID_DISTANCE",
    "summary": "Returns the distance between two H3 cells specified by their IDs.",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/h3_grid_distance",
    "title": "H3_GRID_DISTANCE",
    "description": "Returns the distance between two",
    "syntax": "H3_GRID_DISTANCE( <cell_id_1> , <cell_id_2> )",
    "example": "SELECT H3_GRID_DISTANCE(617540519103561727, 617540519052967935);\n\n+----------------------------------------------------------+\n| H3_GRID_DISTANCE(617540519103561727, 617540519052967935) |\n|----------------------------------------------------------|\n|                                                        5 |\n+----------------------------------------------------------+\n\nSELECT H3_GRID_DISTANCE('891f1d48b93ffff', '891f1d4888fffff');\n\n+--------------------------------------------------------+\n| H3_GRID_DISTANCE('891F1D48B93FFFF', '891F1D4888FFFFF') |\n|--------------------------------------------------------|\n|                                                      5 |\n+--------------------------------------------------------+",
    "arguments": [
        {
            "name": "cell_id_1",
            "description": "An INTEGER that represents the H3 cell ID ( index ), or a VARCHAR that represents the cell ID in hexadecimal format."
        },
        {
            "name": "cell_id_2",
            "description": "An INTEGER that represents the H3 cell ID ( index ), or a VARCHAR that represents the cell ID in hexadecimal format."
        }
    ],
    "returns": "Returns the INTEGER value that represents the distance in grid cells between the two H3 cells."
},
{
    "function_name": "H3_GRID_DISK",
    "summary": "Returns an array of the IDs of the H3 cells that are within the k-distance from the specified cell.",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/h3_grid_disk",
    "title": "H3_GRID_DISK",
    "description": "Returns an",
    "syntax": "H3_GRID_DISK( <cell_id> , <k_value> )",
    "example": "SELECT H3_GRID_DISK(617540519050084351, 1);\n\n+-------------------------------------+\n| H3_GRID_DISK(617540519050084351, 1) |\n|-------------------------------------|\n| [                                   |\n|   617540519050084351,               |\n|   617540519051657215,               |\n|   617540519050608639,               |\n|   617540519050870783,               |\n|   617540519050346495,               |\n|   617540519051395071,               |\n|   617540519051132927                |\n| ]                                   |\n+-------------------------------------+\n\nSELECT H3_GRID_DISK('891f1d48863ffff', 1);\n\n+------------------------------------+\n| H3_GRID_DISK('891F1D48863FFFF', 1) |\n|------------------------------------|\n| [                                  |\n|   \"891f1d48863ffff\",               |\n|   \"891f1d4887bffff\",               |\n|   \"891f1d4886bffff\",               |\n|   \"891f1d4886fffff\",               |\n|   \"891f1d48867ffff\",               |\n|   \"891f1d48877ffff\",               |\n|   \"891f1d48873ffff\"                |\n| ]                                  |\n+------------------------------------+",
    "arguments": [
        {
            "name": "cell_id",
            "description": "An INTEGER that represents the H3 cell ID ( index ), or a VARCHAR that represents the cell ID in hexadecimal format."
        },
        {
            "name": "k_value",
            "description": "An INTEGER that represents the grid distance. You must specify a non-negative value."
        }
    ],
    "returns": "Returns an ARRAY of the IDs of H3 cells that are within the distance k_value from the cell specified by\ncell_id. The IDs are in one of the following formats:"
},
{
    "function_name": "H3_GET_RESOLUTION",
    "summary": "Returns the resolution of an H3 cell.",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/h3_get_resolution",
    "title": "H3_GET_RESOLUTION",
    "description": "Returns the resolution of an",
    "syntax": "H3_GET_RESOLUTION( <cell_id> )",
    "example": "SELECT H3_GET_RESOLUTION(617540519050084351);\n\n+---------------------------------------+\n| H3_GET_RESOLUTION(617540519050084351) |\n|---------------------------------------|\n|                                     9 |\n+---------------------------------------+\n\nSELECT H3_GET_RESOLUTION('89283087033ffff');\n\n+--------------------------------------+\n| H3_GET_RESOLUTION('89283087033FFFF') |\n|--------------------------------------|\n|                                    9 |\n+--------------------------------------+",
    "arguments": [
        {
            "name": "cell_id",
            "description": "An INTEGER that represents the H3 cell ID ( index ), or a VARCHAR that represents the cell ID in hexadecimal format."
        }
    ],
    "returns": "Returns an INTEGER value between 0 and 15, which represents the resolution of the input H3 cell."
},
{
    "function_name": "H3_COVERAGE_STRINGS",
    "summary": "Returns an array of hexadecimal IDs (as VARCHAR values) identifying the minimal set of H3 cells that completely cover a shape (specified by a GEOGRAPHY object).",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/h3_coverage_strings",
    "title": "H3_COVERAGE_STRINGS",
    "description": "Returns an",
    "syntax": "H3_COVERAGE_STRINGS( <geography_expression> , <target_resolution> )",
    "example": "SELECT H3_COVERAGE_STRINGS(\n  TO_GEOGRAPHY(\n    'POLYGON((-122.481889 37.826683,-122.479487 37.808548,-122.474150 37.808904,-122.476510 37.826935,-122.481889 37.826683))'),\n  8) AS set_of_h3_cells_covering_polygon;\n\n+----------------------------------+\n| SET_OF_H3_CELLS_COVERING_POLYGON |\n|----------------------------------|\n| [                                |\n|   \"882830870bfffff\",             |\n|   \"8828308703fffff\",             |\n|   \"8828308739fffff\",             |\n|   \"8828308709fffff\",             |\n|   \"8828308701fffff\",             |\n|   \"8828308715fffff\"              |\n| ]                                |\n|----------------------------------|",
    "arguments": [
        {
            "name": "geography_expression",
            "description": "A GEOGRAPHY object."
        },
        {
            "name": "target_resolution",
            "description": "An INTEGER between 0 and 15 (inclusive) specifying the H3 resolution that you want to use for the returned H3 cells. Specifying any other INTEGER value results in an error."
        }
    ],
    "returns": "Returns an ARRAY of VARCHAR values for the hexadecimal IDs of the minimal set of H3 cells that completely cover the\nspecified input shape."
},
{
    "function_name": "H3_COVERAGE",
    "summary": "Returns an array of IDs (as INTEGER values) identifying the minimal set of H3 cells that completely cover a shape (specified by a GEOGRAPHY object).",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/h3_coverage",
    "title": "H3_COVERAGE",
    "description": "Returns an",
    "syntax": "H3_COVERAGE( <geography_expression> , <target_resolution> )",
    "example": "SELECT H3_COVERAGE(\n  TO_GEOGRAPHY(\n    'POLYGON((-122.481889 37.826683,-122.479487 37.808548,-122.474150 37.808904,-122.476510 37.826935,-122.481889 37.826683))'),\n  8) AS set_of_h3_cells_covering_polygon;\n\n+----------------------------------+\n| SET_OF_H3_CELLS_COVERING_POLYGON |\n|----------------------------------|\n| [                                |\n|   613196571542028287,            |\n|   613196571548319743,            |\n|   613196571598651391,            |\n|   613196571539931135,            |\n|   613196571560902655,            |\n|   613196571550416895             |\n| ]                                |\n+----------------------------------+",
    "arguments": [
        {
            "name": "geography_expression",
            "description": "A GEOGRAPHY object."
        },
        {
            "name": "target_resolution",
            "description": "An INTEGER between 0 and 15 (inclusive) specifying the H3 resolution that you want to use for the returned H3 cells. Specifying any other INTEGER value results in an error."
        }
    ],
    "returns": "Returns an ARRAY of INTEGER values for the IDs of the minimal set of H3 cells that have completely cover the specified input\nshape."
},
{
    "function_name": "H3_COMPACT_CELLS_STRINGS",
    "summary": "Returns an array of VARIANT values that contain the VARCHAR hexadecimal IDs of fewer, larger H3 cells that cover the same area as the H3 cells in the input.",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/h3_compact_cells_strings",
    "title": "H3_COMPACT_CELLS_STRINGS",
    "description": "Returns an",
    "syntax": "H3_COMPACT_CELLS_STRINGS( <array_of_cell_ids> )",
    "example": "SELECT H3_COMPACT_CELLS_STRINGS(\n  [\n    '8a2a10705507fff',\n    '8a2a1070550ffff',\n    '8a2a10705517fff',\n    '8a2a1070551ffff',\n    '8a2a10705527fff',\n    '8a2a1070552ffff',\n    '8a2a10705537fff',\n    '8a2a10705cdffff'\n    ]\n  ) AS compacted;\n\n+----------------------+\n| COMPACTED            |\n|----------------------|\n| [                    |\n|   \"8a2a10705cdffff\", |\n|   \"892a1070553ffff\"  |\n| ]                    |\n+----------------------+",
    "arguments": [
        {
            "name": "array_of_cell_ids",
            "description": "An array of VARIANT values that contain the VARCHAR hexadecimal values that represent H3 cell IDs ( indexes )."
        }
    ],
    "returns": "Returns a value of the ARRAY data type or NULL."
},
{
    "function_name": "H3_COMPACT_CELLS",
    "summary": "Returns an array of VARIANT values that contain the INTEGER IDs of fewer, larger H3 cells that cover the same area as the H3 cells in the input.",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/h3_compact_cells",
    "title": "H3_COMPACT_CELLS",
    "description": "Returns an",
    "syntax": "H3_COMPACT_CELLS( <array_of_cell_ids> )",
    "example": "SELECT H3_COMPACT_CELLS(\n  [\n    622236750562230271,\n    622236750562263039,\n    622236750562295807,\n    622236750562328575,\n    622236750562361343,\n    622236750562394111,\n    622236750562426879,\n    622236750558396415\n  ]\n) AS compacted;\n\n+-----------------------+\n| COMPACTED             |\n|-----------------------|\n| [                     |\n|   622236750558396415, |\n|   617733150935089151  |\n| ]                     |\n+-----------------------+",
    "arguments": [
        {
            "name": "array_of_cell_ids",
            "description": "An array of VARIANT values that contain the INTEGER values that represent H3 cell IDs ( indexes )."
        }
    ],
    "returns": "Returns a value of the ARRAY data type or NULL."
},
{
    "function_name": "H3_CELL_TO_POINT",
    "summary": "Returns the GEOGRAPHY object representing the Point that is the centroid of an H3 cell.",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/h3_cell_to_point",
    "title": "H3_CELL_TO_POINT",
    "description": "Returns the",
    "syntax": "H3_CELL_TO_POINT( <cell_id> )",
    "example": "SELECT H3_CELL_TO_POINT(613036919424548863);\n\n+--------------------------------------+\n| H3_CELL_TO_POINT(613036919424548863) |\n|--------------------------------------|\n| {                                    |\n|   \"coordinates\": [                   |\n|     1.337676791184706e+01,           |\n|     5.251638386722465e+01            |\n|   ],                                 |\n|   \"type\": \"Point\"                    |\n| }                                    |\n+--------------------------------------+\n\nSELECT H3_CELL_TO_POINT('881F1D4887FFFFF');\n\n+-------------------------------------+\n| H3_CELL_TO_POINT('881F1D4887FFFFF') |\n|-------------------------------------|\n| {                                   |\n|   \"coordinates\": [                  |\n|     1.337676791184706e+01,          |\n|     5.251638386722465e+01           |\n|   ],                                |\n|   \"type\": \"Point\"                   |\n| }                                   |\n+-------------------------------------+",
    "arguments": [
        {
            "name": "cell_id",
            "description": "An INTEGER that represents the H3 cell ID ( index ), or a VARCHAR that represents the cell ID in hexadecimal format."
        }
    ],
    "returns": "Returns a GEOGRAPHY object for the Point that represents the centroid of the H3 cell with the specified ID."
},
{
    "function_name": "H3_CELL_TO_PARENT",
    "summary": "Returns the ID of the parent of an H3 cell for a given resolution.",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/h3_cell_to_parent",
    "title": "H3_CELL_TO_PARENT",
    "description": "Returns the ID of the parent of an",
    "syntax": "H3_CELL_TO_PARENT( <cell_id> , <target_resolution> )",
    "example": "SELECT H3_CELL_TO_PARENT(613036919424548863, 7);\n\n+------------------------------------------+\n| H3_CELL_TO_PARENT(613036919424548863, 7) |\n|------------------------------------------|\n|                       608533319805566975 |\n+------------------------------------------+\n\nSELECT H3_CELL_TO_PARENT('881F1D4887FFFFF', 7);\n\n+-----------------------------------------+\n| H3_CELL_TO_PARENT('881F1D4887FFFFF', 7) |\n|-----------------------------------------|\n|  871F1D488FFFFFF                        |\n+-----------------------------------------+",
    "arguments": [
        {
            "name": "cell_id",
            "description": "An INTEGER that represents the H3 cell ID ( index ), or a VARCHAR that represents the cell ID in hexadecimal format."
        },
        {
            "name": "target_resolution",
            "description": "An INTEGER between 0 and 15 (inclusive) specifying the H3 resolution that you want to use for the returned H3 cell. Specifying any other INTEGER value results in an error."
        }
    ],
    "returns": "Returns the ID of the H3 parent cell at the specified target resolution. The ID is in one of the following formats:"
},
{
    "function_name": "H3_CELL_TO_CHILDREN_STRING",
    "summary": "Returns an array of the VARCHAR values containing the hexadecimal IDs of the children of an H3 cell for a given resolution.",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/h3_cell_to_children_string",
    "title": "H3_CELL_TO_CHILDREN_STRING",
    "description": "Returns an",
    "syntax": "H3_CELL_TO_CHILDREN_STRING( <cell_id> , <target_resolution> )",
    "example": "SELECT H3_CELL_TO_CHILDREN_STRING('881F1D4887FFFFF', 9);\n\n+--------------------------------------------------+\n| H3_CELL_TO_CHILDREN_STRING('881F1D4887FFFFF', 9) |\n|--------------------------------------------------|\n| [                                                |\n|   \"891f1d48863ffff\",                             |\n|   \"891f1d48867ffff\",                             |\n|   \"891f1d4886bffff\",                             |\n|   \"891f1d4886fffff\",                             |\n|   \"891f1d48873ffff\",                             |\n|   \"891f1d48877ffff\",                             |\n|   \"891f1d4887bffff\"                              |\n| ]                                                |\n+--------------------------------------------------+",
    "arguments": [
        {
            "name": "cell_id",
            "description": "A VARCHAR that represents the H3 cell ID ( index ) in hexadecimal format."
        },
        {
            "name": "target_resolution",
            "description": "An INTEGER between 0 and 15 (inclusive) specifying the H3 resolution that you want to use for the returned H3 cells. Specifying any other INTEGER value results in an error."
        }
    ],
    "returns": "Returns an array of the VARCHAR values of the hexadecimal IDs of the children of an H3 cell at the specified target resolution."
},
{
    "function_name": "H3_CELL_TO_CHILDREN",
    "summary": "Returns an array of the INTEGER IDs of the children of an H3 cell for a given resolution.",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/h3_cell_to_children",
    "title": "H3_CELL_TO_CHILDREN",
    "description": "Returns an",
    "syntax": "H3_CELL_TO_CHILDREN( <cell_id> , <target_resolution> )",
    "example": "SELECT H3_CELL_TO_CHILDREN(613036919424548863, 9);\n\n+--------------------------------------------+\n| H3_CELL_TO_CHILDREN(613036919424548863, 9) |\n|--------------------------------------------|\n| [                                          |\n|   617540519050084351,                      |\n|   617540519050346495,                      |\n|   617540519050608639,                      |\n|   617540519050870783,                      |\n|   617540519051132927,                      |\n|   617540519051395071,                      |\n|   617540519051657215                       |\n| ]                                          |\n+--------------------------------------------+",
    "arguments": [
        {
            "name": "cell_id",
            "description": "An INTEGER that represents the H3 cell ID ( index )."
        },
        {
            "name": "target_resolution",
            "description": "An INTEGER between 0 and 15 (inclusive) specifying the H3 resolution that you want to use for the returned H3 cells. Specifying any other INTEGER value results in an error."
        }
    ],
    "returns": "Returns an array of the INTEGER values of the IDs of the children of an H3 cell at the specified target resolution."
},
{
    "function_name": "H3_CELL_TO_BOUNDARY",
    "summary": "Returns the GEOGRAPHY object representing the boundary of an H3 cell.",
    "category": "Geospatial functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/h3_cell_to_boundary",
    "title": "H3_CELL_TO_BOUNDARY",
    "description": "Returns the",
    "syntax": "H3_CELL_TO_BOUNDARY( <cell_id> )",
    "example": "SELECT H3_CELL_TO_BOUNDARY(613036919424548863);\n\n+-----------------------------------------+\n| H3_CELL_TO_BOUNDARY(613036919424548863) |\n|-----------------------------------------|\n| {                                       |\n|   \"coordinates\": [                      |\n|     [                                   |\n|       [                                 |\n|         1.337146281884266e+01,          |\n|         5.251934565725256e+01           |\n|       ],                                |\n|       [                                 |\n|         1.336924966147084e+01,          |\n|         5.251510220405509e+01           |\n|       ],                                |\n|       [                                 |\n|         1.337455447449988e+01,          |\n|         5.251214028989955e+01           |\n|       ],                                |\n|       [                                 |\n|         1.338207263166664e+01,          |\n|         5.251342164903257e+01           |\n|       ],                                |\n|       [                                 |\n|         1.338428664751681e+01,          |\n|         5.251766506194694e+01           |\n|       ],                                |\n|       [                                 |\n|         1.337898164779325e+01,          |\n|         5.252062715603375e+01           |\n|       ],                                |\n|       [                                 |\n|         1.337146281884266e+01,          |\n|         5.251934565725256e+01           |\n|       ]                                 |\n|     ]                                   |\n|   ],                                    |\n|   \"type\": \"Polygon\"                     |\n| }                                       |\n+-----------------------------------------+\n\nSELECT H3_CELL_TO_BOUNDARY('881F1D4887FFFFF');\n\n+----------------------------------------+\n| H3_CELL_TO_BOUNDARY('881F1D4887FFFFF') |\n|----------------------------------------|\n| {                                      |\n|   \"coordinates\": [                     |\n|     [                                  |\n|       [                                |\n|         1.337146281884266e+01,         |\n|         5.251934565725256e+01          |\n|       ],                               |\n|       [                                |\n|         1.336924966147084e+01,         |\n|         5.251510220405509e+01          |\n|       ],                               |\n|       [                                |\n|         1.337455447449988e+01,         |\n|         5.251214028989955e+01          |\n|       ],                               |\n|       [                                |\n|         1.338207263166664e+01,         |\n|         5.251342164903257e+01          |\n|       ],                               |\n|       [                                |\n|         1.338428664751681e+01,         |\n|         5.251766506194694e+01          |\n|       ],                               |\n|       [                                |\n|         1.337898164779325e+01,         |\n|         5.252062715603375e+01          |\n|       ],                               |\n|       [                                |\n|         1.337146281884266e+01,         |\n|         5.251934565725256e+01          |\n|       ]                                |\n|     ]                                  |\n|   ],                                   |\n|   \"type\": \"Polygon\"                    |\n| }                                      |\n+----------------------------------------+",
    "arguments": [
        {
            "name": "cell_id",
            "description": "An INTEGER that represents the H3 cell ID ( index ), or a VARCHAR that represents the cell ID in hexadecimal format."
        }
    ],
    "returns": "Returns a GEOGRAPHY object that represents the boundary of the H3 cell with the specified ID."
},
{
    "function_name": "GROUPING_ID",
    "summary": "Describes which of a list of expressions are grouped in a row produced by a GROUP BY query.",
    "category": "Aggregate functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/grouping_id",
    "title": "GROUPING_ID",
    "description": "Describes which of a list of expressions are grouped in a row produced by a",
    "syntax": "GROUPING_ID( <expr1> [ , <expr2> , ... ] )",
    "example": "CREATE OR REPLACE TABLE aggr2(col_x int, col_y int, col_z int);\nINSERT INTO aggr2 VALUES (1, 2, 1), \n                         (1, 2, 3);\nINSERT INTO aggr2 VALUES (2, 1, 10), \n                         (2, 2, 11), \n                         (2, 2, 3);\n\nSELECT col_x, sum(col_z), GROUPING_ID(col_x)\n    FROM aggr2 \n    GROUP BY col_x\n    ORDER BY col_x;\n+-------+------------+--------------------+\n| COL_X | SUM(COL_Z) | GROUPING_ID(COL_X) |\n|-------+------------+--------------------|\n|     1 |          4 |                  0 |\n|     2 |         24 |                  0 |\n+-------+------------+--------------------+\n\nSELECT col_x, col_y, sum(col_z), \n       GROUPING_ID(col_x), \n       GROUPING_ID(col_y), \n       GROUPING_ID(col_x, col_y)\n    FROM aggr2 \n    GROUP BY GROUPING SETS ((col_x), (col_y), ())\n    ORDER BY col_x ASC, col_y DESC;\n+-------+-------+------------+--------------------+--------------------+---------------------------+\n| COL_X | COL_Y | SUM(COL_Z) | GROUPING_ID(COL_X) | GROUPING_ID(COL_Y) | GROUPING_ID(COL_X, COL_Y) |\n|-------+-------+------------+--------------------+--------------------+---------------------------|\n|     1 |  NULL |          4 |                  0 |                  1 |                         1 |\n|     2 |  NULL |         24 |                  0 |                  1 |                         1 |\n|  NULL |  NULL |         28 |                  1 |                  1 |                         3 |\n|  NULL |     2 |         18 |                  1 |                  0 |                         2 |\n|  NULL |     1 |         10 |                  1 |                  0 |                         2 |\n+-------+-------+------------+--------------------+--------------------+---------------------------+"
},
{
    "function_name": "GROUPING",
    "summary": "Describes which of a list of expressions are grouped in a row produced by a GROUP BY query.",
    "category": "Aggregate functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/grouping",
    "title": "GROUPING",
    "description": "Describes which of a list of expressions are grouped in a row produced by a",
    "syntax": "GROUPING( <expr1> [ , <expr2> , ... ] )",
    "example": "CREATE OR REPLACE TABLE aggr2(col_x int, col_y int, col_z int);\nINSERT INTO aggr2 VALUES(1, 2, 1), (1, 2, 3);\nINSERT INTO aggr2 VALUES(2, 1, 10), (2, 2, 11), (2, 2, 3);\n\nSELECT * FROM aggr2 ORDER BY col_x, col_y, col_z;\n+-------+-------+-------+\n| COL_X | COL_Y | COL_Z |\n|-------+-------+-------|\n|     1 |     2 |     1 |\n|     1 |     2 |     3 |\n|     2 |     1 |    10 |\n|     2 |     2 |     3 |\n|     2 |     2 |    11 |\n+-------+-------+-------+\n\nSELECT col_x, col_y, sum(col_z), \n       grouping(col_x), grouping(col_y), grouping(col_x, col_y)\n    FROM aggr2 GROUP BY GROUPING SETS ((col_x), (col_y), ())\n    ORDER BY 1, 2;\n+-------+-------+------------+-----------------+-----------------+------------------------+\n| COL_X | COL_Y | SUM(COL_Z) | GROUPING(COL_X) | GROUPING(COL_Y) | GROUPING(COL_X, COL_Y) |\n|-------+-------+------------+-----------------+-----------------+------------------------|\n|     1 |  NULL |          4 |               0 |               1 |                      1 |\n|     2 |  NULL |         24 |               0 |               1 |                      1 |\n|  NULL |     1 |         10 |               1 |               0 |                      2 |\n|  NULL |     2 |         18 |               1 |               0 |                      2 |\n|  NULL |  NULL |         28 |               1 |               1 |                      3 |\n+-------+-------+------------+-----------------+-----------------+------------------------+"
},
{
    "function_name": "GREATEST_IGNORE_NULLS",
    "summary": "Returns the largest non-NULL value from a list of expressions.",
    "category": "Conditional expression functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/greatest_ignore_nulls",
    "title": "GREATEST_IGNORE_NULLS",
    "description": "Returns the largest non-NULL value from a list of expressions. GREATEST_IGNORE_NULLS supports all data types,\nincluding VARIANT.",
    "syntax": "GREATEST_IGNORE_NULLS( <expr1> [ , <expr2> ... ] )",
    "example": "CREATE TABLE test_greatest_ignore_nulls (\n  col_1 INTEGER,\n  col_2 INTEGER,\n  col_3 INTEGER,\n  col_4 FLOAT);\n\nINSERT INTO test_greatest_ignore_nulls (col_1, col_2, col_3, col_4) VALUES\n  (1, 2,    3,  4.25),\n  (2, 4,   -1,  NULL),\n  (3, 6, NULL,  -2.75);\n\nSELECT col_1,\n       col_2,\n       col_3,\n       col_4,\n       GREATEST_IGNORE_NULLS(col_1, col_2, col_3, col_4) AS greatest_ignore_nulls\n FROM test_greatest_ignore_nulls\n ORDER BY col_1;\n\n+-------+-------+-------+-------+-----------------------+\n| COL_1 | COL_2 | COL_3 | COL_4 | GREATEST_IGNORE_NULLS |\n|-------+-------+-------+-------+-----------------------|\n|     1 |     2 |     3 |  4.25 |                  4.25 |\n|     2 |     4 |    -1 |  NULL |                  4    |\n|     3 |     6 |  NULL | -2.75 |                  6    |\n+-------+-------+-------+-------+-----------------------+",
    "arguments": [
        {
            "name": "exprN",
            "description": "The arguments must include at least one expression. All the expressions\nshould be of the same type or compatible types."
        }
    ],
    "returns": "The first argument determines the return type:"
},
{
    "function_name": "GREATEST",
    "summary": "Returns the largest value from a list of expressions.",
    "category": "Conditional expression functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/greatest",
    "title": "GREATEST",
    "description": "Returns the largest value from a list of expressions. GREATEST supports all data types, including VARIANT.",
    "syntax": "GREATEST( <expr1> [ , <expr2> ... ] )",
    "example": "CREATE TABLE test_table_1_greatest (\n  col_1 INTEGER, \n  col_2 INTEGER, \n  col_3 INTEGER, \n  col_4 FLOAT);\nINSERT INTO test_table_1_greatest (col_1, col_2, col_3, col_4) VALUES\n  (1, 2,    3,  4.00),\n  (2, 4,   -1, -2.00),\n  (3, 6, NULL, 13.45);\n\nSELECT col_1,\n       col_2,\n       col_3,\n       GREATEST(col_1, col_2, col_3) AS greatest\n  FROM test_table_1_greatest\n  ORDER BY col_1;\n\n+-------+-------+-------+----------+\n| COL_1 | COL_2 | COL_3 | GREATEST |\n|-------+-------+-------+----------|\n|     1 |     2 |     3 |        3 |\n|     2 |     4 |    -1 |        4 |\n|     3 |     6 |  NULL |     NULL |\n+-------+-------+-------+----------+\n\nSELECT col_1,\n       col_4,\n       GREATEST(col_1, col_4) AS greatest\n  FROM test_table_1_greatest\n  ORDER BY col_1;\n\n+-------+-------+----------+\n| COL_1 | COL_4 | GREATEST |\n|-------+-------+----------|\n|     1 |  4    |     4    |\n|     2 | -2    |     2    |\n|     3 | 13.45 |    13.45 |\n+-------+-------+----------+",
    "arguments": [
        {
            "name": "exprN",
            "description": "The arguments must include at least one expression. All the expressions\nshould be of the same type or compatible types."
        }
    ],
    "returns": "The first argument determines the return type:"
},
{
    "function_name": "GETVARIABLE",
    "summary": "Returns the value associated with a SQL variable name.",
    "category": "Context functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/getvariable",
    "title": "GETVARIABLE",
    "description": "Returns the value associated with a SQL variable name.",
    "syntax": "GETVARIABLE( '<name>' )",
    "example": "SET MY_LOCAL_VARIABLE= 'my_local_variable_value';\n+----------------------------------+\n| status                           |\n|----------------------------------|\n| Statement executed successfully. |\n+----------------------------------+\nSELECT \n    GETVARIABLE('MY_LOCAL_VARIABLE'), \n    SESSION_CONTEXT('MY_LOCAL_VARIABLE'),\n    $MY_LOCAL_VARIABLE;\n+----------------------------------+--------------------------------------+-------------------------+\n| GETVARIABLE('MY_LOCAL_VARIABLE') | SESSION_CONTEXT('MY_LOCAL_VARIABLE') | $MY_LOCAL_VARIABLE      |\n|----------------------------------+--------------------------------------+-------------------------|\n| my_local_variable_value          | my_local_variable_value              | my_local_variable_value |\n+----------------------------------+--------------------------------------+-------------------------+\n\nSET var_2 = 'value_2';\n+----------------------------------+\n| status                           |\n|----------------------------------|\n| Statement executed successfully. |\n+----------------------------------+\nSELECT \n    GETVARIABLE('var_2'),\n    GETVARIABLE('VAR_2'),\n    SESSION_CONTEXT('var_2'),\n    SESSION_CONTEXT('VAR_2'),\n    $var_2,\n    $VAR_2;\n+----------------------+----------------------+--------------------------+--------------------------+---------+---------+\n| GETVARIABLE('VAR_2') | GETVARIABLE('VAR_2') | SESSION_CONTEXT('VAR_2') | SESSION_CONTEXT('VAR_2') | $VAR_2  | $VAR_2  |\n|----------------------+----------------------+--------------------------+--------------------------+---------+---------|\n| NULL                 | value_2              | NULL                     | value_2                  | value_2 | value_2 |\n+----------------------+----------------------+--------------------------+--------------------------+---------+---------+",
    "arguments": [
        {
            "name": "name",
            "description": "The name of the SQL variable. You must specify the name in uppercase letters, even if you used lowercase letters when defining the variable."
        }
    ],
    "returns": "The data type of the return value is VARCHAR."
},
{
    "function_name": "GETDATE",
    "summary": "Returns the current timestamp for the system in the local time zone.",
    "category": "Context functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/getdate",
    "title": "GETDATE",
    "description": "Returns the current timestamp for the system in the local time zone.",
    "syntax": "GETDATE()",
    "example": "SELECT GETDATE();\n\n+-------------------------------+\n| GETDATE()                     |\n|-------------------------------|\n| 2024-04-17 15:44:20.960000000 |\n+-------------------------------+",
    "returns": "Returns the current system time. The data type of the returned value is\nTIMESTAMP_LTZ."
},
{
    "function_name": "GETBIT",
    "summary": "Given an INTEGER value, returns the value of a bit at a specified position.",
    "category": "Bitwise expression functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/getbit",
    "title": "GETBIT",
    "description": "Given an INTEGER value, returns the value of a bit at a specified position.",
    "syntax": "GETBIT( <integer_expr>, <bit_position> )",
    "example": "SELECT GETBIT(11, 100), GETBIT(11, 3), GETBIT(11, 2), GETBIT(11, 1), GETBIT(11, 0);\n\n+-----------------+---------------+---------------+---------------+---------------+\n| GETBIT(11, 100) | GETBIT(11, 3) | GETBIT(11, 2) | GETBIT(11, 1) | GETBIT(11, 0) |\n|-----------------+---------------+---------------+---------------+---------------|\n|               0 |             1 |             0 |             1 |             1 |\n+-----------------+---------------+---------------+---------------+---------------+",
    "arguments": [
        {
            "name": "integer_expr",
            "description": "This expression must evaluate to a data type that can be cast to an INTEGER value."
        },
        {
            "name": "bit_position",
            "description": "The position of the bit (starting from 0 for the least significant bit up to 127 for the most significant bit) for which\nto retrieve the value."
        }
    ],
    "returns": "The function returns the value of the bit (0 or 1) at the specified position."
},
{
    "function_name": "GET_STAGE_LOCATION",
    "summary": "Retrieves the URL for an external or internal named stage using the stage name as the input.",
    "category": "File functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/get_stage_location",
    "title": "GET_STAGE_LOCATION",
    "description": "Retrieves the URL for an external or internal named stage using the stage name as the input.",
    "syntax": "GET_STAGE_LOCATION( @<stage_name> )",
    "example": "CREATE STAGE images_stage URL = 's3://photos/national_parks/us/yosemite/';\n\nSELECT GET_STAGE_LOCATION(@images_stage);\n\n+----------------------------------------------------------+\n| GET_STAGE_LOCATION(@IMAGES_STAGE)                        |\n+----------------------------------------------------------+\n| s3://photos/national_parks/us/yosemite/                  |\n+----------------------------------------------------------+",
    "arguments": [
        {
            "name": "stage_name",
            "description": "Name of an external or internal named stage. Note If the stage name includes spaces or special characters, it must be enclosed in single quotes (e.g. '@\"my stage\"' for a stage\nnamed \"my stage\" )."
        }
    ],
    "returns": "URL of the cloud storage location in the stage definition."
},
{
    "function_name": "GET_RELATIVE_PATH",
    "summary": "Extracts the path of a staged file relative to its location in the stage using the stage name and absolute file path in cloud storage as inputs.",
    "category": "File functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/get_relative_path",
    "title": "GET_RELATIVE_PATH",
    "description": "Extracts the path of a staged file relative to its location in the stage using the stage name and absolute file path in cloud storage as inputs.",
    "syntax": "GET_RELATIVE_PATH( @<stage_name> , '<absolute_file_path>' )",
    "example": "SELECT GET_RELATIVE_PATH(@images_stage, 's3://photos/national_parks/us/yosemite/half_dome.jpg');\n+================================================================================---------------------+\n| GET_RELATIVE_PATH(@IMAGES_STAGE, 'S3://PHOTOS/NATIONAL_PARKS/US/YOSEMITE/HALF_DOME.JPG')  |\n+================================================================================---------------------+\n| us/yosemite/half_dome.jpg                                                                 |\n+================================================================================---------------------+",
    "arguments": [
        {
            "name": "stage_name",
            "description": "Name of the internal or external stage where the file is stored. Note If the stage name includes spaces or special characters, it must be enclosed in single quotes (e.g. '@\"my stage\"' for a stage\nnamed \"my stage\" )."
        },
        {
            "name": "absolute_file_path",
            "description": "Stage location, including the path and filename, of the file in cloud storage."
        }
    ],
    "returns": "Path of the file relative to the stage location."
},
{
    "function_name": "GET_QUERY_OPERATOR_STATS",
    "summary": "Returns statistics about individual query operators within a query that has completed.",
    "category": "System functions , Table functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/get_query_operator_stats",
    "title": "GET_QUERY_OPERATOR_STATS",
    "description": "Returns statistics about individual query operators within a query that has completed. You can run this function for any\ncompleted query that was executed in the past 14 days.",
    "syntax": "GET_QUERY_OPERATOR_STATS( <query_id> )",
    "example": "select x1.i, x2.i\n    from x1 inner join x2 on x2.i = x1.i\n    order by x1.i, x2.i;\n\nset lqid = (select last_query_id());\n\nselect * from table(get_query_operator_stats($lqid));\n+--------------------------------------+---------+-------------+--------------------+---------------+-----------------------------------------+-----------------------------------------------+----------------------------------------------------------------------+\n| QUERY_ID                             | STEP_ID | OPERATOR_ID | PARENT_OPERATORS   | OPERATOR_TYPE | OPERATOR_STATISTICS                     | EXECUTION_TIME_BREAKDOWN                      | OPERATOR_ATTRIBUTES                                                  |\n|--------------------------------------+---------+-------------+--------------------+---------------+-----------------------------------------+-----------------------------------------------+----------------------------------------------------------------------|\n| 01a8f330-0507-3f5b-0000-43830248e09a |       1 |           0 |               NULL | Result        | {                                       | {                                             | {                                                                    |\n|                                      |         |             |                    |               |   \"input_rows\": 64                      |   \"overall_percentage\": 0.000000000000000e+00 |   \"expressions\": [                                                   |\n|                                      |         |             |                    |               | }                                       | }                                             |     \"X1.I\",                                                          |\n|                                      |         |             |                    |               |                                         |                                               |     \"X2.I\"                                                           |\n|                                      |         |             |                    |               |                                         |                                               |   ]                                                                  |\n|                                      |         |             |                    |               |                                         |                                               | }                                                                    |\n| 01a8f330-0507-3f5b-0000-43830248e09a |       1 |           1 |              [ 0 ] | Sort          | {                                       | {                                             | {                                                                    |\n|                                      |         |             |                    |               |   \"input_rows\": 64,                     |   \"overall_percentage\": 0.000000000000000e+00 |   \"sort_keys\": [                                                     |\n|                                      |         |             |                    |               |   \"output_rows\": 64                     | }                                             |     \"X1.I ASC NULLS LAST\",                                           |\n|                                      |         |             |                    |               | }                                       |                                               |     \"X2.I ASC NULLS LAST\"                                            |\n|                                      |         |             |                    |               |                                         |                                               |   ]                                                                  |\n|                                      |         |             |                    |               |                                         |                                               | }                                                                    |\n| 01a8f330-0507-3f5b-0000-43830248e09a |       1 |           2 |              [ 1 ] | Join          | {                                       | {                                             | {                                                                    |\n|                                      |         |             |                    |               |   \"input_rows\": 128,                    |   \"overall_percentage\": 0.000000000000000e+00 |   \"equality_join_condition\": \"(X2.I = X1.I)\",                        |\n|                                      |         |             |                    |               |   \"output_rows\": 64                     | }                                             |   \"join_type\": \"INNER\"                                               |\n|                                      |         |             |                    |               | }                                       |                                               | }                                                                    |\n| 01a8f330-0507-3f5b-0000-43830248e09a |       1 |           3 |              [ 2 ] | TableScan     | {                                       | {                                             | {                                                                    |\n|                                      |         |             |                    |               |   \"io\": {                               |   \"overall_percentage\": 0.000000000000000e+00 |   \"columns\": [                                                       |\n|                                      |         |             |                    |               |     \"bytes_scanned\": 1024,              | }                                             |     \"I\"                                                              |\n|                                      |         |             |                    |               |     \"percentage_scanned_from_cache\": 1, |                                               |   ],                                                                 |\n|                                      |         |             |                    |               |     \"scan_progress\": 1                  |                                               |   \"table_name\": \"MY_DB.MY_SCHEMA.X2\" |\n|                                      |         |             |                    |               |   },                                    |                                               | }                                                                    |\n|                                      |         |             |                    |               |   \"output_rows\": 64,                    |                                               |                                                                      |\n|                                      |         |             |                    |               |   \"pruning\": {                          |                                               |                                                                      |\n|                                      |         |             |                    |               |     \"partitions_scanned\": 1,            |                                               |                                                                      |\n|                                      |         |             |                    |               |     \"partitions_total\": 1               |                                               |                                                                      |\n|                                      |         |             |                    |               |   }                                     |                                               |                                                                      |\n|                                      |         |             |                    |               | }                                       |                                               |                                                                      |\n| 01a8f330-0507-3f5b-0000-43830248e09a |       1 |           4 |              [ 2 ] | JoinFilter    | {                                       | {                                             | {                                                                    |\n|                                      |         |             |                    |               |   \"input_rows\": 64,                     |   \"overall_percentage\": 0.000000000000000e+00 |   \"join_id\": \"2\"                                                     |\n|                                      |         |             |                    |               |   \"output_rows\": 64                     | }                                             | }                                                                    |\n|                                      |         |             |                    |               | }                                       |                                               |                                                                      |\n| 01a8f330-0507-3f5b-0000-43830248e09a |       1 |           5 |              [ 4 ] | TableScan     | {                                       | {                                             | {                                                                    |\n|                                      |         |             |                    |               |   \"io\": {                               |   \"overall_percentage\": 0.000000000000000e+00 |   \"columns\": [                                                       |\n|                                      |         |             |                    |               |     \"bytes_scanned\": 1024,              | }                                             |     \"I\"                                                              |\n|                                      |         |             |                    |               |     \"percentage_scanned_from_cache\": 1, |                                               |   ],                                                                 |\n|                                      |         |             |                    |               |     \"scan_progress\": 1                  |                                               |   \"table_name\": \"MY_DB.MY_SCHEMA.X1\" |\n|                                      |         |             |                    |               |   },                                    |                                               | }                                                                    |\n|                                      |         |             |                    |               |   \"output_rows\": 64,                    |                                               |                                                                      |\n|                                      |         |             |                    |               |   \"pruning\": {                          |                                               |                                                                      |\n|                                      |         |             |                    |               |     \"partitions_scanned\": 1,            |                                               |                                                                      |\n|                                      |         |             |                    |               |     \"partitions_total\": 1               |                                               |                                                                      |\n|                                      |         |             |                    |               |   }                                     |                                               |                                                                      |\n|                                      |         |             |                    |               | }                                       |                                               |                                                                      |\n+--------------------------------------+---------+-------------+--------------------+---------------+-----------------------------------------+-----------------------------------------------+----------------------------------------------------------------------+\n\nselect *\nfrom t1\n    join t2 on t1.a = t2.a\n    join t3 on t1.b = t3.b\n    join t4 on t1.c = t4.c\n;\n\nset lid = last_query_id();\n\nselect\n        operator_id,\n        operator_attributes,\n        operator_statistics:output_rows / operator_statistics:input_rows as row_multiple\n    from table(get_query_operator_stats($lid))\n    where operator_type = 'Join'\n    order by step_id, operator_id;\n\n+---------+-------------+--------------------------------------------------------------------------+---------------+\n| STEP_ID | OPERATOR_ID | OPERATOR_ATTRIBUTES                                                      | ROW_MULTIPLE  |\n+---------+-------------+--------------------------------------------------------------------------+---------------+\n|       1 |           1 | {  \"equality_join_condition\": \"(T4.C = T1.C)\",   \"join_type\": \"INNER\"  } |  49.969249692 |\n|       1 |           3 | {  \"equality_join_condition\": \"(T3.B = T1.B)\",   \"join_type\": \"INNER\"  } | 116.071428571 |\n|       1 |           5 | {  \"equality_join_condition\": \"(T2.A = T1.A)\",   \"join_type\": \"INNER\"  } |  12.20657277  |\n+---------+-------------+--------------------------------------------------------------------------+---------------+",
    "arguments": [
        {
            "name": "query_id",
            "description": "The ID of a query. You can use: A string literal (a string surrounded by single quotes). A session variable containing a query ID. The return value from a call to the LAST_QUERY_ID function."
        }
    ],
    "returns": "The GET_QUERY_OPERATOR_STATS function is a table function. It returns rows with\nstatistics about each query operator in the query. For more information, see the\nUsage notes and Output sections below."
},
{
    "function_name": "GET_PYTHON_PROFILER_OUTPUT (SNOWFLAKE.CORE)",
    "summary": "Returns output containing a report generated by the Python code profiler.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/get_python_profiler_output",
    "title": "GET_PYTHON_PROFILER_OUTPUT (SNOWFLAKE.CORE)",
    "description": "Returns output containing a report generated by the",
    "syntax": "SNOWFLAKE.CORE.GET_PYTHON_PROFILER_OUTPUT(<query_id>)",
    "example": "Handler Name: main\nPython Runtime Version: 3.8\nModules Profiled: ['main_module']\nFile: _udf_code.py\nFunction: main at line 4\n\nLine #   Mem usage    Increment  Occurrences  Line Contents\n=============================================================\n    4    245.3 MiB    245.3 MiB           1   def main(session, last_n, total):\n    5                                             # create sample dataset to emulate id + elapsed time\n    6    245.8 MiB      0.5 MiB           1       session.sql('''\n    7                                                 CREATE OR REPLACE TABLE sample_query_history (query_id INT, elapsed_time FLOAT)''').collect()\n    8    245.8 MiB      0.0 MiB           2       session.sql('''\n    9                                             INSERT INTO sample_query_history\n    10                                             SELECT\n    11                                             seq8() AS query_id,\n    12                                             uniform(0::float, 100::float, random()) as elapsed_time\n    13    245.8 MiB      0.0 MiB           1       FROM table(generator(rowCount => {0}));'''.format(total)).collect()\n    14\n    15                                             # get the mean of the last n query elapsed time\n    16    245.8 MiB      0.0 MiB           3       df = session.table('sample_query_history').select(\n    17    245.8 MiB      0.0 MiB           1           funcs.col('query_id'),\n    18    245.8 MiB      0.0 MiB           2           funcs.col('elapsed_time')).limit(last_n)\n    19\n    20    327.9 MiB     82.1 MiB           1       pandas_df = df.to_pandas()\n    21    328.9 MiB      1.0 MiB           1       mean_time = pandas_df.loc[:, 'ELAPSED_TIME'].mean()\n    22    320.9 MiB     -8.0 MiB           1       del pandas_df\n    23    320.9 MiB      0.0 MiB           1       return mean_time",
    "arguments": [
        {
            "name": "query_id",
            "description": "Query ID of the stored procedure query for which profiling was enabled."
        }
    ],
    "returns": "A string of type VARCHAR with the report generated by the code profiler."
},
{
    "function_name": "GET_PRESIGNED_URL",
    "summary": "Generates a pre-signed URL to a file on a stage using the stage name and relative file path as inputs.",
    "category": "File functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/get_presigned_url",
    "title": "GET_PRESIGNED_URL",
    "description": "Generates a pre-signed URL to a file on a stage using the stage name and relative file path as inputs.",
    "syntax": "GET_PRESIGNED_URL( @<stage_name> , '<relative_file_path>' , [ <expiration_time> ] )",
    "example": "SELECT GET_PRESIGNED_URL(@images_stage, 'us/yosemite/half_dome.jpg', 3600);\n\n+================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================-------+\n| GET_PRESIGNED_URL(@IMAGES_STAGE, 'US/YOSEMITE/HALF_DOME.JPG', 3600)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |\n|================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================-------|\n| http://myaccount.s3.amazonaws.com/national_parks/us/yosemite/half_dome.jpg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxAus-west-xxxxxxxxxaws1_request&X-Amz-Date=20200625T162738Z&X-Amz-Expires=3600&X-Amz-Security-Token=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx-Amz-SignedHeaders=host&X-Amz-Signature=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx   |\n+================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================-------+\n\n{\n  \"file_url\": \"s3://photos/national_parks/us/yosemite/half_dome.jpg\",\n  \"image_format\": \"jpeg\",\n  \"dimensions\": {\"x\" : 1024, \"y\" : 768},\n  \"tags\":[\n    \"rock\",\n    \"cliff\",\n    \"valley\"\n  ],\n  \"dominant_color\": \"gray\"\n}\n\n-- Create a table to store the file metadata\n\n  CREATE TABLE images_table\n  (\n      file_url string,\n      image_format string,\n      dimensions_X number,\n      dimensions_Y number,\n      tags array,\n      dominant_color string,\n      relative_path string\n  );\n\n-- Load the metadata from the JSON document into the table.\n\nCOPY INTO images_table\n  FROM\n  (SELECT $1:file_url::STRING, $1:image_format::STRING, $1:size::NUMBER, $1:tags, $1:dominant_color::STRING, GET_RELATIVE_PATH(@images_stage, $1:file_url)\n  FROM\n  @images_stage/image_metadata.json)\n  FILE_FORMAT = (type = json);\n\n-- Create a view that queries the pre-signed URL for an image as well as the image metadata stored in a table.\nCREATE VIEW image_catalog AS\n(\n  SELECT\n   size,\n   get_presigned_url(@images_stage, relative_path) AS presigned_url,\n   tags\n  FROM\n    images_table\n);",
    "arguments": [
        {
            "name": "stage_name",
            "description": "Name of the internal or external stage where the file is stored. Note If the stage name includes spaces or special characters, it must be enclosed in single quotes (e.g. '@\"my stage\"' for a stage\nnamed \"my stage\" )."
        },
        {
            "name": "relative_file_path",
            "description": "Path and filename of the file relative to its location on the stage."
        },
        {
            "name": "expiration_time",
            "description": "Length of time (in seconds) after which the short term access token expires. Default value: 3600 (60 minutes). Maximum value: If the stage uses an AWS IAM role ( AWS_ROLE ) to securely connect to your S3 bucket,\nthe maximum expiration time is 3600 (60 minutes). Otherwise, the maximum expiration time is 604800 (7 days)."
        }
    ],
    "returns": "Pre-signed URL of the staged file."
},
{
    "function_name": "GET_PATH , :",
    "summary": "Extracts a value from semi-structured data using a path name.",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/get_path",
    "title": "GET_PATH ,",
    "description": "Extracts a value from semi-structured data using a path name.",
    "syntax": "GET_PATH( <column_identifier> , '<path_name>' )\n\n<column_identifier>:<path_name>\n\n:( <column_identifier> , '<path_name>' )",
    "example": "CREATE OR REPLACE TABLE get_path_demo(\n  id INTEGER,\n  v  VARIANT);\n\nINSERT INTO get_path_demo (id, v)\n  SELECT 1,\n         PARSE_JSON('{\n           \"array1\" : [\n             {\"id1\": \"value_a1\", \"id2\": \"value_a2\", \"id3\": \"value_a3\"}\n           ],\n           \"array2\" : [\n             {\"id1\": \"value_b1\", \"id2\": \"value_b2\", \"id3\": \"value_b3\"}\n           ],\n           \"object_outer_key1\" : {\n             \"object_inner_key1a\": \"object_x1\",\n             \"object_inner_key1b\": \"object_x2\"\n           }\n         }');\n\nINSERT INTO get_path_demo (id, v)\n  SELECT 2,\n         PARSE_JSON('{\n           \"array1\" : [\n             {\"id1\": \"value_c1\", \"id2\": \"value_c2\", \"id3\": \"value_c3\"}\n           ],\n           \"array2\" : [\n             {\"id1\": \"value_d1\", \"id2\": \"value_d2\", \"id3\": \"value_d3\"}\n           ],\n           \"object_outer_key1\" : {\n             \"object_inner_key1a\": \"object_y1\",\n             \"object_inner_key1b\": \"object_y2\"\n           }\n         }');\n\nSELECT * FROM get_path_demo;\n\n+----+----------------------------------------+\n| ID | V                                      |\n|----+----------------------------------------|\n|  1 | {                                      |\n|    |   \"array1\": [                          |\n|    |     {                                  |\n|    |       \"id1\": \"value_a1\",               |\n|    |       \"id2\": \"value_a2\",               |\n|    |       \"id3\": \"value_a3\"                |\n|    |     }                                  |\n|    |   ],                                   |\n|    |   \"array2\": [                          |\n|    |     {                                  |\n|    |       \"id1\": \"value_b1\",               |\n|    |       \"id2\": \"value_b2\",               |\n|    |       \"id3\": \"value_b3\"                |\n|    |     }                                  |\n|    |   ],                                   |\n|    |   \"object_outer_key1\": {               |\n|    |     \"object_inner_key1a\": \"object_x1\", |\n|    |     \"object_inner_key1b\": \"object_x2\"  |\n|    |   }                                    |\n|    | }                                      |\n|  2 | {                                      |\n|    |   \"array1\": [                          |\n|    |     {                                  |\n|    |       \"id1\": \"value_c1\",               |\n|    |       \"id2\": \"value_c2\",               |\n|    |       \"id3\": \"value_c3\"                |\n|    |     }                                  |\n|    |   ],                                   |\n|    |   \"array2\": [                          |\n|    |     {                                  |\n|    |       \"id1\": \"value_d1\",               |\n|    |       \"id2\": \"value_d2\",               |\n|    |       \"id3\": \"value_d3\"                |\n|    |     }                                  |\n|    |   ],                                   |\n|    |   \"object_outer_key1\": {               |\n|    |     \"object_inner_key1a\": \"object_y1\", |\n|    |     \"object_inner_key1b\": \"object_y2\"  |\n|    |   }                                    |\n|    | }                                      |\n+----+----------------------------------------+\n\nSELECT id,\n       GET_PATH(\n         v,\n         'array2[0].id3') AS id3_in_array2\n  FROM get_path_demo;\n\n+----+---------------+\n| ID | ID3_IN_ARRAY2 |\n|----+---------------|\n|  1 | \"value_b3\"    |\n|  2 | \"value_d3\"    |\n+----+---------------+\n\nSELECT id,\n       v:array2[0].id3 AS id3_in_array2\n  FROM get_path_demo;\n\n+----+---------------+\n| ID | ID3_IN_ARRAY2 |\n|----+---------------|\n|  1 | \"value_b3\"    |\n|  2 | \"value_d3\"    |\n+----+---------------+\n\nSELECT id,\n       v:\"array2\"[0].\"id3\" AS id3_in_array2\n  FROM get_path_demo;\n\n+----+---------------+\n| ID | ID3_IN_ARRAY2 |\n|----+---------------|\n|  1 | \"value_b3\"    |\n|  2 | \"value_d3\"    |\n+----+---------------+\n\nSELECT id,\n       GET_PATH(\n         v,\n         'object_outer_key1:object_inner_key1a') AS object_inner_key1A_values\n  FROM get_path_demo;\n\n+----+---------------------------+\n| ID | OBJECT_INNER_KEY1A_VALUES |\n|----+---------------------------|\n|  1 | \"object_x1\"               |\n|  2 | \"object_y1\"               |\n+----+---------------------------+\n\nSELECT id,\n       v:object_outer_key1.object_inner_key1a AS object_inner_key1a_values\n  FROM get_path_demo;\n\n+----+---------------------------+\n| ID | OBJECT_INNER_KEY1A_VALUES |\n|----+---------------------------|\n|  1 | \"object_x1\"               |\n|  2 | \"object_y1\"               |\n+----+---------------------------+\n\nSELECT id,\n       v:\"object_outer_key1\":\"object_inner_key1a\" AS object_inner_key1a_values\n  FROM get_path_demo;\n\n+----+---------------------------+\n| ID | OBJECT_INNER_KEY1A_VALUES |\n|----+---------------------------|\n|  1 | \"object_x1\"               |\n|  2 | \"object_y1\"               |\n+----+---------------------------+",
    "arguments": [
        {
            "name": "column_identifier",
            "description": "An expression that evaluates to a VARIANT, OBJECT, or ARRAY column."
        },
        {
            "name": "path_name",
            "description": "An expression that evaluates to a VARCHAR value. This value specifies the path to the field or element\nthat you want to extract. For structured types , you must specify a string constant."
        }
    ],
    "returns": "The returned value is the specified element of the ARRAY, or the value that corresponds to the specified key of a key-value\npair in the OBJECT."
},
{
    "function_name": "GET_OBJECT_REFERENCES",
    "summary": "Returns a list of objects that a specified object references.",
    "category": "Table functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/get_object_references",
    "title": "GET_OBJECT_REFERENCES",
    "description": "Returns a list of objects that a specified object references. Input is currently limited to the name of a view.",
    "syntax": "GET_OBJECT_REFERENCES(\n  DATABASE_NAME => '<string>'\n  , SCHEMA_NAME => '<string>'\n  , OBJECT_NAME => '<string>' )",
    "example": "-- create a database\ncreate or replace database ex1_gor_x;\nuse database ex1_gor_x;\nuse schema PUBLIC;\n\n-- create a set of tables\ncreate or replace table x_tab_a (mycol int not null);\ncreate or replace table x_tab_b (mycol int not null);\ncreate or replace table x_tab_c (mycol int not null);\n\n-- create views with increasing complexity of references\ncreate or replace view x_view_d as\nselect * from x_tab_a\njoin x_tab_b\nusing ( mycol );\n\ncreate or replace view x_view_e as\nselect x_tab_b.* from x_tab_b, x_tab_c\nwhere x_tab_b.mycol=x_tab_c.mycol;\n\n--create a second database\ncreate or replace database ex1_gor_y;\nuse database ex1_gor_y;\nuse schema PUBLIC;\n\n-- create a table in the second database\ncreate or replace table y_tab_a (mycol int not null);\n\n-- create more views with increasing levels of references\ncreate or replace view y_view_b as\nselect * from ex1_gor_x.public.x_tab_a\njoin y_tab_a\nusing ( mycol );\n\ncreate or replace view y_view_c as\nselect b.* from ex1_gor_x.public.x_tab_b b, ex1_gor_x.public.x_tab_c c\nwhere b.mycol=c.mycol;\n\ncreate or replace view y_view_d as\nselect * from ex1_gor_x.public.x_view_e;\n\ncreate or replace view y_view_e as\nselect e.* from ex1_gor_x.public.x_view_e e, y_tab_a\nwhere e.mycol=y_tab_a.mycol;\n\ncreate or replace view y_view_f as\nselect e.* from ex1_gor_x.public.x_view_e e, ex1_gor_x.public.x_tab_c c, y_tab_a\nwhere e.mycol=y_tab_a.mycol\nand e.mycol=c.mycol;\n\n-- retrieve the references for the last view created\nselect * from table(get_object_references(database_name=>'ex1_gor_y', schema_name=>'public', object_name=>'y_view_f'));\n\n+---------------+-------------+-----------+--------------------------+------------------------+------------------------+------------------------+\n| DATABASE_NAME | SCHEMA_NAME | VIEW_NAME | REFERENCED_DATABASE_NAME | REFERENCED_SCHEMA_NAME | REFERENCED_OBJECT_NAME | REFERENCED_OBJECT_TYPE |\n|---------------+-------------+-----------+--------------------------+------------------------+------------------------+------------------------|\n| EX1_GOR_Y     | PUBLIC      | Y_VIEW_F  | EX1_GOR_Y                | PUBLIC                 | Y_TAB_A                | TABLE                  |\n| EX1_GOR_Y     | PUBLIC      | Y_VIEW_F  | EX1_GOR_X                | PUBLIC                 | X_TAB_B                | TABLE                  |\n| EX1_GOR_Y     | PUBLIC      | Y_VIEW_F  | EX1_GOR_X                | PUBLIC                 | X_TAB_C                | TABLE                  |\n| EX1_GOR_Y     | PUBLIC      | Y_VIEW_F  | EX1_GOR_X                | PUBLIC                 | X_VIEW_E               | VIEW                   |\n+---------------+-------------+-----------+--------------------------+------------------------+------------------------+------------------------+",
    "arguments": [
        {
            "name": "DATABASE_NAME",
            "description": "Name of the database in which the schema and object reside."
        },
        {
            "name": "SCHEMA_NAME",
            "description": "Name of the schema in which the object resides."
        },
        {
            "name": "OBJECT_NAME",
            "description": "Name of the object. Currently limited to the name of a view (secure or not secure)."
        }
    ],
    "returns": "The function returns the following columns:"
},
{
    "function_name": "GET_LINEAGE (SNOWFLAKE.CORE)",
    "summary": "Given a Snowflake object, returns data lineage information upstream or downstream from that object.",
    "category": "Table functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/get_lineage-snowflake-core",
    "title": "GET_LINEAGE (SNOWFLAKE.CORE)",
    "syntax": "SNOWFLAKE.CORE.GET_LINEAGE(\n    '<object_name>',\n    '<object_domain>',\n    '<direction>',\n    [ <distance>, ]\n    [ '<object_version>' ]\n)",
    "arguments": [
        {
            "name": "'",
            "description": "Name of the object for which data lineage information is retrieved. Use the fully qualified name if the object is in a\nschema different from the current schema in the session."
        },
        {
            "name": "'",
            "description": "The domain of the object. Supported domains are ‘COLUMN’, ‘TABLE’ (which includes all table-like objects including\nviews and dynamic tables), and ‘STAGE’. For ML lineage, use TABLE for feature views (which are dynamic tables and\nviews internally), ‘DATASET’, or ‘MODULE’ for models."
        },
        {
            "name": "'",
            "description": "The direction for which the lineage should be retained. Supported directions are ‘UPSTREAM’ and ‘DOWNSTREAM’."
        },
        {
            "name": "distance",
            "description": "The number of levels of lineage to retrieve. The maximum is 5; this is also the default."
        },
        {
            "name": "'",
            "description": "For versioned objects, such as datasets and models, the version of the object for which lineage is retrieved. If not\nspecified, the default version is used."
        }
    ]
},
{
    "function_name": "GET_IGNORE_CASE",
    "summary": "Extracts a field value from an object; returns NULL if either of the arguments is NULL.",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/get_ignore_case",
    "title": "GET_IGNORE_CASE",
    "description": "Extracts a field value from an object; returns NULL if either of the arguments is NULL.",
    "example": "SELECT GET_IGNORE_CASE(TO_OBJECT(PARSE_JSON('{\"aa\":1, \"aA\":2, \"Aa\":3, \"AA\":4}')),'aA') as output;\n\n+--------+\n| OUTPUT |\n|--------|\n| 2      |\n+--------+\n\nSELECT GET_IGNORE_CASE(TO_OBJECT(PARSE_JSON('{\"aa\":1, \"aA\":2, \"Aa\":3}')),'AA') as output;\n\n+--------+\n| OUTPUT |\n|--------|\n| 3      |\n+--------+",
    "arguments": [
        {
            "name": "variant",
            "description": "An expression that evaluates to a VARIANT that contains either an ARRAY or an OBJECT."
        },
        {
            "name": "object",
            "description": "An expression that evaluates to an OBJECT that contains key-value pairs."
        },
        {
            "name": "field_name",
            "description": "An expression that evaluates to a VARCHAR. This specifies the key in a key-value pair for which you want to retrieve the value. field_name must not be an empty string. If object is a structured OBJECT , you must specify a constant for field_name . If object does not contain the specified key: If object is a semi-structured OBJECT, the function returns NULL. If object is a structured OBJECT, an error occurs."
        },
        {
            "name": "map",
            "description": "An expression that evaluates to a MAP ."
        },
        {
            "name": "key",
            "description": "The key in a key-value pair for which you want to retrieve the value. If map does not contain the specified key, the function returns NULL."
        }
    ],
    "returns": "The returned value is the specified element of the ARRAY, or the value that corresponds to the specified key of a key-value\npair in the OBJECT."
},
{
    "function_name": "GET_DDL",
    "summary": "Returns a DDL statement that can be used to recreate the specified object.",
    "category": "Metadata functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/get_ddl",
    "title": "GET_DDL",
    "description": "Returns a DDL statement that can be used to recreate the specified object. For databases and schemas, GET_DDL is recursive\n(that is, it returns the DDL statements for recreating all supported objects within the specified database/schema).",
    "syntax": "GET_DDL( '<object_type>' , '[<namespace>.]<object_name>' [ , <use_fully_qualified_names_for_recreated_objects> ] )",
    "example": "SELECT GET_DDL('VIEW', 'books_view');\n+-----------------------------------------------------------------------------+ \n| GET_DDL('VIEW', 'BOOKS_VIEW')                                               |\n|-----------------------------------------------------------------------------|\n|                                                                             |\n| CREATE OR REPLACE VIEW BOOKS_VIEW as select title, author from books_table; |\n|                                                                             |\n+-----------------------------------------------------------------------------+\n\nSELECT GET_DDL('SCHEMA', 'books_schema');\n+-----------------------------------------------------------------------------+ \n| GET_DDL('SCHEMA', 'BOOKS_SCHEMA')                                           |\n|-----------------------------------------------------------------------------|\n| CREATE OR REPLACE SCHEMA BOOKS_SCHEMA;                                      |\n|                                                                             |\n| CREATE OR REPLACE TABLE BOOKS_TABLE (                                       |\n| \tID NUMBER(38,0),                                                          |\n| \tTITLE VARCHAR(255),                                                       |\n| \tAUTHOR VARCHAR(255)                                                       |\n| );                                                                          |\n|                                                                             |\n| CREATE OR REPLACE VIEW BOOKS_VIEW as select title, author from books_table; |\n|                                                                             |\n+-----------------------------------------------------------------------------+\n\nSELECT GET_DDL('SCHEMA', 'books_schema', true);\n+---------------------------------------------------------------------------------------------------+\n| GET_DDL('SCHEMA', 'BOOKS_SCHEMA', TRUE)                                                           |\n|---------------------------------------------------------------------------------------------------|\n| CREATE OR REPLACE SCHEMA BOOKS_DB.BOOKS_SCHEMA;                                                   |\n|                                                                                                   |\n| CREATE OR REPLACE TABLE BOOKS_DB.BOOKS_SCHEMA.BOOKS_TABLE (                                       |\n| \tID NUMBER(38,0),                                                                                |\n| \tTITLE VARCHAR(255),                                                                             |\n| \tAUTHOR VARCHAR(255)                                                                             |\n| );                                                                                                |\n|                                                                                                   |\n| CREATE OR REPLACE VIEW BOOKS_DB.BOOKS_SCHEMA.BOOKS_VIEW as select title, author from books_table; |\n|                                                                                                   |\n+---------------------------------------------------------------------------------------------------+\n\nSELECT GET_DDL('FUNCTION', 'multiply(number, number)');\n\n+--------------------------------------------------+\n| GET_DDL('FUNCTION', 'MULTIPLY(NUMBER, NUMBER)')  |\n+--------------------------------------------------+\n| CREATE OR REPLACE \"MULTIPLY\"(A NUMBER, B NUMBER) |\n| RETURNS NUMBER(38,0)                             |\n| COMMENT='multiply two numbers'                   |\n| AS 'a * b';                                      |\n+--------------------------------------------------+\n\nSELECT GET_DDL('procedure', 'stproc_1(float)');\n+---------------------------------------------------+\n| GET_DDL('PROCEDURE', 'STPROC_1(FLOAT)')           |\n|---------------------------------------------------|\n| CREATE OR REPLACE PROCEDURE \"STPROC_1\"(\"F\" FLOAT) |\n| RETURNS FLOAT                                     |\n| LANGUAGE JAVASCRIPT                               |\n| EXECUTE AS OWNER                                  |\n| AS '                                              |\n| ''return F;''                                     |\n| ';                                                |\n+---------------------------------------------------+\n\nSELECT GET_DDL('POLICY', 'employee_ssn_mask');\n\n+----------------------------------------------------------------------------+\n|                   GET_DDL('POLICY', 'EMPLOYEE_SSN_MASK')                   |\n+----------------------------------------------------------------------------+\n| CREATE MASKING POLICY employee_ssn_mask AS (val string) RETURNS string ->  |\n| case                                                                       |\n|   when current_role() in ('PAYROLL')                                       |\n|   then val                                                                 |\n|   else '******'                                                            |\n| end;                                                                       |\n+----------------------------------------------------------------------------+\n\nSELECT GET_DDL('INTEGRATION', s3_int);\n\n+----------------------------------------------------------------------------+\n| GET_DDL('INTEGRATION', 's3_int')                                           |\n|----------------------------------------------------------------------------|\n| CREATE OR REPLACE STORAGE INTEGRATION s3_int                               |\n|   TYPE = EXTERNAL_STAGE                                                    |\n|   STORAGE_PROVIDER = 'S3'                                                  |\n|   STORAGE_AWS_ROLE_ARN = 'arn:aws:iam::001234567890:role/myrole'           |\n|   STORAGE_AWS_EXTERNAL_ID='ACCOUNT_SFCRole=2_kztjogs3W9S18I+iWapHpIz/wq4=' |\n|   ENABLED = TRUE                                                           |\n|   STORAGE_ALLOWED_LOCATIONS = ('s3://mybucket1/path1/');                   |\n+----------------------------------------------------------------------------+\n\nCREATE OR REPLACE WAREHOUSE my_wh\n  WAREHOUSE_SIZE=LARGE\n  INITIALLY_SUSPENDED=TRUE;\n\nSELECT GET_DDL('WAREHOUSE', 'my_wh');\n\n+-------------------------------------------+\n| GET_DDL('WAREHOUSE', 'MY_WH')             |\n|-------------------------------------------|\n| create or replace warehouse MY_WH         |\n| with                                      |\n|     warehouse_type='STANDARD'             |\n|     warehouse_size='Large'                |\n|     max_cluster_count=1                   |\n|     min_cluster_count=1                   |\n|     scaling_policy=STANDARD               |\n|     auto_suspend=600                      |\n|     auto_resume=TRUE                      |\n|     initially_suspended=TRUE              |\n|     enable_query_acceleration=FALSE       |\n|     query_acceleration_max_scale_factor=8 |\n|     max_concurrency_level=8               |\n|     statement_queued_timeout_in_seconds=0 |\n|     statement_timeout_in_seconds=172800   |\n| ;                                         |\n+-------------------------------------------+\n\nCREATE OR REPLACE HYBRID TABLE ht_weather\n (id INT PRIMARY KEY,\n  start_time TIMESTAMP,\n  precip NUMBER(3,2),\n  city VARCHAR(20),\n  county VARCHAR(20));\n\nSELECT GET_DDL('TABLE','ht_weather');\n\n+---------------------------------------------+\n| GET_DDL('TABLE','HT_WEATHER')               |\n|---------------------------------------------|\n| create or replace HYBRID TABLE HT_WEATHER ( |\n|   ID NUMBER(38,0) NOT NULL,                 |\n|   START_TIME TIMESTAMP_NTZ(9),              |\n|   PRECIP NUMBER(3,2),                       |\n|   CITY VARCHAR(20),                         |\n|   COUNTY VARCHAR(20),                       |\n|   primary key (ID)                          |\n| );                                          |\n+---------------------------------------------+",
    "arguments": [
        {
            "name": "'",
            "description": "Specifies the type of object for which the DDL is returned. Valid values (corresponding to the supported object types) are: DATABASE DYNAMIC_TABLE EVENT_TABLE FILE_FORMAT FUNCTION (for UDFs, including data metric functions and external functions) ICEBERG_TABLE INTEGRATION (storage) PIPE POLICY (aggregation, authentication, join, masking, password, projection, row access, and session policies) PROCEDURE (for stored procedures) SCHEMA SEMANTIC VIEW SEQUENCE STREAM TABLE (for tables, external tables, and hybrid tables) TAG (object tagging) TASK VIEW (for views and materialized views) WAREHOUSE"
        },
        {
            "name": "'",
            "description": "Specifies the fully-qualified name of the object for which the DDL is returned. Namespace is the database and/or schema in which the object resides: Not used for databases. For schemas, takes the form of database . For schema objects (tables, views, streams, tasks, sequences, file formats, pipes, policies, and UDFs), takes the form of database . schema or schema . Namespace is optional if a database and schema are currently in use within the user session; otherwise, it is required."
        },
        {
            "name": "use_fully_qualified_names_for_recreated_objects",
            "description": "If TRUE, the generated DDL statements use fully-qualified names for the objects to be recreated. Default: FALSE. Note This does not affect the names of other objects referenced in the DDL statement (e.g. the name of a table referenced in\na view definition)."
        }
    ],
    "returns": "Returns a string (a VARCHAR value) containing the text of the DDL statement that created the object."
},
{
    "function_name": "GET_CONTACTS",
    "summary": "Returns the contacts associated with an object.",
    "category": "Table functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/get_contacts",
    "title": "GET_CONTACTS",
    "syntax": "SNOWFLAKE.CORE.GET_CONTACTS (\n  '<object_name>',\n  '<object_type>'\n  [ , '<contact_name>' ]\n)",
    "example": "SELECT * FROM TABLE(SNOWFLAKE.CORE.GET_CONTACTS('t1', 'TABLE'));"
},
{
    "function_name": "GET_CONDITION_QUERY_UUID",
    "summary": "Returns the query ID for the SQL statement executed for the condition of an alert.",
    "category": "Context functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/get_condition_query_uuid",
    "title": "GET_CONDITION_QUERY_UUID",
    "description": "Returns the query ID for the SQL statement executed for the condition of an",
    "syntax": "SNOWFLAKE.ALERT.GET_CONDITION_QUERY_UUID()",
    "returns": "The query ID for the SQL statement for the condition of the alert."
},
{
    "function_name": "GET_ANACONDA_PACKAGES_REPODATA",
    "summary": "Returns a list of third-party packages that are available from Anaconda.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/get_anaconda_packages_repodata",
    "title": "GET_ANACONDA_PACKAGES_REPODATA",
    "description": "Returns a list of third-party packages that are available from Anaconda.\nFor more information, see",
    "syntax": "SNOWFLAKE.SNOWPARK.GET_ANACONDA_PACKAGES_REPODATA( '<architecture>' )",
    "example": "USE ROLE ACCOUNTADMIN;\n\nselect SNOWFLAKE.SNOWPARK.GET_ANACONDA_PACKAGES_REPODATA('linux-64');",
    "arguments": [
        {
            "name": "architecture",
            "description": "String specifying the architecture, which can be: linux-64 , linux-aarch64 , or noarch ."
        }
    ],
    "returns": "Returns a JSON string that contains the contents of repodata.json, which is an index of the packages in a subdir. A subdir represents a particular archtecture. Each subdir will have its own repodata."
},
{
    "function_name": "GET_ABSOLUTE_PATH",
    "summary": "Retrieves the absolute path of a staged file using the stage name and path of the file relative to its location in the stage as inputs.",
    "category": "File functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/get_absolute_path",
    "title": "GET_ABSOLUTE_PATH",
    "description": "Retrieves the absolute path of a staged file using the stage name and path of the file relative to its location in the stage as inputs.",
    "syntax": "GET_ABSOLUTE_PATH( @<stage_name> , '<relative_file_path>' )",
    "example": "SELECT GET_ABSOLUTE_PATH(@images_stage, 'us/yosemite/half_dome.jpg');\n\n+------------------------------------------------------------------------------------------+\n| GET_ABSOLUTE_PATH(@IMAGES_STAGE, 'US/YOSEMITE/HALF_DOME.JPG')                            |\n+------------------------------------------------------------------------------------------+\n| s3://photos/national_parks/us/yosemite/half_dome.jpg                                     |\n+------------------------------------------------------------------------------------------+",
    "arguments": [
        {
            "name": "stage_name",
            "description": "Name of the internal or external stage where the file is stored. Note If the stage name includes spaces or special characters, it must be enclosed in single quotes (e.g. '@\"my stage\"' for a stage\nnamed \"my stage\" )."
        },
        {
            "name": "relative_file_path",
            "description": "Path and filename of the file relative to its location in the stage."
        }
    ],
    "returns": "Absolute path of the file in cloud storage."
},
{
    "function_name": "GET",
    "summary": "Extracts a value from an ARRAY or an OBJECT (or a VARIANT that contains an ARRAY or OBJECT).",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/get",
    "title": "GET",
    "description": "Extracts a value from an",
    "syntax": "GET( <array> , <index> )\n\nGET( <variant> , <index> )",
    "example": "CREATE TABLE vartab (a ARRAY, o OBJECT, v VARIANT);\nINSERT INTO vartab (a, o, v) \n  SELECT\n    ARRAY_CONSTRUCT(2.71, 3.14),\n    OBJECT_CONSTRUCT('Ukraine', 'Kyiv'::VARIANT, \n                     'France',  'Paris'::VARIANT),\n    TO_VARIANT(OBJECT_CONSTRUCT('weatherStationID', 42::VARIANT,\n                     'timestamp', '2022-03-07 14:00'::TIMESTAMP_LTZ::VARIANT,\n                     'temperature', 31.5::VARIANT,\n                     'sensorType', 'indoor'::VARIANT))\n    ;\n\nSELECT a, o, v FROM vartab;\n+---------+----------------------+-------------------------------------------------+\n| A       | O                    | V                                               |\n|---------+----------------------+-------------------------------------------------|\n| [       | {                    | {                                               |\n|   2.71, |   \"France\": \"Paris\", |   \"sensorType\": \"indoor\",                       |\n|   3.14  |   \"Ukraine\": \"Kyiv\"  |   \"temperature\": 31.5,                          |\n| ]       | }                    |   \"timestamp\": \"2022-03-07 14:00:00.000 -0800\", |\n|         |                      |   \"weatherStationID\": 42                        |\n|         |                      | }                                               |\n+---------+----------------------+-------------------------------------------------+\n\nSELECT GET(a, 0) FROM vartab;\n+-----------+\n| GET(A, 0) |\n|-----------|\n| 2.71      |\n+-----------+\n\nSELECT GET(o, 'Ukraine') FROM vartab;\n+-------------------+\n| GET(O, 'UKRAINE') |\n|-------------------|\n| \"Kyiv\"            |\n+-------------------+\n\nSELECT GET(v, 'temperature') FROM vartab;\n+-----------------------+\n| GET(V, 'TEMPERATURE') |\n|-----------------------|\n| 31.5                  |\n+-----------------------+",
    "arguments": [
        {
            "name": "array",
            "description": "An expression that evaluates to an ARRAY ."
        },
        {
            "name": "index",
            "description": "An expression that evaluates to an INTEGER. This specifies the position of the element to retrieve from the ARRAY. The\nposition is 0-based, not 1-based. If the index points outside of the array boundaries, or if the indexed element does not exist (in a sparse array): If array is a semi-structured ARRAY, this function returns NULL. If array is a structured ARRAY, an error occurs."
        },
        {
            "name": "variant",
            "description": "An expression that evaluates to a VARIANT that contains either an ARRAY or an OBJECT."
        },
        {
            "name": "object",
            "description": "An expression that evaluates to an OBJECT that contains key-value pairs."
        },
        {
            "name": "field_name",
            "description": "An expression that evaluates to a VARCHAR. This specifies the key in a key-value pair for which you want to retrieve the value. field_name must not be an empty string. If object is a structured OBJECT , you must specify a constant for field_name . If object does not contain the specified key: If object is a semi-structured OBJECT, the function returns NULL. If object is a structured OBJECT, an error occurs."
        },
        {
            "name": "map",
            "description": "An expression that evaluates to a MAP ."
        },
        {
            "name": "key",
            "description": "The key in a key-value pair for which you want to retrieve the value. If map does not contain the specified key, the function returns NULL."
        }
    ],
    "returns": "The returned value is the specified element of the ARRAY, or the value that corresponds to the specified key of a key-value\npair in the OBJECT."
},
{
    "function_name": "GENERATOR",
    "summary": "Creates rows of data based either on a specified number of rows, a specified generation period (in seconds), or both.",
    "category": "Table functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/generator",
    "title": "GENERATOR",
    "description": "Creates rows of data based either on a specified number of rows, a specified generation period (in seconds), or both. This system-defined table function enables synthetic row generation.",
    "syntax": "GENERATOR( ROWCOUNT => <count> [ , TIMELIMIT => <sec> ] )\n\nGENERATOR( [ TIMELIMIT => <sec> ] )",
    "example": "SELECT seq4(), uniform(1, 10, RANDOM(12)) \n  FROM TABLE(GENERATOR(ROWCOUNT => 10)) v \n  ORDER BY 1;\n+--------+----------------------------+\n| SEQ4() | UNIFORM(1, 10, RANDOM(12)) |\n|--------+----------------------------|\n|      0 |                          7 |\n|      1 |                          2 |\n|      2 |                          5 |\n|      3 |                          9 |\n|      4 |                          6 |\n|      5 |                          9 |\n|      6 |                          9 |\n|      7 |                          5 |\n|      8 |                          3 |\n|      9 |                          8 |\n+--------+----------------------------+\n\nSELECT seq4(), uniform(1, 10, 42) \n  FROM TABLE(GENERATOR(ROWCOUNT => 10)) v \n  ORDER BY 1;\n+--------+--------------------+\n| SEQ4() | UNIFORM(1, 10, 42) |\n|--------+--------------------|\n|      0 |                 10 |\n|      1 |                 10 |\n|      2 |                 10 |\n|      3 |                 10 |\n|      4 |                 10 |\n|      5 |                 10 |\n|      6 |                 10 |\n|      7 |                 10 |\n|      8 |                 10 |\n|      9 |                 10 |\n+--------+--------------------+\n\nSELECT seq4(), uniform(1, 10, RANDOM(12)) \n  FROM TABLE(GENERATOR()) v \n  ORDER BY 1;\n+--------+----------------------------+\n| SEQ4() | UNIFORM(1, 10, RANDOM(12)) |\n|--------+----------------------------|\n+--------+----------------------------+\n\nSELECT COUNT(seq4()) FROM TABLE(GENERATOR(TIMELIMIT => 10)) v;\n\n+---------------+\n| COUNT(SEQ4()) |\n|---------------|\n|    3615440896 |\n+---------------+"
},
{
    "function_name": "GENERATE_COLUMN_DESCRIPTION",
    "summary": "Generates a list of columns from a set of staged files that contain semi-structured data using the INFER_SCHEMA function output.",
    "category": "Metadata functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/generate_column_description",
    "title": "GENERATE_COLUMN_DESCRIPTION",
    "description": "Generates a list of columns from a set of staged files that contain semi-structured data using the",
    "syntax": "GENERATE_COLUMN_DESCRIPTION( <expr> , '<string>' )",
    "example": "-- Create a file format that sets the file type as Parquet.\nCREATE FILE FORMAT my_parquet_format\n  TYPE = parquet;\n\n-- Query the GENERATE_COLUMN_DESCRIPTION function.\nSELECT GENERATE_COLUMN_DESCRIPTION(ARRAY_AGG(OBJECT_CONSTRUCT(*)), 'table') AS COLUMNS\n  FROM TABLE (\n    INFER_SCHEMA(\n      LOCATION=>'@mystage',\n      FILE_FORMAT=>'my_parquet_format'\n    )\n  );\n\n+--------------------+\n| COLUMN_DESCRIPTION |\n|--------------------|\n| \"country\" VARIANT, |\n| \"continent\" TEXT   |\n+--------------------+\n\n-- The function output can be used to define the columns in a table.\nCREATE TABLE mytable (\"country\" VARIANT, \"continent\" TEXT);\n\n-- Query the GENERATE_COLUMN_DESCRIPTION function.\nSELECT GENERATE_COLUMN_DESCRIPTION(ARRAY_AGG(OBJECT_CONSTRUCT(*)), 'external_table') AS COLUMNS\n  FROM TABLE (\n    INFER_SCHEMA(\n      LOCATION=>'@mystage',\n      FILE_FORMAT=>'my_parquet_format'\n    )\n  );\n\n+---------------------------------------------+\n| COLUMN_DESCRIPTION                          |\n|---------------------------------------------|\n| \"country\" VARIANT AS ($1:country::VARIANT), |\n| \"continent\" TEXT AS ($1:continent::TEXT)    |\n+---------------------------------------------+\n\n-- Create a file format that sets the file type as Parquet.\nCREATE OR REPLACE FILE FORMAT my_parquet_format\n  TYPE = PARQUET\n  USE_VECTORIZED_SCANNER = TRUE;\n\n-- Query the GENERATE_COLUMN_DESCRIPTION function.\nSELECT GENERATE_COLUMN_DESCRIPTION(ARRAY_AGG(OBJECT_CONSTRUCT(*)), 'table') AS COLUMNS\n  FROM TABLE (\n    INFER_SCHEMA(\n      LOCATION=>'@my_int_stage',\n      FILE_FORMAT=>'my_parquet_format',\n      KIND => 'ICEBERG'\n    )\n  );\n\n+---------------------------------------------+\n| COLUMN_DESCRIPTION                          |\n|---------------------------------------------|\n| \"id\" INT NOT NULL,                          |\n| \"custnum\" INT NOT NULL                      |\n+---------------------------------------------+\n\n-- Query the GENERATE_COLUMN_DESCRIPTION function.\nSELECT GENERATE_COLUMN_DESCRIPTION(ARRAY_AGG(OBJECT_CONSTRUCT(*)), 'view') AS COLUMNS\n  FROM TABLE (\n    INFER_SCHEMA(\n      LOCATION=>'@mystage',\n      FILE_FORMAT=>'my_parquet_format'\n    )\n  );\n\n+--------------------+\n| COLUMN_DESCRIPTION |\n|--------------------|\n| \"country\" ,        |\n| \"continent\"        |\n+--------------------+",
    "arguments": [
        {
            "name": "expr",
            "description": "Output of the INFER_SCHEMA function formatted as an array."
        },
        {
            "name": "'",
            "description": "Type of object that could be created from the column list. The appropriate formatting for this type is applied to the output. Possible values are table , external_table , or view ."
        }
    ],
    "returns": "The function returns the list of columns in a set of staged files, which can be\nused as input when creating an object of the type identified in the second argument."
},
{
    "function_name": "FLOOR",
    "summary": "Returns values from input_expr rounded to the nearest equal or smaller integer, or to the nearest equal or smaller value with the specified number of places after the decimal point.",
    "category": "Numeric functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/floor",
    "title": "FLOOR",
    "description": "Returns values from",
    "syntax": "FLOOR( <input_expr> [, <scale_expr> ] )",
    "example": "SELECT FLOOR(135.135), FLOOR(-975.975);\n+----------------+-----------------+\n| FLOOR(135.135) | FLOOR(-975.975) |\n|----------------+-----------------|\n|            135 |            -976 |\n+----------------+-----------------+\n\nCREATE TABLE test_floor (n FLOAT, scale INTEGER);\nINSERT INTO test_floor (n, scale) VALUES\n   (-975.975, -1),\n   (-975.975,  0),\n   (-975.975,  2),\n   ( 135.135, -2),\n   ( 135.135,  0),\n   ( 135.135,  1),\n   ( 135.135,  3),\n   ( 135.135, 50),\n   ( 135.135, NULL)\n   ;\n\nSELECT n, scale, FLOOR(n, scale)\n  FROM test_floor\n  ORDER BY n, scale;\n+----------+-------+-----------------+\n|        N | SCALE | FLOOR(N, SCALE) |\n|----------+-------+-----------------|\n| -975.975 |    -1 |        -980     |\n| -975.975 |     0 |        -976     |\n| -975.975 |     2 |        -975.98  |\n|  135.135 |    -2 |         100     |\n|  135.135 |     0 |         135     |\n|  135.135 |     1 |         135.1   |\n|  135.135 |     3 |         135.135 |\n|  135.135 |    50 |         135.135 |\n|  135.135 |  NULL |            NULL |\n+----------+-------+-----------------+",
    "arguments": [
        {
            "name": "input_expr",
            "description": "The value or expression to operate on. The data type should be one of the numeric data types, such as FLOAT or NUMBER."
        },
        {
            "name": "scale_expr",
            "description": "The number of digits the output should include after the decimal point. The expression should evaluate to an\ninteger from -38 to +38. The default scale_expr is zero, meaning that the function removes all digits after the decimal point. For information about negative scales, see the Usage Notes below."
        }
    ],
    "returns": "The return type is based on the input type:"
},
{
    "function_name": "FLATTEN",
    "summary": "Flattens (explodes) compound values into multiple rows.",
    "category": "Table functions , Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/flatten",
    "title": "FLATTEN",
    "description": "Flattens (explodes) compound values into multiple rows.",
    "syntax": "FLATTEN( INPUT => <expr> [ , PATH => <constant_expr> ]\n                         [ , OUTER => TRUE | FALSE ]\n                         [ , RECURSIVE => TRUE | FALSE ]\n                         [ , MODE => 'OBJECT' | 'ARRAY' | 'BOTH' ] )",
    "example": "SELECT * FROM TABLE(FLATTEN(INPUT => PARSE_JSON('[1, ,77]'))) f;\n\n+-----+------+------+-------+-------+------+\n| SEQ |  KEY | PATH | INDEX | VALUE | THIS |\n|-----+------+------+-------+-------+------|\n|   1 | NULL | [0]  |     0 |     1 | [    |\n|     |      |      |       |       |   1, |\n|     |      |      |       |       |   ,  |\n|     |      |      |       |       |   77 |\n|     |      |      |       |       | ]    |\n|   1 | NULL | [2]  |     2 |    77 | [    |\n|     |      |      |       |       |   1, |\n|     |      |      |       |       |   ,  |\n|     |      |      |       |       |   77 |\n|     |      |      |       |       | ]    |\n+-----+------+------+-------+-------+------+\n\nSELECT * FROM TABLE(FLATTEN(INPUT => PARSE_JSON('{\"a\":1, \"b\":[77,88]}'), OUTER => TRUE)) f;\n\n+-----+-----+------+-------+-------+-----------+\n| SEQ | KEY | PATH | INDEX | VALUE | THIS      |\n|-----+-----+------+-------+-------+-----------|\n|     |     |      |       |       |   \"a\": 1, |\n|     |     |      |       |       |   \"b\": [  |\n|     |     |      |       |       |     77,   |\n|     |     |      |       |       |     88    |\n|     |     |      |       |       |   ]       |\n|     |     |      |       |       | }         |\n|   1 | b   | b    |  NULL | [     | {         |\n|     |     |      |       |   77, |   \"a\": 1, |\n|     |     |      |       |   88  |   \"b\": [  |\n|     |     |      |       | ]     |     77,   |\n|     |     |      |       |       |     88    |\n|     |     |      |       |       |   ]       |\n|     |     |      |       |       | }         |\n+-----+-----+------+-------+-------+-----------+\n\nSELECT * FROM TABLE(FLATTEN(INPUT => PARSE_JSON('{\"a\":1, \"b\":[77,88]}'), PATH => 'b')) f;\n\n+-----+------+------+-------+-------+-------+\n| SEQ |  KEY | PATH | INDEX | VALUE | THIS  |\n|-----+------+------+-------+-------+-------|\n|   1 | NULL | b[0] |     0 |    77 | [     |\n|     |      |      |       |       |   77, |\n|     |      |      |       |       |   88  |\n|     |      |      |       |       | ]     |\n|   1 | NULL | b[1] |     1 |    88 | [     |\n|     |      |      |       |       |   77, |\n|     |      |      |       |       |   88  |\n|     |      |      |       |       | ]     |\n+-----+------+------+-------+-------+-------+\n\nSELECT * FROM TABLE(FLATTEN(INPUT => PARSE_JSON('[]'))) f;\n\n+-----+-----+------+-------+-------+------+\n| SEQ | KEY | PATH | INDEX | VALUE | THIS |\n|-----+-----+------+-------+-------+------|\n+-----+-----+------+-------+-------+------+\n\nSELECT * FROM TABLE(FLATTEN(INPUT => PARSE_JSON('[]'), OUTER => TRUE)) f;\n\n+-----+------+------+-------+-------+------+\n| SEQ |  KEY | PATH | INDEX | VALUE | THIS |\n|-----+------+------+-------+-------+------|\n|   1 | NULL |      |  NULL |  NULL | []   |\n+-----+------+------+-------+-------+------+\n\nSELECT * FROM TABLE(FLATTEN(INPUT => PARSE_JSON('{\"a\":1, \"b\":[77,88], \"c\": {\"d\":\"X\"}}'))) f;\n\n+-----+-----+------+-------+------------+--------------+\n| SEQ | KEY | PATH | INDEX | VALUE      | THIS         |\n|-----+-----+------+-------+------------+--------------|\n|   1 | a   | a    |  NULL | 1          | {            |\n|     |     |      |       |            |   \"a\": 1,    |\n|     |     |      |       |            |   \"b\": [     |\n|     |     |      |       |            |     77,      |\n|     |     |      |       |            |     88       |\n|     |     |      |       |            |   ],         |\n|     |     |      |       |            |   \"c\": {     |\n|     |     |      |       |            |     \"d\": \"X\" |\n|     |     |      |       |            |   }          |\n|     |     |      |       |            | }            |\n|   1 | b   | b    |  NULL | [          | {            |\n|     |     |      |       |   77,      |   \"a\": 1,    |\n|     |     |      |       |   88       |   \"b\": [     |\n|     |     |      |       | ]          |     77,      |\n|     |     |      |       |            |     88       |\n|     |     |      |       |            |   ],         |\n|     |     |      |       |            |   \"c\": {     |\n|     |     |      |       |            |     \"d\": \"X\" |\n|     |     |      |       |            |   }          |\n|     |     |      |       |            | }            |\n|   1 | c   | c    |  NULL | {          | {            |\n|     |     |      |       |   \"d\": \"X\" |   \"a\": 1,    |\n|     |     |      |       | }          |   \"b\": [     |\n|     |     |      |       |            |     77,      |\n|     |     |      |       |            |     88       |\n|     |     |      |       |            |   ],         |\n|     |     |      |       |            |   \"c\": {     |\n|     |     |      |       |            |     \"d\": \"X\" |\n|     |     |      |       |            |   }          |\n|     |     |      |       |            | }            |\n+-----+-----+------+-------+------------+--------------+\n\nSELECT * FROM TABLE(FLATTEN(INPUT => PARSE_JSON('{\"a\":1, \"b\":[77,88], \"c\": {\"d\":\"X\"}}'),\n                            RECURSIVE => TRUE )) f;\n\n+-----+------+------+-------+------------+--------------+\n| SEQ | KEY  | PATH | INDEX | VALUE      | THIS         |\n|-----+------+------+-------+------------+--------------|\n|   1 | a    | a    |  NULL | 1          | {            |\n|     |      |      |       |            |   \"a\": 1,    |\n|     |      |      |       |            |   \"b\": [     |\n|     |      |      |       |            |     77,      |\n|     |      |      |       |            |     88       |\n|     |      |      |       |            |   ],         |\n|     |      |      |       |            |   \"c\": {     |\n|     |      |      |       |            |     \"d\": \"X\" |\n|     |      |      |       |            |   }          |\n|     |      |      |       |            | }            |\n|   1 | b    | b    |  NULL | [          | {            |\n|     |      |      |       |   77,      |   \"a\": 1,    |\n|     |      |      |       |   88       |   \"b\": [     |\n|     |      |      |       | ]          |     77,      |\n|     |      |      |       |            |     88       |\n|     |      |      |       |            |   ],         |\n|     |      |      |       |            |   \"c\": {     |\n|     |      |      |       |            |     \"d\": \"X\" |\n|     |      |      |       |            |   }          |\n|     |      |      |       |            | }            |\n|   1 | NULL | b[0] |     0 | 77         | [            |\n|     |      |      |       |            |   77,        |\n|     |      |      |       |            |   88         |\n|     |      |      |       |            | ]            |\n|   1 | NULL | b[1] |     1 | 88         | [            |\n|     |      |      |       |            |   77,        |\n|     |      |      |       |            |   88         |\n|     |      |      |       |            | ]            |\n|   1 | c    | c    |  NULL | {          | {            |\n|     |      |      |       |   \"d\": \"X\" |   \"a\": 1,    |\n|     |      |      |       | }          |   \"b\": [     |\n|     |      |      |       |            |     77,      |\n|     |      |      |       |            |     88       |\n|     |      |      |       |            |   ],         |\n|     |      |      |       |            |   \"c\": {     |\n|     |      |      |       |            |     \"d\": \"X\" |\n|     |      |      |       |            |   }          |\n|     |      |      |       |            | }            |\n|   1 | d    | c.d  |  NULL | \"X\"        | {            |\n|     |      |      |       |            |   \"d\": \"X\"   |\n|     |      |      |       |            | }            |\n+-----+------+------+-------+------------+--------------+\n\nSELECT * FROM TABLE(FLATTEN(INPUT => PARSE_JSON('{\"a\":1, \"b\":[77,88], \"c\": {\"d\":\"X\"}}'),\n                            RECURSIVE => TRUE, MODE => 'OBJECT' )) f;\n\n+-----+-----+------+-------+------------+--------------+\n| SEQ | KEY | PATH | INDEX | VALUE      | THIS         |\n|-----+-----+------+-------+------------+--------------|\n|   1 | a   | a    |  NULL | 1          | {            |\n|     |     |      |       |            |   \"a\": 1,    |\n|     |     |      |       |            |   \"b\": [     |\n|     |     |      |       |            |     77,      |\n|     |     |      |       |            |     88       |\n|     |     |      |       |            |   ],         |\n|     |     |      |       |            |   \"c\": {     |\n|     |     |      |       |            |     \"d\": \"X\" |\n|     |     |      |       |            |   }          |\n|     |     |      |       |            | }            |\n|   1 | b   | b    |  NULL | [          | {            |\n|     |     |      |       |   77,      |   \"a\": 1,    |\n|     |     |      |       |   88       |   \"b\": [     |\n|     |     |      |       | ]          |     77,      |\n|     |     |      |       |            |     88       |\n|     |     |      |       |            |   ],         |\n|     |     |      |       |            |   \"c\": {     |\n|     |     |      |       |            |     \"d\": \"X\" |\n|     |     |      |       |            |   }          |\n|     |     |      |       |            | }            |\n|   1 | c   | c    |  NULL | {          | {            |\n|     |     |      |       |   \"d\": \"X\" |   \"a\": 1,    |\n|     |     |      |       | }          |   \"b\": [     |\n|     |     |      |       |            |     77,      |\n|     |     |      |       |            |     88       |\n|     |     |      |       |            |   ],         |\n|     |     |      |       |            |   \"c\": {     |\n|     |     |      |       |            |     \"d\": \"X\" |\n|     |     |      |       |            |   }          |\n|     |     |      |       |            | }            |\n|   1 | d   | c.d  |  NULL | \"X\"        | {            |\n|     |     |      |       |            |   \"d\": \"X\"   |\n|     |     |      |       |            | }            |\n+-----+-----+------+-------+------------+--------------+\n\nCREATE OR REPLACE TABLE persons AS\n  SELECT column1 AS id, PARSE_JSON(column2) as c\n    FROM values\n      (12712555,\n       '{ name:  { first: \"John\", last: \"Smith\"},\n         contact: [\n         { business:[\n           { type: \"phone\", content:\"555-1234\" },\n           { type: \"email\", content:\"j.smith@example.com\" } ] } ] }'),\n      (98127771,\n       '{ name:  { first: \"Jane\", last: \"Doe\"},\n         contact: [\n         { business:[\n           { type: \"phone\", content:\"555-1236\" },\n           { type: \"email\", content:\"j.doe@example.com\" } ] } ] }') v;\n\nSELECT id as \"ID\",\n    f.value AS \"Contact\",\n    f1.value:type AS \"Type\",\n    f1.value:content AS \"Details\"\n  FROM persons p,\n    LATERAL FLATTEN(INPUT => p.c, PATH => 'contact') f,\n    LATERAL FLATTEN(INPUT => f.value:business) f1;\n\n+----------+-----------------------------------------+---------+-----------------------+\n|       ID | Contact                                 | Type    | Details               |\n|----------+-----------------------------------------+---------+-----------------------|\n| 12712555 | {                                       | \"phone\" | \"555-1234\"            |\n|          |   \"business\": [                         |         |                       |\n|          |     {                                   |         |                       |\n|          |       \"content\": \"555-1234\",            |         |                       |\n|          |       \"type\": \"phone\"                   |         |                       |\n|          |     },                                  |         |                       |\n|          |     {                                   |         |                       |\n|          |       \"content\": \"j.smith@example.com\", |         |                       |\n|          |       \"type\": \"email\"                   |         |                       |\n|          |     }                                   |         |                       |\n|          |   ]                                     |         |                       |\n|          | }                                       |         |                       |\n| 12712555 | {                                       | \"email\" | \"j.smith@example.com\" |\n|          |   \"business\": [                         |         |                       |\n|          |     {                                   |         |                       |\n|          |       \"content\": \"555-1234\",            |         |                       |\n|          |       \"type\": \"phone\"                   |         |                       |\n|          |     },                                  |         |                       |\n|          |     {                                   |         |                       |\n|          |       \"content\": \"j.smith@example.com\", |         |                       |\n|          |       \"type\": \"email\"                   |         |                       |\n|          |     }                                   |         |                       |\n|          |   ]                                     |         |                       |\n|          | }                                       |         |                       |\n| 98127771 | {                                       | \"phone\" | \"555-1236\"            |\n|          |   \"business\": [                         |         |                       |\n|          |     {                                   |         |                       |\n|          |       \"content\": \"555-1236\",            |         |                       |\n|          |       \"type\": \"phone\"                   |         |                       |\n|          |     },                                  |         |                       |\n|          |     {                                   |         |                       |\n|          |       \"content\": \"j.doe@example.com\",   |         |                       |\n|          |       \"type\": \"email\"                   |         |                       |\n|          |     }                                   |         |                       |\n|          |   ]                                     |         |                       |\n|          | }                                       |         |                       |\n| 98127771 | {                                       | \"email\" | \"j.doe@example.com\"   |\n|          |   \"business\": [                         |         |                       |\n|          |     {                                   |         |                       |\n|          |       \"content\": \"555-1236\",            |         |                       |\n|          |       \"type\": \"phone\"                   |         |                       |\n|          |     },                                  |         |                       |\n|          |     {                                   |         |                       |\n|          |       \"content\": \"j.doe@example.com\",   |         |                       |\n|          |       \"type\": \"email\"                   |         |                       |\n|          |     }                                   |         |                       |\n|          |   ]                                     |         |                       |\n|          | }                                       |         |                       |\n+----------+-----------------------------------------+---------+-----------------------+",
    "arguments": [
        {
            "name": "INPUT",
            "description": "The expression that will be flattened into rows. The expression must be of data type VARIANT, OBJECT, or ARRAY."
        },
        {
            "name": "PATH",
            "description": "The path to the element within a VARIANT data structure that needs to be flattened. Can be a zero-length string (that is, an empty path) if the\noutermost element is to be flattened. Default: Zero-length string (empty path)"
        },
        {
            "name": "OUTER",
            "description": "If FALSE , any input rows that cannot be expanded, either because they cannot be accessed in the path or because they have zero fields or entries, are completely omitted from the output. If TRUE , exactly one row is generated for zero-row expansions (with NULL in the KEY, INDEX, and VALUE columns). Default: FALSE Note A zero-row expansion of an empty compound displays NULL in the THIS output column, distinguishing it from an attempt to expand a non-existing or wrong kind of compound."
        },
        {
            "name": "RECURSIVE",
            "description": "If FALSE , only the element referenced by PATH is expanded. If TRUE , the expansion is performed for all sub-elements recursively. Default: FALSE"
        },
        {
            "name": "MODE",
            "description": "Specifies whether only objects, arrays, or both should be flattened. Default: BOTH"
        }
    ]
},
{
    "function_name": "FL_IS_VIDEO",
    "summary": "Checks if the input is a video FILE.",
    "category": "",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/fl_is_video",
    "title": "FL_IS_VIDEO",
    "syntax": "FL_IS_VIDEO( <file_expression> )\n\nFL_IS_VIDEO( <variant_expression> )",
    "example": "CREATE TABLE file_table(f FILE);\nINSERT INTO file_table SELECT TO_FILE(BUILD_STAGE_FILE_URL('@mystage', 'image.png'));\n\nSELECT FL_IS_VIDEO(f) FROM file_table;\n\n+-------------------+\n| FL_IS_VIDEO(F)    |\n|-------------------|\n| False             |\n+-------------------+\n\nCREATE TABLE file_table(f OBJECT);\nINSERT INTO file_table SELECT OBJECT_CONSTRUCT('STAGE', 'MYSTAGE', 'RELATIVE_PATH', 'movie.mp4', 'ETAG', '<ETAG value>',\n  'LAST_MODIFIED', 'Wed, 11 Dec 2024 20:24:00 GMT', 'SIZE', 105859, 'FILE_TYPE', 'video/mp4');\n\nSELECT FL_IS_VIDEO(f) FROM file_table;\n\n+-------------------+\n| FL_IS_VIDEO(F)    |\n|-------------------|\n| True              |\n+-------------------+",
    "arguments": [
        {
            "name": "file_expression",
            "description": "The argument must be an expression of type FILE."
        },
        {
            "name": "variant_expression",
            "description": "The argument must be an OBJECT representing a FILE."
        }
    ],
    "returns": "A BOOLEAN indicating whether the file is a video."
},
{
    "function_name": "FL_IS_IMAGE",
    "summary": "Checks if the input is an image FILE.",
    "category": "",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/fl_is_image",
    "title": "FL_IS_IMAGE",
    "syntax": "FL_IS_IMAGE( <file_expression> )\n\nFL_IS_IMAGE( <variant_expression> )",
    "example": "CREATE TABLE file_table(f FILE);\nINSERT INTO file_table SELECT TO_FILE(BUILD_STAGE_FILE_URL('@mystage', 'image.png'));\n\nSELECT FL_IS_IMAGE(f) FROM file_table;\n\n+-------------------+\n| FL_IS_IMAGE(F)    |\n|-------------------|\n| True              |\n+-------------------+\n\nCREATE TABLE file_table(f OBJECT);\nINSERT INTO file_table SELECT OBJECT_CONSTRUCT('STAGE', 'MYSTAGE', 'RELATIVE_PATH', 'document.pdf', 'ETAG', '<ETAG value>',\n  'LAST_MODIFIED', 'Wed, 11 Dec 2024 20:24:00 GMT', 'SIZE', 105859, 'FILE_TYPE', 'application/pdf');\n\nSELECT FL_IS_IMAGE(f) FROM file_table;\n\n+-------------------+\n| FL_IS_IMAGE(F)    |\n|-------------------|\n| False             |\n+-------------------+",
    "arguments": [
        {
            "name": "file_expression",
            "description": "The argument must be an expression of type FILE."
        },
        {
            "name": "variant_expression",
            "description": "The argument must be an OBJECT representing a FILE."
        }
    ],
    "returns": "A BOOLEAN indicating whether the file is an image."
},
{
    "function_name": "FL_IS_DOCUMENT",
    "summary": "Checks if the input is a document FILE.",
    "category": "",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/fl_is_document",
    "title": "FL_IS_DOCUMENT",
    "syntax": "FL_IS_DOCUMENT( <file_expression> )\n\nFL_IS_DOCUMENT( <variant_expression> )",
    "example": "CREATE TABLE file_table(f FILE);\nINSERT INTO file_table SELECT TO_FILE(BUILD_STAGE_FILE_URL('@mystage', 'image.png'));\n\nSELECT FL_IS_DOCUMENT(f) FROM file_table;\n\n+-------------------+\n| FL_IS_DOCUMENT(F) |\n|-------------------|\n| False             |\n+-------------------+\n\nCREATE TABLE file_table(f OBJECT);\nINSERT INTO file_table SELECT OBJECT_CONSTRUCT('STAGE', 'MYSTAGE', 'RELATIVE_PATH', 'document.pdf', 'ETAG', '<ETAG value>',\n  'LAST_MODIFIED', 'Wed, 11 Dec 2024 20:24:00 GMT', 'SIZE', 105859, 'FILE_TYPE', 'application/pdf');\n\nSELECT FL_IS_DOCUMENT(f) FROM file_table;\n\n+-------------------+\n| FL_IS_DOCUMENT(F) |\n|-------------------|\n| True              |\n+-------------------+",
    "arguments": [
        {
            "name": "file_expression",
            "description": "The argument must be an expression of type FILE."
        },
        {
            "name": "variant_expression",
            "description": "The argument must be an OBJECT representing a FILE."
        }
    ],
    "returns": "A BOOLEAN indicating whether the file is a document."
},
{
    "function_name": "FL_IS_COMPRESSED",
    "summary": "Checks if the input is a compressed FILE.",
    "category": "",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/fl_is_compressed",
    "title": "FL_IS_COMPRESSED",
    "syntax": "FL_IS_COMPRESSED( <file_expression> )\n\nFL_IS_COMPRESSED( <variant_expression> )",
    "example": "CREATE TABLE file_table(f FILE);\nINSERT INTO file_table SELECT TO_FILE(BUILD_STAGE_FILE_URL('@mystage', 'image.png'));\n\nSELECT FL_IS_COMPRESSED(f) FROM file_table;\n\n+---------------------+\n| FL_IS_COMPRESSED(F) |\n|---------------------|\n| False               |\n+---------------------+\n\nCREATE TABLE file_table(f OBJECT);\nINSERT INTO file_table SELECT OBJECT_CONSTRUCT('STAGE', 'MYSTAGE', 'RELATIVE_PATH', 'document.pdf.gz', 'ETAG', '<ETAG value>',\n  'LAST_MODIFIED', 'Wed, 11 Dec 2024 20:24:00 GMT', 'SIZE', 105859, 'FILE_TYPE', 'application/gzip');\n\nSELECT FL_IS_COMPRESSED(f) FROM file_table;\n\n+---------------------+\n| FL_IS_COMPRESSED(F) |\n|---------------------|\n| True                |\n+---------------------+",
    "arguments": [
        {
            "name": "file_expression",
            "description": "The argument must be an expression of type FILE."
        },
        {
            "name": "variant_expression",
            "description": "The argument must be an OBJECT representing a FILE."
        }
    ],
    "returns": "A BOOLEAN indicating whether the file is compressed."
},
{
    "function_name": "FL_IS_AUDIO",
    "summary": "Checks if the input is an audio FILE.",
    "category": "",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/fl_is_audio",
    "title": "FL_IS_AUDIO",
    "syntax": "FL_IS_AUDIO( <file_expression> )\n\nFL_IS_AUDIO( <variant_expression> )",
    "example": "CREATE TABLE file_table(f FILE);\ninsert into file_table select to_file(BUILD_STAGE_FILE_URL('@mystage', 'image.png'));\n\nSELECT FL_IS_AUDIO(f) FROM file_table;\n\n+-------------------+\n| FL_IS_AUDIO(F)    |\n|-------------------|\n| False             |\n+-------------------+\n\nCREATE TABLE file_table(f OBJECT);\n\nINSERT INTO file_table SELECT OBJECT_CONSTRUCT('STAGE', 'MYSTAGE', 'RELATIVE_PATH', 'music.mpeg', 'ETAG', '<ETAG value>',\n  'LAST_MODIFIED', 'Wed, 11 Dec 2024 20:24:00 GMT', 'SIZE', 105859, 'FILE_TYPE', 'audio/mpeg');\n\nSELECT FL_IS_AUDIO(f) FROM file_table;\n\n+-------------------+\n| FL_IS_AUDIO(F)    |\n|-------------------|\n| True              |\n+-------------------+",
    "arguments": [
        {
            "name": "file_expression",
            "description": "The argument must be an expression of type FILE."
        },
        {
            "name": "variant_expression",
            "description": "The argument must be an OBJECT representing a FILE."
        }
    ],
    "returns": "A BOOLEAN indicating whether the file is an audio file."
},
{
    "function_name": "FL_GET_STAGE_FILE_URL",
    "summary": "Returns the stage URL of a FILE.",
    "category": "",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/fl_get_stage_file_url",
    "title": "FL_GET_STAGE_FILE_URL",
    "syntax": "FL_GET_STAGE_FILE_URL( <file_expression> )\n\nFL_GET_STAGE_FILE_URL( <variant_expression> )",
    "example": "CREATE TABLE file_table(f FILE);\nINSERT INTO file_table SELECT TO_FILE(BUILD_STAGE_FILE_URL('@mystage', 'image.png'));\n\nSELECT FL_GET_STAGE_FILE_URL(f) FROM file_table;\n\n+-------------------------------------------------------------------------------------------+\n| FL_GET_STAGE_FILE_URL(F)                                                                  |\n|-------------------------------------------------------------------------------------------|\n| https://snowflake.account.snowflakecomputing.com/api/files/TEST/PUBLIC/MYSTAGE/image.png  |\n+-------------------------------------------------------------------------------------------+\n\nCREATE TABLE file_table(f OBJECT);\nINSERT INTO file_table SELECT OBJECT_CONSTRUCT('STAGE_FILE_URL', 'https://snowflake.account.snowflakecomputing.com/api/files/TEST/PUBLIC/MYSTAGE/image.png',\n  'ETAG', '<ETAG value>', 'LAST_MODIFIED', 'Wed, 11 Dec 2024 20:24:00 GMT', 'SIZE', 105859, 'CONTENT_TYPE', 'image/jpg');\n\nSELECT FL_GET_STAGE_FILE_URL(f) FROM file_table;\n\n+-------------------------------------------------------------------------------------------+\n| FL_GET_STAGE_FILE_URL(F)                                                                  |\n|-------------------------------------------------------------------------------------------|\n| https://snowflake.account.snowflakecomputing.com/api/files/TEST/PUBLIC/MYSTAGE/image.png  |\n+-------------------------------------------------------------------------------------------+",
    "arguments": [
        {
            "name": "file_expression",
            "description": "The argument must be an expression of type FILE."
        },
        {
            "name": "variant_expression",
            "description": "The argument must be an OBJECT representing a FILE."
        }
    ],
    "returns": "The URL of the file as a VARCHAR."
},
{
    "function_name": "FL_GET_STAGE",
    "summary": "Returns the stage name of a FILE.",
    "category": "",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/fl_get_stage",
    "title": "FL_GET_STAGE",
    "syntax": "FL_GET_STAGE( <file_expression> )\n\nFL_GET_STAGE( <variant_expression> )",
    "example": "CREATE TABLE file_table(f FILE);\nINSERT INTO file_table select TO_FILE(BUILD_STAGE_FILE_URL('@mystage', 'image.png'));\n\nSELECT FL_GET_STAGE(f) FROM file_table;\n\n+------------------------+\n| FL_GET_STAGE(F)        |\n|------------------------|\n| MYSTAGE                |\n+------------------------+\n\nCREATE TABLE file_table(f OBJECT);\nINSERT INTO file_table SELECT OBJECT_CONSTRUCT('STAGE', 'MYSTAGE', 'RELATIVE_PATH', 'image.jpg', 'ETAG', '<ETAG value>',\n  'LAST_MODIFIED', 'Wed, 11 Dec 2024 20:24:00 GMT', 'SIZE', 105859, 'CONTENT_TYPE', 'image/jpg');\n\nSELECT FL_GET_STAGE(f) FROM file_table;\n\n+------------------------+\n| FL_GET_STAGE(F)        |\n|------------------------|\n| MYSTAGE                |\n+------------------------+",
    "arguments": [
        {
            "name": "file_expression",
            "description": "The argument must be an expression of type FILE."
        },
        {
            "name": "variant_expression",
            "description": "The argument must be an OBJECT representing a FILE."
        }
    ],
    "returns": "The stage of the file as a VARCHAR."
},
{
    "function_name": "FL_GET_SIZE",
    "summary": "Returns the size, in bytes, of a FILE.",
    "category": "",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/fl_get_size",
    "title": "FL_GET_SIZE",
    "syntax": "FL_GET_SIZE( <file_expression> )\n\nFL_GET_SIZE( <variant_expression> )",
    "example": "CREATE TABLE file_table(f FILE);\nINSERT INTO file_table SELECT TO_FILE(BUILD_STAGE_FILE_URL('@mystage', 'image.png'));\n\nSELECT FL_GET_SIZE(f) FROM file_table;\n\n+-------------------+\n| FL_GET_SIZE(F)    |\n|-------------------|\n| 105859            |\n+-------------------+\n\nCREATE TABLE file_table(f OBJECT);\nINSERT INTO file_table SELECT OBJECT_CONSTRUCT('STAGE', 'MYSTAGE', 'RELATIVE_PATH', 'document.pdf', 'ETAG', '<ETAG value>', 'LAST_MODIFIED', 'Wed, 11 Dec 2024 20:24:00 GMT', 'SIZE', 105859, 'FILE_TYPE', 'application/pdf');\n\nSELECT FL_GET_SIZE(f) FROM file_table;\n\n+-------------------+\n| FL_GET_SIZE(F)    |\n|-------------------|\n| 105859            |\n+-------------------+",
    "arguments": [
        {
            "name": "file_expression",
            "description": "The argument must be an expression of type FILE."
        },
        {
            "name": "variant_expression",
            "description": "The argument must be an OBJECT representing a FILE."
        }
    ],
    "returns": "The size of the file in bytes as an INTEGER."
},
{
    "function_name": "FL_GET_SCOPED_FILE_URL",
    "summary": "Returns the scoped URL of a FILE.",
    "category": "",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/fl_get_scoped_file_url",
    "title": "FL_GET_SCOPED_FILE_URL",
    "syntax": "FL_GET_SCOPED_FILE_URL( <file_expression> )\n\nFL_GET_SCOPED_FILE_URL( <variant_expression> )",
    "example": "CREATE TABLE file_table(f FILE);\nINSERT INTO file_table SELECT TO_FILE(BUILD_SCOPED_FILE_URL('@mystage', 'image.png'));\n\nSELECT FL_GET_SCOPED_FILE_URL(f) FROM file_table;\n\n+--------------------------------------------------------------------------------------------------------------------+\n| FL_GET_SCOPED_FILE_URL(F)                                                                                          |\n|--------------------------------------------------------------------------------------------------------------------|\n| https://snowflake.account.snowflakecomputing.com/api/files/01ba4df2-0100-0001-0000-00040002e2b6/299017/Y6JShH6KjV  |\n+--------------------------------------------------------------------------------------------------------------------+\n\nCREATE TABLE file_table(f OBJECT);\nINSERT INTO file_table SELECT OBJECT_CONSTRUCT('SCOPED_FILE_URL', 'https://snowflake.account.snowflakecomputing.com/api/files/01ba4df2-0100-0001-0000-00040002e2b6/299017/Y6JShH6KjV',\n  'ETAG', '<ETAG value>', 'LAST_MODIFIED', 'Wed, 11 Dec 2024 20:24:00 GMT', 'SIZE', 105859, 'CONTENT_TYPE', 'image/jpg');\n\nSELECT FL_GET_SCOPED_FILE_URL(f) FROM file_table;\n\n+--------------------------------------------------------------------------------------------------------------------+\n| FL_GET_SCOPED_FILE_URL(F)                                                                                          |\n|--------------------------------------------------------------------------------------------------------------------|\n| https://snowflake.account.snowflakecomputing.com/api/files/01ba4df2-0100-0001-0000-00040002e2b6/299017/Y6JShH6KjV  |\n+--------------------------------------------------------------------------------------------------------------------+",
    "arguments": [
        {
            "name": "file_expression",
            "description": "The argument must be an expression of type FILE."
        },
        {
            "name": "variant_expression",
            "description": "The argument must be an OBJECT representing a FILE."
        }
    ],
    "returns": "The scoped URL of the file as a VARCHAR."
},
{
    "function_name": "FL_GET_RELATIVE_PATH",
    "summary": "Returns the relative path of a FILE.",
    "category": "",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/fl_get_relative_path",
    "title": "FL_GET_RELATIVE_PATH",
    "syntax": "FL_GET_RELATIVE_PATH( <file_expression> )\n\nFL_GET_RELATIVE_PATH( <variant_expression> )",
    "example": "CREATE TABLE file_table(f FILE);\nINSERT INTO file_table SELECT TO_FILE(BUILD_STAGE_FILE_URL('@mystage', 'image.png'));\n\nSELECT FL_GET_RELATIVE_PATH(f) FROM file_table;\n\n+-------------------------+\n| FL_GET_RELATIVE_PATH(F) |\n|-------------------------|\n| image.png               |\n+-------------------------+\n\nCREATE TABLE file_table(f OBJECT);\nINSERT INTO file_table SELECT OBJECT_CONSTRUCT('STAGE', 'MYSTAGE', 'RELATIVE_PATH', 'image.jpg', 'ETAG', '<ETAG value>',\n    'LAST_MODIFIED', 'Wed, 11 Dec 2024 20:24:00 GMT', 'SIZE', 105859, 'CONTENT_TYPE', 'image/jpg');\n\nSELECT FL_GET_RELATIVE_PATH(f) FROM file_table;\n\n+-------------------------+\n| FL_GET_RELATIVE_PATH(F) |\n|-------------------------|\n| image.png               |\n+-------------------------+",
    "arguments": [
        {
            "name": "file_expression",
            "description": "The argument must be an expression of type FILE."
        },
        {
            "name": "variant_expression",
            "description": "The argument must be an OBJECT representing a FILE."
        }
    ],
    "returns": "The relative path of the file within its stage as a VARCHAR."
},
{
    "function_name": "FL_GET_LAST_MODIFIED",
    "summary": "Returns the last modified date of a FILE.",
    "category": "",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/fl_get_last_modified",
    "title": "FL_GET_LAST_MODIFIED",
    "syntax": "FL_GET_LAST_MODIFIED( <file_expression> )\n\nFL_GET_LAST_MODIFIED( <variant_expression> )",
    "example": "CREATE TABLE file_table(f FILE);\nINSERT INTO file_table SELECT TO_FILE(BUILD_STAGE_FILE_URL('@mystage', 'image.png'));\n\nSELECT FL_GET_LAST_MODIFIED(f) FROM file_table;\n\n+-------------------------------+\n| FL_GET_LAST_MODIFIED(F)       |\n|-------------------------------|\n| Wed, 11 Dec 2024 20:24:00 GMT |\n+-------------------------------+\n\nCREATE TABLE file_table(f OBJECT);\nINSERT INTO file_table SELECT OBJECT_CONSTRUCT('STAGE', 'MYSTAGE', 'RELATIVE_PATH', 'image.jpg', 'ETAG', '<ETAG value>',\n    'LAST_MODIFIED', 'Wed, 11 Dec 2024 20:24:00 GMT', 'SIZE', 105859, 'CONTENT_TYPE', 'image/jpg');\n\nSELECT FL_GET_LAST_MODIFIED(f) FROM file_table;\n\n+-------------------------------+\n| FL_GET_LAST_MODIFIED(F)       |\n|-------------------------------|\n| Wed, 11 Dec 2024 20:24:00 GMT |\n+-------------------------------+",
    "arguments": [
        {
            "name": "file_expression",
            "description": "The argument must be an expression of type FILE."
        },
        {
            "name": "variant_expression",
            "description": "The argument must be an OBJECT representing a FILE."
        }
    ],
    "returns": "A TIMESTAMP value with the date the file was last modified."
},
{
    "function_name": "FL_GET_FILE_TYPE",
    "summary": "Returns the file type (modality) of a FILE.",
    "category": "",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/fl_get_file_type",
    "title": "FL_GET_FILE_TYPE",
    "syntax": "FL_GET_FILE_TYPE( <file_expression> )\n\nFL_GET_FILE_TYPE( <variant_expression> )",
    "example": "CREATE TABLE FILE_TABLE(f FILE);\nINSERT INTO file_table SELECT TO_FILE(BUILD_STAGE_FILE_URL('@mystage', 'image.png'));\n\nSELECT FL_GET_FILE_TYPE(f) FROM file_table;\n\n+------------------------+\n| FL_GET_FILE_TYPE(F)    |\n|------------------------|\n| image                  |\n+------------------------+\n\nCREATE TABLE file_table(f OBJECT);\nINSERT INTO file_table SELECT OBJECT_CONSTRUCT('STAGE', 'MYSTAGE', 'RELATIVE_PATH', 'document.pdf', 'ETAG', '<ETAG value>',\n  'LAST_MODIFIED', 'Wed, 11 Dec 2024 20:24:00 GMT', 'SIZE', 105859, 'FILE_TYPE', 'application/pdf');\n\nSELECT FL_GET_FILE_TYPE(f) FROM file_table;\n\n+------------------------+\n| FL_GET_FILE_TYPE(F)    |\n|------------------------|\n| document               |\n+------------------------+",
    "arguments": [
        {
            "name": "file_expression",
            "description": "The argument must be an expression of type FILE."
        },
        {
            "name": "variant_expression",
            "description": "The argument must be an OBJECT representing a FILE."
        }
    ],
    "returns": "One of following values as a VARCHAR:"
},
{
    "function_name": "FL_GET_ETAG",
    "summary": "Returns the content hash (ETAG) of a FILE.",
    "category": "",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/fl_get_etag",
    "title": "FL_GET_ETAG",
    "syntax": "FL_GET_ETAG( <file_expression> )\n\nFL_GET_ETAG( <variant_expression> )",
    "example": "CREATE TABLE file_table(f FILE);\nINSERT INTO file_table SELECT TO_FILE(BUILD_STAGE_FILE_URL('@mystage', 'image.png'));\n\nSELECT FL_GET_ETAG(f) FROM file_table;\n\n+-----------------------------------+\n| FL_GET_ETAG(F)                    |\n|-----------------------------------|\n| <ETAG value>                      |\n+-----------------------------------+\n\nCREATE TABLE file_table(f OBJECT);\nINSERT INTO file_table SELECT OBJECT_CONSTRUCT('STAGE', 'MYSTAGE', 'RELATIVE_PATH', 'image.jpg', 'ETAG', '<ETAG value>',\n  'LAST_MODIFIED', 'Wed, 11 Dec 2024 20:24:00 GMT', 'SIZE', 105859, 'CONTENT_TYPE', 'image/jpg');\n\nSELECT FL_GET_ETAG(f) FROM file_table;\n\n+-----------------------------------+\n| FL_GET_ETAG(F)                    |\n|-----------------------------------|\n| <ETAG value>                      |\n+-----------------------------------+",
    "arguments": [
        {
            "name": "file_expression",
            "description": "The argument must be an expression of type FILE."
        },
        {
            "name": "variant_expression",
            "description": "The argument must be an OBJECT representing a FILE."
        }
    ],
    "returns": "A VARCHAR value with the ETAG of the file."
},
{
    "function_name": "FL_GET_CONTENT_TYPE",
    "summary": "Returns the content type (also known as the MIME type) of a FILE.",
    "category": "",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/fl_get_content_type",
    "title": "FL_GET_CONTENT_TYPE",
    "syntax": "FL_GET_CONTENT_TYPE( <file_expression> )\n\nFL_GET_CONTENT_TYPE( <variant_expression> )",
    "example": "CREATE TABLE file_table(f FILE);\nINSERT INTO file_table\n    SELECT TO_FILE(BUILD_STAGE_FILE_URL('@mystage', 'image.png'));\n\nSELECT FL_GET_CONTENT_TYPE(f) FROM file_table;\n\n+------------------------+\n| FL_GET_CONTENT_TYPE(F) |\n|------------------------|\n| image/png              |\n+------------------------+\n\nCREATE TABLE file_table(f OBJECT);\nINSERT INTO file_table\n  SELECT object_construct('STAGE', 'MYSTAGE', 'RELATIVE_PATH', 'image.jpg', 'ETAG', '<ETAG value>',\n      'LAST_MODIFIED', 'Wed, 11 Dec 2024 20:24:00 GMT', 'SIZE', 105859, 'CONTENT_TYPE', 'image/jpg');\n\nSELECT FL_GET_CONTENT_TYPE(f) FROM file_table;\n\n+------------------------+\n| FL_GET_CONTENT_TYPE(F) |\n|------------------------|\n| image/jpg              |\n+------------------------+",
    "arguments": [
        {
            "name": "file_expression",
            "description": "The argument must be an expression of type FILE."
        },
        {
            "name": "variant_expression",
            "description": "The argument must be an OBJECT representing a FILE."
        }
    ],
    "returns": "Aa VARCHAR value with the MIME type of the file, for example 'image/png' for a PNG image file."
},
{
    "function_name": "FIRST_VALUE",
    "summary": "Returns the first value within an ordered group of values.",
    "category": "Window function syntax and usage",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/first_value",
    "title": "FIRST_VALUE",
    "description": "Returns the first value within an ordered group of values.",
    "syntax": "FIRST_VALUE( <expr> ) [ { IGNORE | RESPECT } NULLS ]\n  OVER ( [ PARTITION BY <expr1> ] ORDER BY <expr2>  [ { ASC | DESC } ] [ <window_frame> ] )",
    "example": "SELECT column1,\n       column2,\n       FIRST_VALUE(column2) OVER (PARTITION BY column1 ORDER BY column2 NULLS LAST) AS column2_first\n  FROM VALUES\n    (1, 10), (1, 11), (1, null), (1, 12),\n    (2, 20), (2, 21), (2, 22)\n  ORDER BY column1, column2;\n\n+---------+---------+---------------+\n| COLUMN1 | COLUMN2 | COLUMN2_FIRST |\n|---------+---------+---------------|\n|       1 |      10 |            10 |\n|       1 |      11 |            10 |\n|       1 |      12 |            10 |\n|       1 |    NULL |            10 |\n|       2 |      20 |            20 |\n|       2 |      21 |            20 |\n|       2 |      22 |            20 |\n+---------+---------+---------------+\n\nCREATE TABLE demo1 (i INTEGER, partition_col INTEGER, order_col INTEGER);\n\nINSERT INTO demo1 (i, partition_col, order_col) VALUES\n  (1, 1, 1),\n  (2, 1, 2),\n  (3, 1, 3),\n  (4, 1, 4),\n  (5, 1, 5),\n  (1, 2, 1),\n  (2, 2, 2),\n  (3, 2, 3),\n  (4, 2, 4);\n\nSELECT partition_col, order_col, i,\n       FIRST_VALUE(i)  OVER (PARTITION BY partition_col ORDER BY order_col\n         ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) AS FIRST_VAL,\n       NTH_VALUE(i, 2) OVER (PARTITION BY partition_col ORDER BY order_col\n         ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) AS NTH_VAL,\n       LAST_VALUE(i)   OVER (PARTITION BY partition_col ORDER BY order_col\n         ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) AS LAST_VAL\n  FROM demo1\n  ORDER BY partition_col, i, order_col;\n\n+---------------+-----------+---+-----------+---------+----------+\n| PARTITION_COL | ORDER_COL | I | FIRST_VAL | NTH_VAL | LAST_VAL |\n|---------------+-----------+---+-----------+---------+----------|\n|             1 |         1 | 1 |         1 |       2 |        2 |\n|             1 |         2 | 2 |         1 |       2 |        3 |\n|             1 |         3 | 3 |         2 |       3 |        4 |\n|             1 |         4 | 4 |         3 |       4 |        5 |\n|             1 |         5 | 5 |         4 |       5 |        5 |\n|             2 |         1 | 1 |         1 |       2 |        2 |\n|             2 |         2 | 2 |         1 |       2 |        3 |\n|             2 |         3 | 3 |         2 |       3 |        4 |\n|             2 |         4 | 4 |         3 |       4 |        4 |\n+---------------+-----------+---+-----------+---------+----------+",
    "arguments": [
        {
            "name": "expr",
            "description": "The expression that determines the return value."
        },
        {
            "name": "expr1",
            "description": "The expression by which to partition the rows. You can specify a single expression or a comma-separated list of expressions.\nFor example:"
        },
        {
            "name": "expr2",
            "description": "The expression by which to order the rows. You can specify a single expression or a comma-separated list of expressions.\nFor example:"
        },
        {
            "name": "{",
            "description": "Whether to ignore or respect NULL values when an expr contains NULL values: IGNORE NULLS returns the first non-NULL value. RESPECT NULLS returns a NULL value if it is the first value in the expression. Default: RESPECT NULLS"
        }
    ]
},
{
    "function_name": "FINETUNE (SNOWFLAKE.CORTEX)",
    "summary": "This function lets you create and manage large language models customized for your specific task.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/finetune-snowflake-cortex",
    "title": "FINETUNE (SNOWFLAKE.CORTEX)",
    "syntax": "FINETUNE (\n  { 'CREATE' | 'SHOW' | 'DESCRIBE' | 'CANCEL' }\n  ...\n  )"
},
{
    "function_name": "FINETUNE ('SHOW') (SNOWFLAKE.CORTEX)",
    "summary": "Lists all the fine-tuning jobs in the current account.",
    "category": "",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/finetune-show",
    "title": "FINETUNE ('SHOW') (SNOWFLAKE.CORTEX)",
    "syntax": "SNOWFLAKE.CORTEX.FINETUNE('SHOW')",
    "example": "SELECT SNOWFLAKE.CORTEX.FINETUNE('SHOW');\n\n[{\"id\":\"ft_9544250a-20a9-42b3-babe-74f0a6f88f60\",\"status\":\"SUCCESS\",\"base_model\":\"llama3.1-8b\",\"created_on\":1730835118114},\n{\"id\":\"ft_354cf617-2fd1-4ffa-a3f9-190633f42a25\",\"status\":\"ERROR\",\"base_model\":\"llama3.1-8b\",\"created_on\":1730834536632}]"
},
{
    "function_name": "FINETUNE ('DESCRIBE') (SNOWFLAKE.CORTEX)",
    "summary": "Describes the properties of a fine-tuning job.",
    "category": "",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/finetune-describe",
    "title": "FINETUNE ('DESCRIBE') (SNOWFLAKE.CORTEX)",
    "syntax": "SNOWFLAKE.CORTEX.FINETUNE(\n  'DESCRIBE',\n  '<finetune_job_id>'\n)",
    "example": "SELECT SNOWFLAKE.CORTEX.FINETUNE(\n  'DESCRIBE',\n  'ft_6556e15c-8f12-4d94-8cb0-87e6f2fd2299'\n);\n\n{\n  \"base_model\":\"mistral-7b\",\n  \"created_on\":1717004388348,\n  \"finished_on\":1717004691577,\n  \"id\":\"ft_6556e15c-8f12-4d94-8cb0-87e6f2fd2299\",\n  \"model\":\"mydb.myschema.my_tuned_model\",\n  \"progress\":1.0,\n  \"status\":\"SUCCESS\",\n  \"training_data\":\"SELECT prompt, completion FROM train\",\n  \"trained_tokens\":2670734,\n  \"training_result\":{\"validation_loss\":1.0138969421386719,\"training_loss\":0.6477728401547047},\n  \"validation_data\":\"SELECT prompt, completion FROM validation\",\n  \"options\":{\"max_epochs\":3}\n}"
},
{
    "function_name": "FINETUNE ('CREATE') (SNOWFLAKE.CORTEX)",
    "summary": "Creates a fine-tuning job.",
    "category": "",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/finetune-create",
    "title": "FINETUNE ('CREATE') (SNOWFLAKE.CORTEX)",
    "syntax": "SNOWFLAKE.CORTEX.FINETUNE(\n  'CREATE',\n  '<name>',\n  '<base_model>',\n  '<training_data_query>'\n  [\n    , '<validation_data_query>'\n    [, '<options>' ]\n  ]\n)",
    "example": "SELECT SNOWFLAKE.CORTEX.FINETUNE(\n  'CREATE',\n  'my_tuned_model',\n  'mistral-7b',\n  'SELECT prompt, completion FROM train',\n  'SELECT prompt, completion FROM validation'\n);\n\nSELECT SNOWFLAKE.CORTEX.FINETUNE(\n  'CREATE',\n  'my_tuned_model',\n  'mistral-7b',\n  'SELECT prompt, completion FROM train'\n);\n\nft_6556e15c-8f12-4d94-8cb0-87e6f2fd2299",
    "returns": "Column"
},
{
    "function_name": "FINETUNE ('CANCEL') (SNOWFLAKE.CORTEX)",
    "summary": "Cancels the specified fine-tuning job from the current schema.",
    "category": "",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/finetune-cancel",
    "title": "FINETUNE ('CANCEL') (SNOWFLAKE.CORTEX)",
    "syntax": "SNOWFLAKE.CORTEX.FINETUNE(\n  'CANCEL',\n  '<finetune_job_id>'\n)",
    "example": "SELECT SNOWFLAKE.CORTEX.FINETUNE(\n  'CANCEL',\n  'ft_194bbea4-1208-42f3-88c6-cfb202086125'\n);\n\nCanceled Cortex Fine-tuning job: ft_194bbea4-1208-42f3-88c6-cfb202086125"
},
{
    "function_name": "FILTER",
    "summary": "Filters an array based on the logic in a lambda expression.",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/filter",
    "title": "FILTER",
    "description": "Filters an",
    "syntax": "FILTER( <array> , <lambda_expression> )",
    "example": "SELECT FILTER(\n  [\n    {'name':'Pat', 'value': 50},\n    {'name':'Terry', 'value': 75},\n    {'name':'Dana', 'value': 25}\n  ],\n  a -> a:value >= 50) AS \"Filter >= 50\";\n\n+----------------------+\n| Filter >= 50         |\n|----------------------|\n| [                    |\n|   {                  |\n|     \"name\": \"Pat\",   |\n|     \"value\": 50      |\n|   },                 |\n|   {                  |\n|     \"name\": \"Terry\", |\n|     \"value\": 75      |\n|   }                  |\n| ]                    |\n+----------------------+\n\nSELECT FILTER([1, NULL, 3, 5, NULL], a -> a IS NOT NULL) AS \"Not NULL Elements\";\n\n+-------------------+\n| Not NULL Elements |\n|-------------------|\n| [                 |\n|   1,              |\n|   3,              |\n|   5               |\n| ]                 |\n+-------------------+\n\nCREATE OR REPLACE TABLE orders AS\n  SELECT 1 AS order_id, '2024-01-01' AS order_date, [\n    {'item':'UHD Monitor', 'quantity':3, 'subtotal':1500},\n    {'item':'Business Printer', 'quantity':1, 'subtotal':1200}\n  ] AS order_detail\n  UNION SELECT 2 AS order_id, '2024-01-02' AS order_date, [\n    {'item':'Laptop', 'quantity':5, 'subtotal':7500},\n    {'item':'Noise-canceling Headphones', 'quantity':5, 'subtotal':1000}\n  ] AS order_detail;\n\nSELECT * FROM orders;\n\n+----------+------------+-------------------------------------------+\n| ORDER_ID | ORDER_DATE | ORDER_DETAIL                              |\n|----------+------------+-------------------------------------------|\n|        1 | 2024-01-01 | [                                         |\n|          |            |   {                                       |\n|          |            |     \"item\": \"UHD Monitor\",                |\n|          |            |     \"quantity\": 3,                        |\n|          |            |     \"subtotal\": 1500                      |\n|          |            |   },                                      |\n|          |            |   {                                       |\n|          |            |     \"item\": \"Business Printer\",           |\n|          |            |     \"quantity\": 1,                        |\n|          |            |     \"subtotal\": 1200                      |\n|          |            |   }                                       |\n|          |            | ]                                         |\n|        2 | 2024-01-02 | [                                         |\n|          |            |   {                                       |\n|          |            |     \"item\": \"Laptop\",                     |\n|          |            |     \"quantity\": 5,                        |\n|          |            |     \"subtotal\": 7500                      |\n|          |            |   },                                      |\n|          |            |   {                                       |\n|          |            |     \"item\": \"Noise-canceling Headphones\", |\n|          |            |     \"quantity\": 5,                        |\n|          |            |     \"subtotal\": 1000                      |\n|          |            |   }                                       |\n|          |            | ]                                         |\n+----------+------------+-------------------------------------------+\n\nSELECT order_id,\n       order_date,\n       FILTER(o.order_detail, i -> i:subtotal >= 1500) ORDER_DETAIL_GT_EQUAL_1500\n  FROM orders o;\n\n+----------+------------+----------------------------+\n| ORDER_ID | ORDER_DATE | ORDER_DETAIL_GT_EQUAL_1500 |\n|----------+------------+----------------------------|\n|        1 | 2024-01-01 | [                          |\n|          |            |   {                        |\n|          |            |     \"item\": \"UHD Monitor\", |\n|          |            |     \"quantity\": 3,         |\n|          |            |     \"subtotal\": 1500       |\n|          |            |   }                        |\n|          |            | ]                          |\n|        2 | 2024-01-02 | [                          |\n|          |            |   {                        |\n|          |            |     \"item\": \"Laptop\",      |\n|          |            |     \"quantity\": 5,         |\n|          |            |     \"subtotal\": 7500       |\n|          |            |   }                        |\n|          |            | ]                          |\n+----------+------------+----------------------------+",
    "arguments": [
        {
            "name": "array",
            "description": "The array that contains the elements to be filtered. The array can be semi-structured or structured."
        },
        {
            "name": "lambda_expression",
            "description": "A lambda expression that defines the filter\ncondition on each array element. The lambda expression must have only one argument specified in the following syntax:"
        }
    ],
    "returns": "The return type of this function is an array of the same type as the input array. The returned array contains the elements\nfor which the filter condition returns TRUE."
},
{
    "function_name": "FACTORIAL",
    "summary": "Computes the factorial of its input.",
    "category": "Numeric functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/factorial",
    "title": "FACTORIAL",
    "description": "Computes the factorial of its input. The input argument must be an integer expression in the range of",
    "syntax": "FACTORIAL( <integer_expr> )",
    "example": "SELECT FACTORIAL(0), FACTORIAL(1), FACTORIAL(5), FACTORIAL(10);\n\n+--------------+--------------+--------------+---------------+\n| FACTORIAL(0) | FACTORIAL(1) | FACTORIAL(5) | FACTORIAL(10) |\n|--------------+--------------+--------------+---------------|\n|            1 |            1 |          120 |       3628800 |\n+--------------+--------------+--------------+---------------+"
},
{
    "function_name": "EXTRACT_SEMANTIC_CATEGORIES",
    "summary": "Returns a set of categories (semantic and privacy) for each supported column in the specified table or view.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/extract_semantic_categories",
    "title": "EXTRACT_SEMANTIC_CATEGORIES",
    "syntax": "EXTRACT_SEMANTIC_CATEGORIES( '<object_name>' [ , <max_rows_to_scan> ] )",
    "example": "USE ROLE data_engineer;\n\nUSE WAREHOUSE classification_wh;\n\nSELECT EXTRACT_SEMANTIC_CATEGORIES('my_db.my_schema.hr_data');\n\nUSE ROLE data_engineer;\n\nSELECT EXTRACT_SEMANTIC_CATEGORIES('my_db.my_schema.hr_data', 5000);\n\nUSE ROLE data_engineer;\n\nCREATE OR REPLACE TABLE classification_results(v VARIANT) AS\n  SELECT EXTRACT_SEMANTIC_CATEGORIES('my_db.my_schema.hr_data');",
    "arguments": [
        {
            "name": "object_name",
            "description": "The name of the table, external table, view, or materialized view containing the columns to be classified. If a database and\nschema is not in use in the current session, the name must be fully-qualified. The name must be specified exactly as it is stored in the database. If the name contains special characters, capitalization, or blank\nspaces, the name must be enclosed first in double-quotes and then in single quotes."
        },
        {
            "name": "max_rows_to_scan",
            "description": "The sample size of rows to use for determining the classification categories in the specified table/view. Valid values: 1 to 10000 Default: 10000"
        }
    ],
    "returns": "As a representative example, the JSON object has the following structure:"
},
{
    "function_name": "EXTRACT_ANSWER (SNOWFLAKE.CORTEX)",
    "summary": "Extracts an answer to a given question from a text document.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/extract_answer-snowflake-cortex",
    "title": "EXTRACT_ANSWER (SNOWFLAKE.CORTEX)",
    "description": "Extracts an answer to a given question from a text document. The document may be a plain-English document or a string\nrepresentation of a semi-structured (JSON) data object.",
    "syntax": "SNOWFLAKE.CORTEX.EXTRACT_ANSWER(\n    <source_document>, <question>)",
    "arguments": [
        {
            "name": "source_document",
            "description": "A string containing the plain-text or JSON document that contains the answer to the question."
        },
        {
            "name": "question",
            "description": "A string containing the question to be answered."
        }
    ],
    "returns": "A string containing an answer to the given question."
},
{
    "function_name": "EXTRACT",
    "summary": "Extracts the specified date or time part from a date, time, or timestamp.",
    "category": "Date & time functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/extract",
    "title": "EXTRACT",
    "description": "Extracts the specified date or time part from a date, time, or timestamp.",
    "syntax": "EXTRACT( <date_or_time_part> FROM <date_time_or_timestamp_expr> )",
    "example": "SELECT EXTRACT(year FROM TO_TIMESTAMP('2024-04-10T23:39:20.123-07:00')) AS YEAR;\n\n+------+\n| YEAR |\n|------|\n| 2024 |\n+------+\n\nSELECT DECODE(EXTRACT(dayofweek FROM SYSTIMESTAMP()),\n  1, 'Monday',\n  2, 'Tuesday',\n  3, 'Wednesday',\n  4, 'Thursday',\n  5, 'Friday',\n  6, 'Saturday',\n  7, 'Sunday') AS DAYOFWEEK;\n\n+-----------+\n| DAYOFWEEK |\n|-----------|\n| Thursday  |\n+-----------+",
    "arguments": [
        {
            "name": "date_or_time_part",
            "description": "The unit of time. Must be one of the values listed in Supported date and time parts (e.g. month ).\nThe value can be a string literal or can be unquoted (for example, 'month' or month ). When date_or_time_part is week (or any of its variations), the output is controlled by the WEEK_START session parameter. When date_or_time_part is dayofweek or yearofweek (or any of their variations), the output is controlled by the WEEK_OF_YEAR_POLICY and WEEK_START session parameters. For more information, including examples, see Calendar weeks and weekdays ."
        },
        {
            "name": "date_time_or_timestamp_expr",
            "description": "A date, a time, or a timestamp, or an expression that can be evaluated to a date, a time, or a timestamp."
        }
    ],
    "returns": "Returns a value of NUMBER data type."
},
{
    "function_name": "EXTERNAL_TABLE_FILE_REGISTRATION_HISTORY",
    "summary": "This table function can be used to query information about the metadata history for an external table.",
    "category": "Information Schema , Table functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/external_table_registration_history",
    "title": "EXTERNAL_TABLE_FILE_REGISTRATION_HISTORY",
    "description": "This table function can be used to query information about the metadata history for an external table, including:",
    "syntax": "EXTERNAL_TABLE_FILE_REGISTRATION_HISTORY (\n      TABLE_NAME => '<string>'\n      [, START_TIME => <constant_expr> ] )",
    "example": "select *\nfrom table(information_schema.external_table_file_registration_history(TABLE_NAME=>'MYTABLE'));\n\nselect *\n  from table(information_schema.external_table_file_registration_history(\n    start_time=>dateadd('hour',-1,current_timestamp()),\n    table_name=>'mydb.public.external_table_name'));\n\nselect *\n  from table(information_schema.external_table_file_registration_history(\n    start_time=>cast('2022-04-25' as timestamp),\n    table_name=>'mydb.public.external_table_name'));",
    "arguments": [
        {
            "name": "TABLE_NAME",
            "description": "A string specifying an external table name."
        },
        {
            "name": "START_TIME",
            "description": "Timestamp (in TIMESTAMP_LTZ format), within the last 30 days, marking the start of the time range for retrieving metadata update events. Note If no start time is specified, the function returns all update events within the last 30 days. If the start time falls outside the last 30 days, the function returns results within the last 30 days. If the start time is not a timestamp, it is ignored."
        }
    ]
},
{
    "function_name": "EXTERNAL_TABLE_FILES",
    "summary": "This table function can be used to query information about the staged data files included in the metadata for a specified external table.",
    "category": "Information Schema , Table functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/external_table_files",
    "title": "EXTERNAL_TABLE_FILES",
    "description": "This table function can be used to query information about the staged data files included in the metadata for a specified",
    "syntax": "EXTERNAL_TABLE_FILES(\n      TABLE_NAME => '<string>' )",
    "example": "select *\nfrom table(information_schema.external_table_files(TABLE_NAME=>'MYTABLE'));",
    "arguments": [
        {
            "name": "TABLE_NAME",
            "description": "A string specifying an external table name."
        }
    ]
},
{
    "function_name": "EXTERNAL_FUNCTIONS_HISTORY",
    "summary": "This table function retrieves the history of external functions called by Snowflake for your entire Snowflake account.",
    "category": "Information Schema , Table functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/external_functions_history",
    "title": "EXTERNAL_FUNCTIONS_HISTORY",
    "description": "This table function retrieves the history of external functions called by Snowflake for your entire Snowflake account.",
    "syntax": "EXTERNAL_FUNCTIONS_HISTORY(\n      [ DATE_RANGE_START => <constant_date_expression> ]\n      [, DATE_RANGE_END => <constant_date_expression> ]\n      [, FUNCTION_SIGNATURE => '<string>' ] )",
    "example": "select *\n  from table(information_schema.external_functions_history(\n    date_range_start => to_timestamp_ltz('2020-05-24 12:00:00.000'),\n    date_range_end => to_timestamp_ltz('2020-05-24 12:30:00.000')));\n\nselect *\n  from table(information_schema.external_functions_history(\n    date_range_start => dateadd('hour', -12, current_timestamp()),\n    function_signature => 'mydb.public.myfunction(integer, varchar)'));\n\nselect *\n  from table(information_schema.external_functions_history(\n    date_range_start => dateadd('day', -14, current_date()),\n    date_range_end => current_date()));\n\nselect *\n  from table(information_schema.external_functions_history(\n    date_range_start => dateadd('day', -14, current_date()),\n    date_range_end => current_date(),\n    function_signature => 'mydb.public.myfunction(integer, varchar)'));",
    "arguments": [
        {
            "name": "DATE_RANGE_START",
            "description": "The date/time range, within the last 2 weeks, for which to retrieve the history: If an end date is not specified, then CURRENT_DATE is used as the end of the range. If a start date is not specified, then the range starts 10 minutes prior to the start of DATE_RANGE_END (i.e. the default is to show the previous 10 minutes of history). For example,\nif DATE_RANGE_END is CURRENT_DATE , then the default DATE_RANGE_START is 11:50 PM on the previous day. History is displayed in increments of 5 minutes, 1 hour, or 24 hours (depending on the length of the specified range). If the range falls outside the last 15 days, an error is returned."
        },
        {
            "name": "FUNCTION_SIGNATURE",
            "description": "A string specifying an external function name and the data types of the arguments to the function. (The data types\ndistinguish among overloaded function names.) Only information about that function is returned. Put the signature inside single quotes, for example: Note that the argument data types, but not the argument names, are specified. If no signature is specified, then the output includes the total for all external functions in use within the time\nrange, and the following columns in the results display NULL: FUNCTION_NAME. ARGUMENTS. FUNCTION_ENDPOINT_URL. SOURCE_CLOUD. SOURCE_REGION. TARGET_CLOUD. TARGET_REGION."
        }
    ]
},
{
    "function_name": "EXPLAIN_JSON",
    "summary": "This function converts an EXPLAIN plan from JSON to a table.",
    "category": "System functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/explain_json",
    "title": "EXPLAIN_JSON",
    "description": "This function converts an EXPLAIN plan from JSON to a table. The output is the same as the output of the command",
    "syntax": "EXPLAIN_JSON( <explain_output_in_json_format> )",
    "example": "SELECT * FROM TABLE(\n    EXPLAIN_JSON(\n        SYSTEM$EXPLAIN_PLAN_JSON(\n           'SELECT Z1.ID, Z2.ID FROM Z1, Z2 WHERE Z2.ID = Z1.ID')\n        )\n    );\n+------+------+-----------------+-------------+------------------------------+-------+--------------------------+-----------------+--------------------+---------------+\n| step | id   | parentOperators | operation   | objects                      | alias | expressions              | partitionsTotal | partitionsAssigned | bytesAssigned |\n|------+------+-----------------+-------------+------------------------------+-------+--------------------------+-----------------+--------------------+---------------|\n| NULL | NULL |          NULL | GlobalStats | NULL                         | NULL  | NULL                     |               2 |                  2 |          1024 |\n|    1 |    0 |            NULL | Result      | NULL                         | NULL  | Z1.ID, Z2.ID             |            NULL |               NULL |          NULL |\n|    1 |    1 |             [0] | InnerJoin   | NULL                         | NULL  | joinKey: (Z2.ID = Z1.ID) |            NULL |               NULL |          NULL |\n|    1 |    2 |             [1] | TableScan   | TESTDB.TEMPORARY_DOC_TEST.Z2 | NULL  | ID                       |               1 |                  1 |           512 |\n|    1 |    3 |             [1] | JoinFilter  | NULL                         | NULL  | joinKey: (Z2.ID = Z1.ID) |            NULL |               NULL |          NULL |\n|    1 |    4 |             [3] | TableScan   | TESTDB.TEMPORARY_DOC_TEST.Z1 | NULL  | ID                       |               1 |                  1 |           512 |\n+------+------+-----------------+-------------+------------------------------+-------+--------------------------+-----------------+--------------------+---------------+",
    "arguments": [
        {
            "name": "explain_output_in_json_format",
            "description": "A string, or an expression that evaluates to a string, containing EXPLAIN output as a JSON-compatible string.\nTypically, this input is the output of the function SYSTEM$EXPLAIN_PLAN_JSON.\nIf a literal string is used, it should be surrounded by single quote characters ' ."
        }
    ],
    "returns": "The function returns a table containing the EXPLAIN output as an ordered set of rows."
},
{
    "function_name": "EXP",
    "summary": "Computes Euler’s number e raised to a floating-point value.",
    "category": "Numeric functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/exp",
    "title": "EXP",
    "description": "Computes Euler’s number",
    "syntax": "EXP( <real_expr> )",
    "example": "SELECT EXP(1), EXP(LN(10));\n-------------+-------------+\n   EXP(1)    | EXP(LN(10)) |\n-------------+-------------+\n 2.718281828 | 10          |\n-------------+-------------+"
},
{
    "function_name": "ESTIMATE_REMAINING_DP_AGGREGATES",
    "summary": "Returns the estimated number of aggregation functions that can be run before the limit of a privacy budget is reached.",
    "category": "Differential privacy functions , Table functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/estimate_remaining_dp_aggregates",
    "title": "ESTIMATE_REMAINING_DP_AGGREGATES",
    "syntax": "SNOWFLAKE.DATA_PRIVACY.ESTIMATE_REMAINING_DP_AGGREGATES('<table_name>')",
    "example": "SELECT * FROM TABLE(SNOWFLAKE.DATA_PRIVACY.ESTIMATE_REMAINING_DP_AGGREGATES('my_table'));\n\n+-----------------------------------+--------------+---------------+--------------+\n| NUMBER_OF_REMAINING_DP_AGGREGATES | BUDGET_LIMIT | BUDGET_WINDOW | BUDGET_SPENT |\n|-----------------------------------+--------------+---------------+--------------|\n|                 994               |     233      |     WEEKLY    |     1.8      |\n+-----------------------------------+--------------+---------------+--------------+",
    "arguments": [
        {
            "name": "table_name",
            "description": "The name of the table protected by a differential privacy policy. The function returns privacy budget data based on the queries that you\nhave run against this table since the last budget refresh."
        }
    ]
},
{
    "function_name": "EQUAL_NULL",
    "summary": "Compares whether two expressions are equal.",
    "category": "Conditional expression functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/equal_null",
    "title": "EQUAL_NULL",
    "description": "Compares whether two expressions are equal. The function is NULL-safe, meaning it treats NULLs as known values for comparing equality. Note that this is different from the EQUAL",
    "syntax": "EQUAL_NULL( <expr1> , <expr2> )",
    "example": "CREATE OR REPLACE TABLE x (i number);\nINSERT INTO x values\n    (1), \n    (2), \n    (null);\n\nSELECT x1.i x1_i, x2.i x2_i \n    FROM x x1, x x2\n    ORDER BY x1.i, x2.i;\n+------+------+\n| X1_I | X2_I |\n|------+------|\n|    1 |    1 |\n|    1 |    2 |\n|    1 | NULL |\n|    2 |    1 |\n|    2 |    2 |\n|    2 | NULL |\n| NULL |    1 |\n| NULL |    2 |\n| NULL | NULL |\n+------+------+\n\nSELECT x1.i x1_i, x2.i x2_i \n    FROM x x1, x x2 \n    WHERE x1.i=x2.i;\n+------+------+\n| X1_I | X2_I |\n|------+------|\n|    1 |    1 |\n|    2 |    2 |\n+------+------+\n\nSELECT x1.i x1_i, x2.i x2_i \n    FROM x x1, x x2 \n    WHERE EQUAL_NULL(x1.i,x2.i);\n+------+------+\n| X1_I | X2_I |\n|------+------|\n|    1 |    1 |\n|    2 |    2 |\n| NULL | NULL |\n+------+------+\n\nSELECT x1.i x1_i, \n       x2.i x2_i,\n       x1.i=x2.i, \n       iff(x1.i=x2.i, 'Selected', 'Not') \"SELECT IF X1.I=X2.I\",\n       x1.i<>x2.i, \n       iff(not(x1.i=x2.i), 'Selected', 'Not') \"SELECT IF X1.I<>X2.I\"\n    FROM x x1, x x2;\n+------+------+-----------+---------------------+------------+----------------------+\n| X1_I | X2_I | X1.I=X2.I | SELECT IF X1.I=X2.I | X1.I<>X2.I | SELECT IF X1.I<>X2.I |\n|------+------+-----------+---------------------+------------+----------------------|\n|    1 |    1 | True      | Selected            | False      | Not                  |\n|    1 |    2 | False     | Not                 | True       | Selected             |\n|    1 | NULL | NULL      | Not                 | NULL       | Not                  |\n|    2 |    1 | False     | Not                 | True       | Selected             |\n|    2 |    2 | True      | Selected            | False      | Not                  |\n|    2 | NULL | NULL      | Not                 | NULL       | Not                  |\n| NULL |    1 | NULL      | Not                 | NULL       | Not                  |\n| NULL |    2 | NULL      | Not                 | NULL       | Not                  |\n| NULL | NULL | NULL      | Not                 | NULL       | Not                  |\n+------+------+-----------+---------------------+------------+----------------------+\n\nSELECT x1.i x1_i, \n       x2.i x2_i,\n       equal_null(x1.i,x2.i), \n       iff(equal_null(x1.i,x2.i), 'Selected', 'Not') \"SELECT IF EQUAL_NULL(X1.I,X2.I)\",\n       not(equal_null(x1.i,x2.i)), \n       iff(not(equal_null(x1.i,x2.i)), 'Selected', 'Not') \"SELECT IF NOT(EQUAL_NULL(X1.I,X2.I))\"\n    FROM x x1, x x2;\n+------+------+-----------------------+---------------------------------+----------------------------+--------------------------------------+\n| X1_I | X2_I | EQUAL_NULL(X1.I,X2.I) | SELECT IF EQUAL_NULL(X1.I,X2.I) | NOT(EQUAL_NULL(X1.I,X2.I)) | SELECT IF NOT(EQUAL_NULL(X1.I,X2.I)) |\n|------+------+-----------------------+---------------------------------+----------------------------+--------------------------------------|\n|    1 |    1 | True                  | Selected                        | False                      | Not                                  |\n|    1 |    2 | False                 | Not                             | True                       | Selected                             |\n|    1 | NULL | False                 | Not                             | True                       | Selected                             |\n|    2 |    1 | False                 | Not                             | True                       | Selected                             |\n|    2 |    2 | True                  | Selected                        | False                      | Not                                  |\n|    2 | NULL | False                 | Not                             | True                       | Selected                             |\n| NULL |    1 | False                 | Not                             | True                       | Selected                             |\n| NULL |    2 | False                 | Not                             | True                       | Selected                             |\n| NULL | NULL | True                  | Selected                        | False                      | Not                                  |\n+------+------+-----------------------+---------------------------------+----------------------------+--------------------------------------+"
},
{
    "function_name": "ENTITY_SENTIMENT (SNOWFLAKE.CORTEX)",
    "summary": "Returns sentiment scores for English-language text, including overall sentiment and specific sentiment for specified entities.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/entity_sentiment-snowflake-cortex",
    "title": "ENTITY_SENTIMENT (SNOWFLAKE.CORTEX)",
    "syntax": "SNOWFLAKE.CORTEX.ENTITY_SENTIMENT(<text> [, <entities> ])",
    "arguments": [
        {
            "name": "text",
            "description": "A string containing the text for which sentiment scores should be calculated."
        },
        {
            "name": "entities",
            "description": "An array containing up to ten entities or aspects for which sentiment scores should be calculated. Each entity is a\nstring. For example, if scoring sentiment from a restaurant review, the entities array might be ['cost', 'quality', 'waiting time'] . Entities may be a maximum of 30 characters long. This argument is optional. If you do not provide it, the function will return only the overall sentiment."
        }
    ],
    "returns": "An OBJECT containing a categories field. categories is an ARRAY of category records. Each category includes these fields:"
},
{
    "function_name": "ENDSWITH",
    "summary": "Returns TRUE if the first expression ends with the second expression.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/endswith",
    "title": "ENDSWITH",
    "description": "Returns TRUE if the first expression ends with the second expression. Both expressions must be text or binary expressions.",
    "syntax": "ENDSWITH( <expr1> , <expr2> )",
    "example": "CREATE OR REPLACE TABLE strings_test (s VARCHAR);\n\nINSERT INTO strings_test values\n  ('coffee'),\n  ('ice tea'),\n  ('latte'),\n  ('tea'),\n  (NULL);\n\nSELECT * from strings_test;\n\n+---------+\n| S       |\n|---------|\n| coffee  |\n| ice tea |\n| latte   |\n| tea     |\n| NULL    |\n+---------+\n\nSELECT * FROM strings_test WHERE ENDSWITH(s, 'te');\n\n+-------+\n| S     |\n|-------|\n| latte |\n+-------+\n\nSELECT ENDSWITH(COLLATE('nñ', 'en-ci-ai'), 'n'),\n       ENDSWITH(COLLATE('nñ', 'es-ci-ai'), 'n');\n\n+------------------------------------------+------------------------------------------+\n| ENDSWITH(COLLATE('NÑ', 'EN-CI-AI'), 'N') | ENDSWITH(COLLATE('NÑ', 'ES-CI-AI'), 'N') |\n|------------------------------------------+------------------------------------------|\n| True                                     | False                                    |\n+------------------------------------------+------------------------------------------+",
    "arguments": [
        {
            "name": "expr1",
            "description": "The string to search in."
        },
        {
            "name": "expr2",
            "description": "The string to search for at the end of expr1 ."
        }
    ],
    "returns": "Returns a BOOLEAN or NULL:"
},
{
    "function_name": "ENCRYPT_RAW",
    "summary": "Encrypts a BINARY value using a BINARY key.",
    "category": "Encryption functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/encrypt_raw",
    "title": "ENCRYPT_RAW",
    "description": "Encrypts a BINARY value using a BINARY key.",
    "syntax": "ENCRYPT_RAW( <value_to_encrypt> , <key> , <iv> ,\n         [ [ <additional_authenticated_data> , ] <encryption_method> ]\n       )",
    "example": "ALTER SESSION SET BINARY_OUTPUT_FORMAT='HEX';\n\nCREATE OR REPLACE TABLE binary_table (\n    encryption_key BINARY,   -- DO NOT STORE REAL ENCRYPTION KEYS THIS WAY!\n    initialization_vector BINARY(12), -- DO NOT STORE REAL IV'S THIS WAY!!\n    binary_column BINARY,\n    encrypted_binary_column VARIANT,\n    aad_column BINARY);\n\nINSERT INTO binary_table (encryption_key,\n                          initialization_vector,\n                          binary_column,\n                          aad_column)\n    SELECT SHA2_BINARY('NotSecretEnough', 256),\n            SUBSTR(TO_BINARY(HEX_ENCODE('AlsoNotSecretEnough'), 'HEX'), 0, 12),\n            TO_BINARY(HEX_ENCODE('Bonjour'), 'HEX'),\n            TO_BINARY(HEX_ENCODE('additional data'), 'HEX')\n    ;\n\nUPDATE binary_table SET encrypted_binary_column =\n    ENCRYPT_RAW(binary_column, \n        encryption_key, \n        initialization_vector, \n        aad_column,\n        'AES-GCM');\n+------------------------+-------------------------------------+\n| number of rows updated | number of multi-joined rows updated |\n|------------------------+-------------------------------------|\n|                      1 |                                   0 |\n+------------------------+-------------------------------------+\n\nSELECT 'Bonjour' as original_value,\n       binary_column,\n       hex_decode_string(to_varchar(binary_column)) as decoded,\n       encrypted_binary_column,\n       decrypt_raw(as_binary(get(encrypted_binary_column, 'ciphertext')),\n                  encryption_key,\n                  as_binary(get(encrypted_binary_column, 'iv')),\n                  aad_column,\n                  'AES-GCM',\n                  as_binary(get(encrypted_binary_column, 'tag')))\n           as decrypted,\n       hex_decode_string(to_varchar(decrypt_raw(as_binary(get(encrypted_binary_column, 'ciphertext')),\n                  encryption_key,\n                  as_binary(get(encrypted_binary_column, 'iv')),\n                  aad_column,\n                  'AES-GCM',\n                  as_binary(get(encrypted_binary_column, 'tag')))\n                  ))\n           as decrypted_and_decoded\n    FROM binary_table;\n+----------------+----------------+---------+---------------------------------------------+----------------+-----------------------+\n| ORIGINAL_VALUE | BINARY_COLUMN  | DECODED | ENCRYPTED_BINARY_COLUMN                     | DECRYPTED      | DECRYPTED_AND_DECODED |\n|----------------+----------------+---------+---------------------------------------------+----------------+-----------------------|\n| Bonjour        | 426F6E6A6F7572 | Bonjour | {                                           | 426F6E6A6F7572 | Bonjour               |\n|                |                |         |   \"ciphertext\": \"CA2F4A383F6F55\",           |                |                       |\n|                |                |         |   \"iv\": \"416C736F4E6F745365637265\",         |                |                       |\n|                |                |         |   \"tag\": \"91F28FBC6A2FE9B213D1C44B8D75D147\" |                |                       |\n|                |                |         | }                                           |                |                       |\n+----------------+----------------+---------+---------------------------------------------+----------------+-----------------------+\n\nWITH\n    decrypted_but_not_decoded as (\n        decrypt_raw(as_binary(get(encrypted_binary_column, 'ciphertext')),\n                      encryption_key,\n                      as_binary(get(encrypted_binary_column, 'iv')),\n                      aad_column,\n                      'AES-GCM',\n                      as_binary(get(encrypted_binary_column, 'tag')))\n    )\nSELECT 'Bonjour' as original_value,\n       binary_column,\n       hex_decode_string(to_varchar(binary_column)) as decoded,\n       encrypted_binary_column,\n       decrypted_but_not_decoded,\n       hex_decode_string(to_varchar(decrypted_but_not_decoded))\n           as decrypted_and_decoded\n    FROM binary_table;\n+----------------+----------------+---------+---------------------------------------------+---------------------------+-----------------------+\n| ORIGINAL_VALUE | BINARY_COLUMN  | DECODED | ENCRYPTED_BINARY_COLUMN                     | DECRYPTED_BUT_NOT_DECODED | DECRYPTED_AND_DECODED |\n|----------------+----------------+---------+---------------------------------------------+---------------------------+-----------------------|\n| Bonjour        | 426F6E6A6F7572 | Bonjour | {                                           | 426F6E6A6F7572            | Bonjour               |\n|                |                |         |   \"ciphertext\": \"CA2F4A383F6F55\",           |                           |                       |\n|                |                |         |   \"iv\": \"416C736F4E6F745365637265\",         |                           |                       |\n|                |                |         |   \"tag\": \"91F28FBC6A2FE9B213D1C44B8D75D147\" |                           |                       |\n|                |                |         | }                                           |                           |                       |\n+----------------+----------------+---------+---------------------------------------------+---------------------------+-----------------------+",
    "arguments": [
        {
            "name": "value_to_encrypt",
            "description": "The binary value to encrypt."
        },
        {
            "name": "key",
            "description": "The key to use to encrypt/decrypt the data. The key must be a BINARY value. The key can be any value as long as the\nlength is correct. For example, for AES128, the key must be 128 bits (16 bytes), and for AES256, the key must be\n256 bits (32 bytes). The key used to encrypt the value must be used to decrypt the value."
        },
        {
            "name": "iv",
            "description": "This parameter contains the Initialization Vector (IV) to use to encrypt and decrypt this piece of\ndata. The IV must be a BINARY value of a specific length: For GCM, this field must be 96 bits (12 bytes). While the GCM encryption method allows this field to be a different\nsize, Snowflake currently only supports 96 bits. For CCM, this should be 56 bits (7 bytes). For ECB, this parameter is unneeded. For all other supported encryption modes, this should be 128 bits (16 bytes). This value is used to initialize the first encryption round. You should never use the same IV and key combination\nmore than once, especially for encryption modes like GCM. If this parameter is set to NULL, the implementation will choose a new pseudo-random IV during each call."
        },
        {
            "name": "additional_authenticated_data",
            "description": "Additional authenticated data (AAD) is additional data whose confidentiality and authenticity is assured during the\ndecryption process. However, this AAD is not encrypted and is not included as a field in the returned value from the\nENCRYPT or ENCRYPT_RAW function. If AAD is passed to the encryption function (ENCRYPT or ENCRYPT_RAW), then the same AAD must be passed to the\ndecryption function (DECRYPT or DECRYPT_RAW). If the AAD passed to the decryption function does not match the\nAAD passed to the encryption function, then decryption fails. The difference between the AAD and the passphrase is that the passphrase is intended to be kept\nsecret (otherwise, the encryption is essentially worthless) while the AAD can be left public. The AAD helps\nauthenticate that a public piece of information and an encrypted value are associated with each other. The\nexamples section in the ENCRYPT function includes an example showing the behavior\nwhen the AAD matches and the behavior when it doesn’t match. For ENCRYPT_RAW and DECRYPT_RAW, the data type of the AAD should be BINARY.\nFor ENCRYPT and DECRYPT, the data type of the AAD can be either VARCHAR or BINARY, and does not need to match\nthe data type of the value that was encrypted. AAD is supported only by AEAD-enabled encryption modes like GCM (default)."
        },
        {
            "name": "encryption_method",
            "description": "This string specifies the method to use for encrypting/decrypting the data. This string contains subfields: The algorithm is currently limited to: 'AES' : When a passphrase is passed (e.g. to ENCRYPT), the function uses AES-256 encryption (256 bits). When a key\nis passed (e.g. to ENCRYPT_RAW), the function uses 128, 192, or 256-bit encryption, depending upon the key\nlength. The algorithm is case-insensitive. The mode specifies which block cipher mode should be used to encrypt messages.\nThe following table shows which modes are supported, and which of those modes support padding: Mode Padding Description 'ECB' Yes Encrypt every block individually with the key. This mode is generally discouraged and is included only for compatibility with external implementations. 'CBC' Yes The encrypted block is XORed with the previous block. 'GCM' No Galois/Counter Mode is a high-performance encryption mode that is AEAD-enabled. AEAD additionally assures the authenticity and confidentiality of the encrypted data by generating an AEAD tag. Moreover, AEAD supports AAD (additional authenticated data). 'CTR' No Counter mode. 'OFB' No Output feedback. The ciphertext is XORed with the plaintext of a block. 'CFB' No Cipher feedback is a combination of OFB and CBC. The mode is case-insensitive. The padding specifies how to pad messages whose length is not a multiple of the block size. Padding is\napplicable only for ECB and CBC modes; padding is ignored for other modes. The possible values for padding are: 'PKCS' : Uses PKCS5 for block padding. 'NONE' : No padding. The user needs to take care of the padding when using ECB or CBC mode. The padding is case-insensitive. Default setting: 'AES-GCM' . If the mode is not specified, GCM is used. If the padding is not specified, PKCS is used."
        }
    ],
    "returns": "The function returns the encrypted value. The data type of the returned value is VARIANT."
},
{
    "function_name": "ENCRYPT",
    "summary": "Encrypts a VARCHAR or BINARY value using a VARCHAR passphrase.",
    "category": "Encryption functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/encrypt",
    "title": "ENCRYPT",
    "description": "Encrypts a VARCHAR or BINARY value using a VARCHAR passphrase.",
    "syntax": "ENCRYPT( <value_to_encrypt> , <passphrase> ,\n         [ [ <additional_authenticated_data> , ] <encryption_method> ]\n       )",
    "example": "SELECT encrypt('Secret!', 'SamplePassphrase');\n\nSET passphrase='poiuqewjlkfsd';\n\nSELECT\n    TO_VARCHAR(\n        DECRYPT(\n            ENCRYPT('Patient tested positive for COVID-19', $passphrase),\n            $passphrase),\n        'utf-8')\n        AS decrypted\n    ;\n+--------------------------------------+\n| DECRYPTED                            |\n|--------------------------------------|\n| Patient tested positive for COVID-19 |\n+--------------------------------------+\n\nSELECT encrypt(to_binary(hex_encode('Secret!')), 'SamplePassphrase', to_binary(hex_encode('Authenticated Data')));\n\n6E1361E297C22969345F978A45205E3E98EB872844E3A0F151713894C273FAEF50C365S\n\nSELECT encrypt(to_binary(hex_encode('secret!')), 'sample_passphrase', NULL, 'aes-cbc/pad:pkcs') as encrypted_data;\n\nSELECT\n    TO_VARCHAR(\n        DECRYPT(\n            ENCRYPT('penicillin', $passphrase, 'John Dough AAD', 'aes-gcm'),\n            $passphrase, 'John Dough AAD', 'aes-gcm'),\n        'utf-8')\n        AS medicine\n    ;\n+------------+\n| MEDICINE   |\n|------------|\n| penicillin |\n+------------+\n\nSELECT\n    DECRYPT(\n        ENCRYPT('penicillin', $passphrase, 'John Dough AAD', 'aes-gcm'),\n        $passphrase, 'wrong patient AAD', 'aes-gcm') AS medicine\n    ;\n\n100311 (22023): Decryption failed. Check encrypted data, key, AAD, or AEAD tag.",
    "arguments": [
        {
            "name": "value_to_encrypt",
            "description": "The VARCHAR or BINARY value to encrypt."
        },
        {
            "name": "passphrase",
            "description": "The passphrase to use to encrypt/decrypt the data. The passphrase is always a VARCHAR, regardless of whether the value_to_encrypt is VARCHAR or BINARY."
        },
        {
            "name": "additional_authenticated_data",
            "description": "Additional authenticated data (AAD) is additional data whose confidentiality and authenticity is assured during the\ndecryption process. However, this AAD is not encrypted and is not included as a field in the returned value from the\nENCRYPT or ENCRYPT_RAW function. If AAD is passed to the encryption function (ENCRYPT or ENCRYPT_RAW), then the same AAD must be passed to the\ndecryption function (DECRYPT or DECRYPT_RAW). If the AAD passed to the decryption function does not match the\nAAD passed to the encryption function, then decryption fails. The difference between the AAD and the passphrase is that the passphrase is intended to be kept\nsecret (otherwise, the encryption is essentially worthless) while the AAD can be left public. The AAD helps\nauthenticate that a public piece of information and an encrypted value are associated with each other. The\nexamples section in the ENCRYPT function includes an example showing the behavior\nwhen the AAD matches and the behavior when it doesn’t match. For ENCRYPT_RAW and DECRYPT_RAW, the data type of the AAD should be BINARY.\nFor ENCRYPT and DECRYPT, the data type of the AAD can be either VARCHAR or BINARY, and does not need to match\nthe data type of the value that was encrypted. AAD is supported only by AEAD-enabled encryption modes like GCM (default)."
        },
        {
            "name": "encryption_method",
            "description": "This string specifies the method to use for encrypting/decrypting the data. This string contains subfields: The algorithm is currently limited to: 'AES' : When a passphrase is passed (e.g. to ENCRYPT), the function uses AES-256 encryption (256 bits). When a key\nis passed (e.g. to ENCRYPT_RAW), the function uses 128, 192, or 256-bit encryption, depending upon the key\nlength. The algorithm is case-insensitive. The mode specifies which block cipher mode should be used to encrypt messages.\nThe following table shows which modes are supported, and which of those modes support padding: Mode Padding Description 'ECB' Yes Encrypt every block individually with the key. This mode is generally discouraged and is included only for compatibility with external implementations. 'CBC' Yes The encrypted block is XORed with the previous block. 'GCM' No Galois/Counter Mode is a high-performance encryption mode that is AEAD-enabled. AEAD additionally assures the authenticity and confidentiality of the encrypted data by generating an AEAD tag. Moreover, AEAD supports AAD (additional authenticated data). 'CTR' No Counter mode. 'OFB' No Output feedback. The ciphertext is XORed with the plaintext of a block. 'CFB' No Cipher feedback is a combination of OFB and CBC. The mode is case-insensitive. The padding specifies how to pad messages whose length is not a multiple of the block size. Padding is\napplicable only for ECB and CBC modes; padding is ignored for other modes. The possible values for padding are: 'PKCS' : Uses PKCS5 for block padding. 'NONE' : No padding. The user needs to take care of the padding when using ECB or CBC mode. The padding is case-insensitive. Default setting: 'AES-GCM' . If the mode is not specified, GCM is used. If the padding is not specified, PKCS is used."
        }
    ],
    "returns": "The data type of the returned value is BINARY."
},
{
    "function_name": "EMBED_TEXT_1024 (SNOWFLAKE.CORTEX)",
    "summary": "Creates a vector embedding of 1024 dimensions from text.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/embed_text_1024-snowflake-cortex",
    "title": "EMBED_TEXT_1024 (SNOWFLAKE.CORTEX)",
    "syntax": "SNOWFLAKE.CORTEX.EMBED_TEXT_1024( <model>, <text> )",
    "arguments": [
        {
            "name": "model",
            "description": "A string specifying the vector embedding model to be used to generate the embedding. This must be one of the following values. snowflake-arctic-embed-l-v2.0 snowflake-arctic-embed-l-v2.0-8k nv-embed-qa-4 multilingual-e5-large voyage-multilingual-2 Supported models might have different costs ."
        },
        {
            "name": "text",
            "description": "The text for which an embedding should be calculated."
        }
    ],
    "returns": "A vector embedding of type VECTOR."
},
{
    "function_name": "EMBED_TEXT_768 (SNOWFLAKE.CORTEX)",
    "summary": "Creates a vector embedding of 768 dimensions from English-language text.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/embed_text-snowflake-cortex",
    "title": "EMBED_TEXT_768 (SNOWFLAKE.CORTEX)",
    "syntax": "SNOWFLAKE.CORTEX.EMBED_TEXT_768( <model>, <text> )",
    "example": "SELECT SNOWFLAKE.CORTEX.EMBED_TEXT_768('snowflake-arctic-embed-m-v1.5', 'hello world');",
    "arguments": [
        {
            "name": "model",
            "description": "A string specifying the vector embedding model to be used to generate the embedding. This must be one of the following values. snowflake-arctic-embed-m-v1.5 snowflake-arctic-embed-m e5-base-v2 Supported models might have different costs ."
        },
        {
            "name": "text",
            "description": "The text for which an embedding should be calculated."
        }
    ],
    "returns": "A vector embedding of type VECTOR."
},
{
    "function_name": "EMAIL_INTEGRATION_CONFIG",
    "summary": "Returns a JSON object that specifies the email notification integration, recipients, and subject line to use for an email notification.",
    "category": "Notification functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/email_integration_config",
    "title": "EMAIL_INTEGRATION_CONFIG",
    "description": "Returns a JSON object that specifies the email notification integration, recipients, and subject line to use for an email\nnotification. This is a helper function that you use to construct an integration configuration object for the",
    "syntax": "SNOWFLAKE.NOTIFICATION.EMAIL_INTEGRATION_CONFIG(\n  '<email_integration_name>',\n  '<subject>',\n  <array_of_email_addresses_for_to_line> )",
    "arguments": [
        {
            "name": "'",
            "description": "Name of the email notification integration to use."
        },
        {
            "name": "'",
            "description": "Subject of the email message. The subject cannot exceed 256 characters in length."
        },
        {
            "name": "array_of_email_addresses_for_to_line",
            "description": "ARRAYs of the email addresses to include in the “To:”, “Cc:”, and “Bcc:” lines of the message. You must specify email addresses of users in the current account. These users must verify their email addresses . If the ALLOWED_RECIPIENTS property is set to a list of email addresses in the email notification integration , the email addresses must be in that list. Call the ARRAY_CONSTRUCT function to construct each ARRAY. Note You cannot send an email notification if you only specify the “Bcc:” line."
        }
    ],
    "returns": "A JSON-formatted string that specifies a notification integration for the\nSYSTEM$SEND_SNOWFLAKE_NOTIFICATION stored procedure to send."
},
{
    "function_name": "EDITDISTANCE",
    "summary": "Computes the Levenshtein distance between two input strings.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/editdistance",
    "title": "EDITDISTANCE",
    "description": "Computes the Levenshtein distance between two input strings. It is the number\nof single-character insertions, deletions, or substitutions needed to convert\none string to another.",
    "syntax": "EDITDISTANCE( <string_expr1> , <string_expr2> [ , <max_distance> ] )",
    "example": "SELECT s,\n       t,\n       EDITDISTANCE(s, t),\n       EDITDISTANCE(t, s),\n       EDITDISTANCE(s, t, 3),\n       EDITDISTANCE(s, t, -1)\n  FROM ed;\n\n+----------------+-----------------+--------------------+--------------------+-----------------------+------------------------+\n|      S         |        T        | EDITDISTANCE(S, T) | EDITDISTANCE(T, S) | EDITDISTANCE(S, T, 3) | EDITDISTANCE(S, T, -1) |\n|----------------+-----------------+--------------------+--------------------+-----------------------+------------------------|\n|                |                 | 0                  | 0                  | 0                     | 0                      |\n| Gute nacht     | Ich weis nicht  | 8                  | 8                  | 3                     | 0                      |\n| Ich weiß nicht | Ich wei? nicht  | 1                  | 1                  | 1                     | 0                      |\n| Ich weiß nicht | Ich weiss nicht | 2                  | 2                  | 2                     | 0                      |\n| Ich weiß nicht | [NULL]          | [NULL]             | [NULL]             | [NULL]                | [NULL]                 |\n| Snowflake      | Oracle          | 7                  | 7                  | 3                     | 0                      |\n| święta         | swieta          | 2                  | 2                  | 2                     | 0                      |\n| [NULL]         |                 | [NULL]             | [NULL]             | [NULL]                | [NULL]                 |\n| [NULL]         | [NULL]          | [NULL]             | [NULL]             | [NULL]                | [NULL]                 |\n+----------------+-----------------+--------------------+--------------------+-----------------------+------------------------+\n\nSELECT EDITDISTANCE('future', 'past', 2) < 2;\n\n+---------------------------------------+\n| EDITDISTANCE('FUTURE', 'PAST', 2) < 2 |\n|---------------------------------------|\n| False                                 |\n+---------------------------------------+",
    "arguments": [
        {
            "name": "string_expr1",
            "description": "The input strings."
        },
        {
            "name": "max_distance",
            "description": "Integer expression that specifies the maximum distance to compute. When the distance between the strings exceeds this number, the function stops computing the distance and just returns the\nmaximum distance. Specifying this argument has the same effect as calling LEAST( EDITDISTANCE( string_expr1 , string_expr2 ), max_distance ) . If you specify a negative number (that is, - n ), the function uses 0 as the maximum distance and returns 0 ."
        }
    ]
},
{
    "function_name": "DYNAMIC_TABLES",
    "summary": "This table function returns metadata about dynamic tables, including aggregate lag metrics and the status of the most recent refreshes, within 7 days of the current time.",
    "category": "Information Schema , Table functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/dynamic_tables",
    "title": "DYNAMIC_TABLES",
    "description": "This table function returns metadata about",
    "syntax": "DYNAMIC_TABLES (\n  [ NAME => '<string>' ]\n  [ , REFRESH_DATA_TIMESTAMP_START => <constant_expr> ]\n  [ , RESULT_LIMIT => <integer> ]\n  [ , INCLUDE_CONNECTED => { TRUE | FALSE } ]\n)",
    "example": "SELECT\n  name,\n  target_lag_sec,\n  mean_lag_sec,\n  latest_data_timestamp\nFROM\n  TABLE (\n    INFORMATION_SCHEMA.DYNAMIC_TABLES (\n      NAME => 'mydb.myschema.mydt',\n      INCLUDE_CONNECTED => TRUE\n    )\n  )\nORDER BY\n  target_lag_sec",
    "arguments": [
        {
            "name": "NAME",
            "description": "The name of a dynamic table. Names must be single-quoted and are case insensitive. You can specify the unqualified name ( dynamic_table_name ),\nthe partially qualified name ( schema_name . dynamic_table_name ),\nor the fully qualified name ( database_name . schema_name . dynamic_table_name ). For more information on object name resolution, refer to Object name resolution . The function returns the metadata for this table."
        },
        {
            "name": "REFRESH_DATA_TIMESTAMP_START",
            "description": "Time (in TIMESTAMP_LTZ format) for computing metrics related to dynamic table target lag. Includes all refreshes with LATEST_DATA_TIMESTAMP greater than or equal to REFRESH_DATA_TIMESTAMP_START. Default: All refreshes in refresh history are retained for 7 days."
        },
        {
            "name": "RESULT_LIMIT",
            "description": "A number specifying the maximum number of rows returned by the function. By default, the function returns 100 rows and the results are sorted by the dynamic table’s last completed refresh state in the following\norder, unless specified otherwise using the RESULT_LIMIT argument. FAILED UPSTREAM_FAILED SKIPPED SUCCEEDED CANCELED To sort by a different order, you must provide a large enough RESULT_LIMIT value (for example, the maximum value of a signed integer). As\nlong as RESULT_LIMIT exceeds the total number of dynamic tables in the account, the results can be sorted using an ORDER BY clause. To apply a filter on the results, also specify a large enough RESULT_LIMIT value for the filter to be applied on all dynamic tables. Examples : The following example sorts by a different order of name and returns 100 rows: The following example sorts by a different order of name and returns all rows: The following example filters for all dynamic tables with 1-minute target lag, uses the default sort, and returns all rows: Range: 1 to 10000 Default: 100 ."
        },
        {
            "name": "INCLUDE_CONNECTED",
            "description": "When set to TRUE, the function returns metadata for all dynamic tables connected to the dynamic table specified by the NAME argument. You must specify the NAME argument, you must not specify the RESULT_LIMIT argument. Default: FALSE"
        }
    ]
},
{
    "function_name": "DYNAMIC_TABLE_REFRESH_HISTORY",
    "summary": "This table function returns information about each refresh (completed and running) of dynamic tables.",
    "category": "Information Schema , Table functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/dynamic_table_refresh_history",
    "title": "DYNAMIC_TABLE_REFRESH_HISTORY",
    "description": "This table function returns information about each refresh (completed and running) of",
    "syntax": "DYNAMIC_TABLE_REFRESH_HISTORY(\n  [ DATA_TIMESTAMP_START => <constant_expr> ]\n  [ , DATA_TIMESTAMP_END => <constant_expr> ]\n  [ , RESULT_LIMIT => <integer> ]\n  [ , NAME => '<string>' ]\n  [ , NAME_PREFIX => '<string>' ]\n  [ , ERROR_ONLY => { TRUE | FALSE } ]\n)",
    "example": "SELECT\n  name,\n  state,\n  state_code,\n  state_message,\n  query_id,\n  data_timestamp,\n  refresh_start_time,\n  refresh_end_time\nFROM\n  TABLE (\n    INFORMATION_SCHEMA.DYNAMIC_TABLE_REFRESH_HISTORY (\n      NAME_PREFIX => 'MYDB.MYSCHEMA.', ERROR_ONLY => TRUE\n    )\n  )\nORDER BY\n  name,\n  data_timestamp;",
    "arguments": [
        {
            "name": "DATA_TIMESTAMP_START",
            "description": "Time range (in TIMESTAMP_LTZ format) during which the refreshes occurred. If neither a start version nor an end version is specified, the default range will be the past day. If an end version is not specified, CURRENT_TIMESTAMP is used as the end of the range. If a start version is not specified, the range starts 1 day prior to the start of DATE_TIMESTAMP_END."
        },
        {
            "name": "RESULT_LIMIT",
            "description": "A number specifying the maximum number of rows returned by the function. If the number of matching rows is greater than\nthis limit, the refreshes that finished most recently (and those that are still running) are returned, up to the specified\nlimit. To apply a filter on the results, also specify a large enough RESULT_LIMIT limit value for the filter to be applied on all\ndynamic tables. Range: 1 to 10000 Default: 100 ."
        },
        {
            "name": "NAME",
            "description": "The name of a dynamic table. Names must be single-quoted and are case insensitive. You can specify the unqualified name ( dynamic_table_name ),\nthe partially qualified name ( schema_name . dynamic_table_name ),\nor the fully qualified name ( database_name . schema_name . dynamic_table_name ). For more information on object name resolution, refer to Object name resolution . The function returns the refreshes for this table."
        },
        {
            "name": "NAME_PREFIX",
            "description": "A prefix for dynamic tables. Name prefixes must be single-quoted and are case insensitive. The function returns refreshes for tables with names that start with this prefix. You can use this argument to return the refreshes for dynamic tables in a specific database or schema."
        },
        {
            "name": "ERROR_ONLY",
            "description": "When set to TRUE, this function returns only refreshes that failed or were cancelled."
        }
    ]
},
{
    "function_name": "DYNAMIC_TABLE_GRAPH_HISTORY",
    "summary": "This table function returns information on all dynamic tables in the current account.",
    "category": "Information Schema , Table functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/dynamic_table_graph_history",
    "title": "DYNAMIC_TABLE_GRAPH_HISTORY",
    "description": "This table function returns information on all",
    "syntax": "DYNAMIC_TABLE_GRAPH_HISTORY(\n  [ AS_OF => <constant_expr> ]\n  [ , HISTORY_START => <constant_expr> [ , HISTORY_END => <constant_expr> ] ]\n)",
    "example": "SELECT\n  name,\n  inputs,\n  target_lag_type,\n  target_lag_sec,\n  scheduling_state,\n  alter_trigger\nFROM\n  TABLE (\n    INFORMATION_SCHEMA.DYNAMIC_TABLE_GRAPH_HISTORY ()\n  )\nORDER BY\n  name;\n\n+--------------------+---------------------------------------------------+-----------------+----------------+---------------------------------------------+------------------+\n| NAME               |[] INPUTS                                          | TARGET_LAG_TYPE | TARGET_LAG_SEC | [] SCHEDULING_STATE                         | [] ALTER_TRIGGER |\n|--------------------+---------------------------------------------------+-----------------+----------------+---------------------------------------------|------------------+\n| MY_DYNAMIC_TABLE_1 | [                                                 | USER_DEFINED    | 300            | {                                           | [                |\n|                    |  {                                                |                 |                |   \"resumed_on\": \"2024-03-01 10:29:02.066 Z\",|   \"RESUME\"       |\n|                    |    \"kind\": \"DYNAMIC_TABLE\",                       |                 |                |   \"state\": \"ACTIVE\"                         | ]                |\n|                    |    \"name\": \"MY_QUALIFIED_NAME.MY_DYNAMIC_TABLE_2\" |                 |                | }                                           |                  |\n|                    |  }                                                |                 |                |                                             |                  |\n|                    | ]                                                 |                 |                |                                             |                  |\n+--------------------+---------------------------------------------------+-----------------+----------------+---------------------------------------------+------------------+",
    "arguments": [
        {
            "name": "AS_OF",
            "description": "Time at which to return the state of the graph. You can specify a time that corresponds to a value in\nthe REFRESH_VERSION column in the output of the DYNAMIC_TABLE_REFRESH_HISTORY function."
        },
        {
            "name": "HISTORY_START",
            "description": "Date/time range of the dynamic table refresh history.\nHISTORY_START specifies the earliest date/time, inclusive, to return data.\nHISTORY_END, which must be specified with HISTORY_START, specifies the end date/time for returning data."
        }
    ]
},
{
    "function_name": "DP_INTERVAL_LOW",
    "summary": "Returns the lower bound of the noise interval, which is used by differential privacy to help analysts determine how much noise has been introduced into query results.",
    "category": "Differential privacy functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/dp_interval_low",
    "title": "DP_INTERVAL_LOW",
    "syntax": "DP_INTERVAL_LOW( <aggregated_column> )",
    "example": "SELECT SUM(num_claims) AS sum_claims,\n  DP_INTERVAL_LOW(sum_claims)\n  FROM t1;",
    "arguments": [
        {
            "name": "aggregated_column",
            "description": "Alias of a column that has been aggregated by the query."
        }
    ],
    "returns": "Returns an integer that is the lower bound of the noise interval."
},
{
    "function_name": "DP_INTERVAL_HIGH",
    "summary": "Returns the upper bound of the noise interval, which is used by differential privacy to help analysts determine how much noise has been introduced into query results.",
    "category": "Differential privacy functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/dp_interval_high",
    "title": "DP_INTERVAL_HIGH",
    "syntax": "DP_INTERVAL_HIGH( <aggregated_column> )",
    "example": "SELECT SUM(num_claims) AS sum_claims,\n  DP_INTERVAL_HIGH(sum_claims)\n  FROM t1;",
    "arguments": [
        {
            "name": "aggregated_column",
            "description": "Alias of a column that has been aggregated by the query."
        }
    ],
    "returns": "Returns an integer that is the upper bound of the noise interval."
},
{
    "function_name": "UNIQUE_COUNT (system data metric function)",
    "summary": "Returns the total number of unique non-NULL values for the specified columns in a table.",
    "category": "Data metric functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/dmf_unique_count",
    "title": "UNIQUE_COUNT (system data metric function)",
    "syntax": "SNOWFLAKE.CORE.UNIQUE_COUNT(<query>)",
    "arguments": [
        {
            "name": "query",
            "description": "Specifies a SQL query on a table or view."
        }
    ],
    "returns": "The function returns a scalar value with a NUMBER data type."
},
{
    "function_name": "STDDEV (system data metric function)",
    "summary": "Returns the standard deviation value for the specified column in a table.",
    "category": "Data metric functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/dmf_stddev",
    "title": "STDDEV (system data metric function)",
    "syntax": "SNOWFLAKE.CORE.STDDEV(<query>)",
    "arguments": [
        {
            "name": "query",
            "description": "Specifies a SQL query on a table or view."
        }
    ],
    "returns": "The function returns a NUMBER value."
},
{
    "function_name": "ROW_COUNT (system data metric function)",
    "summary": "Returns the total number of rows for the specified table.",
    "category": "Data metric functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/dmf_row_count",
    "title": "ROW_COUNT (system data metric function)",
    "returns": "The function returns a scalar value with a NUMBER data type."
},
{
    "function_name": "NULL_PERCENT (system data metric function)",
    "summary": "Returns the percentage of columns values that are NULL for the specified column in a table.",
    "category": "Data metric functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/dmf_null_percent",
    "title": "NULL_PERCENT (system data metric function)",
    "syntax": "SNOWFLAKE.CORE.NULL_PERCENT(<query>)",
    "arguments": [
        {
            "name": "query",
            "description": "Specifies a SQL query on a table or view."
        }
    ],
    "returns": "The function returns a NUMBER value."
},
{
    "function_name": "NULL_COUNT (system data metric function)",
    "summary": "Returns the total number of NULL values for the specified columns in a table.",
    "category": "Data metric functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/dmf_null_count",
    "title": "NULL_COUNT (system data metric function)",
    "syntax": "SNOWFLAKE.CORE.NULL_COUNT(<query>)",
    "arguments": [
        {
            "name": "query",
            "description": "Specifies a SQL query on a table or view."
        }
    ],
    "returns": "The function returns a scalar value with a NUMBER data type."
},
{
    "function_name": "MIN (system data metric function)",
    "summary": "Returns the minimum value for the specified column in a table.",
    "category": "Data metric functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/dmf_min",
    "title": "MIN (system data metric function)",
    "syntax": "SNOWFLAKE.CORE.MIN(<query>)",
    "arguments": [
        {
            "name": "query",
            "description": "Specifies a SQL query on a table or view."
        }
    ],
    "returns": "The function returns either a NUMBER or FLOAT value."
},
{
    "function_name": "MAX (system data metric function)",
    "summary": "Returns the maximum value for the specified column in a table.",
    "category": "Data metric functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/dmf_max",
    "title": "MAX (system data metric function)",
    "syntax": "SNOWFLAKE.CORE.MAX(<query>)",
    "arguments": [
        {
            "name": "query",
            "description": "Specifies a SQL query on a table or view."
        }
    ],
    "returns": "The function returns either a NUMBER or FLOAT value."
},
{
    "function_name": "FRESHNESS (system data metric function)",
    "summary": "Returns the difference in seconds between the maximum value of a timestamp column and the scheduled time when the data metric function runs.",
    "category": "Data metric functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/dmf_freshness",
    "title": "FRESHNESS (system data metric function)",
    "syntax": "SNOWFLAKE.CORE.FRESHNESS(<query>)",
    "arguments": [
        {
            "name": "query",
            "description": "Specifies a SQL query on a table or view."
        }
    ],
    "returns": "The function returns a scalar value with a NUMBER data type."
},
{
    "function_name": "DUPLICATE_COUNT (system data metric function)",
    "summary": "Returns the count of column values that have duplicates, including NULL values.",
    "category": "Data metric functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/dmf_duplicate_count",
    "title": "DUPLICATE_COUNT (system data metric function)",
    "syntax": "SNOWFLAKE.CORE.DUPLICATE_COUNT(<query>)",
    "arguments": [
        {
            "name": "query",
            "description": "Specifies a SQL query on a table or view."
        }
    ],
    "returns": "The function returns a scalar value with a NUMBER data type."
},
{
    "function_name": "BLANK_PERCENT (system data metric function)",
    "summary": "Returns the percentage of column values that are blank for the specified column in a table.",
    "category": "Data metric functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/dmf_blank_percent",
    "title": "BLANK_PERCENT (system data metric function)",
    "syntax": "SNOWFLAKE.CORE.BLANK_PERCENT(<query>)",
    "arguments": [
        {
            "name": "query",
            "description": "Specifies a SQL query on a table or view."
        }
    ],
    "returns": "The function returns a NUMBER value."
},
{
    "function_name": "DATA_METRIC_SCHEDULED_TIME (system data metric function)",
    "summary": "Returns the timestamp for when a DMF is scheduled to run or the current timestamp if the function is called manually.",
    "category": "Data metric functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/dmf_data_metric_schedule_time",
    "title": "DATA_METRIC_SCHEDULED_TIME (system data metric function)",
    "syntax": "SNOWFLAKE.CORE.DATA_METRIC_SCHEDULED_TIME()",
    "returns": "The function returns a scalar value with a TIMESTAMP_LTZ data type."
},
{
    "function_name": "BLANK_COUNT (system data metric function)",
    "summary": "Returns the count of column values that are blank for the specified column in a table.",
    "category": "Data metric functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/dmf_blank_count",
    "title": "BLANK_COUNT (system data metric function)",
    "syntax": "SNOWFLAKE.CORE.BLANK_COUNT(<query>)",
    "arguments": [
        {
            "name": "query",
            "description": "Specifies a SQL query on a table or view."
        }
    ],
    "returns": "The function returns a NUMBER value."
},
{
    "function_name": "AVG (system data metric function)",
    "summary": "Returns the average value for the specified column in a table.",
    "category": "Data metric functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/dmf_avg",
    "title": "AVG (system data metric function)",
    "syntax": "SNOWFLAKE.CORE.AVG(<query>)",
    "arguments": [
        {
            "name": "query",
            "description": "Specifies a SQL query on a table or view."
        }
    ],
    "returns": "The function returns a NUMBER value."
},
{
    "function_name": "DIV0NULL",
    "summary": "Performs division like the division operator (/), but returns 0 when the divisor is 0 or NULL (rather than reporting an error or returning NULL).",
    "category": "Numeric functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/div0null",
    "title": "DIV0NULL",
    "description": "Performs division like the division operator (",
    "syntax": "DIV0NULL( <dividend> , <divisor> )",
    "example": "SELECT 1/2;\n\n+----------+\n|      1/2 |\n|----------|\n| 0.500000 |\n+----------+\n\nSELECT DIV0NULL(1, 2);\n\n+----------------+\n| DIV0NULL(1, 2) |\n|----------------|\n|       0.500000 |\n+----------------+\n\nSELECT 1/0;\n100051 (22012): Division by zero\n\nSELECT DIV0NULL(1, 0);\n\n+----------------+\n| DIV0NULL(1, 0) |\n|----------------|\n|       0.000000 |\n+----------------+\n\nSELECT 1/NULL;\n\n+--------+\n| 1/NULL |\n|--------|\n|   NULL |\n+--------+\n\nSELECT DIV0NULL(1, NULL);\n\n+-------------------+\n| DIV0NULL(1, NULL) |\n|-------------------|\n|          0.000000 |\n+-------------------+",
    "arguments": [
        {
            "name": "dividend",
            "description": "Numeric expression that evaluates to the value that you want to divide."
        },
        {
            "name": "divisor",
            "description": "Numeric expression that evaluates to the value that you want to divide by."
        }
    ],
    "returns": "The quotient. If the divisor is 0 or NULL, the function returns 0."
},
{
    "function_name": "DIV0",
    "summary": "Performs division like the division operator (/), but returns 0 when the divisor is 0 (rather than reporting an error).",
    "category": "Numeric functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/div0",
    "title": "DIV0",
    "description": "Performs division like the division operator (",
    "syntax": "DIV0( <dividend> , <divisor> )",
    "example": "SELECT 1/2;\n+----------+                                                                    \n|      1/2 |\n|----------|\n| 0.500000 |\n+----------+\nSELECT DIV0(1, 2);\n+------------+                                                                  \n| DIV0(1, 2) |\n|------------|\n|   0.500000 |\n+------------+\n\nselect 1/0;\n100051 (22012): Division by zero\n\nSELECT DIV0(1, 0);\n+------------+                                                                  \n| DIV0(1, 0) |\n|------------|\n|   0.000000 |\n+------------+",
    "arguments": [
        {
            "name": "dividend",
            "description": "Numeric expression that evaluates to the value that you want to divide."
        },
        {
            "name": "divisor",
            "description": "Numeric expression that evaluates to the value that you want to divide by."
        }
    ],
    "returns": "The quotient. If the divisor is 0, the function returns 0."
},
{
    "function_name": "DENSE_RANK",
    "summary": "Returns the rank of a value within a group of values, without gaps in the ranks.",
    "category": "Window function syntax and usage",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/dense_rank",
    "title": "DENSE_RANK",
    "description": "Returns the rank of a value within a group of values, without gaps in the ranks.",
    "syntax": "DENSE_RANK() OVER ( [ PARTITION BY <expr1> ] ORDER BY <expr2> [ ASC | DESC ] [ <window_frame> ] )",
    "example": "-- Create table and load data.\ncreate or replace table corn_production (farmer_ID INTEGER, state varchar, bushels float);\ninsert into corn_production (farmer_ID, state, bushels) values\n    (1, 'Iowa', 100),\n    (2, 'Iowa', 110),\n    (3, 'Kansas', 120),\n    (4, 'Kansas', 130);\n\nSELECT state, bushels,\n        RANK() OVER (ORDER BY bushels DESC),\n        DENSE_RANK() OVER (ORDER BY bushels DESC)\n    FROM corn_production;\n+--------+---------+-------------------------------------+-------------------------------------------+\n| STATE  | BUSHELS | RANK() OVER (ORDER BY BUSHELS DESC) | DENSE_RANK() OVER (ORDER BY BUSHELS DESC) |\n|--------+---------+-------------------------------------+-------------------------------------------|\n| Kansas |     130 |                                   1 |                                         1 |\n| Kansas |     120 |                                   2 |                                         2 |\n| Iowa   |     110 |                                   3 |                                         3 |\n| Iowa   |     100 |                                   4 |                                         4 |\n+--------+---------+-------------------------------------+-------------------------------------------+\n\nSELECT state, bushels,\n        RANK() OVER (PARTITION BY state ORDER BY bushels DESC),\n        DENSE_RANK() OVER (PARTITION BY state ORDER BY bushels DESC)\n    FROM corn_production;\n+--------+---------+--------------------------------------------------------+--------------------------------------------------------------+\n| STATE  | BUSHELS | RANK() OVER (PARTITION BY STATE ORDER BY BUSHELS DESC) | DENSE_RANK() OVER (PARTITION BY STATE ORDER BY BUSHELS DESC) |\n|--------+---------+--------------------------------------------------------+--------------------------------------------------------------|\n| Iowa   |     110 |                                                      1 |                                                            1 |\n| Iowa   |     100 |                                                      2 |                                                            2 |\n| Kansas |     130 |                                                      1 |                                                            1 |\n| Kansas |     120 |                                                      2 |                                                            2 |\n+--------+---------+--------------------------------------------------------+--------------------------------------------------------------+\n\nSELECT state, bushels,\n        RANK() OVER (ORDER BY bushels DESC),\n        DENSE_RANK() OVER (ORDER BY bushels DESC)\n    FROM corn_production;\n+--------+---------+-------------------------------------+-------------------------------------------+\n| STATE  | BUSHELS | RANK() OVER (ORDER BY BUSHELS DESC) | DENSE_RANK() OVER (ORDER BY BUSHELS DESC) |\n|--------+---------+-------------------------------------+-------------------------------------------|\n| Kansas |     130 |                                   1 |                                         1 |\n| Kansas |     120 |                                   2 |                                         2 |\n| Iowa   |     110 |                                   3 |                                         3 |\n| Iowa   |     110 |                                   3 |                                         3 |\n| Iowa   |     100 |                                   5 |                                         4 |\n+--------+---------+-------------------------------------+-------------------------------------------+"
},
{
    "function_name": "DEGREES",
    "summary": "Converts radians to degrees.",
    "category": "Numeric functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/degrees",
    "title": "DEGREES",
    "description": "Converts radians to degrees.",
    "syntax": "DEGREES( <real_expr> )",
    "example": "SELECT DEGREES(PI()/3), DEGREES(PI()), DEGREES(3 * PI()), DEGREES(1);\n+-----------------+---------------+-------------------+--------------+\n| DEGREES(PI()/3) | DEGREES(PI()) | DEGREES(3 * PI()) |   DEGREES(1) |\n|-----------------+---------------+-------------------+--------------|\n|              60 |           180 |               540 | 57.295779513 |\n+-----------------+---------------+-------------------+--------------+",
    "arguments": [
        {
            "name": "real_expr",
            "description": "An expression representing the number of radians."
        }
    ],
    "returns": "This returns a value of type\nREAL/FLOAT (double-precision floating point)."
},
{
    "function_name": "DECRYPT_RAW",
    "summary": "Decrypts a BINARY value using a BINARY key.",
    "category": "Encryption functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/decrypt_raw",
    "title": "DECRYPT_RAW",
    "description": "Decrypts a BINARY value using a BINARY key.",
    "syntax": "DECRYPT_RAW( <value_to_decrypt> , <key> , <iv> ,\n         [ [ [ <additional_authenticated_data> , ] <encryption_method> , ] <aead_tag> ]\n       )",
    "example": "ALTER SESSION SET BINARY_OUTPUT_FORMAT='HEX';\n\nCREATE OR REPLACE TABLE binary_table (\n    encryption_key BINARY,   -- DO NOT STORE REAL ENCRYPTION KEYS THIS WAY!\n    initialization_vector BINARY(12), -- DO NOT STORE REAL IV'S THIS WAY!!\n    binary_column BINARY,\n    encrypted_binary_column VARIANT,\n    aad_column BINARY);\n\nINSERT INTO binary_table (encryption_key,\n                          initialization_vector,\n                          binary_column,\n                          aad_column)\n    SELECT SHA2_BINARY('NotSecretEnough', 256),\n            SUBSTR(TO_BINARY(HEX_ENCODE('AlsoNotSecretEnough'), 'HEX'), 0, 12),\n            TO_BINARY(HEX_ENCODE('Bonjour'), 'HEX'),\n            TO_BINARY(HEX_ENCODE('additional data'), 'HEX')\n    ;\n\nUPDATE binary_table SET encrypted_binary_column =\n    ENCRYPT_RAW(binary_column, \n        encryption_key, \n        initialization_vector, \n        aad_column,\n        'AES-GCM');\n+------------------------+-------------------------------------+\n| number of rows updated | number of multi-joined rows updated |\n|------------------------+-------------------------------------|\n|                      1 |                                   0 |\n+------------------------+-------------------------------------+\n\nSELECT 'Bonjour' as original_value,\n       binary_column,\n       hex_decode_string(to_varchar(binary_column)) as decoded,\n       encrypted_binary_column,\n       decrypt_raw(as_binary(get(encrypted_binary_column, 'ciphertext')),\n                  encryption_key,\n                  as_binary(get(encrypted_binary_column, 'iv')),\n                  aad_column,\n                  'AES-GCM',\n                  as_binary(get(encrypted_binary_column, 'tag')))\n           as decrypted,\n       hex_decode_string(to_varchar(decrypt_raw(as_binary(get(encrypted_binary_column, 'ciphertext')),\n                  encryption_key,\n                  as_binary(get(encrypted_binary_column, 'iv')),\n                  aad_column,\n                  'AES-GCM',\n                  as_binary(get(encrypted_binary_column, 'tag')))\n                  ))\n           as decrypted_and_decoded\n    FROM binary_table;\n+----------------+----------------+---------+---------------------------------------------+----------------+-----------------------+\n| ORIGINAL_VALUE | BINARY_COLUMN  | DECODED | ENCRYPTED_BINARY_COLUMN                     | DECRYPTED      | DECRYPTED_AND_DECODED |\n|----------------+----------------+---------+---------------------------------------------+----------------+-----------------------|\n| Bonjour        | 426F6E6A6F7572 | Bonjour | {                                           | 426F6E6A6F7572 | Bonjour               |\n|                |                |         |   \"ciphertext\": \"CA2F4A383F6F55\",           |                |                       |\n|                |                |         |   \"iv\": \"416C736F4E6F745365637265\",         |                |                       |\n|                |                |         |   \"tag\": \"91F28FBC6A2FE9B213D1C44B8D75D147\" |                |                       |\n|                |                |         | }                                           |                |                       |\n+----------------+----------------+---------+---------------------------------------------+----------------+-----------------------+\n\nWITH\n    decrypted_but_not_decoded as (\n        decrypt_raw(as_binary(get(encrypted_binary_column, 'ciphertext')),\n                      encryption_key,\n                      as_binary(get(encrypted_binary_column, 'iv')),\n                      aad_column,\n                      'AES-GCM',\n                      as_binary(get(encrypted_binary_column, 'tag')))\n    )\nSELECT 'Bonjour' as original_value,\n       binary_column,\n       hex_decode_string(to_varchar(binary_column)) as decoded,\n       encrypted_binary_column,\n       decrypted_but_not_decoded,\n       hex_decode_string(to_varchar(decrypted_but_not_decoded))\n           as decrypted_and_decoded\n    FROM binary_table;\n+----------------+----------------+---------+---------------------------------------------+---------------------------+-----------------------+\n| ORIGINAL_VALUE | BINARY_COLUMN  | DECODED | ENCRYPTED_BINARY_COLUMN                     | DECRYPTED_BUT_NOT_DECODED | DECRYPTED_AND_DECODED |\n|----------------+----------------+---------+---------------------------------------------+---------------------------+-----------------------|\n| Bonjour        | 426F6E6A6F7572 | Bonjour | {                                           | 426F6E6A6F7572            | Bonjour               |\n|                |                |         |   \"ciphertext\": \"CA2F4A383F6F55\",           |                           |                       |\n|                |                |         |   \"iv\": \"416C736F4E6F745365637265\",         |                           |                       |\n|                |                |         |   \"tag\": \"91F28FBC6A2FE9B213D1C44B8D75D147\" |                           |                       |\n|                |                |         | }                                           |                           |                       |\n+----------------+----------------+---------+---------------------------------------------+---------------------------+-----------------------+",
    "arguments": [
        {
            "name": "value_to_decrypt",
            "description": "The binary value to decrypt."
        },
        {
            "name": "key",
            "description": "The key to use to encrypt/decrypt the data. The key must be a BINARY value. The key can be any value as long as the\nlength is correct. For example, for AES128, the key must be 128 bits (16 bytes), and for AES256, the key must be\n256 bits (32 bytes). The key used to encrypt the value must be used to decrypt the value."
        },
        {
            "name": "iv",
            "description": "This parameter contains the Initialization Vector (IV) to use to encrypt and decrypt this piece of\ndata. The IV must be a BINARY value of a specific length: For GCM, this field must be 96 bits (12 bytes). While the GCM encryption method allows this field to be a different\nsize, Snowflake currently only supports 96 bits. For CCM, this should be 56 bits (7 bytes). For ECB, this parameter is unneeded. For all other supported encryption modes, this should be 128 bits (16 bytes). This value is used to initialize the first encryption round. You should never use the same IV and key combination\nmore than once, especially for encryption modes like GCM. If this parameter is set to NULL, the implementation will choose a new pseudo-random IV during each call."
        },
        {
            "name": "additional_authenticated_data",
            "description": "Additional authenticated data (AAD) is additional data whose confidentiality and authenticity is assured during the\ndecryption process. However, this AAD is not encrypted and is not included as a field in the returned value from the\nENCRYPT or ENCRYPT_RAW function. If AAD is passed to the encryption function (ENCRYPT or ENCRYPT_RAW), then the same AAD must be passed to the\ndecryption function (DECRYPT or DECRYPT_RAW). If the AAD passed to the decryption function does not match the\nAAD passed to the encryption function, then decryption fails. The difference between the AAD and the passphrase is that the passphrase is intended to be kept\nsecret (otherwise, the encryption is essentially worthless) while the AAD can be left public. The AAD helps\nauthenticate that a public piece of information and an encrypted value are associated with each other. The\nexamples section in the ENCRYPT function includes an example showing the behavior\nwhen the AAD matches and the behavior when it doesn’t match. For ENCRYPT_RAW and DECRYPT_RAW, the data type of the AAD should be BINARY.\nFor ENCRYPT and DECRYPT, the data type of the AAD can be either VARCHAR or BINARY, and does not need to match\nthe data type of the value that was encrypted. AAD is supported only by AEAD-enabled encryption modes like GCM (default)."
        },
        {
            "name": "encryption_method",
            "description": "This string specifies the method to use for encrypting/decrypting the data. This string contains subfields: The algorithm is currently limited to: 'AES' : When a passphrase is passed (e.g. to ENCRYPT), the function uses AES-256 encryption (256 bits). When a key\nis passed (e.g. to ENCRYPT_RAW), the function uses 128, 192, or 256-bit encryption, depending upon the key\nlength. The algorithm is case-insensitive. The mode specifies which block cipher mode should be used to encrypt messages.\nThe following table shows which modes are supported, and which of those modes support padding: Mode Padding Description 'ECB' Yes Encrypt every block individually with the key. This mode is generally discouraged and is included only for compatibility with external implementations. 'CBC' Yes The encrypted block is XORed with the previous block. 'GCM' No Galois/Counter Mode is a high-performance encryption mode that is AEAD-enabled. AEAD additionally assures the authenticity and confidentiality of the encrypted data by generating an AEAD tag. Moreover, AEAD supports AAD (additional authenticated data). 'CTR' No Counter mode. 'OFB' No Output feedback. The ciphertext is XORed with the plaintext of a block. 'CFB' No Cipher feedback is a combination of OFB and CBC. The mode is case-insensitive. The padding specifies how to pad messages whose length is not a multiple of the block size. Padding is\napplicable only for ECB and CBC modes; padding is ignored for other modes. The possible values for padding are: 'PKCS' : Uses PKCS5 for block padding. 'NONE' : No padding. The user needs to take care of the padding when using ECB or CBC mode. The padding is case-insensitive. Default setting: 'AES-GCM' . If the mode is not specified, GCM is used. If the padding is not specified, PKCS is used."
        },
        {
            "name": "aead_tag",
            "description": "This BINARY value is needed for AEAD-enabled decryption modes to check the authenticity and confidentiality of the\nencrypted data. Use the AEAD tag that was returned by the ENCRYPT_RAW function. An example below shows how to\naccess and use this value."
        }
    ],
    "returns": "The function returns the decrypted value. The data type of the returned value is BINARY."
},
{
    "function_name": "DECRYPT",
    "summary": "Decrypts a BINARY value using a VARCHAR passphrase.",
    "category": "Encryption functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/decrypt",
    "title": "DECRYPT",
    "description": "Decrypts a BINARY value using a VARCHAR passphrase.",
    "syntax": "DECRYPT( <value_to_decrypt> , <passphrase> ,\n         [ [ <additional_authenticated_data> , ] <encryption_method> ]\n       )",
    "example": "SET passphrase='poiuqewjlkfsd';\n\nSELECT\n    TO_VARCHAR(\n        DECRYPT(\n            ENCRYPT('Patient tested positive for COVID-19', $passphrase),\n            $passphrase),\n        'utf-8')\n        AS decrypted\n    ;\n+--------------------------------------+\n| DECRYPTED                            |\n|--------------------------------------|\n| Patient tested positive for COVID-19 |\n+--------------------------------------+\n\nALTER SESSION SET BINARY_OUTPUT_FORMAT='hex';\n\nCREATE TABLE binary_table (\n    binary_column BINARY,\n    encrypted_binary_column BINARY);\nINSERT INTO binary_table (binary_column) \n    SELECT (TO_BINARY(HEX_ENCODE('Hello')));\nUPDATE binary_table \n    SET encrypted_binary_column = ENCRYPT(binary_column, 'SamplePassphrase');\n\nSELECT 'Hello' as original_value,\n       binary_column, \n       hex_decode_string(to_varchar(binary_column)) as decoded,\n       -- encrypted_binary_column,\n       decrypt(encrypted_binary_column, 'SamplePassphrase') as decrypted,\n       hex_decode_string(to_varchar(decrypt(encrypted_binary_column, 'SamplePassphrase'))) as decrypted_and_decoded\n    FROM binary_table;\n+----------------+---------------+---------+------------+-----------------------+\n| ORIGINAL_VALUE | BINARY_COLUMN | DECODED | DECRYPTED  | DECRYPTED_AND_DECODED |\n|----------------+---------------+---------+------------+-----------------------|\n| Hello          | 48656C6C6F    | Hello   | 48656C6C6F | Hello                 |\n+----------------+---------------+---------+------------+-----------------------+\n\nselect encrypt(to_binary(hex_encode('secret!')), 'sample_passphrase', NULL, 'aes-cbc/pad:pkcs') as encrypted_data;\n\nSELECT\n    TO_VARCHAR(\n        DECRYPT(\n            ENCRYPT('penicillin', $passphrase, 'John Dough AAD', 'aes-gcm'),\n            $passphrase, 'John Dough AAD', 'aes-gcm'),\n        'utf-8')\n        AS medicine\n    ;\n+------------+\n| MEDICINE   |\n|------------|\n| penicillin |\n+------------+\n\nSELECT\n    DECRYPT(\n        ENCRYPT('penicillin', $passphrase, 'John Dough AAD', 'aes-gcm'),\n        $passphrase, 'wrong patient AAD', 'aes-gcm') AS medicine\n    ;\n\n100311 (22023): Decryption failed. Check encrypted data, key, AAD, or AEAD tag.",
    "arguments": [
        {
            "name": "value_to_decrypt",
            "description": "The BINARY value to decrypt."
        },
        {
            "name": "passphrase",
            "description": "The passphrase to use to encrypt/decrypt the data. The passphrase is a VARCHAR."
        },
        {
            "name": "additional_authenticated_data",
            "description": "Additional authenticated data (AAD) is additional data whose confidentiality and authenticity is assured during the\ndecryption process. However, this AAD is not encrypted and is not included as a field in the returned value from the\nENCRYPT or ENCRYPT_RAW function. If AAD is passed to the encryption function (ENCRYPT or ENCRYPT_RAW), then the same AAD must be passed to the\ndecryption function (DECRYPT or DECRYPT_RAW). If the AAD passed to the decryption function does not match the\nAAD passed to the encryption function, then decryption fails. The difference between the AAD and the passphrase is that the passphrase is intended to be kept\nsecret (otherwise, the encryption is essentially worthless) while the AAD can be left public. The AAD helps\nauthenticate that a public piece of information and an encrypted value are associated with each other. The\nexamples section in the ENCRYPT function includes an example showing the behavior\nwhen the AAD matches and the behavior when it doesn’t match. For ENCRYPT_RAW and DECRYPT_RAW, the data type of the AAD should be BINARY.\nFor ENCRYPT and DECRYPT, the data type of the AAD can be either VARCHAR or BINARY, and does not need to match\nthe data type of the value that was encrypted. AAD is supported only by AEAD-enabled encryption modes like GCM (default)."
        },
        {
            "name": "encryption_method",
            "description": "This string specifies the method to use for encrypting/decrypting the data. This string contains subfields: The algorithm is currently limited to: 'AES' : When a passphrase is passed (e.g. to ENCRYPT), the function uses AES-256 encryption (256 bits). When a key\nis passed (e.g. to ENCRYPT_RAW), the function uses 128, 192, or 256-bit encryption, depending upon the key\nlength. The algorithm is case-insensitive. The mode specifies which block cipher mode should be used to encrypt messages.\nThe following table shows which modes are supported, and which of those modes support padding: Mode Padding Description 'ECB' Yes Encrypt every block individually with the key. This mode is generally discouraged and is included only for compatibility with external implementations. 'CBC' Yes The encrypted block is XORed with the previous block. 'GCM' No Galois/Counter Mode is a high-performance encryption mode that is AEAD-enabled. AEAD additionally assures the authenticity and confidentiality of the encrypted data by generating an AEAD tag. Moreover, AEAD supports AAD (additional authenticated data). 'CTR' No Counter mode. 'OFB' No Output feedback. The ciphertext is XORed with the plaintext of a block. 'CFB' No Cipher feedback is a combination of OFB and CBC. The mode is case-insensitive. The padding specifies how to pad messages whose length is not a multiple of the block size. Padding is\napplicable only for ECB and CBC modes; padding is ignored for other modes. The possible values for padding are: 'PKCS' : Uses PKCS5 for block padding. 'NONE' : No padding. The user needs to take care of the padding when using ECB or CBC mode. The padding is case-insensitive. Default setting: 'AES-GCM' . If the mode is not specified, GCM is used. If the padding is not specified, PKCS is used."
        }
    ],
    "returns": "Returns the decrypted value as a BINARY value. If the original value before encryption was VARCHAR, you must\nexplicitly convert the returned BINARY back to VARCHAR. For example:"
},
{
    "function_name": "DECOMPRESS_STRING",
    "summary": "Decompresses the compressed BINARY input parameter to a string.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/decompress_string",
    "title": "DECOMPRESS_STRING",
    "description": "Decompresses the compressed",
    "syntax": "DECOMPRESS_STRING(<input>, <method>)",
    "example": "SELECT COMPRESS('Snowflake', 'SNAPPY');\n+---------------------------------+\n| COMPRESS('SNOWFLAKE', 'SNAPPY') |\n|---------------------------------|\n| 0920536E6F77666C616B65          |\n+---------------------------------+\n\nSELECT DECOMPRESS_STRING(TO_BINARY('0920536E6F77666C616B65', 'HEX'), 'SNAPPY');\n+-------------------------------------------------------------------------+\n| DECOMPRESS_STRING(TO_BINARY('0920536E6F77666C616B65', 'HEX'), 'SNAPPY') |\n|-------------------------------------------------------------------------|\n| Snowflake                                                               |\n+-------------------------------------------------------------------------+",
    "arguments": [
        {
            "name": "input",
            "description": "A BINARY value (or expression) with data that was compressed using one\nof the compression methods specified in COMPRESS ."
        },
        {
            "name": "method",
            "description": "The compression method originally used to compress the input .\nSee COMPRESS for a list of compression\nmethods. The DECOMPRESS_STRING method, unlike the COMPRESS method, does\nnot require you to specify the compression level. If you do specify\nthe compression level, DECOMPRESS_STRING ignores it and uses the\nactual compression level."
        }
    ],
    "returns": "A string with decompressed data."
},
{
    "function_name": "DECOMPRESS_BINARY",
    "summary": "Decompresses the compressed BINARY input parameter.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/decompress_binary",
    "title": "DECOMPRESS_BINARY",
    "description": "Decompresses the compressed",
    "syntax": "DECOMPRESS_BINARY(<input>, <method>)",
    "example": "SELECT DECOMPRESS_BINARY(TO_BINARY('0920536E6F77666C616B65', 'HEX'), 'SNAPPY');\n+-------------------------------------------------------------------------+\n| DECOMPRESS_BINARY(TO_BINARY('0920536E6F77666C616B65', 'HEX'), 'SNAPPY') |\n|-------------------------------------------------------------------------|\n| 536E6F77666C616B65                                                      |\n+-------------------------------------------------------------------------+",
    "arguments": [
        {
            "name": "input",
            "description": "A BINARY value (or expression) with data that was compressed using one\nof the compression methods specified in COMPRESS . If you attempt to decompress a compressed string, rather than a\ncompressed BINARY value, you do not get an error; instead, the function\nreturns a BINARY value. See the Usage Notes below for details."
        },
        {
            "name": "method",
            "description": "The compression method originally used to compress the input .\nSee COMPRESS for a list of compression\nmethods. The DECOMPRESS_BINARY method, unlike the COMPRESS method, does\nnot require you to specify the compression level. If you do specify\nthe compression level, DECOMPRESS_BINARY ignores it and uses the actual\ncompression level."
        }
    ],
    "returns": "The data type of the returned value is BINARY."
},
{
    "function_name": "DECODE",
    "summary": "Compares the select expression to each search expression in order.",
    "category": "Conditional expression functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/decode",
    "title": "DECODE",
    "description": "Compares the select expression to each search expression in order. As soon as\na search expression matches the selection expression, the corresponding result\nexpression is returned.",
    "syntax": "DECODE( <expr> , <search1> , <result1> [ , <search2> , <result2> ... ] [ , <default> ] )",
    "example": "CREATE TABLE d (column1 INTEGER);\nINSERT INTO d (column1) VALUES \n    (1),\n    (2),\n    (NULL),\n    (4);\n\nSELECT column1, decode(column1, \n                       1, 'one', \n                       2, 'two', \n                       NULL, '-NULL-', \n                       'other'\n                      ) AS decode_result\n    FROM d;\n+---------+---------------+\n| COLUMN1 | DECODE_RESULT |\n|---------+---------------|\n|       1 | one           |\n|       2 | two           |\n|    NULL | -NULL-        |\n|       4 | other         |\n+---------+---------------+\n\nSELECT column1, decode(column1, \n                       1, 'one', \n                       2, 'two', \n                       NULL, '-NULL-'\n                       ) AS decode_result\n    FROM d;\n+---------+---------------+\n| COLUMN1 | DECODE_RESULT |\n|---------+---------------|\n|       1 | one           |\n|       2 | two           |\n|    NULL | -NULL-        |\n|       4 | NULL          |\n+---------+---------------+",
    "arguments": [
        {
            "name": "expr",
            "description": "This is the “select expression”. The “search expressions” are compared to\nthis select expression, and if there is a match then DECODE returns the result that corresponds to that search expression. The select\nexpression is typically a column, but can be a subquery, literal, or other\nexpression."
        },
        {
            "name": "searchN",
            "description": "The search expressions indicate the values to compare to the select\nexpression. If one of these search expressions matches, the function returns\nthe corresponding result . If more than one search expression would\nmatch, only the first match’s result is returned."
        },
        {
            "name": "resultN",
            "description": "The results are the values that will be returned if one of the search\nexpressions matches the select expression."
        },
        {
            "name": "default",
            "description": "If an optional default is specified, and if none of the search expressions\nmatch the select expression, then DECODE returns this default value."
        }
    ]
},
{
    "function_name": "DAYNAME",
    "summary": "Extracts the three-letter day-of-week name from the specified date or timestamp.",
    "category": "Date & time functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/dayname",
    "title": "DAYNAME",
    "description": "Extracts the three-letter day-of-week name from the specified date or timestamp.",
    "syntax": "DAYNAME( <date_or_timestamp_expr> )",
    "example": "SELECT DAYNAME(TO_DATE('2024-04-01')) AS DAY;\n\n+-----+\n| DAY |\n|-----|\n| Mon |\n+-----+\n\nSELECT DAYNAME(TO_TIMESTAMP_NTZ('2024-04-02 10:00')) AS DAY;\n\n+-----+\n| DAY |\n|-----|\n| Tue |\n+-----+\n\nCREATE OR REPLACE TABLE dates (d DATE);\n\nINSERT INTO dates (d) VALUES \n  ('2024-01-01'::DATE),\n  ('2024-01-02'::DATE),\n  ('2024-01-03'::DATE),\n  ('2024-01-04'::DATE),\n  ('2024-01-05'::DATE),\n  ('2024-01-06'::DATE),\n  ('2024-01-07'::DATE),\n  ('2024-01-08'::DATE);\n\nSELECT d, DAYNAME(d) \n  FROM dates\n  ORDER BY d;\n\n+------------+------------+\n| D          | DAYNAME(D) |\n|------------+------------|\n| 2024-01-01 | Mon        |\n| 2024-01-02 | Tue        |\n| 2024-01-03 | Wed        |\n| 2024-01-04 | Thu        |\n| 2024-01-05 | Fri        |\n| 2024-01-06 | Sat        |\n| 2024-01-07 | Sun        |\n| 2024-01-08 | Mon        |\n+------------+------------+",
    "arguments": [
        {
            "name": "date_or_timestamp_expr",
            "description": "A date or a timestamp, or an expression that can be evaluated to a date or a timestamp."
        }
    ],
    "returns": "Returns a value of VARCHAR data type."
},
{
    "function_name": "DATEDIFF",
    "summary": "Calculates the difference between two date, time, or timestamp expressions based on the date or time part requested.",
    "category": "Date & time functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/datediff",
    "title": "DATEDIFF",
    "description": "Calculates the difference between two date, time, or timestamp expressions based on the date or time part requested.\nThe function returns the result of subtracting the second argument from the third argument.",
    "syntax": "DATEDIFF( <date_or_time_part>, <date_or_time_expr1>, <date_or_time_expr2> )",
    "example": "SELECT DATEDIFF(year, \n                '2020-04-09 14:39:20'::TIMESTAMP, \n                '2023-05-08 23:39:20'::TIMESTAMP) \n  AS diff_years;\n\n+------------+\n| DIFF_YEARS |\n|------------|\n|          3 |\n+------------+\n\nSELECT DATEDIFF(hour, \n               '2023-05-08T23:39:20.123-07:00'::TIMESTAMP, \n               DATEADD(year, 2, ('2023-05-08T23:39:20.123-07:00')::TIMESTAMP)) \n  AS diff_hours;\n\n+------------+\n| DIFF_HOURS |\n|------------|\n|      17544 |\n+------------+\n\nSELECT column1 date_1, column2 date_2,\n       DATEDIFF(year, column1, column2) diff_years,\n       DATEDIFF(month, column1, column2) diff_months,\n       DATEDIFF(day, column1, column2) diff_days,\n       column2::DATE - column1::DATE AS diff_days_via_minus\n  FROM VALUES\n       ('2015-12-30', '2015-12-31'),\n       ('2015-12-31', '2016-01-01'),\n       ('2016-01-01', '2017-12-31'),\n       ('2016-08-23', '2016-09-07');\n\n+------------+------------+------------+-------------+-----------+---------------------+\n| DATE_1     | DATE_2     | DIFF_YEARS | DIFF_MONTHS | DIFF_DAYS | DIFF_DAYS_VIA_MINUS |\n|------------+------------+------------+-------------+-----------+---------------------|\n| 2015-12-30 | 2015-12-31 |          0 |           0 |         1 |                   1 |\n| 2015-12-31 | 2016-01-01 |          1 |           1 |         1 |                   1 |\n| 2016-01-01 | 2017-12-31 |          1 |          23 |       730 |                 730 |\n| 2016-08-23 | 2016-09-07 |          0 |           1 |        15 |                  15 |\n+------------+------------+------------+-------------+-----------+---------------------+\n\nALTER SESSION SET TIMESTAMP_NTZ_OUTPUT_FORMAT = 'DY, DD MON YYYY HH24:MI:SS';\n\nSELECT column1 timestamp_1, column2 timestamp_2,\n       DATEDIFF(hour, column1, column2) diff_hours,\n       DATEDIFF(minute, column1, column2) diff_minutes,\n       DATEDIFF(second, column1, column2) diff_seconds\n  FROM VALUES\n       ('2016-01-01 01:59:59'::TIMESTAMP, '2016-01-01 02:00:00'::TIMESTAMP),\n       ('2016-01-01 01:00:00'::TIMESTAMP, '2016-01-01 01:59:00'::TIMESTAMP),\n       ('2016-01-01 01:00:59'::TIMESTAMP, '2016-01-01 02:00:00'::TIMESTAMP);\n\n+---------------------------+---------------------------+------------+--------------+--------------+\n| TIMESTAMP_1               | TIMESTAMP_2               | DIFF_HOURS | DIFF_MINUTES | DIFF_SECONDS |\n|---------------------------+---------------------------+------------+--------------+--------------|\n| Fri, 01 Jan 2016 01:59:59 | Fri, 01 Jan 2016 02:00:00 |          1 |            1 |            1 |\n| Fri, 01 Jan 2016 01:00:00 | Fri, 01 Jan 2016 01:59:00 |          0 |           59 |         3540 |\n| Fri, 01 Jan 2016 01:00:59 | Fri, 01 Jan 2016 02:00:00 |          1 |           60 |         3541 |\n+---------------------------+---------------------------+------------+--------------+--------------+\n\nSELECT column1 specified_timestamp,\n       column2 timestamp_now,\n       DATEDIFF(year, column1, column2) diff_years,\n       DATEDIFF(month, column1, column2) diff_months,\n       DATEDIFF(day, column1, column2) diff_days,\n       column2::DATE - column1::DATE AS diff_days_via_minus\n  FROM VALUES\n    ('2012-08-23 09:00:00.000 -0700', CURRENT_TIMESTAMP);\n\n+-------------------------------+-------------------------------+------------+-------------+-----------+---------------------+\n| SPECIFIED_TIMESTAMP           | TIMESTAMP_NOW                 | DIFF_YEARS | DIFF_MONTHS | DIFF_DAYS | DIFF_DAYS_VIA_MINUS |\n|-------------------------------+-------------------------------+------------+-------------+-----------+---------------------|\n| 2012-08-23 09:00:00.000 -0700 | 2024-09-04 17:21:12.189 -0700 |         12 |         145 |      4395 |                4395 |\n+-------------------------------+-------------------------------+------------+-------------+-----------+---------------------+",
    "arguments": [
        {
            "name": "date_or_time_part",
            "description": "The unit of time. Must be one of the values listed in Supported date and time parts (for example, month ).\nThe value can be a string literal or can be unquoted (for example, 'month' or month )."
        },
        {
            "name": "date_or_time_expr1",
            "description": "The values to compare. Must be a date, a time, a timestamp, or an expression that can be evaluated to\na date, a time, or a timestamp. The value date_or_time_expr1 is subtracted from date_or_time_expr2 ."
        },
        {
            "name": "date_expr1",
            "description": "The values to compare. Must be a date, or an expression that can be evaluated to a date. The value date_expr1 is\nsubtracted from date_expr2 ."
        }
    ],
    "returns": "For DATEDIFF:"
},
{
    "function_name": "DATEADD",
    "summary": "Adds the specified value for the specified date or time part to a date, time, or timestamp.",
    "category": "Date & time functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/dateadd",
    "title": "DATEADD",
    "description": "Adds the specified value for the specified date or time part to a date, time, or timestamp.",
    "syntax": "DATEADD( <date_or_time_part>, <value>, <date_or_time_expr> )",
    "example": "SELECT TO_DATE('2022-05-08') AS original_date,\n       DATEADD(year, 2, TO_DATE('2022-05-08')) AS date_plus_two_years;\n\n+---------------+---------------------+\n| ORIGINAL_DATE | DATE_PLUS_TWO_YEARS |\n|---------------+---------------------|\n| 2022-05-08    | 2024-05-08          |\n+---------------+---------------------+\n\nSELECT TO_DATE('2022-05-08') AS original_date,\n       DATEADD(year, -2, TO_DATE('2022-05-08')) AS date_minus_two_years;\n\n+---------------+----------------------+\n| ORIGINAL_DATE | DATE_MINUS_TWO_YEARS |\n|---------------+----------------------|\n| 2022-05-08    | 2020-05-08           |\n+---------------+----------------------+\n\nALTER SESSION SET TIMESTAMP_OUTPUT_FORMAT = 'YYYY-MM-DD HH24:MI:SS.FF9';\nCREATE TABLE datetest (d date);\nINSERT INTO datetest VALUES ('2022-04-05');\n\nSELECT d AS original_date,\n       DATEADD(year, 2, d) AS date_plus_two_years,\n       TO_TIMESTAMP(d) AS original_timestamp,\n       DATEADD(hour, 2, d) AS timestamp_plus_two_hours\n  FROM datetest;\n\n+---------------+---------------------+-------------------------+--------------------------+\n| ORIGINAL_DATE | DATE_PLUS_TWO_YEARS | ORIGINAL_TIMESTAMP      | TIMESTAMP_PLUS_TWO_HOURS |\n|---------------+---------------------+-------------------------+--------------------------|\n| 2022-04-05    | 2024-04-05          | 2022-04-05 00:00:00.000 | 2022-04-05 02:00:00.000  |\n+---------------+---------------------+-------------------------+--------------------------+\n\nSELECT DATEADD(month, 1, '2023-01-31'::DATE) AS date_plus_one_month;\n\n+---------------------+\n| DATE_PLUS_ONE_MONTH |\n|---------------------|\n| 2023-02-28          |\n+---------------------+\n\nSELECT DATEADD(month, 1, '2023-02-28'::DATE) AS date_plus_one_month;\n\n+---------------------+\n| DATE_PLUS_ONE_MONTH |\n|---------------------|\n| 2023-03-28          |\n+---------------------+\n\nSELECT TO_TIME('05:00:00') AS original_time,\n       DATEADD(hour, 3, TO_TIME('05:00:00')) AS time_plus_three_hours;\n\n+---------------+-----------------------+\n| ORIGINAL_TIME | TIME_PLUS_THREE_HOURS |\n|---------------+-----------------------|\n| 05:00:00      | 08:00:00              |\n+---------------+-----------------------+",
    "arguments": [
        {
            "name": "date_or_time_part",
            "description": "This indicates the units of time that you want to add. For example if you\nwant to add two days, then specify day . This unit of measure must\nbe one of the values listed in Supported date and time parts ."
        },
        {
            "name": "value",
            "description": "This is the number of units of time that you want to add. For example,\nif the units of time is day , and you want to add two days, specify 2 .\nIf you want to subtract two days, specify -2 ."
        },
        {
            "name": "date_or_time_expr",
            "description": "date_or_time_expr must evaluate to a date, time, or timestamp.\nThis is the date, time, or timestamp to which you want to add.\nFor example, if you want to add two days to August 1, 2024, then specify '2024-08-01'::DATE . If the data type is TIME, then the date_or_time_part must be in units of hours or smaller, not days or bigger. If the input data type is DATE, and the date_or_time_part is hours\nor smaller, the input value will not be rejected, but instead will be\ntreated as a TIMESTAMP with hours, minutes, seconds, and fractions of\na second all initially set to 0 (e.g. midnight on the specified date)."
        }
    ],
    "returns": "If date_or_time_expr is a time, then the return data type is a time."
},
{
    "function_name": "DATE_TRUNC",
    "summary": "Truncates a DATE, TIME, or TIMESTAMP value to the specified precision.",
    "category": "Date & time functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/date_trunc",
    "title": "DATE_TRUNC",
    "description": "Truncates a DATE, TIME, or TIMESTAMP value to the specified precision. For example,\ntruncating a timestamp down to the quarter returns the timestamp corresponding\nto midnight of the first day of the original timestamp’s quarter.",
    "syntax": "DATE_TRUNC( <date_or_time_part>, <date_or_time_expr> )",
    "example": "CREATE OR REPLACE TABLE test_date_trunc (\n mydate DATE,\n mytime TIME,\n mytimestamp TIMESTAMP);\n\nINSERT INTO test_date_trunc VALUES (\n  '2024-05-09',\n  '08:50:48',\n  '2024-05-09 08:50:57.891 -0700');\n\nSELECT * FROM test_date_trunc;\n\n+------------+----------+-------------------------+\n| MYDATE     | MYTIME   | MYTIMESTAMP             |\n|------------+----------+-------------------------|\n| 2024-05-09 | 08:50:48 | 2024-05-09 08:50:57.891 |\n+------------+----------+-------------------------+\n\nSELECT mydate AS \"DATE\",\n       DATE_TRUNC('year', mydate) AS \"TRUNCATED TO YEAR\",\n       DATE_TRUNC('month', mydate) AS \"TRUNCATED TO MONTH\",\n       DATE_TRUNC('week', mydate) AS \"TRUNCATED TO WEEK\",\n       DATE_TRUNC('day', mydate) AS \"TRUNCATED TO DAY\"\n  FROM test_date_trunc;\n\n+------------+-------------------+--------------------+-------------------+------------------+\n| DATE       | TRUNCATED TO YEAR | TRUNCATED TO MONTH | TRUNCATED TO WEEK | TRUNCATED TO DAY |\n|------------+-------------------+--------------------+-------------------+------------------|\n| 2024-05-09 | 2024-01-01        | 2024-05-01         | 2024-05-06        | 2024-05-09       |\n+------------+-------------------+--------------------+-------------------+------------------+\n\nSELECT mytime AS \"TIME\",\n       DATE_TRUNC('minute', mytime) AS \"TRUNCATED TO MINUTE\"\n  FROM test_date_trunc;\n\n+----------+---------------------+\n| TIME     | TRUNCATED TO MINUTE |\n|----------+---------------------|\n| 08:50:48 | 08:50:00            |\n+----------+---------------------+\n\nSELECT mytimestamp AS \"TIMESTAMP\",\n       DATE_TRUNC('hour', mytimestamp) AS \"TRUNCATED TO HOUR\",\n       DATE_TRUNC('minute', mytimestamp) AS \"TRUNCATED TO MINUTE\",\n       DATE_TRUNC('second', mytimestamp) AS \"TRUNCATED TO SECOND\"\n  FROM test_date_trunc;\n\n+-------------------------+-------------------------+-------------------------+-------------------------+\n| TIMESTAMP               | TRUNCATED TO HOUR       | TRUNCATED TO MINUTE     | TRUNCATED TO SECOND     |\n|-------------------------+-------------------------+-------------------------+-------------------------|\n| 2024-05-09 08:50:57.891 | 2024-05-09 08:00:00.000 | 2024-05-09 08:50:00.000 | 2024-05-09 08:50:57.000 |\n+-------------------------+-------------------------+-------------------------+-------------------------+\n\nSELECT DATE_TRUNC('quarter', mytimestamp) AS \"TRUNCATED\",\n       EXTRACT('quarter', mytimestamp) AS \"EXTRACTED\"\n  FROM test_date_trunc;\n\n+-------------------------+-----------+\n| TRUNCATED               | EXTRACTED |\n|-------------------------+-----------|\n| 2024-04-01 00:00:00.000 |         2 |\n+-------------------------+-----------+",
    "arguments": [
        {
            "name": "date_or_time_part",
            "description": "This argument must be one of the values listed in Supported date and time parts ."
        },
        {
            "name": "date_or_time_expr",
            "description": "This argument must evaluate to a date, time, or timestamp."
        }
    ],
    "returns": "The returned value is the same type as the input value."
},
{
    "function_name": "DATE_PART",
    "summary": "Extracts the specified date or time part from a date, time, or timestamp.",
    "category": "Date & time functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/date_part",
    "title": "DATE_PART",
    "description": "Extracts the specified date or time part from a date, time, or timestamp.",
    "syntax": "DATE_PART( <date_or_time_part> , <date_time_or_timestamp_expr> )",
    "example": "SELECT DATE_PART(quarter, '2024-04-08'::DATE);\n\n+----------------------------------------+\n| DATE_PART(QUARTER, '2024-04-08'::DATE) |\n|----------------------------------------|\n|                                      2 |\n+----------------------------------------+\n\nSELECT TO_TIMESTAMP(\n  '2024-04-08T23:39:20.123-07:00') AS \"TIME_STAMP1\",\n  DATE_PART(year, \"TIME_STAMP1\") AS \"EXTRACTED YEAR\";\n\n+-------------------------+----------------+\n| TIME_STAMP1             | EXTRACTED YEAR |\n|-------------------------+----------------|\n| 2024-04-08 23:39:20.123 |           2024 |\n+-------------------------+----------------+\n\nSELECT TO_TIMESTAMP(\n  '2024-04-08T23:39:20.123-07:00') AS \"TIME_STAMP1\",\n  DATE_PART(epoch_second, \"TIME_STAMP1\") AS \"EXTRACTED EPOCH SECOND\";\n\n+-------------------------+------------------------+\n| TIME_STAMP1             | EXTRACTED EPOCH SECOND |\n|-------------------------+------------------------|\n| 2024-04-08 23:39:20.123 |             1712619560 |\n+-------------------------+------------------------+\n\nSELECT TO_TIMESTAMP(\n  '2024-04-08T23:39:20.123-07:00') AS \"TIME_STAMP1\",\n  DATE_PART(epoch_millisecond, \"TIME_STAMP1\") AS \"EXTRACTED EPOCH MILLISECOND\";\n\n+-------------------------+-----------------------------+\n| TIME_STAMP1             | EXTRACTED EPOCH MILLISECOND |\n|-------------------------+-----------------------------|\n| 2024-04-08 23:39:20.123 |               1712619560123 |\n+-------------------------+-----------------------------+",
    "arguments": [
        {
            "name": "date_or_time_part",
            "description": "The unit of time. Must be one of the values listed in Supported date and time parts (e.g. month ).\nThe value can be a string literal or can be unquoted (for example, 'month' or month ). When date_or_time_part is week (or any of its variations), the output is controlled by the WEEK_START session parameter. When date_or_time_part is dayofweek or yearofweek (or any of their variations), the output is controlled by the WEEK_OF_YEAR_POLICY and WEEK_START session parameters. For more information, including examples, see Calendar weeks and weekdays ."
        },
        {
            "name": "date_time_or_timestamp_expr",
            "description": "A date, a time, or a timestamp, or an expression that can be evaluated to a date, a time, or a timestamp."
        }
    ],
    "returns": "Returns a value of NUMBER data type."
},
{
    "function_name": "DATE_FROM_PARTS",
    "summary": "Creates a date from individual numeric components that represent the year, month, and day of the month.",
    "category": "Date & time functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/date_from_parts",
    "title": "DATE_FROM_PARTS",
    "description": "Creates a date from individual numeric components that represent the year,\nmonth, and day of the month.",
    "syntax": "DATE_FROM_PARTS( <year>, <month>, <day> )",
    "example": "SELECT DATE_FROM_PARTS(1977, 8, 7);\n+-----------------------------+\n| DATE_FROM_PARTS(1977, 8, 7) |\n|-----------------------------|\n| 1977-08-07                  |\n+-----------------------------+\n\nSELECT DATE_FROM_PARTS(2010, 1, 100), DATE_FROM_PARTS(2010, 1 + 24, 1);\n+-------------------------------+----------------------------------+\n| DATE_FROM_PARTS(2010, 1, 100) | DATE_FROM_PARTS(2010, 1 + 24, 1) |\n|-------------------------------+----------------------------------|\n| 2010-04-10                    | 2012-01-01                       |\n+-------------------------------+----------------------------------+\n\nSELECT DATE_FROM_PARTS(2004, 1, 1),   -- January 1, 2004, as expected.\n       DATE_FROM_PARTS(2004, 0, 1),   -- This is one month prior to DATE_FROM_PARTS(2004, 1, 1), so it's December 1, 2003.\n                                      -- This is NOT a synonym for January 1, 2004.\n       DATE_FROM_PARTS(2004, -1, 1)   -- This is two months (not one month) before DATE_FROM_PARTS(2004, 1, 1), so it's November 1, 2003.\n       ;\n+-----------------------------+-----------------------------+------------------------------+\n| DATE_FROM_PARTS(2004, 1, 1) | DATE_FROM_PARTS(2004, 0, 1) | DATE_FROM_PARTS(2004, -1, 1) |\n|-----------------------------+-----------------------------+------------------------------|\n| 2004-01-01                  | 2003-12-01                  | 2003-11-01                   |\n+-----------------------------+-----------------------------+------------------------------+\n\nSELECT DATE_FROM_PARTS(2004, 2, 1),   -- February 1, 2004, as expected.\n       DATE_FROM_PARTS(2004, 2, 0),   -- This is one day prior to DATE_FROM_PARTS(2004, 2, 1), so it's January 31, 2004.\n       DATE_FROM_PARTS(2004, 2, -1);  -- Two days prior to DATE_FROM_PARTS(2004, 2, 1) so it's January 30, 2004.\n+-----------------------------+-----------------------------+------------------------------+\n| DATE_FROM_PARTS(2004, 2, 1) | DATE_FROM_PARTS(2004, 2, 0) | DATE_FROM_PARTS(2004, 2, -1) |\n|-----------------------------+-----------------------------+------------------------------|\n| 2004-02-01                  | 2004-01-31                  | 2004-01-30                   |\n+-----------------------------+-----------------------------+------------------------------+\n\nSELECT DATE_FROM_PARTS(2004, -1, -1);  -- Two months and two days prior to DATE_FROM_PARTS(2004, 1, 1), so it's October 30, 2003.\n+-------------------------------+\n| DATE_FROM_PARTS(2004, -1, -1) |\n|-------------------------------|\n| 2003-10-30                    |\n+-------------------------------+",
    "arguments": [
        {
            "name": "year",
            "description": "The integer expression to use as a year for building a date."
        },
        {
            "name": "month",
            "description": "The integer expression to use as a month for building a date, with\nJanuary represented as 1, and December as 12."
        },
        {
            "name": "day",
            "description": "The integer expression to use as a day for building a date, usually in\nthe 1-31 range."
        }
    ]
},
{
    "function_name": "DATASKETCHES_HLL_ESTIMATE",
    "summary": "Returns the cardinality estimate for the given sketch.",
    "category": "Aggregate functions , Window function syntax and usage",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/datasketches_hll_estimate",
    "title": "DATASKETCHES_HLL_ESTIMATE",
    "syntax": "DATASKETCHES_HLL_ESTIMATE( <binary_sketch> )",
    "example": "CREATE OR REPLACE TABLE datasketches_demo(v INT, g INT);\n\nINSERT INTO datasketches_demo SELECT 1, 1;\nINSERT INTO datasketches_demo SELECT 2, 1;\nINSERT INTO datasketches_demo SELECT 2, 1;\nINSERT INTO datasketches_demo SELECT 2, 1;\nINSERT INTO datasketches_demo SELECT 1, 2;\nINSERT INTO datasketches_demo SELECT 1, 2;\nINSERT INTO datasketches_demo SELECT 4, 2;\nINSERT INTO datasketches_demo SELECT 4, 2;\nINSERT INTO datasketches_demo SELECT 5, 2;\n\nWITH\n  accumulated AS (\n    SELECT g,\n           DATASKETCHES_HLL_ACCUMULATE(v) AS accumulated_sketches\n      FROM datasketches_demo\n      GROUP BY g)\nSELECT g, DATASKETCHES_HLL_ESTIMATE(accumulated_sketches) AS accumulated_estimate\n  FROM accumulated;\n\n+---+----------------------+\n| G | ACCUMULATED_ESTIMATE |\n|---+----------------------|\n| 1 |          2.000000005 |\n| 2 |          3.000000015 |\n+---+----------------------+\n\nWITH\n  accumulated AS (\n    SELECT g,\n           DATASKETCHES_HLL_ACCUMULATE(v) AS accumulated_sketches\n      FROM datasketches_demo\n      GROUP BY g),\n  combined AS (\n    SELECT DATASKETCHES_HLL_COMBINE(accumulated_sketches) AS unified\n      FROM accumulated)\nSELECT DATASKETCHES_HLL_ESTIMATE(unified) AS unified_estimate\n  FROM combined;\n\n+------------------+\n| UNIFIED_ESTIMATE |\n|------------------|\n|       4.00000003 |\n+------------------+",
    "arguments": [
        {
            "name": "binary_sketch",
            "description": "An expression that contains sketch information in binary format."
        }
    ],
    "returns": "The function returns a value of type DOUBLE."
},
{
    "function_name": "DATASKETCHES_HLL_COMBINE",
    "summary": "Combines (merges) input sketches into a single output sketch.",
    "category": "Aggregate functions , Window function syntax and usage",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/datasketches_hll_combine",
    "title": "DATASKETCHES_HLL_COMBINE",
    "syntax": "DATASKETCHES_HLL_COMBINE( [ DISTINCT ]  <state> [ , <max_log_k> ] )",
    "example": "CREATE OR REPLACE TABLE datasketches_demo(v INT, g INT);\n\nINSERT INTO datasketches_demo SELECT 1, 1;\nINSERT INTO datasketches_demo SELECT 2, 1;\nINSERT INTO datasketches_demo SELECT 2, 1;\nINSERT INTO datasketches_demo SELECT 2, 1;\nINSERT INTO datasketches_demo SELECT 1, 2;\nINSERT INTO datasketches_demo SELECT 1, 2;\nINSERT INTO datasketches_demo SELECT 4, 2;\nINSERT INTO datasketches_demo SELECT 4, 2;\nINSERT INTO datasketches_demo SELECT 5, 2;\n\nWITH\n  accumulated AS (\n    SELECT g,\n           DATASKETCHES_HLL_ACCUMULATE(v) AS accumulated_sketches\n      FROM datasketches_demo\n      GROUP BY g)\nSELECT DATASKETCHES_HLL_COMBINE(accumulated_sketches) AS combined_sketches\n  FROM accumulated;\n\n+--------------------------------------------------+\n| COMBINED_SKETCHES                                |\n|--------------------------------------------------|\n| 0201070C030804002BF2FB06862FF90D81BC5D067B65E608 |\n+--------------------------------------------------+",
    "returns": "The function returns a BINARY value that is compatible with the Apache Datasketches library."
},
{
    "function_name": "DATASKETCHES_HLL_ACCUMULATE",
    "summary": "Returns the sketch at the end of aggregation.",
    "category": "Aggregate functions , Window function syntax and usage",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/datasketches_hll_accumulate",
    "title": "DATASKETCHES_HLL_ACCUMULATE",
    "syntax": "DATASKETCHES_HLL_ACCUMULATE( [ DISTINCT ] <expr> [ , <max_log_k> ] )",
    "example": "CREATE OR REPLACE TABLE datasketches_demo(v INT, g INT);\n\nINSERT INTO datasketches_demo SELECT 1, 1;\nINSERT INTO datasketches_demo SELECT 2, 1;\nINSERT INTO datasketches_demo SELECT 2, 1;\nINSERT INTO datasketches_demo SELECT 2, 1;\nINSERT INTO datasketches_demo SELECT 1, 2;\nINSERT INTO datasketches_demo SELECT 1, 2;\nINSERT INTO datasketches_demo SELECT 4, 2;\nINSERT INTO datasketches_demo SELECT 4, 2;\nINSERT INTO datasketches_demo SELECT 5, 2;\n\nSELECT g,\n       DATASKETCHES_HLL_ACCUMULATE(v) AS accumulated_sketches\n  FROM datasketches_demo\n  GROUP BY g;\n\n+---+------------------------------------------+\n| G | ACCUMULATED_SKETCHES                     |\n|---+------------------------------------------|\n| 1 | 0201070C030802002BF2FB06862FF90D         |\n| 2 | 0201070C030803002BF2FB0681BC5D067B65E608 |\n+---+------------------------------------------+",
    "returns": "The function returns a BINARY value that is compatible with the Apache Datasketches library."
},
{
    "function_name": "DATASKETCHES_HLL",
    "summary": "Returns an approximation of the distinct cardinality of the input (that is, DATASKETCHES_HLL(col1) returns an approximation of COUNT(DISTINCT col1)).",
    "category": "Aggregate functions , Window functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/datasketches_hll",
    "title": "DATASKETCHES_HLL",
    "syntax": "DATASKETCHES_HLL( [ DISTINCT ] <expr1> [ , <max_log_k> ] )",
    "example": "CREATE OR REPLACE TABLE datasketches_demo(v INT, g INT);\n\nINSERT INTO datasketches_demo SELECT 1, 1;\nINSERT INTO datasketches_demo SELECT 2, 1;\nINSERT INTO datasketches_demo SELECT 2, 1;\nINSERT INTO datasketches_demo SELECT 2, 1;\nINSERT INTO datasketches_demo SELECT 1, 2;\nINSERT INTO datasketches_demo SELECT 1, 2;\nINSERT INTO datasketches_demo SELECT 4, 2;\nINSERT INTO datasketches_demo SELECT 4, 2;\nINSERT INTO datasketches_demo SELECT 5, 2;\n\nSELECT g,\n       DATASKETCHES_HLL(v),\n       COUNT(DISTINCT v)\n  FROM datasketches_demo GROUP BY g;\n\n+---+---------------------+-------------------+\n| G | DATASKETCHES_HLL(V) | COUNT(DISTINCT V) |\n|---+---------------------+-------------------|\n| 1 |         2.000000005 |                 2 |\n| 2 |         3.000000015 |                 3 |\n+---+---------------------+-------------------+\n\nSELECT DATASKETCHES_HLL(v),\n       COUNT(DISTINCT v)\n  FROM datasketches_demo;\n\n+---------------------+-------------------+\n| DATASKETCHES_HLL(V) | COUNT(DISTINCT V) |\n|---------------------+-------------------|\n|          4.00000003 |                 4 |\n+---------------------+-------------------+",
    "returns": "The function returns a value of type DOUBLE."
},
{
    "function_name": "DATABASE_STORAGE_USAGE_HISTORY",
    "summary": "This table function can be used to query the average daily storage usage, in bytes, for a single database (or all the databases in your account) within a specified date range.",
    "category": "Information Schema , Table functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/database_storage_usage_history",
    "title": "DATABASE_STORAGE_USAGE_HISTORY",
    "description": "This table function can be used to query the average daily storage usage, in bytes, for a single database (or all the databases in your account) within a specified date range. The results include:",
    "syntax": "DATABASE_STORAGE_USAGE_HISTORY(\n      [ DATE_RANGE_START => <constant_expr> ]\n      [, DATE_RANGE_END => <constant_expr> ]\n      [, DATABASE_NAME => '<string>' ] )",
    "example": "select *\nfrom table(information_schema.database_storage_usage_history(dateadd('days',-10,current_date()),current_date()));",
    "arguments": [
        {
            "name": "DATE_RANGE_START",
            "description": "The date range, within the last 6 months, for which to retrieve database storage usage: If an end date is not specified, then CURRENT_DATE is used as the end of the range. If a start date is not specified, then DATE_RANGE_END is used as the start of the range (i.e. the default is one day of storage usage). If the range falls outside the last 6 months, an error is returned."
        },
        {
            "name": "DATABASE_NAME",
            "description": "The name of the database to retrieve storage usage history for. Note that the database name must be enclosed in single quotes. Also, if the database name contains any spaces, mixed-case characters,\nor special characters, the name must be double-quoted within the single quotes (e.g. '\"My DB\"' vs 'mydb' ). If no database is specified, then data is returned for all the databases in your account."
        }
    ]
},
{
    "function_name": "DATABASE_REPLICATION_USAGE_HISTORY",
    "summary": "This table function can be used to query the replication history for a specified database within a specified date range.",
    "category": "Information Schema , Table functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/database_replication_usage_history",
    "title": "DATABASE_REPLICATION_USAGE_HISTORY",
    "description": "This table function can be used to query the replication history for a specified database within a specified date range. The information\nreturned by the function includes the database name, credits consumed, and bytes transferred for replication.",
    "syntax": "DATABASE_REPLICATION_USAGE_HISTORY(\n  [ DATE_RANGE_START => <constant_expr> ]\n  [ , DATE_RANGE_END => <constant_expr> ]\n  [ , DATABASE_NAME => '<string>' ] )",
    "example": "select database_name, credits_used, bytes_transferred\n  from table(information_schema.database_replication_usage_history(\n    date_range_start=>'2023-03-28 12:00:00.000 +0000',\n    date_range_end=>'2023-03-28 12:30:00.000 +0000'));\n\nselect database_name, credits_used, bytes_transferred\n  from table(information_schema.database_replication_usage_history(\n    date_range_start=>dateadd(H, -12, current_timestamp)));\n\nselect start_time, end_time, database_name, credits_used, bytes_transferred\n  from table(information_schema.database_replication_usage_history(\n    date_range_start=>dateadd(d, -7, current_date),\n    date_range_end=>current_date));\n\nselect start_time, end_time, database_name, credits_used, bytes_transferred\n  from table(information_schema.database_replication_usage_history(\n    date_range_start=>dateadd(d, -7, current_date),\n    date_range_end=>current_date,\n    database_name=>'mydb'));",
    "arguments": [
        {
            "name": "DATE_RANGE_START",
            "description": "The date/time range to display the database replication history: If an end date is not specified, then CURRENT_DATE is used as the end of the range. If a start date is not specified, then the range starts 10 minutes prior to the start of DATE_RANGE_END (i.e. the default\nis to show the previous 10 minutes of history). For example, if DATE_RANGE_END is CURRENT_DATE, then the default DATE_RANGE_START is 11:50 PM on the previous day."
        },
        {
            "name": "DATABASE_NAME",
            "description": "Database name. If specified, only shows the history for the specified database. If a name is not specified, then the results include the data for each database replicated within the specified time range."
        }
    ]
},
{
    "function_name": "DATABASE_REFRESH_PROGRESS , DATABASE_REFRESH_PROGRESS_BY_JOB",
    "summary": "The DATABASE_REFRESH_PROGRESS family of functions can be used to query the status of a database refresh along various dimensions.",
    "category": "Information Schema , Table functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/database_refresh_progress",
    "title": "DATABASE_REFRESH_PROGRESS , DATABASE_REFRESH_PROGRESS_BY_JOB",
    "description": "The DATABASE_REFRESH_PROGRESS family of functions can be used to query the status of a database refresh along various dimensions:",
    "syntax": "DATABASE_REFRESH_PROGRESS( '<secondary_db_name>' )\n\nDATABASE_REFRESH_PROGRESS_BY_JOB( '<query_id>' )",
    "example": "select *\nfrom table(information_schema.database_refresh_progress(mydb1));\n\nselect *\nfrom table(information_schema.database_refresh_progress_by_job('012a3b45-1234-a12b-0000-1aa200012345'));",
    "arguments": [
        {
            "name": "secondary_db_name",
            "description": "Name of the secondary database. This argument is optional if the secondary database is the active database in the current session. Note that the entire name must be enclosed in single quotes."
        },
        {
            "name": "query_id",
            "description": "ID of the database refresh query. The query ID can be obtained from the History page in the web interface."
        }
    ]
},
{
    "function_name": "DATABASE_REFRESH_HISTORY",
    "summary": "Returns the refresh history for a secondary database.",
    "category": "Information Schema , Table functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/database_refresh_history",
    "title": "DATABASE_REFRESH_HISTORY",
    "description": "Returns the refresh history for a secondary database.",
    "syntax": "DATABASE_REFRESH_HISTORY( '<secondary_db_name>' )",
    "example": "select *\nfrom table(information_schema.database_refresh_history());",
    "arguments": [
        {
            "name": "secondary_db_name",
            "description": "Name of the secondary database. This argument is optional if the secondary database is the active database in the current session. Note that the entire name must be enclosed in single quotes."
        }
    ]
},
{
    "function_name": "DATA_TRANSFER_HISTORY",
    "summary": "This table function can be used to query the history of data transferred from Snowflake tables into a different cloud storage provider’s network (i.e. from Snowflake on AWS, Google Cloud Platform, or Microsoft Azure into the other cloud provider’s network) and/or geographical region within a specified date range.",
    "category": "Information Schema , Table functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/data_transfer_history",
    "title": "DATA_TRANSFER_HISTORY",
    "description": "This table function can be used to query the history of data transferred from Snowflake tables into a different cloud storage provider’s network (i.e. from Snowflake on AWS, Google Cloud Platform, or Microsoft Azure into the other cloud provider’s network) and/or geographical region within a specified date range. The function returns the history for your entire Snowflake account.",
    "syntax": "DATA_TRANSFER_HISTORY(\n      [ DATE_RANGE_START => <constant_expr> ]\n      [, DATE_RANGE_END => <constant_expr> ] )",
    "example": "select *\n  from table(mydb.information_schema.data_transfer_history(\n    date_range_start=>to_timestamp_tz('2017-10-24 12:00:00.000 -0700'),\n    date_range_end=>to_timestamp_tz('2017-10-24 12:30:00.000 -0700')));\n\nselect *\n  from table(information_schema.data_transfer_history(\n    date_range_start=>dateadd('hour',-12,current_timestamp())));\n\nselect *\n  from table(information_schema.data_transfer_history(\n    date_range_start=>dateadd('day',-14,current_date()),\n    date_range_end=>current_date()));",
    "arguments": [
        {
            "name": "DATE_RANGE_START",
            "description": "The date/time range, within the last 2 weeks, for which to retrieve the data transfer history: If an end date is not specified, then CURRENT_DATE is used as the end of the range. If a start date is not specified, then the range starts 10 minutes prior to the start of DATE_RANGE_END (i.e. the default is to show the previous 10 minutes of data transfer history).\nFor example, if DATE_RANGE_END is CURRENT_DATE , then the default DATE_RANGE_START is 11:50 PM on the previous day. History is displayed in increments of 5 minutes, 1 hour, or 24 hours (depending on the length of the specified range). If the range falls outside the last 15 days, an error is returned."
        }
    ]
},
{
    "function_name": "DATA_QUALITY_MONITORING_RESULTS",
    "summary": "Returns a row for each data metric function assigned to the specified object, which includes the evaluation result and other metadata of the data metric function on the object.",
    "category": "LOCAL , Table functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/data_quality_monitoring_results",
    "title": "DATA_QUALITY_MONITORING_RESULTS",
    "description": "Returns a row for each data metric function assigned to the specified object, which includes the evaluation result and other metadata of\nthe data metric function on the object.",
    "syntax": "DATA_QUALITY_MONITORING_RESULTS(\n  REF_ENTITY_NAME => '<string>' ,\n  REF_ENTITY_DOMAIN => '<string>'\n  )",
    "example": "USE DATABASE SNOWFLAKE;\nUSE SCHEMA LOCAL;\nSELECT *\n  FROM TABLE(SNOWFLAKE.LOCAL.DATA_QUALITY_MONITORING_RESULTS(\n    REF_ENTITY_NAME => 'my_db.my_schema.my_table',\n    REF_ENTITY_DOMAIN => 'table'));",
    "arguments": [
        {
            "name": "REF_ENTITY_NAME",
            "description": "The name of the table object on which the data metric function is set. The entire object name must be enclosed in single quotes. If the object name is case-sensitive or includes any special characters or spaces, double quotes are required to process the\ncase/characters. The double quotes must be enclosed within the single quotes, such as '\"<table_name>\"' ."
        },
        {
            "name": "REF_ENTITY_DOMAIN",
            "description": "The object type on which the data metric function is set. If the object is a kind of table, use 'TABLE' as the argument value. If the object is a view or materialized view, use 'VIEW' as the argument value. For a list of supported object types on which a data metric function can be set, see Supported table kinds ."
        }
    ],
    "returns": "The function returns the following columns:"
},
{
    "function_name": "DATA_METRIC_FUNCTION_REFERENCES",
    "summary": "Returns a row for each object that has the specified data metric function assigned to the object or returns a row for each data metric function assigned to the specified object.",
    "category": "Information Schema , Table functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/data_metric_function_references",
    "title": "DATA_METRIC_FUNCTION_REFERENCES",
    "syntax": "DATA_METRIC_FUNCTION_REFERENCES(\n  METRIC_NAME => '<string>' )\n\nDATA_METRIC_FUNCTION_REFERENCES(\n  REF_ENTITY_NAME => '<string>' ,\n  REF_ENTITY_DOMAIN => '<string>'\n  )",
    "example": "USE DATABASE governance;\nUSE SCHEMA INFORMATION_SCHEMA;\nSELECT *\n  FROM TABLE(\n    INFORMATION_SCHEMA.DATA_METRIC_FUNCTION_REFERENCES(\n      REF_ENTITY_NAME => 'hr.tables.empl_info',\n      REF_ENTITY_DOMAIN => 'table'\n    )\n  );\n\nUSE DATABASE governance;\nUSE SCHEMA INFORMATION_SCHEMA;\nSELECT *\n  FROM TABLE(\n    INFORMATION_SCHEMA.DATA_METRIC_FUNCTION_REFERENCES(\n      METRIC_NAME => 'governance.dmfs.count_positive_numbers'\n    )\n  );",
    "arguments": [
        {
            "name": "METRIC_NAME",
            "description": "Specifies the name of the data metric function. The entire data metric name must be enclosed in single quotes. If the data metric name is case-sensitive or includes any special characters or spaces, double quotes are required to process the\ncase/characters. The double quotes must be enclosed within the single quotes, such as '\"<metric_name>\"' ."
        },
        {
            "name": "REF_ENTITY_NAME",
            "description": "The name of the object, such as table_name , view_name , or external_table_name , on which the data metric function is added. The entire object name must be enclosed in single quotes. If the object name is case-sensitive or includes any special characters or spaces, double quotes are required to process the\ncase/characters. The double quotes must be enclosed within the single quotes, such as '\"<table_name>\"' ."
        },
        {
            "name": "REF_ENTITY_DOMAIN",
            "description": "The object type, such as table or materialized view, on which the data metric function is added. Use 'TABLE' for all supported table types ."
        }
    ],
    "returns": "The function returns the following columns:"
},
{
    "function_name": "CURRENT_WAREHOUSE",
    "summary": "Returns the name of the warehouse in use for the current session.",
    "category": "Context functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/current_warehouse",
    "title": "CURRENT_WAREHOUSE",
    "description": "Returns the name of the warehouse in use for the current session.",
    "syntax": "CURRENT_WAREHOUSE()",
    "example": "SELECT CURRENT_WAREHOUSE(), CURRENT_DATABASE(), CURRENT_SCHEMA();\n\n+---------------------+--------------------+------------------+\n| CURRENT_WAREHOUSE() | CURRENT_DATABASE() | CURRENT_SCHEMA() |\n|---------------------+--------------------+------------------|\n| DEV_WAREHOUSE       | TEST_DATABASE      | UDF_TEST_SCHEMA  |\n+---------------------+--------------------+------------------+"
},
{
    "function_name": "CURRENT_VERSION",
    "summary": "Returns the current Snowflake version.",
    "category": "Context functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/current_version",
    "title": "CURRENT_VERSION",
    "description": "Returns the current Snowflake version.",
    "syntax": "CURRENT_VERSION()",
    "example": "SELECT CURRENT_VERSION();\n\n+-------------------+\n| CURRENT_VERSION() |\n|-------------------|\n| 7.32.1            |\n+-------------------+",
    "returns": "The data type of the returned value is VARCHAR."
},
{
    "function_name": "CURRENT_USER",
    "summary": "Returns the name of the user currently logged into the system.",
    "category": "Context functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/current_user",
    "title": "CURRENT_USER",
    "description": "Returns the name of the user currently logged into the system.",
    "syntax": "CURRENT_USER()\n\nCURRENT_USER",
    "example": "SELECT CURRENT_USER();\n\n+----------------+\n| CURRENT_USER() |\n|----------------|\n| TSMITH         |\n+----------------+",
    "returns": "This function returns a value of type VARCHAR."
},
{
    "function_name": "CURRENT_TRANSACTION",
    "summary": "Returns the transaction id of an open transaction in the current session.",
    "category": "Context functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/current_transaction",
    "title": "CURRENT_TRANSACTION",
    "description": "Returns the transaction id of an open transaction in the current session.",
    "syntax": "CURRENT_TRANSACTION()",
    "example": "SELECT CURRENT_TRANSACTION();\n\n+-----------------------+\n| CURRENT_TRANSACTION() |\n|-----------------------|\n| 1661899308790000000   |\n+-----------------------+"
},
{
    "function_name": "CURRENT_TIMESTAMP",
    "summary": "Returns the current timestamp for the system in the local time zone.",
    "category": "Context functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/current_timestamp",
    "title": "CURRENT_TIMESTAMP",
    "description": "Returns the current timestamp for the system in the local time zone.",
    "syntax": "CURRENT_TIMESTAMP( [ <fract_sec_precision> ] )\n\nCURRENT_TIMESTAMP",
    "example": "ALTER SESSION SET TIMESTAMP_OUTPUT_FORMAT = 'YYYY-MM-DD HH24:MI:SS.FF';\n\nSELECT CURRENT_TIMESTAMP(2);\n\n+------------------------+\n| CURRENT_TIMESTAMP(2)   |\n|------------------------|\n| 2024-04-17 15:41:38.29 |\n+------------------------+\n\nSELECT CURRENT_TIMESTAMP(4);\n\n+--------------------------+\n| CURRENT_TIMESTAMP(4)     |\n|--------------------------|\n| 2024-04-17 15:42:14.2100 |\n+--------------------------+\n\nSELECT CURRENT_TIMESTAMP;\n\n+-------------------------------+\n| CURRENT_TIMESTAMP             |\n|-------------------------------|\n| 2024-04-17 15:42:55.130000000 |\n+-------------------------------+",
    "arguments": [
        {
            "name": "fract_sec_precision",
            "description": "This optional argument indicates the precision with which to report the\ntime. For example, a value of 3 says to use 3 digits after the decimal\npoint (i.e. to specify the time with a precision of milliseconds). The default precision is 9 (nanoseconds). Valid values range from 0 - 9. However, most platforms do not support true\nnanosecond precision; the precision that you get might be less than the\nprecision you specify. In practice, precision is usually approximately\nmilliseconds (3 digits) at most. Note Fractional seconds are only displayed if they have been explicitly set in the TIMESTAMP_OUTPUT_FORMAT parameter for the session (e.g. 'YYYY-MM-DD HH24:MI:SS.FF' )."
        }
    ],
    "returns": "Returns the current system time. The data type of the returned value is\nTIMESTAMP_LTZ."
},
{
    "function_name": "CURRENT_TIME",
    "summary": "Returns the current time for the system.",
    "category": "Context functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/current_time",
    "title": "CURRENT_TIME",
    "description": "Returns the current time for the system.",
    "syntax": "CURRENT_TIME( [ <fract_sec_precision> ] )\n\nCURRENT_TIME",
    "example": "ALTER SESSION SET TIME_OUTPUT_FORMAT = 'HH24:MI:SS.FF';\n\nSELECT CURRENT_TIME(2);\n\n+-----------------+\n| CURRENT_TIME(2) |\n|-----------------|\n| 15:35:51.24     |\n+-----------------+\n\nSELECT CURRENT_TIME(4);\n\n+-----------------+\n| CURRENT_TIME(4) |\n|-----------------|\n| 15:36:53.5570   |\n+-----------------+\n\nSELECT CURRENT_TIME;\n\n+--------------------+\n| CURRENT_TIME       |\n|--------------------|\n| 15:37:29.644000000 |\n+--------------------+",
    "arguments": [
        {
            "name": "fract_sec_precision",
            "description": "This optional argument indicates the precision with which to report the\ntime. For example, a value of 3 says to use 3 digits after the decimal\npoint (i.e. to specify the time with a precision of milliseconds). The default precision is 9 (nanoseconds). Valid values range from 0 - 9. However, most platforms do not support true\nnanosecond precision; the precision that you get might be less than the\nprecision you specify. In practice, precision is usually approximately\nmilliseconds (3 digits) at most. Note Fractional seconds are only displayed if they have been explicitly set in the TIME_OUTPUT_FORMAT parameter for the session (e.g. 'HH24:MI:SS.FF' )."
        }
    ],
    "returns": "Returns a value of type TIME."
},
{
    "function_name": "CURRENT_TASK_GRAPHS",
    "summary": "Returns the status of a graph run that is currently scheduled or is executing.",
    "category": "Information Schema , Table functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/current_task_graphs",
    "title": "CURRENT_TASK_GRAPHS",
    "description": "Returns the status of a",
    "syntax": "CURRENT_TASK_GRAPHS(\n      [ RESULT_LIMIT => <integer> ]\n      [, ROOT_TASK_NAME => '<string>' ] )",
    "example": "select *\n  from table(information_schema.current_task_graphs())\n  order by scheduled_time;\n\nselect *\n  from table(information_schema.current_task_graphs(\n    result_limit => 10,\n    root_task_name=>'MYTASK'));",
    "arguments": [
        {
            "name": "RESULT_LIMIT",
            "description": "A number specifying the maximum number of rows returned by the function. Note that the results are returned in descending SCHEDULED_TIME\norder. If the number of matching rows is greater than the result limit, the graph executions with the most recent scheduled timestamp are\nreturned, up to the specified limit. Range: 1 to 10000 Default: 1000"
        },
        {
            "name": "ROOT_TASK_NAME",
            "description": "A case-insensitive string specifying the name of the root task. Only non-qualified task names are supported. Only graph runs for the\nspecified task are returned. Note that if multiple tasks have the same name, the function returns the graph runs for each of these tasks."
        }
    ]
},
{
    "function_name": "CURRENT_STATEMENT",
    "summary": "Returns the SQL text of the statement that is currently executing.",
    "category": "Context functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/current_statement",
    "title": "CURRENT_STATEMENT",
    "description": "Returns the SQL text of the statement that is currently executing.",
    "syntax": "CURRENT_STATEMENT()",
    "example": "SELECT 2.71, CURRENT_STATEMENT();\n\n+------+-----------------------------------+\n| 2.71 | CURRENT_STATEMENT()               |\n|------+-----------------------------------|\n| 2.71 | SELECT 2.71, CURRENT_STATEMENT(); |\n+------+-----------------------------------+"
},
{
    "function_name": "CURRENT_SESSION",
    "summary": "Returns a unique system identifier for the Snowflake session corresponding to the present connection.",
    "category": "Context functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/current_session",
    "title": "CURRENT_SESSION",
    "description": "Returns a unique system identifier for the Snowflake session corresponding to the present connection. This will generally be a system-generated alphanumeric string. It is",
    "syntax": "CURRENT_SESSION()",
    "example": "SELECT CURRENT_SESSION();\n-------------------+\n CURRENT_SESSION() |\n-------------------+\n 34359980038       |\n-------------------+",
    "returns": "The data type of the returned value is VARCHAR."
},
{
    "function_name": "CURRENT_SECONDARY_ROLES",
    "summary": "Returns the secondary roles in use for the current session.",
    "category": "Context functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/current_secondary_roles",
    "title": "CURRENT_SECONDARY_ROLES",
    "description": "Returns the",
    "syntax": "CURRENT_SECONDARY_ROLES()",
    "example": "SELECT CURRENT_SECONDARY_ROLES();\n\n+------------------------------------------------------+\n|           CURRENT_SECONDARY_ROLES()                  |\n+------------------------------------------------------+\n| {\"roles\":\"ROLE1,ROLE2,ROLE3\",\"value\":\"ALL\"}          |\n+------------------------------------------------------+",
    "returns": "Returns a string (VARCHAR) that is a JSON-encoded object containing the following name/value pairs:"
},
{
    "function_name": "CURRENT_SCHEMAS",
    "summary": "Returns active search path schemas.",
    "category": "Context functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/current_schemas",
    "title": "CURRENT_SCHEMAS",
    "description": "Returns active search path schemas.",
    "syntax": "CURRENT_SCHEMAS()",
    "example": "SELECT CURRENT_SCHEMAS();\n\n+-----------------------------------------+\n| CURRENT_SCHEMAS()                       |\n|-----------------------------------------|\n| [\"TEST_DB1.BILLING\", \"TEST_DB1.PUBLIC\"] |\n+-----------------------------------------+"
},
{
    "function_name": "CURRENT_SCHEMA",
    "summary": "Returns the name of the current schema, which varies depending on where you call the function.",
    "category": "Context functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/current_schema",
    "title": "CURRENT_SCHEMA",
    "description": "Returns the name of the current schema, which varies depending on where you call the function:",
    "syntax": "CURRENT_SCHEMA()",
    "example": "SELECT CURRENT_WAREHOUSE(), CURRENT_DATABASE(), CURRENT_SCHEMA();\n\n+---------------------+--------------------+------------------+\n| CURRENT_WAREHOUSE() | CURRENT_DATABASE() | CURRENT_SCHEMA() |\n|---------------------+--------------------+------------------|\n| DEV_WAREHOUSE       | TEST_DATABASE      | UDF_TEST_SCHEMA  |\n+---------------------+--------------------+------------------+"
},
{
    "function_name": "CURRENT_ROLE_TYPE",
    "summary": "Calling the CURRENT_ROLE_TYPE function returns ROLE if the current active (primary) role in the session is an account role.",
    "category": "Context functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/current_role_type",
    "title": "CURRENT_ROLE_TYPE",
    "description": "Calling the CURRENT_ROLE_TYPE function returns",
    "syntax": "CURRENT_ROLE_TYPE()",
    "example": "SELECT CURRENT_ROLE_TYPE();\n\n+---------------------+\n| CURRENT_ROLE_TYPE() |\n|---------------------|\n| ROLE                |\n+---------------------+"
},
{
    "function_name": "CURRENT_ROLE",
    "summary": "Returns the name of the primary role in use for the current session when the primary role is an account-level role or NULL if the role in use for the current session is a database role.",
    "category": "Context functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/current_role",
    "title": "CURRENT_ROLE",
    "description": "Returns the name of the",
    "syntax": "CURRENT_ROLE()",
    "example": "SELECT CURRENT_ROLE();\n\n+----------------+\n| CURRENT_ROLE() |\n|----------------|\n| SYSADMIN       |\n+----------------+"
},
{
    "function_name": "CURRENT_REGION",
    "summary": "Returns the name of the region for the account where the current user is logged in.",
    "category": "Context functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/current_region",
    "title": "CURRENT_REGION",
    "description": "Returns the name of the region for the account where the current user is logged in.",
    "syntax": "CURRENT_REGION()",
    "example": "SELECT CURRENT_REGION();\n\n+------------------+\n| CURRENT_REGION() |\n|------------------|\n| AWS_US_WEST_2    |\n+------------------+\n\nSELECT CURRENT_REGION();\n\n+----------------------+\n| CURRENT_REGION()     |\n|----------------------|\n| PUBLIC.AWS_US_WEST_2 |\n+----------------------+"
},
{
    "function_name": "CURRENT_ORGANIZATION_USER",
    "summary": "Returns the name of the user currently logged into the system, but only if the user is an organization user.",
    "category": "Context functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/current_organization_user",
    "title": "CURRENT_ORGANIZATION_USER",
    "syntax": "CURRENT_ORGANIZATION_USER()",
    "example": "SELECT CURRENT_ORGANIZATION_USER();\n\n+-----------------------------+\n| CURRENT_ORGANIZATION_USER() |\n|-----------------------------|\n| TSMITH                      |\n+-----------------------------+",
    "returns": "If the current user is an organization user, returns a value of type VARCHAR."
},
{
    "function_name": "CURRENT_ORGANIZATION_NAME",
    "summary": "Returns the name of the organization to which the current account belongs.",
    "category": "Context functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/current_organization_name",
    "title": "CURRENT_ORGANIZATION_NAME",
    "description": "Returns the name of the organization to which the current account belongs.",
    "syntax": "CURRENT_ORGANIZATION_NAME()",
    "returns": "The data type of the returned value is VARCHAR."
},
{
    "function_name": "CURRENT_IP_ADDRESS",
    "summary": "Returns the IP address of the client that submitted the request.",
    "category": "Context functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/current_ip_address",
    "title": "CURRENT_IP_ADDRESS",
    "description": "Returns the IP address of the client that submitted the request.",
    "syntax": "CURRENT_IP_ADDRESS()",
    "example": "select current_ip_address();\n\n+----------------------+\n| CURRENT_IP_ADDRESS() |\n+----------------------+\n| 192.0.2.255          |\n+----------------------+"
},
{
    "function_name": "CURRENT_DATE",
    "summary": "Returns the current date of the system.",
    "category": "Context functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/current_date",
    "title": "CURRENT_DATE",
    "description": "Returns the current date of the system.",
    "syntax": "CURRENT_DATE()\n\nCURRENT_DATE",
    "example": "SELECT CURRENT_DATE(), CURRENT_TIME(), CURRENT_TIMESTAMP();\n\n+----------------+----------------+-------------------------------+\n| CURRENT_DATE() | CURRENT_TIME() | CURRENT_TIMESTAMP()           |\n|----------------+----------------+-------------------------------|\n| 2024-04-18     | 07:47:37       | 2024-04-18 07:47:37.084 -0700 |\n+----------------+----------------+-------------------------------+",
    "returns": "The function returns a value of type DATE."
},
{
    "function_name": "CURRENT_DATABASE",
    "summary": "Returns the name of the current database, which varies depending on where you call the function.",
    "category": "Context functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/current_database",
    "title": "CURRENT_DATABASE",
    "description": "Returns the name of the current database, which varies depending on where you call the function:",
    "syntax": "CURRENT_DATABASE()",
    "example": "SELECT CURRENT_WAREHOUSE(), CURRENT_DATABASE(), CURRENT_SCHEMA();\n\n+---------------------+--------------------+------------------+\n| CURRENT_WAREHOUSE() | CURRENT_DATABASE() | CURRENT_SCHEMA() |\n|---------------------+--------------------+------------------|\n| DEV_WAREHOUSE       | TEST_DATABASE      | UDF_TEST_SCHEMA  |\n+---------------------+--------------------+------------------+"
},
{
    "function_name": "CURRENT_CLIENT",
    "summary": "Returns the version of the client from which the function was called.",
    "category": "Context functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/current_client",
    "title": "CURRENT_CLIENT",
    "description": "Returns the version of the client from which the function was called. If called from an application using the JDBC or ODBC driver to connect to Snowflake, returns the version of the driver.",
    "syntax": "CURRENT_CLIENT()",
    "example": "SELECT CURRENT_CLIENT();\n\n+------------------+\n| CURRENT_CLIENT() |\n|------------------|\n| SnowSQL 1.1.18   |\n+------------------+\n\nSELECT CURRENT_CLIENT();"
},
{
    "function_name": "CURRENT_AVAILABLE_ROLES",
    "summary": "Returns a list of all account-level roles granted to the current user.",
    "category": "Context functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/current_available_roles",
    "title": "CURRENT_AVAILABLE_ROLES",
    "description": "Returns a list of all account-level roles granted to the current user. The list includes all roles that are granted\ndirectly to the user plus all account-level roles lower in the hierarchies of these roles.",
    "syntax": "CURRENT_AVAILABLE_ROLES()",
    "example": "SELECT CURRENT_AVAILABLE_ROLES();\n\n+----------------------------------------------------------+\n| ROW | CURRENT_AVAILABLE_ROLES()                          |\n+-----+----------------------------------------------------+\n|  1  | [ \"PUBLIC\", \"ANALYST\", \"DATA_ADMIN\", \"DATA_USER\" ] |\n+-----+----------------------------------------------------+\n\nSELECT INDEX,VALUE,THIS FROM TABLE(FLATTEN(input => PARSE_JSON(CURRENT_AVAILABLE_ROLES())));\n\n+-----+-------+------------------------+---------------------------+\n| ROW | INDEX | VALUE                  | THIS                      |\n+-----+-------+------------------------+---------------------------+\n|   1 |     0 | \"PUBLIC\"               | [                         |\n|     |       |                        |   \"PUBLIC\",               |\n|     |       |                        |   \"ANALYST\",              |\n|     |       |                        |   \"DATA_ADMIN\",           |\n|     |       |                        |   \"DATA_USER\"             |\n|     |       |                        | ]                         |\n+-----+-------+------------------------+---------------------------+\n|   2 |     1 | \"ANALYST\"              | [                         |\n|     |       |                        |   \"PUBLIC\",               |\n|     |       |                        |   \"ANALYST\",              |\n|     |       |                        |   \"DATA_ADMIN\",           |\n|     |       |                        |   \"DATA_USER\"             |\n|     |       |                        | ]                         |\n+-----+-------+------------------------+---------------------------+\n|   3 |     2 | \"DATA_ADMIN\"           | [                         |\n|     |       |                        |   \"PUBLIC\",               |\n|     |       |                        |   \"ANALYST\",              |\n|     |       |                        |   \"DATA_ADMIN\",           |\n|     |       |                        |   \"DATA_USER\"             |\n|     |       |                        | ]                         |\n+-----+-------+------------------------+---------------------------+\n|   4 |     3 | \"DATA_USER\"            | [                         |\n|     |       |                        |   \"PUBLIC\",               |\n|     |       |                        |   \"ANALYST\",              |\n|     |       |                        |   \"DATA_ADMIN\",           |\n|     |       |                        |   \"DATA_USER\"             |\n|     |       |                        | ]                         |\n+-----+-------+------------------------+---------------------------+",
    "returns": "Returns a string (VARCHAR) that is a JSON-encoded list of available account-level roles. The returned value can be\npassed to the PARSE_JSON function to get a VARIANT that contains a list of all the\navailable roles."
},
{
    "function_name": "CURRENT_ACCOUNT_NAME",
    "summary": "Returns the name of the current account.",
    "category": "Context functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/current_account_name",
    "title": "CURRENT_ACCOUNT_NAME",
    "description": "Returns the name of the current account.",
    "syntax": "CURRENT_ACCOUNT_NAME()",
    "returns": "Returns the name of the current account."
},
{
    "function_name": "CURRENT_ACCOUNT",
    "summary": "Returns the account locator used by the user’s current session.",
    "category": "Context functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/current_account",
    "title": "CURRENT_ACCOUNT",
    "description": "Returns the",
    "syntax": "CURRENT_ACCOUNT()",
    "example": "SELECT CURRENT_ACCOUNT();\n\n+-------------------+\n| CURRENT_ACCOUNT() |\n|-------------------|\n| XY12345           |\n+-------------------+",
    "returns": "The data type of the returned value is VARCHAR."
},
{
    "function_name": "CUMULATIVE_PRIVACY_LOSSES",
    "summary": "Returns the privacy budgets associated with a specific privacy policy.",
    "category": "Table functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/cumulative_privacy_losses",
    "title": "CUMULATIVE_PRIVACY_LOSSES",
    "syntax": "SNOWFLAKE.DATA_PRIVACY.CUMULATIVE_PRIVACY_LOSSES( '<privacy_policy>' )",
    "example": "SELECT *\n  FROM TABLE(SNOWFLAKE.DATA_PRIVACY.CUMULATIVE_PRIVACY_LOSSES(\n    'my_policy_db.my_policy_schema.my_policy_privacy'));",
    "arguments": [
        {
            "name": "'",
            "description": "Specifies the fully-qualified name of the privacy policy. A privacy policy is a schema-level object."
        }
    ]
},
{
    "function_name": "CUME_DIST",
    "summary": "Finds the cumulative distribution of a value with regard to other values within the same window partition.",
    "category": "Window functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/cume_dist",
    "title": "CUME_DIST",
    "description": "Finds the cumulative distribution of a value with regard to other values within the same window partition.",
    "syntax": "CUME_DIST() OVER ( [ PARTITION BY <partition_expr> ] ORDER BY <order_expr>  [ ASC | DESC ] )",
    "example": "SELECT\n    symbol,\n    exchange,\n    CUME_DIST() OVER (PARTITION BY exchange ORDER BY price) AS cume_dist\n  FROM trades;\n\n+------+--------+------------+\n|symbol|exchange|CUME_DIST   |\n+------+--------+------------+\n|SPY   |C       |0.3333333333|\n|AAPL  |C       |         1.0|\n|AAPL  |C       |         1.0|\n|YHOO  |N       |0.1666666667|\n|QQQ   |N       |         0.5|\n|QQQ   |N       |         0.5|\n|SPY   |N       |0.8333333333|\n|SPY   |N       |0.8333333333|\n|AAPL  |N       |         1.0|\n|YHOO  |Q       |0.3333333333|\n|YHOO  |Q       |0.3333333333|\n|MSFT  |Q       |0.6666666667|\n|MSFT  |Q       |0.6666666667|\n|QQQ   |Q       |         1.0|\n|QQQ   |Q       |         1.0|\n|YHOO  |P       |         0.2|\n|MSFT  |P       |         0.6|\n|MSFT  |P       |         0.6|\n|SPY   |P       |         0.8|\n|AAPL  |P       |         1.0|\n+------+--------+------------+",
    "arguments": [
        {
            "name": "partition_expr",
            "description": "This is the optional expression to use to group rows into partitions."
        },
        {
            "name": "order_expr",
            "description": "This expression specifies the order of the rows within each partition."
        }
    ],
    "returns": "The data type of the returned value is DOUBLE."
},
{
    "function_name": "COVAR_SAMP",
    "summary": "Returns the sample covariance for non-null pairs in a group.",
    "category": "Aggregate functions , Window functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/covar_samp",
    "title": "COVAR_SAMP",
    "description": "Returns the sample covariance for non-null pairs in a group. It is computed for non-null pairs using the following formula:",
    "syntax": "COVAR_SAMP( y , x )",
    "example": "CREATE OR REPLACE TABLE aggr(k int, v decimal(10,2), v2 decimal(10, 2));\nINSERT INTO aggr VALUES(1, 10, NULL);\nINSERT INTO aggr VALUES(2, 10, 11), (2, 20, 22), (2, 25, NULL), (2, 30, 35);\n\nSELECT k, COVAR_SAMP(v, v2) FROM aggr GROUP BY k;\n\n+---+-------------------+\n| K | COVAR_SAMP(V, V2) |\n|---+-------------------|\n| 1 |              NULL |\n| 2 |               120 |\n+---+-------------------+"
},
{
    "function_name": "COVAR_POP",
    "summary": "Returns the population covariance for non-null pairs in a group.",
    "category": "Aggregate functions , Window functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/covar_pop",
    "title": "COVAR_POP",
    "description": "Returns the population covariance for non-null pairs in a group. It is computed for non-null pairs using the following formula:",
    "syntax": "COVAR_POP( y , x )",
    "example": "CREATE OR REPLACE TABLE aggr(k int, v decimal(10,2), v2 decimal(10, 2));\nINSERT INTO aggr VALUES(1, 10, NULL);\nINSERT INTO aggr VALUES(2, 10, 11), (2, 20, 22), (2, 25, NULL), (2, 30, 35);\n\nSELECT * FROM aggr;\n\n+---+-------+-------+\n| K |     V |    V2 |\n|---+-------+-------|\n| 1 | 10.00 |  NULL |\n| 2 | 10.00 | 11.00 |\n| 2 | 20.00 | 22.00 |\n| 2 | 25.00 |  NULL |\n| 2 | 30.00 | 35.00 |\n+---+-------+-------+\n\nSELECT k, COVAR_POP(v, v2) FROM aggr GROUP BY k;\n\n+---+------------------+\n| K | COVAR_POP(V, V2) |\n|---+------------------|\n| 1 |             NULL |\n| 2 |               80 |\n+---+------------------+"
},
{
    "function_name": "COUNT_TOKENS (SNOWFLAKE.CORTEX)",
    "summary": "Returns the number of tokens in a prompt for the large language model or the task-specific function specified in the argument.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/count_tokens-snowflake-cortex",
    "title": "COUNT_TOKENS (SNOWFLAKE.CORTEX)",
    "description": "Returns the number of tokens in a prompt for the large language model or the task-specific function specified in the argument. This\nfunction does not support fine-tuned models.",
    "syntax": "SNOWFLAKE.CORTEX.COUNT_TOKENS( <model_name> , <input_text> )\n\nSNOWFLAKE.CORTEX.COUNT_TOKENS( <function_name> , <input_text> )",
    "example": "SELECT SNOWFLAKE.CORTEX.COUNT_TOKENS( 'snowflake-arctic', 'what is a large language model?' );\n\n+---+\n| 6 |\n+---+\n\nSELECT SNOWFLAKE.CORTEX.COUNT_TOKENS('summarize', prompt) FROM mydb.myschema.mytable LIMIT 10;\n\n+-----------+\n| 1 |  1932 |\n+-----------+\n| 2 |  2379 |\n+-----------+\n| 3 |  2185 |\n+-----------+\n| 4 |  1195 |\n+-----------+\n| 5 |  2908 |\n+-----------+\n| 6 |  2601 |\n+-----------+\n| 7 |  2122 |\n+-----------+\n| 8 |  1720 |\n+-----------+\n| 9 |  2512 |\n+-----------+\n| 10 | 1510 |\n+-----------+\n\nSELECT SNOWFLAKE.CORTEX.COUNT_TOKENS('translate', 'Dies ist ein kurzer Text.');\n\n+---+\n| 9 |\n+---+",
    "arguments": [
        {
            "name": "model_name",
            "description": "Name of the model you want to base the token count on. Specify one of the following values: deepseek-r1 e5-base-v2 gemma-7b jamba-1.5-large jamba-1.5-mini jamba-instruct llama2-70b-chat llama3-70b llama3-8b llama3.1-405b llama3.1-70b llama3.1-8b llama3.2-1b llama3.2-3b llama3.3-70b llama4-maverick llama4-scout mixtral-8x7b mistral-7b mistral-large mistral-large2 nv-embed-qa-4 reka-core reka-flash snowflake-arctic snowflake-arctic-embed-m snowflake-arctic-embed-m-v1.5 snowflake-llama-3.1-405b snowflake-llama-3.3-70b voyage-multilingual-2"
        },
        {
            "name": "function_name",
            "description": "Specify one of the following values: extract_answer sentiment summarize translate Model task function names are case-sensitive and must be lowercase."
        },
        {
            "name": "input_text",
            "description": "Input text to count the tokens in."
        }
    ],
    "returns": "Returns an INT , INTEGER , BIGINT , SMALLINT , TINYINT , BYTEINT type that is the number of tokens in the input text based on the model or function specified."
},
{
    "function_name": "COUNT_IF",
    "summary": "Returns the number of records that satisfy a condition or NULL if no records satisfy the condition.",
    "category": "Aggregate functions , Window functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/count_if",
    "title": "COUNT_IF",
    "description": "Returns the number of records that satisfy a condition or NULL if no records satisfy the condition.",
    "syntax": "COUNT_IF( <condition> )",
    "example": "CREATE TABLE basic_example (i_col INTEGER, j_col INTEGER);\nINSERT INTO basic_example VALUES\n    (11,101), (11,102), (11,NULL), (12,101), (NULL,101), (NULL,102);\n\nSELECT *\n    FROM basic_example\n    ORDER BY i_col;\n\n+-------+-------+\n| I_COL | J_COL |\n|-------+-------|\n|    11 |   101 |\n|    11 |   102 |\n|    11 |  NULL |\n|    12 |   101 |\n|  NULL |   101 |\n|  NULL |   102 |\n+-------+-------+\n\nSELECT COUNT_IF(TRUE) FROM basic_example;\n\n+----------------+\n| COUNT_IF(TRUE) |\n|----------------|\n|              6 |\n+----------------+\n\nSELECT COUNT_IF(j_col > i_col) FROM basic_example;\n\n+-------------------------+\n| COUNT_IF(J_COL > I_COL) |\n|-------------------------|\n|                       3 |\n+-------------------------+\n\nSELECT COUNT_IF(i_col IS NOT NULL AND j_col IS NOT NULL) FROM basic_example;\n\n+---------------------------------------------------+\n| COUNT_IF(I_COL IS NOT NULL AND J_COL IS NOT NULL) |\n|---------------------------------------------------|\n|                                                 3 |\n+---------------------------------------------------+",
    "arguments": [
        {
            "name": "condition",
            "description": "The condition is an expression that should evaluate to a BOOLEAN value (True, False, or NULL)"
        },
        {
            "name": "expr1",
            "description": "The column to partition on, if you want the result to be split into multiple\nwindows."
        },
        {
            "name": "expr2",
            "description": "The column to order each window on. Note that this is separate from the ORDER BY clause that sorts the final result set."
        }
    ],
    "returns": "If the function does not return NULL, the data type of the returned value is NUMBER."
},
{
    "function_name": "COUNT",
    "summary": "Returns either the number of non-NULL records for the specified columns, or the total number of records.",
    "category": "Aggregate functions , Window functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/count",
    "title": "COUNT",
    "description": "Returns either the number of non-NULL records for the specified columns, or the total number of records.",
    "syntax": "COUNT( [ DISTINCT ] <expr1> [ , <expr2> ... ] )\n\nCOUNT(*)\n\nCOUNT(<alias>.*)",
    "example": "CREATE TABLE basic_example (i_col INTEGER, j_col INTEGER);\nINSERT INTO basic_example VALUES\n    (11,101), (11,102), (11,NULL), (12,101), (NULL,101), (NULL,102);\n\nSELECT *\n    FROM basic_example\n    ORDER BY i_col;\n\n+-------+-------+\n| I_COL | J_COL |\n|-------+-------|\n|    11 |   101 |\n|    11 |   102 |\n|    11 |  NULL |\n|    12 |   101 |\n|  NULL |   101 |\n|  NULL |   102 |\n+-------+-------+\n\nSELECT COUNT(*) AS \"All\",\n       COUNT(* ILIKE 'i_c%') AS \"ILIKE\",\n       COUNT(* EXCLUDE i_col) AS \"EXCLUDE\",\n       COUNT(i_col) AS \"i_col\", \n       COUNT(DISTINCT i_col) AS \"DISTINCT i_col\", \n       COUNT(j_col) AS \"j_col\", \n       COUNT(DISTINCT j_col) AS \"DISTINCT j_col\"\n  FROM basic_example;\n\n+-----+-------+---------+-------+----------------+-------+----------------+\n| All | ILIKE | EXCLUDE | i_col | DISTINCT i_col | j_col | DISTINCT j_col |\n|-----+-------+---------+-------+----------------+-------+----------------|\n|   6 |     4 |       5 |     4 |              2 |     5 |              2 |\n+-----+-------+---------+-------+----------------+-------+----------------+\n\nSELECT i_col, COUNT(*), COUNT(j_col)\n    FROM basic_example\n    GROUP BY i_col\n    ORDER BY i_col;\n\n+-------+----------+--------------+\n| I_COL | COUNT(*) | COUNT(J_COL) |\n|-------+----------+--------------|\n|    11 |        3 |            2 |\n|    12 |        1 |            1 |\n|  NULL |        2 |            2 |\n+-------+----------+--------------+\n\nSELECT COUNT(n.*) FROM basic_example AS n;\n\n+------------+\n| COUNT(N.*) |\n|------------|\n|          3 |\n+------------+\n\nCREATE OR REPLACE TABLE count_example_with_variant_column (\n  i_col INTEGER, \n  j_col INTEGER, \n  v VARIANT);\n\nBEGIN WORK;\n\nINSERT INTO count_example_with_variant_column (i_col, j_col, v) \n  VALUES (NULL, 10, NULL);\nINSERT INTO count_example_with_variant_column (i_col, j_col, v) \n  SELECT 1, 11, PARSE_JSON('{\"Title\": null}');\nINSERT INTO count_example_with_variant_column (i_col, j_col, v) \n  SELECT 2, 12, PARSE_JSON('{\"Title\": \"O\"}');\nINSERT INTO count_example_with_variant_column (i_col, j_col, v) \n  SELECT 3, 12, PARSE_JSON('{\"Title\": \"I\"}');\n\nCOMMIT WORK;\n\nSELECT i_col, j_col, v, v:Title\n    FROM count_example_with_variant_column\n    ORDER BY i_col;\n\n+-------+-------+-----------------+---------+\n| I_COL | J_COL | V               | V:TITLE |\n|-------+-------+-----------------+---------|\n|     1 |    11 | {               | null    |\n|       |       |   \"Title\": null |         |\n|       |       | }               |         |\n|     2 |    12 | {               | \"O\"     |\n|       |       |   \"Title\": \"O\"  |         |\n|       |       | }               |         |\n|     3 |    12 | {               | \"I\"     |\n|       |       |   \"Title\": \"I\"  |         |\n|       |       | }               |         |\n|  NULL |    10 | NULL            | NULL    |\n+-------+-------+-----------------+---------+\n\nSELECT COUNT(v:Title)\n    FROM count_example_with_variant_column;\n\n+----------------+\n| COUNT(V:TITLE) |\n|----------------|\n|              2 |\n+----------------+",
    "arguments": [
        {
            "name": "expr1",
            "description": "A column name, which can be a qualified name (for example, database.schema.table.column_name)."
        },
        {
            "name": "expr2",
            "description": "You can include additional column name(s) if you wish. For example, you\ncould count the number of distinct combinations of last name and first name."
        },
        {
            "name": "expr3",
            "description": "The column to partition on, if you want the result to be split into multiple\nwindows."
        },
        {
            "name": "expr4",
            "description": "The column to order each window on. Note that this is separate from any\nORDER BY clause to order the final result set."
        },
        {
            "name": "*",
            "description": "Returns the total number of records. When you pass a wildcard to the function, you can qualify the wildcard with the name or alias for the table.\nFor example, to pass in all of the columns from the table named mytable , specify the following: You can also use the ILIKE and EXCLUDE keywords for filtering: ILIKE filters for column names that match the specified pattern. Only one\npattern is allowed. For example: EXCLUDE filters out column names that don’t match the specified column or columns. For example: Qualifiers are valid when you use these keywords. The following example uses the ILIKE keyword to\nfilter for all of the columns that match the pattern col1% in the table mytable : The ILIKE and EXCLUDE keywords can’t be combined in a single function call. If you specify an unqualified and unfiltered wildcard ( * ), the function returns the total number of records, including\nrecords with NULL values. If you specify a wildcard with the ILIKE or EXCLUDE keyword for filtering, the function excludes records with NULL values. For this function, the ILIKE and EXCLUDE keywords are valid only in a SELECT list or GROUP BY clause. For more information about the ILIKE and EXCLUDE keywords, see the “Parameters” section in SELECT ."
        },
        {
            "name": "alias",
            "description": "Returns the number of records that don’t contain any NULL values. For an example, see Examples ."
        }
    ],
    "returns": "Returns a value of type NUMBER."
},
{
    "function_name": "COT",
    "summary": "Computes the cotangent of its argument; the argument should be expressed in radians.",
    "category": "Numeric functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/cot",
    "title": "COT",
    "description": "Computes the cotangent of its argument; the argument should be expressed in\nradians.",
    "syntax": "COT( <real_expr> )",
    "example": "SELECT COT(0), COT(PI()/3), COT(RADIANS(90));\n\n--------+--------------+------------------+\n COT(0) | COT(PI()/3)  | COT(RADIANS(90)) |\n--------+--------------+------------------+\n inf    | 0.5773502692 | 6.123233996e-17  |\n--------+--------------+------------------+"
},
{
    "function_name": "COSH",
    "summary": "Computes the hyperbolic cosine of its argument.",
    "category": "Numeric functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/cosh",
    "title": "COSH",
    "description": "Computes the hyperbolic cosine of its argument.",
    "syntax": "COSH( <real_expr> )",
    "example": "SELECT COSH(1.5);\n\n-------------+\n  COSH(1.5)  |\n-------------+\n 2.352409615 |\n-------------+",
    "arguments": [
        {
            "name": "real_expr",
            "description": "This expression should evaluate to a real number."
        }
    ]
},
{
    "function_name": "COS",
    "summary": "Computes the cosine of its argument; the argument should be expressed in radians.",
    "category": "Numeric functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/cos",
    "title": "COS",
    "description": "Computes the cosine of its argument; the argument should be expressed in\nradians.",
    "syntax": "COS( <real_expr> )",
    "example": "SELECT COS(0), COS(PI()/3), COS(RADIANS(90));\n\n--------+-------------+------------------+\n COS(0) | COS(PI()/3) | COS(RADIANS(90)) |\n--------+-------------+------------------+\n 1      | 0.5         | 6.123233996e-17  |\n--------+-------------+------------------+",
    "arguments": [
        {
            "name": "real_expr",
            "description": "This expression should evaluate to a real number. The value should be in\nradians, not degrees."
        }
    ]
},
{
    "function_name": "CORTEX_SEARCH_DATA_SCAN",
    "summary": "This table function returns the data indexed by a Cortex Search service, including the columns defined in the source query and the computed vector embeddings for the search column.",
    "category": "Table functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/cortex_search_data_scan",
    "title": "CORTEX_SEARCH_DATA_SCAN",
    "description": "This table function returns the data indexed by a",
    "syntax": "CORTEX_SEARCH_DATA_SCAN(\n      SERVICE_NAME => '<string>' )",
    "example": "CREATE OR REPLACE CORTEX SEARCH SERVICE transcript_search_service\n  ON transcript_text\n  ATTRIBUTES region\n  WAREHOUSE = cortex_search_wh\n  TARGET_LAG = '1 day'\n  AS (\n    SELECT\n        transcript_text,\n        region,\n        agent_id,\n    FROM support_transcripts\n);\n\nSELECT\n  *\nFROM\n  TABLE (\n    CORTEX_SEARCH_DATA_SCAN (\n      SERVICE_NAME => 'transcript_search_service'\n    )\n  );\n\n+ ---------------------------------------------------------- + --------------- + -------- + ------------------------------ +\n|                      transcript_text                       |     region      | agent_id | _GENERATED_EMBEDDINGS_MY_MODEL |\n| ---------------------------------------------------------- | --------------- | -------- | ------------------------------ |\n| 'My internet has been down since yesterday, can you help?' | 'North America' | 'AG1001' | [0.1, 0.2, 0.3, 0.4]           |\n| 'I was overcharged for my last bill, need an explanation.' | 'Europe'        | 'AG1002' | [0.1, 0.2, 0.3, 0.4]           |\n+ ---------------------------------------------------------- + --------------- + -------- + ------------------------------ +",
    "arguments": [
        {
            "name": "SERVICE_NAME",
            "description": "The name of a Cortex Search service. You can specify any of the following: Unqualified name ( service_name ) Partially qualified name ( schema_name . service_name ) Fully qualified name ( database_name . schema_name . service_name ) For more information on object name resolution, refer to Object Name Resolution ."
        }
    ]
},
{
    "function_name": "CORR",
    "summary": "Returns the correlation coefficient for non-null pairs in a group.",
    "category": "Aggregate functions , Window functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/corr",
    "title": "CORR",
    "description": "Returns the correlation coefficient for non-null pairs in a group. It is computed for non-null pairs using the following formula:",
    "syntax": "CORR( y , x )",
    "example": "CREATE OR REPLACE TABLE aggr(k int, v decimal(10,2), v2 decimal(10, 2));\nINSERT INTO aggr VALUES(1, 10, NULL);\nINSERT INTO aggr VALUES(2, 10, 11), (2, 20, 22), (2, 25, NULL), (2, 30, 35);\n\nSELECT * FROM aggr;\n\n+---+-------+-------+\n| K |     V |    V2 |\n|---+-------+-------|\n| 1 | 10.00 |  NULL |\n| 2 | 10.00 | 11.00 |\n| 2 | 20.00 | 22.00 |\n| 2 | 25.00 |  NULL |\n| 2 | 30.00 | 35.00 |\n+---+-------+-------+\n\nSELECT k, CORR(v, v2) FROM aggr GROUP BY k;\n\n+---+--------------+\n| K |  CORR(V, V2) |\n|---+--------------|\n| 1 |         NULL |\n| 2 | 0.9988445981 |\n+---+--------------+"
},
{
    "function_name": "COPY_HISTORY",
    "summary": "This table function can be used to query Snowflake data loading history along various dimensions within the last 14 days.",
    "category": "Information Schema , Table functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/copy_history",
    "title": "COPY_HISTORY",
    "description": "This table function can be used to query Snowflake data loading history along various dimensions within the last 14 days.\nThe function returns load activity for both",
    "syntax": "COPY_HISTORY(\n      TABLE_NAME => '<string>'\n       , START_TIME => <constant_expr>\n      [, END_TIME => <constant_expr> ]\n      [, PIPE_NAME => '<string>' ] )",
    "example": "select *\nfrom table(information_schema.copy_history(TABLE_NAME=>'MYTABLE', START_TIME=> DATEADD(hours, -1, CURRENT_TIMESTAMP())));",
    "arguments": [
        {
            "name": "TABLE_NAME",
            "description": "A string specifying a table name."
        },
        {
            "name": "START_TIME",
            "description": "Timestamp (in TIMESTAMP_LTZ format), within the last 14 days, marking the start of the time range for retrieving load events."
        },
        {
            "name": "END_TIME",
            "description": "Timestamp (in TIMESTAMP_LTZ format), within the last 14 days, marking the end of the time range for retrieving load events. Default: CURRENT_TIMESTAMP ."
        },
        {
            "name": "PIPE_NAME",
            "description": "A string specifying a pipe name."
        }
    ]
},
{
    "function_name": "CONVERT_TIMEZONE",
    "summary": "Converts a timestamp to another time zone.",
    "category": "Date & time functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/convert_timezone",
    "title": "CONVERT_TIMEZONE",
    "description": "Converts a timestamp to another time zone.",
    "syntax": "CONVERT_TIMEZONE( <source_tz> , <target_tz> , <source_timestamp_ntz> )\n\nCONVERT_TIMEZONE( <target_tz> , <source_timestamp> )",
    "example": "ALTER SESSION UNSET TIMESTAMP_OUTPUT_FORMAT;\n\nSELECT CONVERT_TIMEZONE(\n  'America/Los_Angeles',\n  'America/New_York',\n  '2024-01-01 14:00:00'::TIMESTAMP_NTZ\n) AS conv;\n\n+-------------------------+\n| CONV                    |\n|-------------------------|\n| 2024-01-01 17:00:00.000 |\n+-------------------------+\n\nSELECT CONVERT_TIMEZONE(\n  'Europe/Warsaw',\n  'UTC',\n  '2024-01-01 00:00:00'::TIMESTAMP_NTZ\n) AS conv;\n\n+-------------------------+\n| CONV                    |\n|-------------------------|\n| 2023-12-31 23:00:00.000 |\n+-------------------------+\n\nSELECT CONVERT_TIMEZONE(\n  'America/Los_Angeles',\n  '2024-04-05 12:00:00 +02:00'\n) AS time_in_la;\n\n+-------------------------------+\n| TIME_IN_LA                    |\n|-------------------------------|\n| 2024-04-05 03:00:00.000 -0700 |\n+-------------------------------+\n\nSELECT\n  CURRENT_TIMESTAMP() AS now_in_la,\n  CONVERT_TIMEZONE('America/New_York', CURRENT_TIMESTAMP()) AS now_in_nyc,\n  CONVERT_TIMEZONE('Europe/Paris', CURRENT_TIMESTAMP()) AS now_in_paris,\n  CONVERT_TIMEZONE('Asia/Tokyo', CURRENT_TIMESTAMP()) AS now_in_tokyo;\n\n+-------------------------------+-------------------------------+-------------------------------+-------------------------------+\n| NOW_IN_LA                     | NOW_IN_NYC                    | NOW_IN_PARIS                  | NOW_IN_TOKYO                  |\n|-------------------------------+-------------------------------+-------------------------------+-------------------------------|\n| 2024-06-12 08:52:53.114 -0700 | 2024-06-12 11:52:53.114 -0400 | 2024-06-12 17:52:53.114 +0200 | 2024-06-13 00:52:53.114 +0900 |\n+-------------------------------+-------------------------------+-------------------------------+-------------------------------+",
    "arguments": [
        {
            "name": "source_tz",
            "description": "String specifying the time zone for the input timestamp. Required for timestamps with no time zone (i.e. TIMESTAMP_NTZ)."
        },
        {
            "name": "target_tz",
            "description": "String specifying the time zone to which the input timestamp is converted."
        },
        {
            "name": "source_timestamp_ntz",
            "description": "For the 3-argument version, string specifying the timestamp to convert (must be TIMESTAMP_NTZ)."
        },
        {
            "name": "source_timestamp",
            "description": "For the 2-argument version, string specifying the timestamp to convert (can be any timestamp variant, including TIMESTAMP_NTZ)."
        }
    ],
    "returns": "Returns a value of type TIMESTAMP_NTZ, TIMESTAMP_TZ, or NULL:"
},
{
    "function_name": "CONTAINS",
    "summary": "Returns true if expr1 contains expr2.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/contains",
    "title": "CONTAINS",
    "description": "Returns true if",
    "syntax": "CONTAINS( <expr1> , <expr2> )",
    "example": "CREATE OR REPLACE TABLE strings_test (s VARCHAR);\n\nINSERT INTO strings_test values\n  ('coffee'),\n  ('ice tea'),\n  ('latte'),\n  ('tea'),\n  (NULL);\n\nSELECT * from strings_test;\n\n+---------+\n| S       |\n|---------|\n| coffee  |\n| ice tea |\n| latte   |\n| tea     |\n| NULL    |\n+---------+\n\nSELECT * FROM strings_test WHERE CONTAINS(s, 'te');\n\n+---------+\n| S       |\n|---------|\n| ice tea |\n| latte   |\n| tea     |\n+---------+\n\nSELECT CONTAINS(COLLATE('ñ', 'en-ci-ai'), 'n'),\n       CONTAINS(COLLATE('ñ', 'es-ci-ai'), 'n');\n\n+-----------------------------------------+-----------------------------------------+\n| CONTAINS(COLLATE('Ñ', 'EN-CI-AI'), 'N') | CONTAINS(COLLATE('Ñ', 'ES-CI-AI'), 'N') |\n|-----------------------------------------+-----------------------------------------|\n| True                                    | False                                   |\n+-----------------------------------------+-----------------------------------------+",
    "arguments": [
        {
            "name": "expr1",
            "description": "The string to search in."
        },
        {
            "name": "expr2",
            "description": "The string to search for."
        }
    ],
    "returns": "Returns a BOOLEAN or NULL:"
},
{
    "function_name": "CONDITIONAL_TRUE_EVENT",
    "summary": "Returns a window event number for each row within a window partition based on the result of the boolean argument expr1.",
    "category": "Window functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/conditional_true_event",
    "title": "CONDITIONAL_TRUE_EVENT",
    "description": "Returns a window event number for each row within a window partition based on the result of the boolean argument",
    "syntax": "CONDITIONAL_TRUE_EVENT( <expr1> ) OVER ( [ PARTITION BY <expr2> ] ORDER BY <expr3> )",
    "example": "CREATE TABLE table1 (province VARCHAR, o_col INTEGER, o2_col INTEGER);\nINSERT INTO table1 (province, o_col, o2_col) VALUES\n    ('Alberta',    0, 10),\n    ('Alberta',    0, 10),\n    ('Alberta',   13, 10),\n    ('Alberta',   13, 11),\n    ('Alberta',   14, 11),\n    ('Alberta',   15, 12),\n    ('Alberta', NULL, NULL),\n    ('Manitoba',    30, 30);\n\nSELECT province, o_col, \n      CONDITIONAL_TRUE_EVENT(o_col) \n        OVER (PARTITION BY province ORDER BY o_col) \n          AS true_event\n    FROM table1\n    ORDER BY province, o_col\n    ;\n+----------+-------+------------+\n| PROVINCE | O_COL | TRUE_EVENT |\n|----------+-------+------------|\n| Alberta  |     0 |          0 |\n| Alberta  |     0 |          0 |\n| Alberta  |    13 |          1 |\n| Alberta  |    13 |          2 |\n| Alberta  |    14 |          3 |\n| Alberta  |    15 |          4 |\n| Alberta  |  NULL |          4 |\n| Manitoba |    30 |          1 |\n+----------+-------+------------+\n\nSELECT province, o_col, \n      CONDITIONAL_TRUE_EVENT(o_col) \n        OVER (PARTITION BY province ORDER BY o_col) \n          AS true_event,\n      CONDITIONAL_TRUE_EVENT(o_col > 20) \n        OVER (PARTITION BY province ORDER BY o_col) \n          AS true_event_gt_20\n    FROM table1\n    ORDER BY province, o_col\n    ;\n+----------+-------+------------+------------------+\n| PROVINCE | O_COL | TRUE_EVENT | TRUE_EVENT_GT_20 |\n|----------+-------+------------+------------------|\n| Alberta  |     0 |          0 |                0 |\n| Alberta  |     0 |          0 |                0 |\n| Alberta  |    13 |          1 |                0 |\n| Alberta  |    13 |          2 |                0 |\n| Alberta  |    14 |          3 |                0 |\n| Alberta  |    15 |          4 |                0 |\n| Alberta  |  NULL |          4 |                0 |\n| Manitoba |    30 |          1 |                1 |\n+----------+-------+------------+------------------+\n\nSELECT province, o_col,\n      CONDITIONAL_CHANGE_EVENT(o_col) \n        OVER (PARTITION BY province ORDER BY o_col) \n          AS change_event,\n      CONDITIONAL_TRUE_EVENT(o_col) \n        OVER (PARTITION BY province ORDER BY o_col) \n          AS true_event\n    FROM table1\n    ORDER BY province, o_col\n    ;\n+----------+-------+--------------+------------+\n| PROVINCE | O_COL | CHANGE_EVENT | TRUE_EVENT |\n|----------+-------+--------------+------------|\n| Alberta  |     0 |            0 |          0 |\n| Alberta  |     0 |            0 |          0 |\n| Alberta  |    13 |            1 |          1 |\n| Alberta  |    13 |            1 |          2 |\n| Alberta  |    14 |            2 |          3 |\n| Alberta  |    15 |            3 |          4 |\n| Alberta  |  NULL |            3 |          4 |\n| Manitoba |    30 |            0 |          1 |\n+----------+-------+--------------+------------+\n\nCREATE TABLE borrowers (\n    name VARCHAR,\n    status_date DATE,\n    late_balance NUMERIC(11, 2),\n    thirty_day_late_balance NUMERIC(11, 2)\n    );\nINSERT INTO borrowers (name, status_date, late_balance, thirty_day_late_balance) VALUES\n\n    -- Pays late frequently, but catches back up rather than falling further\n    -- behind.\n    ('Geoffrey Flake', '2018-01-01'::DATE,    0.0,    0.0),\n    ('Geoffrey Flake', '2018-02-01'::DATE, 1000.0,    0.0),\n    ('Geoffrey Flake', '2018-03-01'::DATE, 2000.0, 1000.0),\n    ('Geoffrey Flake', '2018-04-01'::DATE,    0.0,    0.0),\n    ('Geoffrey Flake', '2018-05-01'::DATE, 1000.0,    0.0),\n    ('Geoffrey Flake', '2018-06-01'::DATE, 2000.0, 1000.0),\n    ('Geoffrey Flake', '2018-07-01'::DATE,    0.0,    0.0),\n    ('Geoffrey Flake', '2018-08-01'::DATE,    0.0,    0.0),\n\n    -- Keeps falling further behind.\n    ('Cy Dismal', '2018-01-01'::DATE,    0.0,    0.0),\n    ('Cy Dismal', '2018-02-01'::DATE,    0.0,    0.0),\n    ('Cy Dismal', '2018-03-01'::DATE, 1000.0,    0.0),\n    ('Cy Dismal', '2018-04-01'::DATE, 2000.0, 1000.0),\n    ('Cy Dismal', '2018-05-01'::DATE, 3000.0, 2000.0),\n    ('Cy Dismal', '2018-06-01'::DATE, 4000.0, 3000.0),\n    ('Cy Dismal', '2018-07-01'::DATE, 5000.0, 4000.0),\n    ('Cy Dismal', '2018-08-01'::DATE, 6000.0, 5000.0),\n\n    -- Fell behind and isn't catching up, but isn't falling further and \n    -- further behind. Essentially, this person just 'failed' once.\n    ('Leslie Safer', '2018-01-01'::DATE,    0.0,    0.0),\n    ('Leslie Safer', '2018-02-01'::DATE,    0.0,    0.0),\n    ('Leslie Safer', '2018-03-01'::DATE, 1000.0, 1000.0),\n    ('Leslie Safer', '2018-04-01'::DATE, 2000.0, 1000.0),\n    ('Leslie Safer', '2018-05-01'::DATE, 2000.0, 1000.0),\n    ('Leslie Safer', '2018-06-01'::DATE, 2000.0, 1000.0),\n    ('Leslie Safer', '2018-07-01'::DATE, 2000.0, 1000.0),\n    ('Leslie Safer', '2018-08-01'::DATE, 2000.0, 1000.0),\n\n    -- Always pays on time and in full.\n    ('Ida Idyll', '2018-01-01'::DATE,    0.0,    0.0),\n    ('Ida Idyll', '2018-02-01'::DATE,    0.0,    0.0),\n    ('Ida Idyll', '2018-03-01'::DATE,    0.0,    0.0),\n    ('Ida Idyll', '2018-04-01'::DATE,    0.0,    0.0),\n    ('Ida Idyll', '2018-05-01'::DATE,    0.0,    0.0),\n    ('Ida Idyll', '2018-06-01'::DATE,    0.0,    0.0),\n    ('Ida Idyll', '2018-07-01'::DATE,    0.0,    0.0),\n    ('Ida Idyll', '2018-08-01'::DATE,    0.0,    0.0)\n\n    ;\n\nSELECT name, status_date, late_balance AS \"OVERDUE\", \n        thirty_day_late_balance AS \"30 DAYS OVERDUE\",\n        CONDITIONAL_CHANGE_EVENT(thirty_day_late_balance) \n          OVER (PARTITION BY name ORDER BY status_date) AS change_event_cnt,\n        CONDITIONAL_TRUE_EVENT(thirty_day_late_balance) \n          OVER (PARTITION BY name ORDER BY status_date) AS true_cnt\n    FROM borrowers\n    ORDER BY name, status_date\n    ;\n+----------------+-------------+---------+-----------------+------------------+----------+\n| NAME           | STATUS_DATE | OVERDUE | 30 DAYS OVERDUE | CHANGE_EVENT_CNT | TRUE_CNT |\n|----------------+-------------+---------+-----------------+------------------+----------|\n| Cy Dismal      | 2018-01-01  |    0.00 |            0.00 |                0 |        0 |\n| Cy Dismal      | 2018-02-01  |    0.00 |            0.00 |                0 |        0 |\n| Cy Dismal      | 2018-03-01  | 1000.00 |            0.00 |                0 |        0 |\n| Cy Dismal      | 2018-04-01  | 2000.00 |         1000.00 |                1 |        1 |\n| Cy Dismal      | 2018-05-01  | 3000.00 |         2000.00 |                2 |        2 |\n| Cy Dismal      | 2018-06-01  | 4000.00 |         3000.00 |                3 |        3 |\n| Cy Dismal      | 2018-07-01  | 5000.00 |         4000.00 |                4 |        4 |\n| Cy Dismal      | 2018-08-01  | 6000.00 |         5000.00 |                5 |        5 |\n| Geoffrey Flake | 2018-01-01  |    0.00 |            0.00 |                0 |        0 |\n| Geoffrey Flake | 2018-02-01  | 1000.00 |            0.00 |                0 |        0 |\n| Geoffrey Flake | 2018-03-01  | 2000.00 |         1000.00 |                1 |        1 |\n| Geoffrey Flake | 2018-04-01  |    0.00 |            0.00 |                2 |        1 |\n| Geoffrey Flake | 2018-05-01  | 1000.00 |            0.00 |                2 |        1 |\n| Geoffrey Flake | 2018-06-01  | 2000.00 |         1000.00 |                3 |        2 |\n| Geoffrey Flake | 2018-07-01  |    0.00 |            0.00 |                4 |        2 |\n| Geoffrey Flake | 2018-08-01  |    0.00 |            0.00 |                4 |        2 |\n| Ida Idyll      | 2018-01-01  |    0.00 |            0.00 |                0 |        0 |\n| Ida Idyll      | 2018-02-01  |    0.00 |            0.00 |                0 |        0 |\n| Ida Idyll      | 2018-03-01  |    0.00 |            0.00 |                0 |        0 |\n| Ida Idyll      | 2018-04-01  |    0.00 |            0.00 |                0 |        0 |\n| Ida Idyll      | 2018-05-01  |    0.00 |            0.00 |                0 |        0 |\n| Ida Idyll      | 2018-06-01  |    0.00 |            0.00 |                0 |        0 |\n| Ida Idyll      | 2018-07-01  |    0.00 |            0.00 |                0 |        0 |\n| Ida Idyll      | 2018-08-01  |    0.00 |            0.00 |                0 |        0 |\n| Leslie Safer   | 2018-01-01  |    0.00 |            0.00 |                0 |        0 |\n| Leslie Safer   | 2018-02-01  |    0.00 |            0.00 |                0 |        0 |\n| Leslie Safer   | 2018-03-01  | 1000.00 |         1000.00 |                1 |        1 |\n| Leslie Safer   | 2018-04-01  | 2000.00 |         1000.00 |                1 |        2 |\n| Leslie Safer   | 2018-05-01  | 2000.00 |         1000.00 |                1 |        3 |\n| Leslie Safer   | 2018-06-01  | 2000.00 |         1000.00 |                1 |        4 |\n| Leslie Safer   | 2018-07-01  | 2000.00 |         1000.00 |                1 |        5 |\n| Leslie Safer   | 2018-08-01  | 2000.00 |         1000.00 |                1 |        6 |\n+----------------+-------------+---------+-----------------+------------------+----------+\n\nCREATE OR REPLACE TABLE tbl\n(p int, o int, i int, r int, s varchar(100));\n\nINSERT INTO tbl VALUES\n(100,1,1,70,'seventy'),(100,2,2,30, 'thirty'),(100,3,3,40,'fourty'),(100,4,NULL,90,'ninety'),(100,5,5,50,'fifty'),(100,6,6,30,'thirty'),\n(200,7,7,40,'fourty'),(200,8,NULL,NULL,'n_u_l_l'),(200,9,NULL,NULL,'n_u_l_l'),(200,10,10,20,'twenty'),(200,11,NULL,90,'ninety'),\n(300,12,12,30,'thirty'),\n(400,13,NULL,20,'twenty');\n\nSELECT * FROM tbl ORDER BY p, o, i;\n\n+-----+----+--------+--------+---------+\n|  P  | O  |   I    |   R    |    S    |\n+-----+----+--------+--------+---------+\n| 100 | 1  | 1      | 70     | seventy |\n| 100 | 2  | 2      | 30     | thirty  |\n| 100 | 3  | 3      | 40     | fourty  |\n| 100 | 4  | [NULL] | 90     | ninety  |\n| 100 | 5  | 5      | 50     | fifty   |\n| 100 | 6  | 6      | 30     | thirty  |\n| 200 | 7  | 7      | 40     | fourty  |\n| 200 | 8  | [NULL] | [NULL] | n_u_l_l |\n| 200 | 9  | [NULL] | [NULL] | n_u_l_l |\n| 200 | 10 | 10     | 20     | twenty  |\n| 200 | 11 | [NULL] | 90     | ninety  |\n| 300 | 12 | 12     | 30     | thirty  |\n| 400 | 13 | [NULL] | 20     | twenty  |\n+-----+----+--------+--------+---------+\n\nSELECT p, o, CONDITIONAL_TRUE_EVENT(o>2) OVER (PARTITION BY p ORDER BY o) FROM tbl ORDER BY p, o;\n\n+-----+----+--------------------------------------------------------------+\n|   P |  O | CONDITIONAL_TRUE_EVENT(O>2) OVER (PARTITION BY P ORDER BY O) |\n|-----+----+--------------------------------------------------------------|\n| 100 |  1 |                                                            0 |\n| 100 |  2 |                                                            0 |\n| 100 |  3 |                                                            1 |\n| 100 |  4 |                                                            2 |\n| 100 |  5 |                                                            3 |\n| 100 |  6 |                                                            4 |\n| 200 |  7 |                                                            1 |\n| 200 |  8 |                                                            2 |\n| 200 |  9 |                                                            3 |\n| 200 | 10 |                                                            4 |\n| 200 | 11 |                                                            5 |\n| 300 | 12 |                                                            1 |\n| 400 | 13 |                                                            1 |\n+-----+----+--------------------------------------------------------------+\n\nSELECT p, o, CONDITIONAL_TRUE_EVENT(LAG(O) OVER (PARTITION BY P ORDER BY O) >1) OVER (PARTITION BY P ORDER BY O) FROM tbl ORDER BY p, o;\n\n+-----+----+-----------------------------------------------------------------------------------------------------+\n|   P |  O | CONDITIONAL_TRUE_EVENT(LAG(O) OVER (PARTITION BY P ORDER BY O) >1) OVER (PARTITION BY P ORDER BY O) |\n|-----+----+-----------------------------------------------------------------------------------------------------|\n| 100 |  1 |                                                                                                   0 |\n| 100 |  2 |                                                                                                   0 |\n| 100 |  3 |                                                                                                   1 |\n| 100 |  4 |                                                                                                   2 |\n| 100 |  5 |                                                                                                   3 |\n| 100 |  6 |                                                                                                   4 |\n| 200 |  7 |                                                                                                   0 |\n| 200 |  8 |                                                                                                   1 |\n| 200 |  9 |                                                                                                   2 |\n| 200 | 10 |                                                                                                   3 |\n| 200 | 11 |                                                                                                   4 |\n| 300 | 12 |                                                                                                   0 |\n| 400 | 13 |                                                                                                   0 |\n+-----+----+-----------------------------------------------------------------------------------------------------+",
    "arguments": [
        {
            "name": "expr1",
            "description": "This is a boolean expression that changes the window event number value when it evaluates true."
        },
        {
            "name": "expr2",
            "description": "This is the optional expression to partition by."
        },
        {
            "name": "expr3",
            "description": "This is the expression to order by within each partition."
        }
    ]
},
{
    "function_name": "CONDITIONAL_CHANGE_EVENT",
    "summary": "Returns a window event number for each row within a window partition when the value of the argument expr1 in the current row is different from the value of expr1 in the previous row.",
    "category": "Window functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/conditional_change_event",
    "title": "CONDITIONAL_CHANGE_EVENT",
    "description": "Returns a window event number for each row within a window partition when the value of the argument",
    "syntax": "CONDITIONAL_CHANGE_EVENT( <expr1> ) OVER ( [ PARTITION BY <expr2> ] ORDER BY <expr3> )",
    "example": "CREATE TABLE voltage_readings (\n    site_ID INTEGER, -- which refrigerator the measurement was taken in.\n    ts TIMESTAMP,  -- the time at which the temperature was measured.\n    VOLTAGE FLOAT\n    );\nINSERT INTO voltage_readings (site_ID, ts, voltage) VALUES\n    (1, '2019-10-30 13:00:00', 120),\n    (1, '2019-10-30 13:15:00', 120),\n    (1, '2019-10-30 13:30:00',   0),\n    (1, '2019-10-30 13:45:00',   0),\n    (1, '2019-10-30 14:00:00',   0),\n    (1, '2019-10-30 14:15:00',   0),\n    (1, '2019-10-30 14:30:00', 120)\n    ;\n\nSELECT site_ID, ts, voltage\n    FROM voltage_readings\n    WHERE voltage = 0\n    ORDER BY ts;\n+---------+-------------------------+---------+\n| SITE_ID | TS                      | VOLTAGE |\n|---------+-------------------------+---------|\n|       1 | 2019-10-30 13:30:00.000 |       0 |\n|       1 | 2019-10-30 13:45:00.000 |       0 |\n|       1 | 2019-10-30 14:00:00.000 |       0 |\n|       1 | 2019-10-30 14:15:00.000 |       0 |\n+---------+-------------------------+---------+\n\nSELECT\n      site_ID,\n      ts,\n      voltage,\n      CONDITIONAL_CHANGE_EVENT(voltage = 0) OVER (ORDER BY ts) AS power_changes\n    FROM voltage_readings;\n+---------+-------------------------+---------+---------------+\n| SITE_ID | TS                      | VOLTAGE | POWER_CHANGES |\n|---------+-------------------------+---------+---------------|\n|       1 | 2019-10-30 13:00:00.000 |     120 |             0 |\n|       1 | 2019-10-30 13:15:00.000 |     120 |             0 |\n|       1 | 2019-10-30 13:30:00.000 |       0 |             1 |\n|       1 | 2019-10-30 13:45:00.000 |       0 |             1 |\n|       1 | 2019-10-30 14:00:00.000 |       0 |             1 |\n|       1 | 2019-10-30 14:15:00.000 |       0 |             1 |\n|       1 | 2019-10-30 14:30:00.000 |     120 |             2 |\n+---------+-------------------------+---------+---------------+\n\nWITH power_change_events AS\n    (\n    SELECT\n      site_ID,\n      ts,\n      voltage,\n      CONDITIONAL_CHANGE_EVENT(voltage = 0) OVER (ORDER BY ts) AS power_changes\n    FROM voltage_readings\n    )\nSELECT\n      site_ID,\n      MIN(ts),\n      voltage,\n      power_changes\n    FROM power_change_events\n    GROUP BY site_ID, power_changes, voltage\n    ORDER BY 2\n    ;\n+---------+-------------------------+---------+---------------+\n| SITE_ID | MIN(TS)                 | VOLTAGE | POWER_CHANGES |\n|---------+-------------------------+---------+---------------|\n|       1 | 2019-10-30 13:00:00.000 |     120 |             0 |\n|       1 | 2019-10-30 13:30:00.000 |       0 |             1 |\n|       1 | 2019-10-30 14:30:00.000 |     120 |             2 |\n+---------+-------------------------+---------+---------------+\n\nWITH power_change_events AS\n    (\n    SELECT\n          site_ID,\n          CONDITIONAL_CHANGE_EVENT(voltage = 0) OVER (ORDER BY ts) AS power_changes\n        FROM voltage_readings\n    )\nSELECT MAX(power_changes) \n    FROM power_change_events\n    GROUP BY site_ID\n    ;\n+--------------------+\n| MAX(POWER_CHANGES) |\n|--------------------|\n|                  2 |\n+--------------------+\n\nCREATE TABLE table1 (province VARCHAR, o_col INTEGER, o2_col INTEGER);\nINSERT INTO table1 (province, o_col, o2_col) VALUES\n    ('Alberta',    0, 10),\n    ('Alberta',    0, 10),\n    ('Alberta',   13, 10),\n    ('Alberta',   13, 11),\n    ('Alberta',   14, 11),\n    ('Alberta',   15, 12),\n    ('Alberta', NULL, NULL),\n    ('Manitoba',    30, 30);\n\nSELECT province, o_col,\n      CONDITIONAL_CHANGE_EVENT(o_col) \n        OVER (PARTITION BY province ORDER BY o_col) \n          AS change_event\n    FROM table1\n    ORDER BY province, o_col\n    ;\n+----------+-------+--------------+\n| PROVINCE | O_COL | CHANGE_EVENT |\n|----------+-------+--------------|\n| Alberta  |     0 |            0 |\n| Alberta  |     0 |            0 |\n| Alberta  |    13 |            1 |\n| Alberta  |    13 |            1 |\n| Alberta  |    14 |            2 |\n| Alberta  |    15 |            3 |\n| Alberta  |  NULL |            3 |\n| Manitoba |    30 |            0 |\n+----------+-------+--------------+\n\nSELECT province, o_col,\n      'o_col < 15' AS condition,\n      CONDITIONAL_CHANGE_EVENT(o_col) \n        OVER (PARTITION BY province ORDER BY o_col) \n          AS change_event,\n      CONDITIONAL_CHANGE_EVENT(o_col < 15) \n        OVER (PARTITION BY province ORDER BY o_col) \n          AS change_event_2\n    FROM table1\n    ORDER BY province, o_col\n    ;\n+----------+-------+------------+--------------+----------------+\n| PROVINCE | O_COL | CONDITION  | CHANGE_EVENT | CHANGE_EVENT_2 |\n|----------+-------+------------+--------------+----------------|\n| Alberta  |     0 | o_col < 15 |            0 |              0 |\n| Alberta  |     0 | o_col < 15 |            0 |              0 |\n| Alberta  |    13 | o_col < 15 |            1 |              0 |\n| Alberta  |    13 | o_col < 15 |            1 |              0 |\n| Alberta  |    14 | o_col < 15 |            2 |              0 |\n| Alberta  |    15 | o_col < 15 |            3 |              1 |\n| Alberta  |  NULL | o_col < 15 |            3 |              1 |\n| Manitoba |    30 | o_col < 15 |            0 |              0 |\n+----------+-------+------------+--------------+----------------+\n\nSELECT province, o_col,\n      CONDITIONAL_CHANGE_EVENT(o_col) \n        OVER (PARTITION BY province ORDER BY o_col) \n          AS change_event,\n      CONDITIONAL_TRUE_EVENT(o_col) \n        OVER (PARTITION BY province ORDER BY o_col) \n          AS true_event\n    FROM table1\n    ORDER BY province, o_col\n    ;\n+----------+-------+--------------+------------+\n| PROVINCE | O_COL | CHANGE_EVENT | TRUE_EVENT |\n|----------+-------+--------------+------------|\n| Alberta  |     0 |            0 |          0 |\n| Alberta  |     0 |            0 |          0 |\n| Alberta  |    13 |            1 |          1 |\n| Alberta  |    13 |            1 |          2 |\n| Alberta  |    14 |            2 |          3 |\n| Alberta  |    15 |            3 |          4 |\n| Alberta  |  NULL |            3 |          4 |\n| Manitoba |    30 |            0 |          1 |\n+----------+-------+--------------+------------+\n\nCREATE TABLE borrowers (\n    name VARCHAR,\n    status_date DATE,\n    late_balance NUMERIC(11, 2),\n    thirty_day_late_balance NUMERIC(11, 2)\n    );\nINSERT INTO borrowers (name, status_date, late_balance, thirty_day_late_balance) VALUES\n\n    -- Pays late frequently, but catches back up rather than falling further\n    -- behind.\n    ('Geoffrey Flake', '2018-01-01'::DATE,    0.0,    0.0),\n    ('Geoffrey Flake', '2018-02-01'::DATE, 1000.0,    0.0),\n    ('Geoffrey Flake', '2018-03-01'::DATE, 2000.0, 1000.0),\n    ('Geoffrey Flake', '2018-04-01'::DATE,    0.0,    0.0),\n    ('Geoffrey Flake', '2018-05-01'::DATE, 1000.0,    0.0),\n    ('Geoffrey Flake', '2018-06-01'::DATE, 2000.0, 1000.0),\n    ('Geoffrey Flake', '2018-07-01'::DATE,    0.0,    0.0),\n    ('Geoffrey Flake', '2018-08-01'::DATE,    0.0,    0.0),\n\n    -- Keeps falling further behind.\n    ('Cy Dismal', '2018-01-01'::DATE,    0.0,    0.0),\n    ('Cy Dismal', '2018-02-01'::DATE,    0.0,    0.0),\n    ('Cy Dismal', '2018-03-01'::DATE, 1000.0,    0.0),\n    ('Cy Dismal', '2018-04-01'::DATE, 2000.0, 1000.0),\n    ('Cy Dismal', '2018-05-01'::DATE, 3000.0, 2000.0),\n    ('Cy Dismal', '2018-06-01'::DATE, 4000.0, 3000.0),\n    ('Cy Dismal', '2018-07-01'::DATE, 5000.0, 4000.0),\n    ('Cy Dismal', '2018-08-01'::DATE, 6000.0, 5000.0),\n\n    -- Fell behind and isn't catching up, but isn't falling further and \n    -- further behind. Essentially, this person just 'failed' once.\n    ('Leslie Safer', '2018-01-01'::DATE,    0.0,    0.0),\n    ('Leslie Safer', '2018-02-01'::DATE,    0.0,    0.0),\n    ('Leslie Safer', '2018-03-01'::DATE, 1000.0, 1000.0),\n    ('Leslie Safer', '2018-04-01'::DATE, 2000.0, 1000.0),\n    ('Leslie Safer', '2018-05-01'::DATE, 2000.0, 1000.0),\n    ('Leslie Safer', '2018-06-01'::DATE, 2000.0, 1000.0),\n    ('Leslie Safer', '2018-07-01'::DATE, 2000.0, 1000.0),\n    ('Leslie Safer', '2018-08-01'::DATE, 2000.0, 1000.0),\n\n    -- Always pays on time and in full.\n    ('Ida Idyll', '2018-01-01'::DATE,    0.0,    0.0),\n    ('Ida Idyll', '2018-02-01'::DATE,    0.0,    0.0),\n    ('Ida Idyll', '2018-03-01'::DATE,    0.0,    0.0),\n    ('Ida Idyll', '2018-04-01'::DATE,    0.0,    0.0),\n    ('Ida Idyll', '2018-05-01'::DATE,    0.0,    0.0),\n    ('Ida Idyll', '2018-06-01'::DATE,    0.0,    0.0),\n    ('Ida Idyll', '2018-07-01'::DATE,    0.0,    0.0),\n    ('Ida Idyll', '2018-08-01'::DATE,    0.0,    0.0)\n\n    ;\n\nSELECT name, status_date, late_balance AS \"OVERDUE\", \n        thirty_day_late_balance AS \"30 DAYS OVERDUE\",\n        CONDITIONAL_CHANGE_EVENT(thirty_day_late_balance) \n          OVER (PARTITION BY name ORDER BY status_date) AS change_event_cnt,\n        CONDITIONAL_TRUE_EVENT(thirty_day_late_balance) \n          OVER (PARTITION BY name ORDER BY status_date) AS true_cnt\n    FROM borrowers\n    ORDER BY name, status_date\n    ;\n+----------------+-------------+---------+-----------------+------------------+----------+\n| NAME           | STATUS_DATE | OVERDUE | 30 DAYS OVERDUE | CHANGE_EVENT_CNT | TRUE_CNT |\n|----------------+-------------+---------+-----------------+------------------+----------|\n| Cy Dismal      | 2018-01-01  |    0.00 |            0.00 |                0 |        0 |\n| Cy Dismal      | 2018-02-01  |    0.00 |            0.00 |                0 |        0 |\n| Cy Dismal      | 2018-03-01  | 1000.00 |            0.00 |                0 |        0 |\n| Cy Dismal      | 2018-04-01  | 2000.00 |         1000.00 |                1 |        1 |\n| Cy Dismal      | 2018-05-01  | 3000.00 |         2000.00 |                2 |        2 |\n| Cy Dismal      | 2018-06-01  | 4000.00 |         3000.00 |                3 |        3 |\n| Cy Dismal      | 2018-07-01  | 5000.00 |         4000.00 |                4 |        4 |\n| Cy Dismal      | 2018-08-01  | 6000.00 |         5000.00 |                5 |        5 |\n| Geoffrey Flake | 2018-01-01  |    0.00 |            0.00 |                0 |        0 |\n| Geoffrey Flake | 2018-02-01  | 1000.00 |            0.00 |                0 |        0 |\n| Geoffrey Flake | 2018-03-01  | 2000.00 |         1000.00 |                1 |        1 |\n| Geoffrey Flake | 2018-04-01  |    0.00 |            0.00 |                2 |        1 |\n| Geoffrey Flake | 2018-05-01  | 1000.00 |            0.00 |                2 |        1 |\n| Geoffrey Flake | 2018-06-01  | 2000.00 |         1000.00 |                3 |        2 |\n| Geoffrey Flake | 2018-07-01  |    0.00 |            0.00 |                4 |        2 |\n| Geoffrey Flake | 2018-08-01  |    0.00 |            0.00 |                4 |        2 |\n| Ida Idyll      | 2018-01-01  |    0.00 |            0.00 |                0 |        0 |\n| Ida Idyll      | 2018-02-01  |    0.00 |            0.00 |                0 |        0 |\n| Ida Idyll      | 2018-03-01  |    0.00 |            0.00 |                0 |        0 |\n| Ida Idyll      | 2018-04-01  |    0.00 |            0.00 |                0 |        0 |\n| Ida Idyll      | 2018-05-01  |    0.00 |            0.00 |                0 |        0 |\n| Ida Idyll      | 2018-06-01  |    0.00 |            0.00 |                0 |        0 |\n| Ida Idyll      | 2018-07-01  |    0.00 |            0.00 |                0 |        0 |\n| Ida Idyll      | 2018-08-01  |    0.00 |            0.00 |                0 |        0 |\n| Leslie Safer   | 2018-01-01  |    0.00 |            0.00 |                0 |        0 |\n| Leslie Safer   | 2018-02-01  |    0.00 |            0.00 |                0 |        0 |\n| Leslie Safer   | 2018-03-01  | 1000.00 |         1000.00 |                1 |        1 |\n| Leslie Safer   | 2018-04-01  | 2000.00 |         1000.00 |                1 |        2 |\n| Leslie Safer   | 2018-05-01  | 2000.00 |         1000.00 |                1 |        3 |\n| Leslie Safer   | 2018-06-01  | 2000.00 |         1000.00 |                1 |        4 |\n| Leslie Safer   | 2018-07-01  | 2000.00 |         1000.00 |                1 |        5 |\n| Leslie Safer   | 2018-08-01  | 2000.00 |         1000.00 |                1 |        6 |\n+----------------+-------------+---------+-----------------+------------------+----------+\n\nCREATE OR REPLACE TABLE tbl\n(p int, o int, i int, r int, s varchar(100));\n\nINSERT INTO tbl VALUES\n(100,1,1,70,'seventy'),(100,2,2,30, 'thirty'),(100,3,3,40,'fourty'),(100,4,NULL,90,'ninety'),(100,5,5,50,'fifty'),(100,6,6,30,'thirty'),\n(200,7,7,40,'fourty'),(200,8,NULL,NULL,'n_u_l_l'),(200,9,NULL,NULL,'n_u_l_l'),(200,10,10,20,'twenty'),(200,11,NULL,90,'ninety'),\n(300,12,12,30,'thirty'),\n(400,13,NULL,20,'twenty');\n\nSELECT * FROM tbl ORDER BY p, o, i;\n\n+-----+----+--------+--------+---------+\n|  P  | O  |   I    |   R    |    S    |\n+-----+----+--------+--------+---------+\n| 100 | 1  | 1      | 70     | seventy |\n| 100 | 2  | 2      | 30     | thirty  |\n| 100 | 3  | 3      | 40     | fourty  |\n| 100 | 4  | [NULL] | 90     | ninety  |\n| 100 | 5  | 5      | 50     | fifty   |\n| 100 | 6  | 6      | 30     | thirty  |\n| 200 | 7  | 7      | 40     | fourty  |\n| 200 | 8  | [NULL] | [NULL] | n_u_l_l |\n| 200 | 9  | [NULL] | [NULL] | n_u_l_l |\n| 200 | 10 | 10     | 20     | twenty  |\n| 200 | 11 | [NULL] | 90     | ninety  |\n| 300 | 12 | 12     | 30     | thirty  |\n| 400 | 13 | [NULL] | 20     | twenty  |\n+-----+----+--------+--------+---------+\n\nSELECT p, o, CONDITIONAL_CHANGE_EVENT(o) OVER (PARTITION BY p ORDER BY o) FROM tbl ORDER BY p, o;\n\n+-----+----+--------------------------------------------------------------+\n|   P |  O | CONDITIONAL_CHANGE_EVENT(O) OVER (PARTITION BY P ORDER BY O) |\n|-----+----+--------------------------------------------------------------|\n| 100 |  1 |                                                            0 |\n| 100 |  2 |                                                            1 |\n| 100 |  3 |                                                            2 |\n| 100 |  4 |                                                            3 |\n| 100 |  5 |                                                            4 |\n| 100 |  6 |                                                            5 |\n| 200 |  7 |                                                            0 |\n| 200 |  8 |                                                            1 |\n| 200 |  9 |                                                            2 |\n| 200 | 10 |                                                            3 |\n| 200 | 11 |                                                            4 |\n| 300 | 12 |                                                            0 |\n| 400 | 13 |                                                            0 |\n+-----+----+--------------------------------------------------------------+",
    "arguments": [
        {
            "name": "expr1",
            "description": "This is an expression that gets compared with the expression of the previous row."
        },
        {
            "name": "expr2",
            "description": "This is the optional expression to partition by."
        },
        {
            "name": "expr3",
            "description": "This is the expression to order by within each partition."
        }
    ]
},
{
    "function_name": "CONCAT_WS",
    "summary": "Concatenates two or more strings, or concatenates two or more binary values.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/concat_ws",
    "title": "CONCAT_WS",
    "description": "Concatenates two or more strings, or concatenates two or more binary values.\nIf any of the values is null, the result is also null.",
    "syntax": "CONCAT_WS( <separator> , <expression1> [ , <expressionN> ... ] )",
    "example": "SELECT CONCAT_WS(',', 'one', 'two', 'three');\n+---------------------------------------+\n| CONCAT_WS(',', 'ONE', 'TWO', 'THREE') |\n|---------------------------------------|\n| one,two,three                         |\n+---------------------------------------+\n\nSELECT CONCAT_WS(',', 'one');\n+-----------------------+\n| CONCAT_WS(',', 'ONE') |\n|-----------------------|\n| one                   |\n+-----------------------+",
    "arguments": [
        {
            "name": "separator",
            "description": "The separator must meet the same requirements as expressionN ."
        },
        {
            "name": "expressionN",
            "description": "The input expressions must all be strings, or all be binary values."
        }
    ],
    "returns": "The function returns a VARCHAR or BINARY that contains the 2nd through Nth arguments, separated by the first\nargument."
},
{
    "function_name": "CONCAT , ||",
    "summary": "Concatenates one or more strings, or concatenates one or more binary values.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/concat",
    "title": "CONCAT ,",
    "description": "Concatenates one or more strings, or concatenates one or more binary values.",
    "syntax": "CONCAT( <expr> [ , <expr> ... ] )\n\n<expr> || <expr> [ || <expr> ... ]",
    "example": "SELECT CONCAT('George Washington ', 'Carver');\n\n+----------------------------------------+\n| CONCAT('GEORGE WASHINGTON ', 'CARVER') |\n|----------------------------------------|\n| George Washington Carver               |\n+----------------------------------------+\n\nCREATE OR REPLACE TABLE concat_function_example (s1 VARCHAR, s2 VARCHAR, s3 VARCHAR);\nINSERT INTO concat_function_example (s1, s2, s3) VALUES\n  ('co', 'd', 'e'),\n  ('Colorado ', 'River ', NULL);\n\nSELECT CONCAT(s1, s2)\n  FROM concat_function_example;\n\n+-----------------+\n| CONCAT(S1, S2)  |\n|-----------------|\n| cod             |\n| Colorado River  |\n+-----------------+\n\nSELECT CONCAT(s1, s2, s3)\n  FROM concat_function_example;\n\n+--------------------+\n| CONCAT(S1, S2, S3) |\n|--------------------|\n| code               |\n| NULL               |\n+--------------------+\n\nSELECT CONCAT(\n    IFF(s1 IS NULL, '', s1),\n    IFF(s2 IS NULL, '', s2),\n    IFF(s3 IS NULL, '', s3)) AS concat_non_null_strings\n  FROM concat_function_example;\n\n+-------------------------+\n| CONCAT_NON_NULL_STRINGS |\n|-------------------------|\n| code                    |\n| Colorado River          |\n+-------------------------+\n\nSELECT 'This ' || 'is ' || 'another ' || 'concatenation ' || 'technique.';\n\n+--------------------------------------------------------------------+\n| 'THIS ' || 'IS ' || 'ANOTHER ' || 'CONCATENATION ' || 'TECHNIQUE.' |\n|--------------------------------------------------------------------|\n| This is another concatenation technique.                           |\n+--------------------------------------------------------------------+",
    "arguments": [
        {
            "name": "expr",
            "description": "The input expressions must all be strings, or all be binary values."
        }
    ],
    "returns": "The data type of the returned value is the same as the data type of the input value(s)."
},
{
    "function_name": "COMPRESS",
    "summary": "Compresses the input string or binary value with a compression method.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/compress",
    "title": "COMPRESS",
    "description": "Compresses the input string or binary value with a compression method.",
    "syntax": "COMPRESS(<input>, <method>)",
    "example": "SELECT COMPRESS('Snowflake', 'SNAPPY');\n+---------------------------------+\n| COMPRESS('SNOWFLAKE', 'SNAPPY') |\n|---------------------------------|\n| 0920536E6F77666C616B65          |\n+---------------------------------+",
    "arguments": [
        {
            "name": "input",
            "description": "A BINARY or string value (or expression) to be compressed."
        },
        {
            "name": "method",
            "description": "A string with compression method and optional compression level. Supported\nmethods are: SNAPPY . ZLIB . ZSTD . BZ2 . The compression level is specified in parentheses, for example: zlib(1) . The compression level is a non-negative integer. 0 means\ndefault level (same as omitting the compression level). The compression\nlevel is ignored if the method doesn’t support compression levels."
        }
    ],
    "returns": "A BINARY with compressed data."
},
{
    "function_name": "COMPLETE_TASK_GRAPHS",
    "summary": "Returns the status of a completed graph run.",
    "category": "Information Schema , Table functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/complete_task_graphs",
    "title": "COMPLETE_TASK_GRAPHS",
    "description": "Returns the status of a completed",
    "syntax": "COMPLETE_TASK_GRAPHS(\n      [ RESULT_LIMIT => <integer> ]\n      [, ROOT_TASK_NAME => '<string>' ]\n      [, ERROR_ONLY => { TRUE | FALSE } ] )",
    "example": "select *\n  from table(information_schema.complete_task_graphs())\n  order by scheduled_time;\n\nselect *\n  from table(information_schema.complete_task_graphs (\n    result_limit => 10,\n    root_task_name=>'MYTASK'));",
    "arguments": [
        {
            "name": "RESULT_LIMIT",
            "description": "A number specifying the maximum number of rows returned by the function. Note that the results are returned in descending COMPLETED_TIME\norder. If the number of matching rows is greater than the result limit, the graph executions with the most recent completed timestamp are\nreturned, up to the specified limit. Range: 1 to 10000 Default: 1000"
        },
        {
            "name": "ROOT_TASK_NAME",
            "description": "A case-insensitive string specifying the name of the root task. Only non-qualified task names are supported. Only graph runs for the\nspecified task are returned. Note that if multiple tasks have the same name, the function returns the graph runs for each of these tasks."
        },
        {
            "name": "ERROR_ONLY",
            "description": "When set to TRUE, this function returns only graph runs that failed or were cancelled."
        }
    ]
},
{
    "function_name": "COMPLETE (SNOWFLAKE.CORTEX)",
    "summary": "Given a prompt, generates a response (completion) using your choice of supported language model.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/complete-snowflake-cortex",
    "title": "COMPLETE (SNOWFLAKE.CORTEX)",
    "syntax": "SNOWFLAKE.CORTEX.COMPLETE(\n    <model>, <prompt_or_history> [ , <options> ] )",
    "example": "SELECT SNOWFLAKE.CORTEX.COMPLETE('snowflake-arctic', 'What are large language models?');\n\nSELECT SNOWFLAKE.CORTEX.COMPLETE(\n    'openai-gpt-4.1',\n        CONCAT('Critique this review in bullet points: <review>', content, '</review>')\n) FROM reviews LIMIT 10;\n\nSELECT SNOWFLAKE.CORTEX.COMPLETE(\n    'claude-4-sonnet ',\n    [\n        {\n            'role': 'user',\n            'content': 'how does a snowflake get its unique pattern?'\n        }\n    ],\n    {\n        'temperature': 0.7,\n        'max_tokens': 10\n    }\n);\n\n{\n    \"choices\": [\n        {\n            \"messages\": \" The unique pattern on a snowflake is\"\n        }\n    ],\n    \"created\": 1708536426,\n    \"model\": \"llama2-70b-chat\",\n    \"usage\": {\n        \"completion_tokens\": 10,\n        \"prompt_tokens\": 22,\n        \"guardrail_tokens\": 0,\n        \"total_tokens\": 32\n    }\n}\n\nSELECT SNOWFLAKE.CORTEX.COMPLETE(\n    'mistral-large2',\n    [\n        {\n            'role': 'user',\n            'content': <'Prompt that generates an unsafe response'>\n        }\n    ],\n    {\n        'guardrails': true\n    }\n);\n\n{\n    \"choices\": [\n        {\n            \"messages\": \"Response filtered by Cortex Guard\"\n        }\n    ],\n    \"created\": 1718882934,\n    \"model\": \"mistral-7b\",\n    \"usage\": {\n        \"completion_tokens\": 402,\n        \"prompt_tokens\": 93,\n        \"guardrails _tokens\": 677,\n        \"total_tokens\": 1172\n    }\n}\n\nSELECT SNOWFLAKE.CORTEX.COMPLETE(\n    'llama3.1-70b',\n    [\n        {'role': 'system', 'content': 'You are a helpful AI assistant. Analyze the movie review text and determine the overall sentiment. Answer with just \\\"Positive\\\", \\\"Negative\\\", or \\\"Neutral\\\"' },\n        {'role': 'user', 'content': 'this was really good'}\n    ], {}\n    ) as response;\n\n{\n    \"choices\": [\n        {\n        \"messages\": \" Positive\"\n        }\n    ],\n    \"created\": 1708479449,\n    \"model\": \"llama2-70b-chat\",\n    \"usage\": {\n        \"completion_tokens\": 3,\n        \"prompt_tokens\": 64,\n        \"total_tokens\": 67\n    }\n}",
    "arguments": [
        {
            "name": "model",
            "description": "A string specifying the model to be used. Specify one of the following values. claude-4-opus claude-4-sonnet claude-3-7-sonnet claude-3-5-sonnet deepseek-r1 gemma-7b jamba-1.5-mini jamba-1.5-large jamba-instruct llama2-70b-chat llama3-8b llama3-70b llama3.1-8b llama3.1-70b llama3.1-405b llama3.2-1b llama3.2-3b llama3.3-70b llama4-maverick llama4-scout mistral-large mistral-large2 mistral-7b mixtral-8x7b openai-gpt-4.1 openai-o4-mini reka-core reka-flash snowflake-arctic snowflake-llama-3.1-405b snowflake-llama-3.3-70b Supported models might have different costs ."
        },
        {
            "name": "prompt_or_history",
            "description": "The prompt or conversation history to be used to generate a completion. If options is not present, the prompt given must be a string. If options is present, the argument must be an array of objects representing a\nconversation in chronological order. Each object must contain a role key and a content key. The content value is a prompt or a response, depending on the role. The role must be one of the\nfollowing."
        },
        {
            "name": "options",
            "description": "An object containing zero or more of the following options that affect the model’s\nhyperparameters. See LLM Settings . temperature : A value from 0 to 1 (inclusive) that controls the randomness of the output of the language model. A\nhigher temperature (for example, 0.7) results in more diverse and random output, while a lower temperature (such as\n0.2) makes the output more deterministic and focused. Default: 0 top_p : A value from 0 to 1 (inclusive) that controls the randomness and diversity of the language model,\ngenerally used as an alternative to temperature . The difference is that top_p restricts the set of possible tokens\nthat the model outputs, while temperature influences which tokens are chosen at each step. Default: 0 max_tokens : Sets the maximum number of output tokens in the response. Small values can result in truncated responses. Default: 4096\nMaximum allowed value: 8192 guardrails : Filters potentially unsafe and harmful responses from a language model using Cortex Guard .\nEither TRUE or FALSE. Default: FALSE response_format : A JSON schema that the response should follow. This is a SQL\nsub-object, not a string. If response_format is not specified, the response is a string containing either the\nresponse or a serialized JSON object containing the response and information about it. For more information, see AI_COMPLETE Structured Outputs . Specifying the options argument, even if it is an empty object ( {} ), affects how the prompt argument is\ninterpreted and how the response is formatted."
        }
    ],
    "returns": "When the options argument is not specified, returns a string containing the response."
},
{
    "function_name": "COMPLETE (SNOWFLAKE.CORTEX) (multimodal)",
    "summary": "Given an image and a prompt, generates a response (completion) using a language model.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/complete-snowflake-cortex-multimodal",
    "title": "COMPLETE (SNOWFLAKE.CORTEX) (multimodal)",
    "syntax": "SNOWFLAKE.CORTEX.COMPLETE(\n    '<model>', '<prompt>', <file_object>)\nFROM <table>",
    "example": "SELECT SNOWFLAKE.CORTEX.COMPLETE('claude-3-5-sonnet',\n    'Which country will observe the largest inflation change in 2024 compared to 2023?',\n    TO_FILE('@myimages', 'highest-inflation.png'));\n\nLooking at the data, Venezuela will experience the largest change in inflation rates between 2023 and 2024.\nThe inflation rate in Venezuela is projected to decrease significantly from 337.46% in 2023 to 99.98% in 2024,\nrepresenting a reduction of approximately 237.48 percentage points. This is the most dramatic change among\nall countries shown in the chart, even though Zimbabwe has higher absolute inflation rates.\n\nSELECT SNOWFLAKE.CORTEX.COMPLETE('claude-3-5-sonnet',\n    'Classify the landmark identified in this image. Respond in JSON only with the landmark name.',\n    TO_FILE('@myimages', 'Seattle.jpg'));\n\n{\"landmark\": \"Space Needle\"}\n\nSELECT SNOWFLAKE.CORTEX.COMPLETE('claude-3-5-sonnet',\n    'Extract the kitchen appliances identified in this image. Respond in JSON only with the identified appliances.',\n    TO_FILE('@myimages', 'kitchen.png'));\n\n{\n    \"appliances\": [ \"microwave\",\"electric stove\",\"oven\",\"refrigerator\" ]\n}\n\nCREATE TABLE image_table AS\n    (SELECT TO_FILE('@myimages', RELATIVE_PATH) AS img FROM DIRECTORY(@myimages));\n\nSELECT SNOWFLAKE.CORTEX.COMPLETE('claude-3-5-sonnet',\n    PROMPT('Classify the input image {0} in no more than 2 words. Respond in JSON', img_file)) AS image_classification\nFROM image_table;\n\n{ \"classification\": \"Inflation Rates\" }\n{ \"classification\": \"beverage refrigerator\" }\n{ \"classification\": \"Space Needle\" }\n{ \"classification\": \"Modern Kitchen\" }\n{ \"classification\": \"Pie Chart\" }\n{ \"classification\": \"Economic Graph\" }\n{ \"classification\": \"Persian Cat\" }\n{ \"classification\": \"Labrador Retriever\" }\n{ \"classification\": \"Jedi Cat\" }\n{ \"classification\": \"Sleeping cat\" }\n{ \"classification\": \"Persian Cat\" }\n{ \"classification\": \"Garden Costume\" }\n{ \"classification\": \"Floral Fashion\" }\n\nSELECT SNOWFLAKE.CORTEX.COMPLETE('claude-3-5-sonnet',\n    PROMPT('Classify the input image {0} in no more than 2 words. Respond in JSON',\n        TO_FILE('@myimages', img_path)) AS image_classification\nFROM image_table;\n\nSELECT SNOWFLAKE.CORTEX.COMPLETE('claude-3-5-sonnet',\n    PROMPT('Classify the input image {0} in no more than 2 words. Respond in JSON',\n        TO_FILE('@myimages', RELATIVE_PATH))) as image_classification\nFROM DIRECTORY(@myimages);\n\nSNOWFLAKE.CORTEX.COMPLETE('claude-3-5-sonnet',\n    PROMPT('Given the input image {0}, {1}. Respond in JSON',\n        TO_FILE('@myimages', img_path), prompt) as image_result)\nFROM image_table;",
    "arguments": [
        {
            "name": "model",
            "description": "A string specifying the model to be used. Specify one of the following models: claude-3-5-sonnet pixtral-large Supported models might have different costs and context windows. New models might be added from time to time."
        },
        {
            "name": "prompt",
            "description": "A string containing a question about the image and optionally specifying an output format, such as JSON. Either\nthis or the prompt_object argument is required."
        },
        {
            "name": "prompt_object",
            "description": "A SQL OBJECT containing a string prompt with numbered placeholders ( {0} , {1} , and so on) and one or more text or\nFILE valuse that are inserted into the prompt. The PROMPT function function is a convenient way to create an object\nwith the required layout. Either this argument or prompt is required."
        },
        {
            "name": "file_object",
            "description": "A FILE object that contains an image file to be processed. Use the TO_FILE function to\ncreate FILE objects from a stage path. Required when using a string prompt."
        },
        {
            "name": "FROM",
            "description": "An optional table containing image paths and an optional prompt for each image, allowing images to be batch-processed\nin a single call to COMPLETE."
        }
    ],
    "returns": "A string containing the language model’s response."
},
{
    "function_name": "COLLATION",
    "summary": "Returns the collation specification of the expression.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/collation",
    "title": "COLLATION",
    "description": "Returns the collation specification of the expression.",
    "syntax": "COLLATION(<expression>)",
    "example": "CREATE OR REPLACE TABLE collation1 (v VARCHAR COLLATE 'es');\nINSERT INTO collation1 (v) VALUES ('ñ');\n\nSELECT COLLATION(v)\n  FROM collation1;\n\n+--------------+\n| COLLATION(V) |\n|--------------|\n| es           |\n+--------------+",
    "arguments": [
        {
            "name": "expression",
            "description": "The expression for which you want to know the collation specification.\nTypically, this is a column name."
        }
    ],
    "returns": "Returns a VARCHAR value that contains the collation specification of the expression."
},
{
    "function_name": "COLLATE",
    "summary": "Returns a copy of the original string, but with the specified collation_specification property instead of the original collation_specification property.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/collate",
    "title": "COLLATE",
    "description": "Returns a copy of the original string, but with the specified",
    "syntax": "COLLATE(<string_expression>, '<collation_specification>')",
    "example": "CREATE OR REPLACE TABLE collation1 (v VARCHAR COLLATE 'es');\nINSERT INTO collation1 (v) VALUES ('ñ');\n\nSELECT v,\n       COLLATION(v),\n       COLLATE(v, 'es-ci'),\n       COLLATION(COLLATE(v, 'es-ci'))\n  FROM collation1;\n\n+---+--------------+---------------------+--------------------------------+\n| V | COLLATION(V) | COLLATE(V, 'ES-CI') | COLLATION(COLLATE(V, 'ES-CI')) |\n|---+--------------+---------------------+--------------------------------|\n| ñ | es           | ñ                   | es-ci                          |\n+---+--------------+---------------------+--------------------------------+\n\nSELECT v,\n       v = 'ñ' AS \"COMPARISON TO LOWER CASE\",\n       v = 'Ñ' AS \"COMPARISON TO UPPER CASE\",\n       COLLATE(v, 'es-ci'),\n       COLLATE(v, 'es-ci') = 'Ñ'\n  FROM collation1;\n\n+---+--------------------------+--------------------------+---------------------+---------------------------+\n| V | COMPARISON TO LOWER CASE | COMPARISON TO UPPER CASE | COLLATE(V, 'ES-CI') | COLLATE(V, 'ES-CI') = 'Ñ' |\n|---+--------------------------+--------------------------+---------------------+---------------------------|\n| ñ | True                     | False                    | ñ                   | True                      |\n+---+--------------------------+--------------------------+---------------------+---------------------------+\n\nSELECT *\n  FROM t1\n  ORDER BY COLLATE(col1 , 'de');\n\nSELECT spanish_phrase FROM collation_demo \n  ORDER BY COLLATE(spanish_phrase, 'utf8');\n\nSELECT spanish_phrase FROM collation_demo \n  ORDER BY spanish_phrase COLLATE 'utf8';",
    "arguments": [
        {
            "name": "string_expression",
            "description": "The string to copy."
        },
        {
            "name": "collation_specification",
            "description": "The collation to store with the copy of the string. For more information about collation\nspecifiers, see Collation specifications ."
        }
    ],
    "returns": "Returns a copy of the original string, but with the specified\ncollation_specification property instead of the original\ncollation_specification."
},
{
    "function_name": "COALESCE",
    "summary": "Returns the first non-NULL expression among its arguments, or NULL if all its arguments are NULL.",
    "category": "Conditional expression functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/coalesce",
    "title": "COALESCE",
    "description": "Returns the first non-NULL expression among its arguments, or NULL if\nall its arguments are NULL.",
    "syntax": "COALESCE( <expr1> , <expr2> [ , ... , <exprN> ] )",
    "example": "SELECT column1, column2, column3, coalesce(column1, column2, column3)\nFROM (values\n  (1,    2,    3   ),\n  (null, 2,    3   ),\n  (null, null, 3   ),\n  (null, null, null),\n  (1,    null, 3   ),\n  (1,    null, null),\n  (1,    2,    null)\n) v;\n\n+---------+---------+---------+-------------------------------------+\n| COLUMN1 | COLUMN2 | COLUMN3 | COALESCE(COLUMN1, COLUMN2, COLUMN3) |\n|---------+---------+---------+-------------------------------------|\n|       1 |       2 |       3 |                                   1 |\n|    NULL |       2 |       3 |                                   2 |\n|    NULL |    NULL |       3 |                                   3 |\n|    NULL |    NULL |    NULL |                                NULL |\n|       1 |    NULL |       3 |                                   1 |\n|       1 |    NULL |    NULL |                                   1 |\n|       1 |       2 |    NULL |                                   1 |\n+---------+---------+---------+-------------------------------------+"
},
{
    "function_name": "CLASSIFY_TEXT (SNOWFLAKE.CORTEX)",
    "summary": "Classifies free-form text into categories that you provide.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/classify_text-snowflake-cortex",
    "title": "CLASSIFY_TEXT (SNOWFLAKE.CORTEX)",
    "syntax": "SNOWFLAKE.CORTEX.CLASSIFY_TEXT( <input> , <list_of_categories>, [ <options> ] )",
    "example": "SELECT SNOWFLAKE.CORTEX.CLASSIFY_TEXT('One day I will see the world', ['travel', 'cooking']);\n\n{\n  \"label\": \"travel\"\n}\n\nCREATE OR REPLACE TEMPORARY TABLE text_classification_table AS\nSELECT 'France' AS input, ['North America', 'Europe', 'Asia'] AS classes\nUNION ALL\nSELECT 'Singapore', ['North America', 'Europe', 'Asia']\nUNION ALL\nSELECT 'one day I will see the world', ['travel', 'cooking', 'dancing']\nUNION ALL\nSELECT 'my lobster bisque is second to none', ['travel', 'cooking', 'dancing'];\n\nSELECT input,\n       classes,\n       SNOWFLAKE.CORTEX.CLASSIFY_TEXT(input, classes)['label'] as classification\nFROM text_classification_table;\n\nSELECT SNOWFLAKE.CORTEX.CLASSIFY_TEXT(\n  'When I am not at work, I love creating recipes using every day ingredients',\n  ['travel', 'cooking', 'fitness'],\n  {\n    'task_description': 'Return a classification of the Hobby identified in the text'\n  }\n);\n\n{\n  \"label\": \"cooking\"\n}\n\nSELECT SNOWFLAKE.CORTEX.CLASSIFY_TEXT(\n  'I love running every morning before the world wakes up',\n  [{\n    'label': 'travel',\n    'description': 'Hobbies related to going from one place to another',\n    'examples': ['I like flying to Europe', 'Every summer we go to Italy' , 'I love traveling to learn new cultures']\n  },{\n    'label': 'cooking',\n    'description': 'Hobbies related to preparing food',\n    'examples': ['I like learning about new ingredients', 'You must bring your soul to the recipe' , 'Baking is my therapy']\n    },{\n    'label': 'fitness',\n    'description': 'Hobbies related to being active and healthy',\n    'examples': ['I cannot live without my Strava app', 'Running is life' , 'I go to the Gym every day']\n    }],\n  {'task_description': 'Return a classification of the Hobby identified in the text'})\n\n{\n  \"label\": \"fitness\"\n}\n\nSELECT SNOWFLAKE.CORTEX.CLASSIFY_TEXT(\n  'I love running every morning before the world wakes up',\n  [{\n    'label': 'travel',\n    'description': 'Hobbies related to going from one place to another',\n    'examples': ['I like flying to Europe']\n  },{\n    'label': 'cooking',\n    'examples': ['I like learning about new ingredients', 'You must bring your soul to the recipe' , 'Baking is my therapy']\n    },{\n    'label': 'fitness',\n    'description': 'Hobbies related to being active and healthy'\n    }],\n  {'task_description': 'Return a classification of the Hobby identified in the text'})\n\n{\n  \"label\": \"fitness\"\n}",
    "arguments": [
        {
            "name": "input",
            "description": "String to classify. The input string is case sensitive. You may get different results for the same string that uses different\ncapitalization."
        },
        {
            "name": "list_of_categories",
            "description": "Array that represents the categories. Must contain at least two and at most 100 unique categories. Categories are case\nsensitive. If these requirements are not met, the function returns an error. For a full list of errors, see Error conditions . Categories may be simple strings or SQL objects; all categories must be the same type. Using objects, you can\nprovide a description and examples of each category, providing context that can help improve classification accuracy.\nIt is not required to provide descriptions or examples for each category; you are free to provide a description,\nexamples, both, or neither for each category. label : The name of the category. This key is required. description : A description of the category. Descriptions should be no longer than about 25 words (1-2 sentences) long.\nThis key is optional. examples : An array of examples that are representative of the category. Typically no more than five examples are needed,\nbut there is a limit of 20 examples per category. The number of examples does not need to be the same for every category.\nThis key is optional. Note Descriptions and examples count as input tokens, which increases the cost of the classification operation. Read\nmore in Cost considerations ."
        },
        {
            "name": "options",
            "description": "An object that contains optional configuration (as key/value pairs) for the classification operation. Currently, the\nonly available key is: task_description : A string containing a short explanation of the text classification task. Task descriptions should\nbe no more than about 50 words (3-4 sentences) long."
        }
    ],
    "returns": "An OBJECT value (VARIANT). The object’s label field is a string specifying the category to which the input prompt belongs."
},
{
    "function_name": "CHR , CHAR",
    "summary": "Converts a Unicode code point (including 7-bit ASCII) into the character that matches the input Unicode.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/chr",
    "title": "CHR , CHAR",
    "description": "Converts a Unicode code point (including 7-bit ASCII) into the character that matches the input Unicode. If an invalid code point is specified, an error is returned.",
    "syntax": "CHR( <input> )",
    "example": "SELECT column1, CHR(column1)\nFROM (VALUES(83), (33), (169), (8364), (0), (null));\n\n+---------+--------------+\n| COLUMN1 | CHR(COLUMN1) |\n|---------+--------------|\n|      83 | S            |\n|      33 | !            |\n|     169 | ©            |\n|    8364 | €            |\n|       0 |              |\n|    NULL | NULL         |\n+---------+--------------+\n\nSELECT column1, CHR(column1)\nFROM (VALUES(-1));\n\nFAILURE: Invalid character code -1 in the CHR input\n\nSELECT column1, CHR(column1)\nFROM (VALUES(999999999999));\n\nFAILURE: Invalid character code 999999999999 in the CHR input",
    "arguments": [
        {
            "name": "input",
            "description": "The Unicode code point for which the character is returned."
        }
    ],
    "returns": "The data type of the returned value is VARCHAR."
},
{
    "function_name": "CHECK_XML",
    "summary": "Checks the validity of an XML document.",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/check_xml",
    "title": "CHECK_XML",
    "description": "Checks the validity of an",
    "syntax": "CHECK_XML( <string_containing_xml> [ , <disable_auto_convert> ] )",
    "example": "SELECT CHECK_XML('<name> Valid </name>');\n\n+-----------------------------------+\n| CHECK_XML('<NAME> VALID </NAME>') |\n|-----------------------------------|\n| NULL                              |\n+-----------------------------------+\n\nSELECT CHECK_XML('<name> Invalid </WRONG_CLOSING_TAG>');\n\n+--------------------------------------------------+\n| CHECK_XML('<NAME> INVALID </WRONG_CLOSING_TAG>') |\n|--------------------------------------------------|\n| no opening tag for </WRONG_CLOSING_TAG>, pos 35  |\n+--------------------------------------------------+\n\nSELECT xml_str, CHECK_XML(xml_str)\n  FROM my_table\n  WHERE CHECK_XML(xml_str) IS NOT NULL;",
    "arguments": [
        {
            "name": "string_containing_xml",
            "description": "Specify an expression that evaluates to a VARCHAR value that contains valid XML."
        },
        {
            "name": "disable_auto_convert",
            "description": "Specify the same value that you pass to the PARSE_XML function. Default: FALSE"
        }
    ],
    "returns": "The data type of the returned value is VARCHAR."
},
{
    "function_name": "CHECK_JSON",
    "summary": "Checks the validity of a JSON document.",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/check_json",
    "title": "CHECK_JSON",
    "description": "Checks the validity of a JSON document. If the input string is a valid JSON\ndocument or a NULL, the output is NULL (i.e. no error). If the input cannot be\ntranslated to a valid JSON value, the output string contains the error message.",
    "syntax": "CHECK_JSON( <string_or_variant_expr> )",
    "example": "CREATE TABLE sample_json_table (ID INTEGER, varchar1 VARCHAR, variant1 VARIANT);\nINSERT INTO sample_json_table (ID, varchar1) VALUES \n    (1, '{\"ValidKey1\": \"ValidValue1\"}'),\n    (2, '{\"Malformed -- Missing value\": }'),\n    (3, NULL)\n    ;\nUPDATE sample_json_table SET variant1 = varchar1::VARIANT;\n\nSELECT ID, CHECK_JSON(varchar1), varchar1 FROM sample_json_table ORDER BY ID;\n+----+----------------------+----------------------------------+\n| ID | CHECK_JSON(VARCHAR1) | VARCHAR1                         |\n|----+----------------------+----------------------------------|\n|  1 | NULL                 | {\"ValidKey1\": \"ValidValue1\"}     |\n|  2 | misplaced }, pos 32  | {\"Malformed -- Missing value\": } |\n|  3 | NULL                 | NULL                             |\n+----+----------------------+----------------------------------+\n\nSELECT ID, CHECK_JSON(variant1), variant1 FROM sample_json_table ORDER BY ID;\n+----+----------------------+--------------------------------------+\n| ID | CHECK_JSON(VARIANT1) | VARIANT1                             |\n|----+----------------------+--------------------------------------|\n|  1 | NULL                 | \"{\\\"ValidKey1\\\": \\\"ValidValue1\\\"}\"   |\n|  2 | misplaced }, pos 32  | \"{\\\"Malformed -- Missing value\\\": }\" |\n|  3 | NULL                 | NULL                                 |\n+----+----------------------+--------------------------------------+",
    "arguments": [
        {
            "name": "string_or_variant_expr",
            "description": "A VARIANT or string value (or expression) to check. If the expression is of type VARIANT , it should contain a\nstring."
        }
    ]
},
{
    "function_name": "CHARINDEX",
    "summary": "Searches for the first occurrence of the first argument in the second argument and, if successful, returns the position (1-based) of the first argument in the second argument.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/charindex",
    "title": "CHARINDEX",
    "description": "Searches for the first occurrence of the first argument in the second argument and, if successful, returns the position (1-based) of the first argument in the second argument.",
    "syntax": "CHARINDEX( <expr1>, <expr2> [ , <start_pos> ] )",
    "example": "select charindex('an', 'banana', 1);\n+------------------------------+\n| CHARINDEX('AN', 'BANANA', 1) |\n|------------------------------|\n|                            2 |\n+------------------------------+\n\nselect charindex('an', 'banana', 3);\n+------------------------------+\n| CHARINDEX('AN', 'BANANA', 3) |\n|------------------------------|\n|                            4 |\n+------------------------------+\n\nSELECT n, h, CHARINDEX(n, h) FROM pos;\n\n+--------+---------------------+-----------------+\n| N      | H                   | CHARINDEX(N, H) |\n|--------+---------------------+-----------------|\n|        |                     |               1 |\n|        | sth                 |               1 |\n| 43     | 41424344            |               5 |\n| a      | NULL                |            NULL |\n| dog    | catalog             |               0 |\n| log    | catalog             |               5 |\n| lésine | le péché, la lésine |              14 |\n| nicht  | Ich weiß nicht      |              10 |\n| sth    |                     |               0 |\n| ☃c     | ☃a☃b☃c☃d            |               5 |\n| ☃☃     | bunch of ☃☃☃☃       |              10 |\n| ❄c     | ❄a☃c❄c☃             |               5 |\n| NULL   | a                   |            NULL |\n| NULL   | NULL                |            NULL |\n+--------+---------------------+-----------------+\n\nSELECT CHARINDEX(X'EF', X'ABCDEF');\n+-----------------------------+\n| CHARINDEX(X'EF', X'ABCDEF') |\n|-----------------------------|\n|                           3 |\n+-----------------------------+\n\nSELECT CHARINDEX(X'BC', X'ABCD');\n+---------------------------+\n| CHARINDEX(X'BC', X'ABCD') |\n|---------------------------|\n|                         0 |\n+---------------------------+",
    "arguments": [
        {
            "name": "expr1",
            "description": "A string or binary expression representing the value to look for."
        },
        {
            "name": "expr2",
            "description": "A string or binary expression representing the value to search."
        },
        {
            "name": "start_pos",
            "description": "A number indicating the position from where to start the search (with 1 representing the start of expr2 ). Default: 1"
        }
    ]
},
{
    "function_name": "CEIL",
    "summary": "Returns values from input_expr rounded to the nearest equal or larger integer, or to the nearest equal or larger value with the specified number of places after the decimal point.",
    "category": "Numeric functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/ceil",
    "title": "CEIL",
    "description": "Returns values from",
    "syntax": "CEIL( <input_expr> [, <scale_expr> ] )",
    "example": "SELECT CEIL(135.135), CEIL(-975.975);\n+---------------+----------------+\n| CEIL(135.135) | CEIL(-975.975) |\n|---------------+----------------|\n|           136 |           -975 |\n+---------------+----------------+\n\nCREATE TRANSIENT TABLE test_ceiling (n FLOAT, scale INTEGER);\nINSERT INTO test_ceiling (n, scale) VALUES\n   (-975.975, -1),\n   (-975.975,  0),\n   (-975.975,  2),\n   ( 135.135, -2),\n   ( 135.135,  0),\n   ( 135.135,  1),\n   ( 135.135,  3),\n   ( 135.135, 50),\n   ( 135.135, NULL)\n   ;\n\nSELECT n, scale, ceil(n, scale)\n  FROM test_ceiling\n  ORDER BY n, scale;\n+----------+-------+----------------+\n|        N | SCALE | CEIL(N, SCALE) |\n|----------+-------+----------------|\n| -975.975 |    -1 |       -970     |\n| -975.975 |     0 |       -975     |\n| -975.975 |     2 |       -975.97  |\n|  135.135 |    -2 |        200     |\n|  135.135 |     0 |        136     |\n|  135.135 |     1 |        135.2   |\n|  135.135 |     3 |        135.135 |\n|  135.135 |    50 |        135.135 |\n|  135.135 |  NULL |           NULL |\n+----------+-------+----------------+",
    "arguments": [
        {
            "name": "input_expr",
            "description": "The value or expression to operate on. The data type should be one of the numeric data types, such as FLOAT or NUMBER."
        },
        {
            "name": "scale_expr",
            "description": "The number of digits the output should include after the decimal point. The expression should evaluate to an\ninteger from -38 to +38. The default scale_expr is zero, meaning that the function removes all digits after the decimal point. For information about negative scales, see the Usage Notes below."
        }
    ],
    "returns": "The return type is based on the input type:"
},
{
    "function_name": "CBRT",
    "summary": "Returns the cubic root of a numeric expression.",
    "category": "Numeric functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/cbrt",
    "title": "CBRT",
    "description": "Returns the cubic root of a numeric expression.",
    "syntax": "CBRT(expr)",
    "example": "SELECT x, cbrt(x) FROM tab;\n\n--------+-------------+\n   x    |   cbrt(x)   |\n--------+-------------+\n 0      | 0           |\n 2      | 1.25992105  |\n -10    | -2.15443469 |\n [NULL] | [NULL]      |\n--------+-------------+"
},
{
    "function_name": "CAST , ::",
    "summary": "Converts a value of one data type into another data type.",
    "category": "Conversion functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/cast",
    "title": "CAST ,",
    "description": "Converts a value of one data type into another data type. The semantics of CAST\nare the same as the semantics of the corresponding TO_",
    "syntax": "CAST( <source_expr> AS <target_data_type> )\n  [ RENAME FIELDS | ADD FIELDS ]\n\n<source_expr> :: <target_data_type>",
    "example": "CREATE OR REPLACE TABLE test_data_type_conversion (\n  varchar_value VARCHAR,\n  number_value NUMBER(5, 4),\n  timestamp_value TIMESTAMP);\n\nINSERT INTO test_data_type_conversion VALUES (\n  '9.8765',\n  1.2345,\n  '2024-05-09 14:32:29.135 -0700');\n\nSELECT * FROM test_data_type_conversion;\n\n+---------------+--------------+-------------------------+\n| VARCHAR_VALUE | NUMBER_VALUE | TIMESTAMP_VALUE         |\n|---------------+--------------+-------------------------|\n| 9.8765        |       1.2345 | 2024-05-09 14:32:29.135 |\n+---------------+--------------+-------------------------+\n\nSELECT CAST(varchar_value AS NUMBER(5,2)) AS varchar_to_number1,\n       SYSTEM$TYPEOF(varchar_to_number1) AS data_type\n  FROM test_data_type_conversion;\n\n+--------------------+------------------+\n| VARCHAR_TO_NUMBER1 | DATA_TYPE        |\n|--------------------+------------------|\n|               9.88 | NUMBER(5,2)[SB4] |\n+--------------------+------------------+\n\nSELECT varchar_value::NUMBER(6,5) AS varchar_to_number2,\n       SYSTEM$TYPEOF(varchar_to_number2) AS data_type\n  FROM test_data_type_conversion;\n\n+--------------------+------------------+\n| VARCHAR_TO_NUMBER2 | DATA_TYPE        |\n|--------------------+------------------|\n|            9.87650 | NUMBER(6,5)[SB4] |\n+--------------------+------------------+\n\nSELECT CAST(number_value AS INTEGER) AS number_to_integer,\n       SYSTEM$TYPEOF(number_to_integer) AS data_type\n  FROM test_data_type_conversion;\n\n+-------------------+-------------------+\n| NUMBER_TO_INTEGER | DATA_TYPE         |\n|-------------------+-------------------|\n|                 1 | NUMBER(38,0)[SB1] |\n+-------------------+-------------------+\n\nSELECT CAST(number_value AS VARCHAR) AS number_to_varchar,\n       SYSTEM$TYPEOF(number_to_varchar) AS data_type\n  FROM test_data_type_conversion;\n\n+-------------------+--------------+\n| NUMBER_TO_VARCHAR | DATA_TYPE    |\n|-------------------+--------------|\n| 1.2345            | VARCHAR[LOB] |\n+-------------------+--------------+\n\nSELECT CAST(timestamp_value AS DATE) AS timestamp_to_date,\n       SYSTEM$TYPEOF(timestamp_to_date) AS data_type\n  FROM test_data_type_conversion;\n\n+-------------------+-----------+\n| TIMESTAMP_TO_DATE | DATA_TYPE |\n|-------------------+-----------|\n| 2024-05-09        | DATE[SB4] |\n+-------------------+-----------+",
    "arguments": [
        {
            "name": "source_expr",
            "description": "Expression of any supported data type to be converted into a\ndifferent data type."
        },
        {
            "name": "target_data_type",
            "description": "The data type to which to convert the expression. If the data\ntype supports additional properties, such as precision and scale (for numbers/decimals), the properties can be included."
        },
        {
            "name": "RENAME",
            "description": "For structured OBJECTs , specifies that you want to change the OBJECT to use\ndifferent key-value pairs. The values in the original object are copied to the new key-value pairs in the order in which\nthey appear. For an example, see Example: Changing the key names in an OBJECT value ."
        },
        {
            "name": "ADD",
            "description": "For structured OBJECTs , specifies that you want to add key-value pairs to the\nOBJECT. For an example, see Example: Adding keys to an OBJECT value . The values for the newly added keys will be set to NULL. If you want to assign a value to these keys, call the OBJECT_INSERT function instead."
        }
    ]
},
{
    "function_name": "CASE",
    "summary": "Works like a cascading “if-then-else” statement.",
    "category": "Conditional expression functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/case",
    "title": "CASE",
    "description": "Works like a cascading “if-then-else” statement. In the more general form,\na series of conditions are evaluated in sequence. When a condition evaluates\nto TRUE, the evaluation stops and the associated result (after THEN) is\nreturned. If none of the conditions evaluate to TRUE, then the result after\nthe optional ELSE is returned, if present; otherwise NULL is returned.",
    "syntax": "CASE\n    WHEN <condition1> THEN <result1>\n  [ WHEN <condition2> THEN <result2> ]\n  [ ... ]\n  [ ELSE <result3> ]\nEND\n\nCASE <expr>\n    WHEN <value1> THEN <result1>\n  [ WHEN <value2> THEN <result2> ]\n  [ ... ]\n  [ ELSE <result3> ]\nEND",
    "example": "SELECT\n    column1,\n    CASE\n        WHEN column1=1 THEN 'one'\n        WHEN column1=2 THEN 'two'\n        ELSE 'other'\n    END AS result\nFROM (values(1),(2),(3)) v;\n\n+---------+--------+\n| COLUMN1 | RESULT |\n|---------+--------|\n|       1 | one    |\n|       2 | two    |\n|       3 | other  |\n+---------+--------+\n\nSELECT\n    column1,\n    CASE\n        WHEN column1=1 THEN 'one'\n        WHEN column1=2 THEN 'two'\n    END AS result\nFROM (values(1),(2),(3)) v;\n\n+---------+--------+\n| COLUMN1 | RESULT |\n|---------+--------|\n|       1 | one    |\n|       2 | two    |\n|       3 | NULL   |\n+---------+--------+\n\nSELECT\n    column1,\n    CASE \n        WHEN column1 = 1 THEN 'one'\n        WHEN column1 = 2 THEN 'two'\n        WHEN column1 IS NULL THEN 'NULL'\n        ELSE 'other'\n    END AS result\nFROM VALUES (1), (2), (NULL);\n\n+---------+--------+\n| COLUMN1 | RESULT |\n|---------+--------|\n|       1 | one    |\n|       2 | two    |\n|    NULL | NULL   |\n+---------+--------+\n\nSELECT CASE COLLATE('m', 'upper')\n    WHEN 'M' THEN TRUE\n    ELSE FALSE\nEND;\n\n+----------------------------+\n| CASE COLLATE('M', 'UPPER') |\n|     WHEN 'M' THEN TRUE     |\n|     ELSE FALSE             |\n| END                        |\n|----------------------------|\n| True                       |\n+----------------------------+\n\nSELECT CASE 'm'\n    WHEN COLLATE('M', 'lower') THEN TRUE\n    ELSE FALSE\nEND;\n\n+------------------------------------------+\n| CASE 'M'                                 |\n|     WHEN COLLATE('M', 'LOWER') THEN TRUE |\n|     ELSE FALSE                           |\n| END                                      |\n|------------------------------------------|\n| True                                     |\n+------------------------------------------+",
    "arguments": [
        {
            "name": "condition#",
            "description": "In the first form of CASE , each condition is an expression that\nshould evaluate to a BOOLEAN value (True, False, or NULL)."
        },
        {
            "name": "expr",
            "description": "A general expression."
        },
        {
            "name": "value",
            "description": "In the second form of CASE , each value is a potential match\nfor expr . The value can be a literal or an expression.\nThe value must be the same data type as the expr , or\nmust be a data type that can be cast to the data type of the expr ."
        },
        {
            "name": "result#",
            "description": "In the first form of the CASE clause, if condition# is true,\nthen the function returns the corresponding result# . If more than\none condition is true, then the result associated with the first true\ncondition is returned. In the second form of the CASE statement, if value# matches the expr , then the corresponding result is returned. If more\nthan one value matches the expr , then the first matching\nvalue’s result is returned. The result should be an expression that evaluates to a single value. In both forms of CASE , if the optional ELSE clause is present, and\nif no matches are found, then the function returns the result in the ELSE clause. If no ELSE clause is present, and no matches are found,\nthen the result is NULL."
        }
    ]
},
{
    "function_name": "BUILD_STAGE_FILE_URL",
    "summary": "Generates a Snowflake file URL to a staged file using the stage name and relative file path as inputs.",
    "category": "File functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/build_stage_file_url",
    "title": "BUILD_STAGE_FILE_URL",
    "description": "Generates a Snowflake",
    "syntax": "BUILD_STAGE_FILE_URL( @<stage_name> , '<relative_file_path>' )",
    "example": "SELECT BUILD_STAGE_FILE_URL(@images_stage,'/us/yosemite/half_dome.jpg');\n\nhttps://my_account.snowflakecomputing.com/api/files/MY_DB/PUBLIC/IMAGES_STAGE/us/yosemite/half_dome.jpg",
    "arguments": [
        {
            "name": "stage_name",
            "description": "Name of the internal or external stage where the file is stored. Note If the stage name includes spaces or special characters, it must be enclosed in single quotes (e.g. '@\"my stage\"' for a stage\nnamed \"my stage\" )."
        },
        {
            "name": "relative_file_path",
            "description": "Path and filename of the file relative to its location in the stage."
        }
    ],
    "returns": "The function returns a file URL in the following format:"
},
{
    "function_name": "BUILD_SCOPED_FILE_URL",
    "summary": "Generates a scoped Snowflake file URL to a staged file using the stage name and relative file path as inputs.",
    "category": "File functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/build_scoped_file_url",
    "title": "BUILD_SCOPED_FILE_URL",
    "description": "Generates a scoped Snowflake file URL to a staged file using the stage name and relative file path as inputs.",
    "syntax": "BUILD_SCOPED_FILE_URL(\n  @<stage_name> ,\n  '<relative_file_path>' ,\n  <use_privatelink_host_for_business_critical>)",
    "example": "SELECT BUILD_SCOPED_FILE_URL(@images_stage,'/us/yosemite/half_dome.jpg', TRUE);\n\nhttps://my_account.snowflakecomputing.com/api/files/019260c2-00c0-f2f2-0000-4383001cf046/bXlfZGF0YWJhc2UvbXlfc2NoZW1hL215X3N0YWdlL2ZvbGRlcjEvZm9sZGVyMi9maWxlMQ\n\n-- Create a table that stores the relative file path for each staged file along with any other related data.\nCREATE TABLE acct_table (\n  acct_name string,\n  relative_file_path string\n);\n\n-- Create a secure view on the table you created.\n-- A role that has the SELECT privilege on the secure view has scoped access to the filtered set of files that include the acct1 text string.\nCREATE SECURE VIEW acct1_files\nAS\n  SELECT BUILD_SCOPED_FILE_URL(@acct_files, relative_file_path, FALSE) scoped_url\n  FROM acct_table\n  WHERE acct_name = 'acct1';",
    "arguments": [
        {
            "name": "stage_name",
            "description": "Name of the internal or external stage where the file is stored. Note If the stage name includes spaces or special characters, it must be enclosed in single quotes (for example, '@\"my stage\"' for a stage named \"my stage\" )."
        },
        {
            "name": "relative_file_path",
            "description": "Path and filename of the file, relative to its location on the stage."
        },
        {
            "name": "use_privatelink_host_for_business_critical",
            "description": "Specifies whether to prepend privatelink to the URL for Business Critical accounts. TRUE prepends privatelink to the URL just\nbefore the hostname; for example, privatelink.snowflakecomputing.com . Note Snowflake prepends privatelink to the URL regardless of whether you’ve enabled private connectivity. FALSE overrides the default behavior and does not add privatelink to the URL. Default: TRUE"
        }
    ],
    "returns": "The function returns a scoped URL in the following format:"
},
{
    "function_name": "BOOLXOR_AGG",
    "summary": "Returns TRUE if exactly one Boolean record in the group evaluates to TRUE.",
    "category": "Aggregate functions , Window functions , Conditional expression functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/boolxor_agg",
    "title": "BOOLXOR_AGG",
    "description": "Returns TRUE if exactly one Boolean record in the group evaluates to TRUE.",
    "syntax": "BOOLXOR_AGG( <expr> )",
    "example": "create or replace table test_boolean_agg(\n    id integer,\n    c1 boolean, \n    c2 boolean,\n    c3 boolean,\n    c4 boolean\n    );\n\ninsert into test_boolean_agg (id, c1, c2, c3, c4) values \n    (1, true, true,  true,  false),\n    (2, true, false, false, false),\n    (3, true, true,  false, false),\n    (4, true, false, false, false);\n\nselect * from test_boolean_agg;\n+----+------+-------+-------+-------+\n| ID | C1   | C2    | C3    | C4    |\n|----+------+-------+-------+-------|\n|  1 | True | True  | True  | False |\n|  2 | True | False | False | False |\n|  3 | True | True  | False | False |\n|  4 | True | False | False | False |\n+----+------+-------+-------+-------+\n\nselect boolxor_agg(c1), boolxor_agg(c2), boolxor_agg(c3), boolxor_agg(c4)\n    from test_boolean_agg;\n+-----------------+-----------------+-----------------+-----------------+\n| BOOLXOR_AGG(C1) | BOOLXOR_AGG(C2) | BOOLXOR_AGG(C3) | BOOLXOR_AGG(C4) |\n|-----------------+-----------------+-----------------+-----------------|\n| False           | False           | True            | False           |\n+-----------------+-----------------+-----------------+-----------------+\n\ninsert into test_boolean_agg (id, c1, c2, c3, c4) values\n    (-4, false, false, false, true),\n    (-3, false, true,  true,  true),\n    (-2, false, false, true,  true),\n    (-1, false, true,  true,  true);\n\nselect * \n    from test_boolean_agg\n    order by id;\n+----+-------+-------+-------+-------+\n| ID | C1    | C2    | C3    | C4    |\n|----+-------+-------+-------+-------|\n| -4 | False | False | False | True  |\n| -3 | False | True  | True  | True  |\n| -2 | False | False | True  | True  |\n| -1 | False | True  | True  | True  |\n|  1 | True  | True  | True  | False |\n|  2 | True  | False | False | False |\n|  3 | True  | True  | False | False |\n|  4 | True  | False | False | False |\n+----+-------+-------+-------+-------+\n\nselect \n      id, \n      boolxor_agg(c1) OVER (PARTITION BY (id > 0)),\n      boolxor_agg(c2) OVER (PARTITION BY (id > 0)),\n      boolxor_agg(c3) OVER (PARTITION BY (id > 0)),\n      boolxor_agg(c4) OVER (PARTITION BY (id > 0))\n    from test_boolean_agg\n    order by id;\n+----+----------------------------------------------+----------------------------------------------+----------------------------------------------+----------------------------------------------+\n| ID | BOOLXOR_AGG(C1) OVER (PARTITION BY (ID > 0)) | BOOLXOR_AGG(C2) OVER (PARTITION BY (ID > 0)) | BOOLXOR_AGG(C3) OVER (PARTITION BY (ID > 0)) | BOOLXOR_AGG(C4) OVER (PARTITION BY (ID > 0)) |\n|----+----------------------------------------------+----------------------------------------------+----------------------------------------------+----------------------------------------------|\n| -4 | False                                        | False                                        | False                                        | False                                        |\n| -3 | False                                        | False                                        | False                                        | False                                        |\n| -2 | False                                        | False                                        | False                                        | False                                        |\n| -1 | False                                        | False                                        | False                                        | False                                        |\n|  1 | False                                        | False                                        | True                                         | False                                        |\n|  2 | False                                        | False                                        | True                                         | False                                        |\n|  3 | False                                        | False                                        | True                                         | False                                        |\n|  4 | False                                        | False                                        | True                                         | False                                        |\n+----+----------------------------------------------+----------------------------------------------+----------------------------------------------+----------------------------------------------+\n\nselect boolxor_agg('invalid type');\n\n100037 (22018): Boolean value 'invalid_type' is not recognized",
    "arguments": [
        {
            "name": "expr",
            "description": "The input expression must be an expression that can be evaluated to a boolean or converted to a boolean."
        },
        {
            "name": "partition_expr",
            "description": "This column or expression specifies how to separate the input into partitions (sub-windows)."
        }
    ],
    "returns": "The data type of the returned value is BOOLEAN."
},
{
    "function_name": "BOOLXOR",
    "summary": "Computes the Boolean XOR of two numeric expressions (i.e. one of the expressions, but not both expressions, is TRUE).",
    "category": "Conditional expression functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/boolxor",
    "title": "BOOLXOR",
    "description": "Computes the Boolean XOR of two numeric expressions (i.e. one of the expressions, but not both expressions, is TRUE). In accordance with Boolean semantics:",
    "syntax": "BOOLXOR( expr1 , expr2 )",
    "example": "SELECT BOOLXOR(2, 0), BOOLXOR(1, -1), BOOLXOR(0, 0), BOOLXOR(NULL, 3), BOOLXOR(NULL, 0), BOOLXOR(NULL, NULL);\n\n+---------------+----------------+---------------+------------------+------------------+---------------------+\n| BOOLXOR(2, 0) | BOOLXOR(1, -1) | BOOLXOR(0, 0) | BOOLXOR(NULL, 3) | BOOLXOR(NULL, 0) | BOOLXOR(NULL, NULL) |\n|---------------+----------------+---------------+------------------+------------------+---------------------|\n| True          | False          | False         | NULL             | NULL             | NULL                |\n+---------------+----------------+---------------+------------------+------------------+---------------------+"
},
{
    "function_name": "BOOLOR_AGG",
    "summary": "Returns TRUE if at least one Boolean record in a group evaluates to TRUE.",
    "category": "Aggregate functions , Window functions , Conditional expression functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/boolor_agg",
    "title": "BOOLOR_AGG",
    "description": "Returns TRUE if at least one Boolean record in a group evaluates to TRUE.",
    "syntax": "BOOLOR_AGG( <expr> )",
    "example": "create or replace table test_boolean_agg(\n    id integer,\n    c1 boolean, \n    c2 boolean,\n    c3 boolean,\n    c4 boolean\n    );\n\ninsert into test_boolean_agg (id, c1, c2, c3, c4) values \n    (1, true, true,  true,  false),\n    (2, true, false, false, false),\n    (3, true, true,  false, false),\n    (4, true, false, false, false);\n\nselect * from test_boolean_agg;\n+----+------+-------+-------+-------+\n| ID | C1   | C2    | C3    | C4    |\n|----+------+-------+-------+-------|\n|  1 | True | True  | True  | False |\n|  2 | True | False | False | False |\n|  3 | True | True  | False | False |\n|  4 | True | False | False | False |\n+----+------+-------+-------+-------+\n\nselect boolor_agg(c1), boolor_agg(c2), boolor_agg(c3), boolor_agg(c4)\n    from test_boolean_agg;\n+----------------+----------------+----------------+----------------+\n| BOOLOR_AGG(C1) | BOOLOR_AGG(C2) | BOOLOR_AGG(C3) | BOOLOR_AGG(C4) |\n|----------------+----------------+----------------+----------------|\n| True           | True           | True           | False          |\n+----------------+----------------+----------------+----------------+\n\ninsert into test_boolean_agg (id, c1, c2, c3, c4) values\n    (-4, false, false, false, true),\n    (-3, false, true,  true,  true),\n    (-2, false, false, true,  true),\n    (-1, false, true,  true,  true);\n\nselect * \n    from test_boolean_agg\n    order by id;\n+----+-------+-------+-------+-------+\n| ID | C1    | C2    | C3    | C4    |\n|----+-------+-------+-------+-------|\n| -4 | False | False | False | True  |\n| -3 | False | True  | True  | True  |\n| -2 | False | False | True  | True  |\n| -1 | False | True  | True  | True  |\n|  1 | True  | True  | True  | False |\n|  2 | True  | False | False | False |\n|  3 | True  | True  | False | False |\n|  4 | True  | False | False | False |\n+----+-------+-------+-------+-------+\n\nselect \n      id,\n      boolor_agg(c1) OVER (PARTITION BY (id > 0)),\n      boolor_agg(c2) OVER (PARTITION BY (id > 0)),\n      boolor_agg(c3) OVER (PARTITION BY (id > 0)),\n      boolor_agg(c4) OVER (PARTITION BY (id > 0))\n    from test_boolean_agg\n    order by id;\n+----+---------------------------------------------+---------------------------------------------+---------------------------------------------+---------------------------------------------+\n| ID | BOOLOR_AGG(C1) OVER (PARTITION BY (ID > 0)) | BOOLOR_AGG(C2) OVER (PARTITION BY (ID > 0)) | BOOLOR_AGG(C3) OVER (PARTITION BY (ID > 0)) | BOOLOR_AGG(C4) OVER (PARTITION BY (ID > 0)) |\n|----+---------------------------------------------+---------------------------------------------+---------------------------------------------+---------------------------------------------|\n| -4 | False                                       | True                                        | True                                        | True                                        |\n| -3 | False                                       | True                                        | True                                        | True                                        |\n| -2 | False                                       | True                                        | True                                        | True                                        |\n| -1 | False                                       | True                                        | True                                        | True                                        |\n|  1 | True                                        | True                                        | True                                        | False                                       |\n|  2 | True                                        | True                                        | True                                        | False                                       |\n|  3 | True                                        | True                                        | True                                        | False                                       |\n|  4 | True                                        | True                                        | True                                        | False                                       |\n+----+---------------------------------------------+---------------------------------------------+---------------------------------------------+---------------------------------------------+\n\nselect boolor_agg('invalid type');\n\n100037 (22018): Boolean value 'invalid_type' is not recognized",
    "arguments": [
        {
            "name": "expr",
            "description": "The input expression must be an expression that can be evaluated to a boolean or converted to a boolean."
        },
        {
            "name": "partition_expr",
            "description": "This column or expression specifies how to separate the input into partitions (sub-windows)."
        }
    ],
    "returns": "The data type of the returned value is BOOLEAN."
},
{
    "function_name": "BOOLOR",
    "summary": "Computes the Boolean OR of two numeric expressions.",
    "category": "Conditional expression functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/boolor",
    "title": "BOOLOR",
    "description": "Computes the Boolean OR of two numeric expressions. In accordance with Boolean semantics:",
    "syntax": "BOOLOR( expr1 , expr2 )",
    "example": "SELECT BOOLOR(1, 2), BOOLOR(-1.35, 0), BOOLOR(3, NULL), BOOLOR(0, 0), BOOLOR(NULL, 0), BOOLOR(NULL, NULL);\n\n+--------------+------------------+-----------------+--------------+-----------------+--------------------+\n| BOOLOR(1, 2) | BOOLOR(-1.35, 0) | BOOLOR(3, NULL) | BOOLOR(0, 0) | BOOLOR(NULL, 0) | BOOLOR(NULL, NULL) |\n|--------------+------------------+-----------------+--------------+-----------------+--------------------|\n| True         | True             | True            | False        | NULL            | NULL               |\n+--------------+------------------+-----------------+--------------+-----------------+--------------------+"
},
{
    "function_name": "BOOLNOT",
    "summary": "Computes the Boolean NOT of a single numeric expression.",
    "category": "Conditional expression functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/boolnot",
    "title": "BOOLNOT",
    "description": "Computes the Boolean NOT of a single numeric expression. In accordance with Boolean semantics:",
    "syntax": "BOOLNOT( expr )",
    "example": "SELECT BOOLNOT(0), BOOLNOT(10), BOOLNOT(-3.79), BOOLNOT(NULL);\n\n+------------+-------------+----------------+---------------+\n| BOOLNOT(0) | BOOLNOT(10) | BOOLNOT(-3.79) | BOOLNOT(NULL) |\n|------------+-------------+----------------+---------------|\n| True       | False       | False          | NULL          |\n+------------+-------------+----------------+---------------+"
},
{
    "function_name": "BOOLAND_AGG",
    "summary": "Returns TRUE if all non-NULL Boolean records in a group evaluate to TRUE.",
    "category": "Aggregate functions , Window functions , Conditional expression functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/booland_agg",
    "title": "BOOLAND_AGG",
    "description": "Returns TRUE if all non-NULL Boolean records in a group evaluate to TRUE.",
    "syntax": "BOOLAND_AGG( <expr> )",
    "example": "create or replace table test_boolean_agg(\n    id integer,\n    c1 boolean, \n    c2 boolean,\n    c3 boolean,\n    c4 boolean\n    );\n\ninsert into test_boolean_agg (id, c1, c2, c3, c4) values \n    (1, true, true,  true,  false),\n    (2, true, false, false, false),\n    (3, true, true,  false, false),\n    (4, true, false, false, false);\n\nselect * from test_boolean_agg;\n+----+------+-------+-------+-------+\n| ID | C1   | C2    | C3    | C4    |\n|----+------+-------+-------+-------|\n|  1 | True | True  | True  | False |\n|  2 | True | False | False | False |\n|  3 | True | True  | False | False |\n|  4 | True | False | False | False |\n+----+------+-------+-------+-------+\n\nselect booland_agg(c1), booland_agg(c2), booland_agg(c3), booland_agg(c4)\n    from test_boolean_agg;\n+-----------------+-----------------+-----------------+-----------------+\n| BOOLAND_AGG(C1) | BOOLAND_AGG(C2) | BOOLAND_AGG(C3) | BOOLAND_AGG(C4) |\n|-----------------+-----------------+-----------------+-----------------|\n| True            | False           | False           | False           |\n+-----------------+-----------------+-----------------+-----------------+\n\ninsert into test_boolean_agg (id, c1, c2, c3, c4) values\n    (-4, false, false, false, true),\n    (-3, false, true,  true,  true),\n    (-2, false, false, true,  true),\n    (-1, false, true,  true,  true);\n\nselect * \n    from test_boolean_agg\n    order by id;\n+----+-------+-------+-------+-------+\n| ID | C1    | C2    | C3    | C4    |\n|----+-------+-------+-------+-------|\n| -4 | False | False | False | True  |\n| -3 | False | True  | True  | True  |\n| -2 | False | False | True  | True  |\n| -1 | False | True  | True  | True  |\n|  1 | True  | True  | True  | False |\n|  2 | True  | False | False | False |\n|  3 | True  | True  | False | False |\n|  4 | True  | False | False | False |\n+----+-------+-------+-------+-------+\n\nselect \n      id,\n      booland_agg(c1) OVER (PARTITION BY (id > 0)),\n      booland_agg(c2) OVER (PARTITION BY (id > 0)),\n      booland_agg(c3) OVER (PARTITION BY (id > 0)),\n      booland_agg(c4) OVER (PARTITION BY (id > 0))\n    from test_boolean_agg\n    order by id;\n+----+----------------------------------------------+----------------------------------------------+----------------------------------------------+----------------------------------------------+\n| ID | BOOLAND_AGG(C1) OVER (PARTITION BY (ID > 0)) | BOOLAND_AGG(C2) OVER (PARTITION BY (ID > 0)) | BOOLAND_AGG(C3) OVER (PARTITION BY (ID > 0)) | BOOLAND_AGG(C4) OVER (PARTITION BY (ID > 0)) |\n|----+----------------------------------------------+----------------------------------------------+----------------------------------------------+----------------------------------------------|\n| -4 | False                                        | False                                        | False                                        | True                                         |\n| -3 | False                                        | False                                        | False                                        | True                                         |\n| -2 | False                                        | False                                        | False                                        | True                                         |\n| -1 | False                                        | False                                        | False                                        | True                                         |\n|  1 | True                                         | False                                        | False                                        | False                                        |\n|  2 | True                                         | False                                        | False                                        | False                                        |\n|  3 | True                                         | False                                        | False                                        | False                                        |\n|  4 | True                                         | False                                        | False                                        | False                                        |\n+----+----------------------------------------------+----------------------------------------------+----------------------------------------------+----------------------------------------------+\n\nselect booland_agg('invalid type');\n\n100037 (22018): Boolean value 'invalid_type' is not recognized",
    "arguments": [
        {
            "name": "expr",
            "description": "The input expression must be an expression that can be evaluated to a boolean or converted to a boolean."
        },
        {
            "name": "partition_expr",
            "description": "This column or expression specifies how to separate the input into partitions (sub-windows)."
        }
    ],
    "returns": "The data type of the returned value is BOOLEAN."
},
{
    "function_name": "BOOLAND",
    "summary": "Computes the Boolean AND of two numeric expressions.",
    "category": "Conditional expression functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/booland",
    "title": "BOOLAND",
    "description": "Computes the Boolean AND of two numeric expressions. In accordance with Boolean semantics:",
    "syntax": "BOOLAND( expr1 , expr2 )",
    "example": "SELECT BOOLAND(1, -2), BOOLAND(0, 2.35), BOOLAND(0, 0), BOOLAND(0, NULL), BOOLAND(NULL, 3), BOOLAND(NULL, NULL);\n\n+----------------+------------------+---------------+------------------+------------------+---------------------+\n| BOOLAND(1, -2) | BOOLAND(0, 2.35) | BOOLAND(0, 0) | BOOLAND(0, NULL) | BOOLAND(NULL, 3) | BOOLAND(NULL, NULL) |\n|----------------+------------------+---------------+------------------+------------------+---------------------|\n| True           | False            | False         | False            | NULL             | NULL                |\n+----------------+------------------+---------------+------------------+------------------+---------------------+"
},
{
    "function_name": "BITXOR_AGG",
    "summary": "Returns the bitwise XOR value of all non-NULL numeric records in a group.",
    "category": "Aggregate functions , Window functions , Bitwise expression functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/bitxor_agg",
    "title": "BITXOR_AGG",
    "description": "Returns the bitwise XOR value of all non-NULL numeric records in a group.",
    "syntax": "BITXOR_AGG( [ DISTINCT ] <expr1> )",
    "example": "CREATE OR REPLACE TABLE bitwise_example\n  (k INT, d DECIMAL(10,5), s1 VARCHAR(10), s2 VARCHAR(10));\n\nINSERT INTO bitwise_example VALUES\n  (15, 1.1, '12','one'),\n  (26, 2.9, '10','two'),\n  (12, 7.1, '7.9','two'),\n  (14, NULL, NULL,'null'),\n  (8, NULL, NULL, 'null'),\n  (NULL, 9.1, '14','nine');\n\nSELECT k AS k_col, d AS d_col, s1, s2\n  FROM bitwise_example\n  ORDER BY k_col;\n\n+-------+---------+------+------+\n| K_COL |   D_COL | S1   | S2   |\n|-------+---------+------+------|\n|     8 |    NULL | NULL | null |\n|    12 | 7.10000 | 7.9  | two  |\n|    14 |    NULL | NULL | null |\n|    15 | 1.10000 | 12   | one  |\n|    26 | 2.90000 | 10   | two  |\n|  NULL | 9.10000 | 14   | nine |\n+-------+---------+------+------+\n\nSELECT BITXOR_AGG(k), \n       BITXOR_AGG(d), \n       BITXOR_AGG(s1) \n  FROM bitwise_example;\n\n+---------------+---------------+----------------+\n| BITXOR_AGG(K) | BITXOR_AGG(D) | BITXOR_AGG(S1) |\n|---------------+---------------+----------------|\n|            31 |            12 |              0 |\n+---------------+---------------+----------------+\n\nSELECT s2, \n       BITXOR_AGG(k), \n       BITXOR_AGG(d) \n  FROM bitwise_example \n  GROUP BY s2\n  ORDER BY 3;\n\n+------+---------------+---------------+\n| S2   | BITXOR_AGG(K) | BITXOR_AGG(D) |\n|------+---------------+---------------|\n| one  |            15 |             1 |\n| two  |            22 |             4 |\n| nine |          NULL |             9 |\n| null |             6 |          NULL |\n+------+---------------+---------------+\n\nSELECT BITXOR_AGG(s2) FROM bitwise_example;\n\n100038 (22018): Numeric value 'one' is not recognized",
    "arguments": [
        {
            "name": "expr1",
            "description": "This expression must evaluate to a numeric value or a value\nof a data type that can be cast to a numeric value."
        },
        {
            "name": "expr2",
            "description": "This expression is used to group the rows in partitions."
        }
    ],
    "returns": "The data type of the returned value is NUMBER(38, 0)."
},
{
    "function_name": "BITXOR",
    "summary": "Returns the bitwise XOR of two numeric or binary expressions.",
    "category": "Bitwise expression functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/bitxor",
    "title": "BITXOR",
    "description": "Returns the bitwise XOR of two numeric or binary expressions.",
    "syntax": "BITXOR( <expr1> , <expr2> [ , '<padside>' ] )",
    "example": "CREATE OR REPLACE TABLE bits (ID INTEGER, bit1 INTEGER, bit2 INTEGER);\n\nINSERT INTO bits (ID, bit1, bit2) VALUES \n  (   11,    1,     1),    -- Bits are all the same.\n  (   24,    2,     4),    -- Bits are all different.\n  (   42,    4,     2),    -- Bits are all different.\n  ( 1624,   16,    24),    -- Bits overlap.\n  (65504,    0, 65504),    -- Lots of bits (all but the low 6 bits).\n  (    0, NULL,  NULL)     -- No bits.\n  ;\n\nSELECT bit1, \n       bit2, \n       BITAND(bit1, bit2), \n       BITOR(bit1, bit2), \n       BITXOR(bit1, BIT2)\n  FROM bits\n  ORDER BY bit1;\n\n+------+-------+--------------------+-------------------+--------------------+\n| BIT1 |  BIT2 | BITAND(BIT1, BIT2) | BITOR(BIT1, BIT2) | BITXOR(BIT1, BIT2) |\n|------+-------+--------------------+-------------------+--------------------|\n|    0 | 65504 |                  0 |             65504 |              65504 |\n|    1 |     1 |                  1 |                 1 |                  0 |\n|    2 |     4 |                  0 |                 6 |                  6 |\n|    4 |     2 |                  0 |                 6 |                  6 |\n|   16 |    24 |                 16 |                24 |                  8 |\n| NULL |  NULL |               NULL |              NULL |               NULL |\n+------+-------+--------------------+-------------------+--------------------+\n\nCREATE OR REPLACE TABLE bits (ID INTEGER, bit1 BINARY(2), bit2 BINARY(2), bit3 BINARY(4));\n\nINSERT INTO bits VALUES\n  (1, x'1010', x'0101', x'11001010'),\n  (2, x'1100', x'0011', x'01011010'),\n  (3, x'BCBC', x'EEFF', x'ABCDABCD'),\n  (4, NULL, NULL, NULL);\n\nSELECT bit1,\n       bit2,\n       BITAND(bit1, bit2),\n       BITOR(bit1, bit2),\n       BITXOR(bit1, bit2)\n  FROM bits;\n\n+------+------+--------------------+-------------------+--------------------+\n| BIT1 | BIT2 | BITAND(BIT1, BIT2) | BITOR(BIT1, BIT2) | BITXOR(BIT1, BIT2) |\n|------+------+--------------------+-------------------+--------------------|\n| 1010 | 0101 | 0000               | 1111              | 1111               |\n| 1100 | 0011 | 0000               | 1111              | 1111               |\n| BCBC | EEFF | ACBC               | FEFF              | 5243               |\n| NULL | NULL | NULL               | NULL              | NULL               |\n+------+------+--------------------+-------------------+--------------------+\n\nSELECT bit1,\n       bit3,\n       BITAND(bit1, bit3),\n       BITOR(bit1, bit3),\n       BITXOR(bit1, bit3)\n  FROM bits;\n\n100544 (22026): The lengths of two variable-sized fields do not match: first length 2, second length 4\n\nSELECT bit1,\n       bit3,\n       BITAND(bit1, bit3, 'LEFT'),\n       BITOR(bit1, bit3, 'LEFT'),\n       BITXOR(bit1, bit3, 'LEFT')\n  FROM bits;\n\n+------+----------+----------------------------+---------------------------+----------------------------+\n| BIT1 | BIT3     | BITAND(BIT1, BIT3, 'LEFT') | BITOR(BIT1, BIT3, 'LEFT') | BITXOR(BIT1, BIT3, 'LEFT') |\n|------+----------+----------------------------+---------------------------+----------------------------|\n| 1010 | 11001010 | 00001010                   | 11001010                  | 11000000                   |\n| 1100 | 01011010 | 00001000                   | 01011110                  | 01010110                   |\n| BCBC | ABCDABCD | 0000A88C                   | ABCDBFFD                  | ABCD1771                   |\n| NULL | NULL     | NULL                       | NULL                      | NULL                       |\n+------+----------+----------------------------+---------------------------+----------------------------+\n\nSELECT bit1,\n       bit3,\n       BITAND(bit1, bit3, 'RIGHT'),\n       BITOR(bit1, bit3, 'RIGHT'),\n       BITXOR(bit1, bit3, 'RIGHT')\n  FROM bits;\n\n+------+----------+-----------------------------+----------------------------+-----------------------------+\n| BIT1 | BIT3     | BITAND(BIT1, BIT3, 'RIGHT') | BITOR(BIT1, BIT3, 'RIGHT') | BITXOR(BIT1, BIT3, 'RIGHT') |\n|------+----------+-----------------------------+----------------------------+-----------------------------|\n| 1010 | 11001010 | 10000000                    | 11101010                   | 01101010                    |\n| 1100 | 01011010 | 01000000                    | 11011010                   | 10011010                    |\n| BCBC | ABCDABCD | A88C0000                    | BFFDABCD                   | 1771ABCD                    |\n| NULL | NULL     | NULL                        | NULL                       | NULL                        |\n+------+----------+-----------------------------+----------------------------+-----------------------------+",
    "arguments": [
        {
            "name": "expr1",
            "description": "This expression must evaluate to an INTEGER value, a BINARY value, or a value of a data type\nthat can be cast to an INTEGER value."
        },
        {
            "name": "expr2",
            "description": "This expression must evaluate to an INTEGER value, a BINARY value, or a value of a data type\nthat can be cast to an INTEGER value."
        },
        {
            "name": "'",
            "description": "When two BINARY argument values are not the same length, specifies which side to pad the value\nwith the shorter length. Specify one of the following case-insensitive values: LEFT - Pad the value on the left. RIGHT - Pad the value on the right. The shorter value is padded with zeros so that it equals the length of the larger value. This argument is valid only when BINARY expressions are specified. If the length of two BINARY values are different, this argument is required."
        }
    ],
    "returns": "Returns an INTEGER value, a BINARY value, or NULL:"
},
{
    "function_name": "BITSHIFTRIGHT",
    "summary": "Shifts the bits for a numeric or binary expression n positions to the right.",
    "category": "Bitwise expression functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/bitshiftright",
    "title": "BITSHIFTRIGHT",
    "description": "Shifts the bits for a numeric or binary expression",
    "syntax": "BITSHIFTRIGHT( <expr1> , <n> )",
    "example": "CREATE OR REPLACE TABLE bits (ID INTEGER, bit1 INTEGER, bit2 INTEGER);\n\nINSERT INTO bits (ID, bit1, bit2) VALUES \n  (   11,    1,     1),    -- Bits are all the same.\n  (   24,    2,     4),    -- Bits are all different.\n  (   42,    4,     2),    -- Bits are all different.\n  ( 1624,   16,    24),    -- Bits overlap.\n  (65504,    0, 65504),    -- Lots of bits (all but the low 6 bits).\n  (    0, NULL,  NULL)     -- No bits.\n  ;\n\nSELECT bit1, \n       bit2, \n       BITSHIFTLEFT(bit1, 1), \n       BITSHIFTRIGHT(bit2, 1)\n  FROM bits\n  ORDER BY bit1;\n\n+------+-------+-----------------------+------------------------+\n| BIT1 |  BIT2 | BITSHIFTLEFT(BIT1, 1) | BITSHIFTRIGHT(BIT2, 1) |\n|------+-------+-----------------------+------------------------|\n|    0 | 65504 |                     0 |                  32752 |\n|    1 |     1 |                     2 |                      0 |\n|    2 |     4 |                     4 |                      2 |\n|    4 |     2 |                     8 |                      1 |\n|   16 |    24 |                    32 |                     12 |\n| NULL |  NULL |                  NULL |                   NULL |\n+------+-------+-----------------------+------------------------+\n\nCREATE OR REPLACE TABLE bits (ID INTEGER, bit1 BINARY(2), bit2 BINARY(2), bit3 BINARY(4));\n\nINSERT INTO bits VALUES\n  (1, x'1010', x'0101', x'11001010'),\n  (2, x'1100', x'0011', x'01011010'),\n  (3, x'BCBC', x'EEFF', x'ABCDABCD'),\n  (4, NULL, NULL, NULL);\n\nSELECT bit1,\n       bit3,\n       BITSHIFTRIGHT(bit1, 1),\n       BITSHIFTRIGHT(bit3, 1),\n       BITSHIFTRIGHT(bit1, 8),\n       BITSHIFTRIGHT(bit3, 16)\n  FROM bits;\n\n+------+----------+------------------------+------------------------+------------------------+-------------------------+\n| BIT1 | BIT3     | BITSHIFTRIGHT(BIT1, 1) | BITSHIFTRIGHT(BIT3, 1) | BITSHIFTRIGHT(BIT1, 8) | BITSHIFTRIGHT(BIT3, 16) |\n|------+----------+------------------------+------------------------+------------------------+-------------------------|\n| 1010 | 11001010 | 0808                   | 08800808               | 0010                   | 00001100                |\n| 1100 | 01011010 | 0880                   | 00808808               | 0011                   | 00000101                |\n| BCBC | ABCDABCD | 5E5E                   | 55E6D5E6               | 00BC                   | 0000ABCD                |\n| NULL | NULL     | NULL                   | NULL                   | NULL                   | NULL                    |\n+------+----------+------------------------+------------------------+------------------------+-------------------------+",
    "arguments": [
        {
            "name": "expr1",
            "description": "This expression must evaluate to an INTEGER value, a BINARY value, or a value of a data type\nthat can be cast to an INTEGER value."
        },
        {
            "name": "n",
            "description": "The number of bits to shift by."
        }
    ],
    "returns": "Returns an INTEGER value, a BINARY value, or NULL:"
},
{
    "function_name": "BITSHIFTLEFT",
    "summary": "Shifts the bits for a numeric or binary expression n positions to the left.",
    "category": "Bitwise expression functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/bitshiftleft",
    "title": "BITSHIFTLEFT",
    "description": "Shifts the bits for a numeric or binary expression",
    "syntax": "BITSHIFTLEFT( <expr1> , <n> )",
    "example": "CREATE OR REPLACE TABLE bits (ID INTEGER, bit1 INTEGER, bit2 INTEGER);\n\nINSERT INTO bits (ID, bit1, bit2) VALUES \n  (   11,    1,     1),    -- Bits are all the same.\n  (   24,    2,     4),    -- Bits are all different.\n  (   42,    4,     2),    -- Bits are all different.\n  ( 1624,   16,    24),    -- Bits overlap.\n  (65504,    0, 65504),    -- Lots of bits (all but the low 6 bits).\n  (    0, NULL,  NULL)     -- No bits.\n  ;\n\nSELECT bit1, \n       bit2, \n       BITSHIFTLEFT(bit1, 1), \n       BITSHIFTRIGHT(bit2, 1)\n  FROM bits\n  ORDER BY bit1;\n\n+------+-------+-----------------------+------------------------+\n| BIT1 |  BIT2 | BITSHIFTLEFT(BIT1, 1) | BITSHIFTRIGHT(BIT2, 1) |\n|------+-------+-----------------------+------------------------|\n|    0 | 65504 |                     0 |                  32752 |\n|    1 |     1 |                     2 |                      0 |\n|    2 |     4 |                     4 |                      2 |\n|    4 |     2 |                     8 |                      1 |\n|   16 |    24 |                    32 |                     12 |\n| NULL |  NULL |                  NULL |                   NULL |\n+------+-------+-----------------------+------------------------+\n\nCREATE OR REPLACE TABLE bits (ID INTEGER, bit1 BINARY(2), bit2 BINARY(2), bit3 BINARY(4));\n\nINSERT INTO bits VALUES\n  (1, x'1010', x'0101', x'11001010'),\n  (2, x'1100', x'0011', x'01011010'),\n  (3, x'BCBC', x'EEFF', x'ABCDABCD'),\n  (4, NULL, NULL, NULL);\n\nSELECT bit1,\n       bit3,\n       BITSHIFTLEFT(bit1, 1),\n       BITSHIFTLEFT(bit3, 1),\n       BITSHIFTLEFT(bit1, 8),\n       BITSHIFTLEFT(bit3, 16)\n  FROM bits;\n\n+------+----------+-----------------------+-----------------------+-----------------------+------------------------+\n| BIT1 | BIT3     | BITSHIFTLEFT(BIT1, 1) | BITSHIFTLEFT(BIT3, 1) | BITSHIFTLEFT(BIT1, 8) | BITSHIFTLEFT(BIT3, 16) |\n|------+----------+-----------------------+-----------------------+-----------------------+------------------------|\n| 1010 | 11001010 | 2020                  | 22002020              | 1000                  | 10100000               |\n| 1100 | 01011010 | 2200                  | 02022020              | 0000                  | 10100000               |\n| BCBC | ABCDABCD | 7978                  | 579B579A              | BC00                  | ABCD0000               |\n| NULL | NULL     | NULL                  | NULL                  | NULL                  | NULL                   |\n+------+----------+-----------------------+-----------------------+-----------------------+------------------------+",
    "arguments": [
        {
            "name": "expr1",
            "description": "This expression must evaluate to an INTEGER value, a BINARY value, or a value of a data type\nthat can be cast to an INTEGER value."
        },
        {
            "name": "n",
            "description": "The number of bits to shift by."
        }
    ],
    "returns": "Returns an INTEGER value, a BINARY value, or NULL:"
},
{
    "function_name": "BITOR_AGG",
    "summary": "Returns the bitwise OR value of all non-NULL numeric records in a group.",
    "category": "Aggregate functions , Window functions , Bitwise expression functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/bitor_agg",
    "title": "BITOR_AGG",
    "description": "Returns the bitwise OR value of all non-NULL numeric records in a group.",
    "syntax": "BITOR_AGG( <expr1> )",
    "example": "CREATE OR REPLACE TABLE bitwise_example\n  (k INT, d DECIMAL(10,5), s1 VARCHAR(10), s2 VARCHAR(10));\n\nINSERT INTO bitwise_example VALUES\n  (15, 1.1, '12','one'),\n  (26, 2.9, '10','two'),\n  (12, 7.1, '7.9','two'),\n  (14, NULL, NULL,'null'),\n  (8, NULL, NULL, 'null'),\n  (NULL, 9.1, '14','nine');\n\nSELECT k AS k_col, d AS d_col, s1, s2\n  FROM bitwise_example\n  ORDER BY k_col;\n\n+-------+---------+------+------+\n| K_COL |   D_COL | S1   | S2   |\n|-------+---------+------+------|\n|     8 |    NULL | NULL | null |\n|    12 | 7.10000 | 7.9  | two  |\n|    14 |    NULL | NULL | null |\n|    15 | 1.10000 | 12   | one  |\n|    26 | 2.90000 | 10   | two  |\n|  NULL | 9.10000 | 14   | nine |\n+-------+---------+------+------+\n\nSELECT BITOR_AGG(k), \n       BITOR_AGG(d), \n       BITOR_AGG(s1) \n  FROM bitwise_example;\n\n+--------------+--------------+---------------+\n| BITOR_AGG(K) | BITOR_AGG(D) | BITOR_AGG(S1) |\n|--------------+--------------+---------------|\n|           31 |           15 |            14 |\n+--------------+--------------+---------------+\n\nSELECT s2, \n       BITOR_AGG(k), \n       BITOR_AGG(d) \n  FROM bitwise_example group by s2\n  ORDER BY 3;\n\n+------+--------------+--------------+\n| S2   | BITOR_AGG(K) | BITOR_AGG(D) |\n|------+--------------+--------------|\n| one  |           15 |            1 |\n| two  |           30 |            7 |\n| nine |         NULL |            9 |\n| null |           14 |         NULL |\n+------+--------------+--------------+\n\nSELECT BITOR_AGG(s2) FROM bitwise_example;\n\n100038 (22018): Numeric value 'one' is not recognized",
    "arguments": [
        {
            "name": "expr1",
            "description": "This expression must evaluate to a numeric value or a value\nof a data type that can be cast to a numeric value."
        },
        {
            "name": "expr2",
            "description": "This expression is used to group the rows in partitions."
        }
    ],
    "returns": "The data type of the returned value is NUMBER(38, 0)."
},
{
    "function_name": "BITOR",
    "summary": "Returns the bitwise OR of two numeric or binary expressions.",
    "category": "Bitwise expression functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/bitor",
    "title": "BITOR",
    "description": "Returns the bitwise OR of two numeric or binary expressions.",
    "syntax": "BITOR( <expr1> , <expr2> [ , '<padside>' ] )",
    "example": "CREATE OR REPLACE TABLE bits (ID INTEGER, bit1 INTEGER, bit2 INTEGER);\n\nINSERT INTO bits (ID, bit1, bit2) VALUES \n  (   11,    1,     1),    -- Bits are all the same.\n  (   24,    2,     4),    -- Bits are all different.\n  (   42,    4,     2),    -- Bits are all different.\n  ( 1624,   16,    24),    -- Bits overlap.\n  (65504,    0, 65504),    -- Lots of bits (all but the low 6 bits).\n  (    0, NULL,  NULL)     -- No bits.\n  ;\n\nSELECT bit1, \n       bit2, \n       BITAND(bit1, bit2), \n       BITOR(bit1, bit2), \n       BITXOR(bit1, BIT2)\n  FROM bits\n  ORDER BY bit1;\n\n+------+-------+--------------------+-------------------+--------------------+\n| BIT1 |  BIT2 | BITAND(BIT1, BIT2) | BITOR(BIT1, BIT2) | BITXOR(BIT1, BIT2) |\n|------+-------+--------------------+-------------------+--------------------|\n|    0 | 65504 |                  0 |             65504 |              65504 |\n|    1 |     1 |                  1 |                 1 |                  0 |\n|    2 |     4 |                  0 |                 6 |                  6 |\n|    4 |     2 |                  0 |                 6 |                  6 |\n|   16 |    24 |                 16 |                24 |                  8 |\n| NULL |  NULL |               NULL |              NULL |               NULL |\n+------+-------+--------------------+-------------------+--------------------+\n\nCREATE OR REPLACE TABLE bits (ID INTEGER, bit1 BINARY(2), bit2 BINARY(2), bit3 BINARY(4));\n\nINSERT INTO bits VALUES\n  (1, x'1010', x'0101', x'11001010'),\n  (2, x'1100', x'0011', x'01011010'),\n  (3, x'BCBC', x'EEFF', x'ABCDABCD'),\n  (4, NULL, NULL, NULL);\n\nSELECT bit1,\n       bit2,\n       BITAND(bit1, bit2),\n       BITOR(bit1, bit2),\n       BITXOR(bit1, bit2)\n  FROM bits;\n\n+------+------+--------------------+-------------------+--------------------+\n| BIT1 | BIT2 | BITAND(BIT1, BIT2) | BITOR(BIT1, BIT2) | BITXOR(BIT1, BIT2) |\n|------+------+--------------------+-------------------+--------------------|\n| 1010 | 0101 | 0000               | 1111              | 1111               |\n| 1100 | 0011 | 0000               | 1111              | 1111               |\n| BCBC | EEFF | ACBC               | FEFF              | 5243               |\n| NULL | NULL | NULL               | NULL              | NULL               |\n+------+------+--------------------+-------------------+--------------------+\n\nSELECT bit1,\n       bit3,\n       BITAND(bit1, bit3),\n       BITOR(bit1, bit3),\n       BITXOR(bit1, bit3)\n  FROM bits;\n\n100544 (22026): The lengths of two variable-sized fields do not match: first length 2, second length 4\n\nSELECT bit1,\n       bit3,\n       BITAND(bit1, bit3, 'LEFT'),\n       BITOR(bit1, bit3, 'LEFT'),\n       BITXOR(bit1, bit3, 'LEFT')\n  FROM bits;\n\n+------+----------+----------------------------+---------------------------+----------------------------+\n| BIT1 | BIT3     | BITAND(BIT1, BIT3, 'LEFT') | BITOR(BIT1, BIT3, 'LEFT') | BITXOR(BIT1, BIT3, 'LEFT') |\n|------+----------+----------------------------+---------------------------+----------------------------|\n| 1010 | 11001010 | 00001010                   | 11001010                  | 11000000                   |\n| 1100 | 01011010 | 00001000                   | 01011110                  | 01010110                   |\n| BCBC | ABCDABCD | 0000A88C                   | ABCDBFFD                  | ABCD1771                   |\n| NULL | NULL     | NULL                       | NULL                      | NULL                       |\n+------+----------+----------------------------+---------------------------+----------------------------+\n\nSELECT bit1,\n       bit3,\n       BITAND(bit1, bit3, 'RIGHT'),\n       BITOR(bit1, bit3, 'RIGHT'),\n       BITXOR(bit1, bit3, 'RIGHT')\n  FROM bits;\n\n+------+----------+-----------------------------+----------------------------+-----------------------------+\n| BIT1 | BIT3     | BITAND(BIT1, BIT3, 'RIGHT') | BITOR(BIT1, BIT3, 'RIGHT') | BITXOR(BIT1, BIT3, 'RIGHT') |\n|------+----------+-----------------------------+----------------------------+-----------------------------|\n| 1010 | 11001010 | 10000000                    | 11101010                   | 01101010                    |\n| 1100 | 01011010 | 01000000                    | 11011010                   | 10011010                    |\n| BCBC | ABCDABCD | A88C0000                    | BFFDABCD                   | 1771ABCD                    |\n| NULL | NULL     | NULL                        | NULL                       | NULL                        |\n+------+----------+-----------------------------+----------------------------+-----------------------------+",
    "arguments": [
        {
            "name": "expr1",
            "description": "This expression must evaluate to an INTEGER value, a BINARY value, or a value of a data type\nthat can be cast to an INTEGER value."
        },
        {
            "name": "expr2",
            "description": "This expression must evaluate to an INTEGER value, a BINARY value, or a value of a data type\nthat can be cast to an INTEGER value."
        },
        {
            "name": "'",
            "description": "When two BINARY argument values are not the same length, specifies which side to pad the value\nwith the shorter length. Specify one of the following case-insensitive values: LEFT - Pad the value on the left. RIGHT - Pad the value on the right. The shorter value is padded with zeros so that it equals the length of the larger value. This argument is valid only when BINARY expressions are specified. If the length of two BINARY values are different, this argument is required."
        }
    ],
    "returns": "Returns an INTEGER value, a BINARY value, or NULL:"
},
{
    "function_name": "BITNOT",
    "summary": "Returns the bitwise negation of a numeric or binary expression.",
    "category": "Bitwise expression functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/bitnot",
    "title": "BITNOT",
    "description": "Returns the bitwise negation of a numeric or binary expression.",
    "syntax": "BITNOT( <expr> )",
    "example": "CREATE OR REPLACE TABLE bits (ID INTEGER, bit1 INTEGER, bit2 INTEGER);\n\nINSERT INTO bits (ID, bit1, bit2) VALUES \n  (   11,    1,     1),    -- Bits are all the same.\n  (   24,    2,     4),    -- Bits are all different.\n  (   42,    4,     2),    -- Bits are all different.\n  ( 1624,   16,    24),    -- Bits overlap.\n  (65504,    0, 65504),    -- Lots of bits (all but the low 6 bits).\n  (    0, NULL,  NULL)     -- No bits.\n  ;\n\nSELECT bit1, \n       bit2, \n       BITNOT(bit1), \n       BITNOT(bit2)\n  FROM bits\n  ORDER BY bit1;\n\n+------+-------+--------------+--------------+\n| BIT1 |  BIT2 | BITNOT(BIT1) | BITNOT(BIT2) |\n|------+-------+--------------+--------------|\n|    0 | 65504 |           -1 |       -65505 |\n|    1 |     1 |           -2 |           -2 |\n|    2 |     4 |           -3 |           -5 |\n|    4 |     2 |           -5 |           -3 |\n|   16 |    24 |          -17 |          -25 |\n| NULL |  NULL |         NULL |         NULL |\n+------+-------+--------------+--------------+\n\nCREATE OR REPLACE TABLE bits (ID INTEGER, bit1 BINARY(2), bit2 BINARY(2), bit3 BINARY(4));\n\nINSERT INTO bits VALUES\n  (1, x'1010', x'0101', x'11001010'),\n  (2, x'1100', x'0011', x'01011010'),\n  (3, x'BCBC', x'EEFF', x'ABCDABCD'),\n  (4, NULL, NULL, NULL);\n\nSELECT bit1,\n       bit2,\n       bit3,\n       BITNOT(bit1),\n       BITNOT(bit2),\n       BITNOT(bit3)\n  FROM bits;\n\n+------+------+----------+--------------+--------------+--------------+\n| BIT1 | BIT2 | BIT3     | BITNOT(BIT1) | BITNOT(BIT2) | BITNOT(BIT3) |\n|------+------+----------+--------------+--------------+--------------|\n| 1010 | 0101 | 11001010 | EFEF         | FEFE         | EEFFEFEF     |\n| 1100 | 0011 | 01011010 | EEFF         | FFEE         | FEFEEFEF     |\n| BCBC | EEFF | ABCDABCD | 4343         | 1100         | 54325432     |\n| NULL | NULL | NULL     | NULL         | NULL         | NULL         |\n+------+------+----------+--------------+--------------+--------------+",
    "arguments": [
        {
            "name": "expr",
            "description": "This expression must evaluate to an INTEGER value, a BINARY value, or a value of a data type\nthat can be cast to an INTEGER value."
        }
    ],
    "returns": "Returns an INTEGER value, a BINARY value, or NULL:"
},
{
    "function_name": "BITMAP_OR_AGG",
    "summary": "Returns a bitmap containing the results of a binary OR operation on the input bitmaps.",
    "category": "Aggregate functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/bitmap_or_agg",
    "title": "BITMAP_OR_AGG",
    "description": "Returns a bitmap containing the results of a binary OR operation on the input bitmaps.",
    "syntax": "BITMAP_OR_AGG( <bitmap> )",
    "arguments": [
        {
            "name": "bitmap",
            "description": "A bitmap returned by the BITMAP_CONSTRUCT_AGG or BITMAP_OR_AGG function."
        }
    ],
    "returns": "The function returns a bitmap containing the results of a binary OR operation on the input bitmaps."
},
{
    "function_name": "BITMAP_COUNT",
    "summary": "Given a bitmap that represents the set of distinct values for a column, returns the number of distinct value.",
    "category": "Aggregate functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/bitmap_count",
    "title": "BITMAP_COUNT",
    "description": "Given a bitmap that represents the set of distinct values for a column, returns the number of distinct value.",
    "syntax": "BITMAP_COUNT( <bitmap> )",
    "arguments": [
        {
            "name": "bitmap",
            "description": "This expression must evaluate to a bitmap returned by the BITMAP_CONSTRUCT_AGG or BITMAP_OR_AGG functions."
        }
    ],
    "returns": "The function returns the number of distinct values in a column, as represented by the bits set in the input bitmap."
},
{
    "function_name": "BITMAP_CONSTRUCT_AGG",
    "summary": "Returns a bitmap with bits set for each distinct value in a group.",
    "category": "Aggregate functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/bitmap_construct_agg",
    "title": "BITMAP_CONSTRUCT_AGG",
    "description": "Returns a bitmap with bits set for each distinct value in a group.",
    "syntax": "BITMAP_CONSTRUCT_AGG( <relative_position> )",
    "arguments": [
        {
            "name": "relative_position",
            "description": "The relative position of a bit for a value (returned by the BITMAP_BIT_POSITION function)."
        }
    ],
    "returns": "The function returns a BINARY value that is a bitmap with bits set for each distinct value in a group."
},
{
    "function_name": "BITMAP_BUCKET_NUMBER",
    "summary": "Given a numeric value, returns an identifier (“bucket number”) for the bitmap containing the bit that represents the value..",
    "category": "Aggregate functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/bitmap_bucket_number",
    "title": "BITMAP_BUCKET_NUMBER",
    "description": "Given a numeric value, returns an identifier (“bucket number”) for the bitmap containing the bit that represents the value..",
    "syntax": "BITMAP_BUCKET_NUMBER( <numeric_expr> )",
    "arguments": [
        {
            "name": "numeric_expr",
            "description": "This expression must evaluate to a data type that can be cast to NUMBER."
        }
    ],
    "returns": "The function returns a number that identifies the bitmap containing the bit that represents the value."
},
{
    "function_name": "BITMAP_BIT_POSITION",
    "summary": "Given a numeric value, returns the relative position for the bit that represents that value in a bitmap.",
    "category": "Aggregate functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/bitmap_bit_position",
    "title": "BITMAP_BIT_POSITION",
    "description": "Given a numeric value, returns the relative position for the bit that represents that value in a bitmap.",
    "syntax": "BITMAP_BIT_POSITION( <numeric_expr> )",
    "arguments": [
        {
            "name": "numeric_expr",
            "description": "This expression must evaluate to a data type that can be cast to NUMBER."
        }
    ],
    "returns": "The function returns the zero-based position of the bit for that value in a bitmap."
},
{
    "function_name": "BITAND_AGG",
    "summary": "Returns the bitwise AND value of all non-NULL numeric records in a group.",
    "category": "Aggregate functions , Window functions , Bitwise expression functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/bitand_agg",
    "title": "BITAND_AGG",
    "description": "Returns the bitwise AND value of all non-NULL numeric records in a group.",
    "syntax": "BITAND_AGG( <expr1> )",
    "example": "CREATE OR REPLACE TABLE bitwise_example\n  (k INT, d DECIMAL(10,5), s1 VARCHAR(10), s2 VARCHAR(10));\n\nINSERT INTO bitwise_example VALUES\n  (15, 1.1, '12','one'),\n  (26, 2.9, '10','two'),\n  (12, 7.1, '7.9','two'),\n  (14, NULL, NULL,'null'),\n  (8, NULL, NULL, 'null'),\n  (NULL, 9.1, '14','nine');\n\nSELECT k AS k_col, d AS d_col, s1, s2\n  FROM bitwise_example\n  ORDER BY k_col;\n\n+-------+---------+------+------+\n| K_COL |   D_COL | S1   | S2   |\n|-------+---------+------+------|\n|     8 |    NULL | NULL | null |\n|    12 | 7.10000 | 7.9  | two  |\n|    14 |    NULL | NULL | null |\n|    15 | 1.10000 | 12   | one  |\n|    26 | 2.90000 | 10   | two  |\n|  NULL | 9.10000 | 14   | nine |\n+-------+---------+------+------+\n\nSELECT BITAND_AGG(k), \n       BITAND_AGG(d), \n       BITAND_AGG(s1) \n  FROM bitwise_example;\n\n+---------------+---------------+----------------+\n| BITAND_AGG(K) | BITAND_AGG(D) | BITAND_AGG(S1) |\n|---------------+---------------+----------------|\n|             8 |             1 |              8 |\n+---------------+---------------+----------------+\n\nSELECT s2, \n       BITAND_AGG(k), \n       BITAND_AGG(d) \n  FROM bitwise_example \n  GROUP BY s2\n  ORDER BY 3;\n\n+------+---------------+---------------+\n| S2   | BITAND_AGG(K) | BITAND_AGG(D) |\n|------+---------------+---------------|\n| one  |            15 |             1 |\n| two  |             8 |             3 |\n| nine |          NULL |             9 |\n| null |             8 |          NULL |\n+------+---------------+---------------+\n\nSELECT BITAND_AGG(s2) FROM bitwise_example;\n\n100038 (22018): Numeric value 'one' is not recognized",
    "arguments": [
        {
            "name": "expr1",
            "description": "This expression must evaluate to a numeric value or a value\nof a data type that can be cast to a numeric value."
        },
        {
            "name": "expr2",
            "description": "This expression is used to group the rows in partitions."
        }
    ],
    "returns": "The data type of the returned value is NUMBER(38, 0)."
},
{
    "function_name": "BITAND",
    "summary": "Returns the bitwise AND of two numeric or binary expressions.",
    "category": "Bitwise expression functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/bitand",
    "title": "BITAND",
    "description": "Returns the bitwise AND of two numeric or binary expressions.",
    "syntax": "BITAND( <expr1> , <expr2> [ , '<padside>' ] )",
    "example": "CREATE OR REPLACE TABLE bits (ID INTEGER, bit1 INTEGER, bit2 INTEGER);\n\nINSERT INTO bits (ID, bit1, bit2) VALUES \n  (   11,    1,     1),    -- Bits are all the same.\n  (   24,    2,     4),    -- Bits are all different.\n  (   42,    4,     2),    -- Bits are all different.\n  ( 1624,   16,    24),    -- Bits overlap.\n  (65504,    0, 65504),    -- Lots of bits (all but the low 6 bits).\n  (    0, NULL,  NULL)     -- No bits.\n  ;\n\nSELECT bit1, \n       bit2, \n       BITAND(bit1, bit2), \n       BITOR(bit1, bit2), \n       BITXOR(bit1, BIT2)\n  FROM bits\n  ORDER BY bit1;\n\n+------+-------+--------------------+-------------------+--------------------+\n| BIT1 |  BIT2 | BITAND(BIT1, BIT2) | BITOR(BIT1, BIT2) | BITXOR(BIT1, BIT2) |\n|------+-------+--------------------+-------------------+--------------------|\n|    0 | 65504 |                  0 |             65504 |              65504 |\n|    1 |     1 |                  1 |                 1 |                  0 |\n|    2 |     4 |                  0 |                 6 |                  6 |\n|    4 |     2 |                  0 |                 6 |                  6 |\n|   16 |    24 |                 16 |                24 |                  8 |\n| NULL |  NULL |               NULL |              NULL |               NULL |\n+------+-------+--------------------+-------------------+--------------------+\n\nCREATE OR REPLACE TABLE bits (ID INTEGER, bit1 BINARY(2), bit2 BINARY(2), bit3 BINARY(4));\n\nINSERT INTO bits VALUES\n  (1, x'1010', x'0101', x'11001010'),\n  (2, x'1100', x'0011', x'01011010'),\n  (3, x'BCBC', x'EEFF', x'ABCDABCD'),\n  (4, NULL, NULL, NULL);\n\nSELECT bit1,\n       bit2,\n       BITAND(bit1, bit2),\n       BITOR(bit1, bit2),\n       BITXOR(bit1, bit2)\n  FROM bits;\n\n+------+------+--------------------+-------------------+--------------------+\n| BIT1 | BIT2 | BITAND(BIT1, BIT2) | BITOR(BIT1, BIT2) | BITXOR(BIT1, BIT2) |\n|------+------+--------------------+-------------------+--------------------|\n| 1010 | 0101 | 0000               | 1111              | 1111               |\n| 1100 | 0011 | 0000               | 1111              | 1111               |\n| BCBC | EEFF | ACBC               | FEFF              | 5243               |\n| NULL | NULL | NULL               | NULL              | NULL               |\n+------+------+--------------------+-------------------+--------------------+\n\nSELECT bit1,\n       bit3,\n       BITAND(bit1, bit3),\n       BITOR(bit1, bit3),\n       BITXOR(bit1, bit3)\n  FROM bits;\n\n100544 (22026): The lengths of two variable-sized fields do not match: first length 2, second length 4\n\nSELECT bit1,\n       bit3,\n       BITAND(bit1, bit3, 'LEFT'),\n       BITOR(bit1, bit3, 'LEFT'),\n       BITXOR(bit1, bit3, 'LEFT')\n  FROM bits;\n\n+------+----------+----------------------------+---------------------------+----------------------------+\n| BIT1 | BIT3     | BITAND(BIT1, BIT3, 'LEFT') | BITOR(BIT1, BIT3, 'LEFT') | BITXOR(BIT1, BIT3, 'LEFT') |\n|------+----------+----------------------------+---------------------------+----------------------------|\n| 1010 | 11001010 | 00001010                   | 11001010                  | 11000000                   |\n| 1100 | 01011010 | 00001000                   | 01011110                  | 01010110                   |\n| BCBC | ABCDABCD | 0000A88C                   | ABCDBFFD                  | ABCD1771                   |\n| NULL | NULL     | NULL                       | NULL                      | NULL                       |\n+------+----------+----------------------------+---------------------------+----------------------------+\n\nSELECT bit1,\n       bit3,\n       BITAND(bit1, bit3, 'RIGHT'),\n       BITOR(bit1, bit3, 'RIGHT'),\n       BITXOR(bit1, bit3, 'RIGHT')\n  FROM bits;\n\n+------+----------+-----------------------------+----------------------------+-----------------------------+\n| BIT1 | BIT3     | BITAND(BIT1, BIT3, 'RIGHT') | BITOR(BIT1, BIT3, 'RIGHT') | BITXOR(BIT1, BIT3, 'RIGHT') |\n|------+----------+-----------------------------+----------------------------+-----------------------------|\n| 1010 | 11001010 | 10000000                    | 11101010                   | 01101010                    |\n| 1100 | 01011010 | 01000000                    | 11011010                   | 10011010                    |\n| BCBC | ABCDABCD | A88C0000                    | BFFDABCD                   | 1771ABCD                    |\n| NULL | NULL     | NULL                        | NULL                       | NULL                        |\n+------+----------+-----------------------------+----------------------------+-----------------------------+",
    "arguments": [
        {
            "name": "expr1",
            "description": "This expression must evaluate to an INTEGER value, a BINARY value, or a value of a data type\nthat can be cast to an INTEGER value."
        },
        {
            "name": "expr2",
            "description": "This expression must evaluate to an INTEGER value, a BINARY value, or a value of a data type\nthat can be cast to an INTEGER value."
        },
        {
            "name": "'",
            "description": "When two BINARY argument values are not the same length, specifies which side to pad the value\nwith the shorter length. Specify one of the following case-insensitive values: LEFT - Pad the value on the left. RIGHT - Pad the value on the right. The shorter value is padded with zeros so that it equals the length of the larger value. This argument is valid only when BINARY expressions are specified. If the length of two BINARY values are different, this argument is required."
        }
    ],
    "returns": "Returns an INTEGER value, a BINARY value, or NULL:"
},
{
    "function_name": "BIT_LENGTH",
    "summary": "Returns the length of a string or binary value in bits.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/bit_length",
    "title": "BIT_LENGTH",
    "description": "Returns the length of a string or binary value in bits.",
    "syntax": "BIT_LENGTH(<string_or_binary>)",
    "example": "CREATE TABLE bl (v VARCHAR, b BINARY);\nINSERT INTO bl (v, b) VALUES \n   ('abc', NULL),\n   ('\\u0394', X'A1B2');\n\nSELECT v, b, BIT_LENGTH(v), BIT_LENGTH(b) FROM bl ORDER BY v;\n+-----+------+---------------+---------------+\n| V   | B    | BIT_LENGTH(V) | BIT_LENGTH(B) |\n|-----+------+---------------+---------------|\n| abc | NULL |            24 |          NULL |\n| Δ   | A1B2 |            16 |            16 |\n+-----+------+---------------+---------------+",
    "arguments": [
        {
            "name": "string_or_binary",
            "description": "The string or binary value for which the length is returned."
        }
    ]
},
{
    "function_name": "[ NOT ] BETWEEN",
    "summary": "Returns TRUE when the input expression (numeric or string) is within the specified lower and upper boundary.",
    "category": "Conditional expression functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/between",
    "title": "[ NOT ] BETWEEN",
    "description": "Returns",
    "syntax": "<expr> [ NOT ] BETWEEN <lower_bound> AND <upper_bound>",
    "example": "SELECT 'true' WHERE 1 BETWEEN 0 AND 10;\n\n+--------+\n| 'TRUE' |\n|--------|\n| true   |\n+--------+\n\nSELECT 'true' WHERE 1.35 BETWEEN 1 AND 2;\n\n+--------+\n| 'TRUE' |\n|--------|\n| true   |\n+--------+\n\nSELECT 'true' WHERE 'the' BETWEEN 'that' AND 'then';\n\n+--------+\n| 'TRUE' |\n|--------|\n| true   |\n+--------+\n\nSELECT 'm' BETWEEN COLLATE('A', 'lower') AND COLLATE('Z', 'lower');\n\n+-------------------------------------------------------------+\n| 'M' BETWEEN COLLATE('A', 'LOWER') AND COLLATE('Z', 'LOWER') |\n|-------------------------------------------------------------|\n| True                                                        |\n+-------------------------------------------------------------+\n\nSELECT COLLATE('m', 'upper') BETWEEN 'A' AND 'Z';\n\n+-------------------------------------------+\n| COLLATE('M', 'UPPER') BETWEEN 'A' AND 'Z' |\n|-------------------------------------------|\n| True                                      |\n+-------------------------------------------+",
    "arguments": [
        {
            "name": "expr",
            "description": "The input expression."
        },
        {
            "name": "lower_bound",
            "description": "The lower boundary."
        },
        {
            "name": "upper_bound",
            "description": "The upper boundary."
        }
    ],
    "returns": "The function returns a value of type BOOLEAN."
},
{
    "function_name": "BASE64_ENCODE",
    "summary": "Encodes the input (string or binary) using Base64 encoding.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/base64_encode",
    "title": "BASE64_ENCODE",
    "description": "Encodes the input (string or binary) using Base64 encoding.",
    "syntax": "BASE64_ENCODE( <input> [ , <max_line_length> ] [ , <alphabet> ] )",
    "example": "SELECT BASE64_ENCODE('Snowflake');\n\n----------------------------+\n BASE64_ENCODE('SNOWFLAKE') |\n----------------------------+\n U25vd2ZsYWtl               |\n----------------------------+\n\nSELECT BASE64_ENCODE('Snowflake ❄❄❄ Snowman ☃☃☃',32,'$');\n\n---------------------------------------------------+\n BASE64_ENCODE('SNOWFLAKE ❄❄❄ SNOWMAN ☃☃☃',32,'$') |\n---------------------------------------------------+\n U25vd2ZsYWtlIOKdhOKdhOKdhCBTbm93                  |\n bWFuIOKYg$KYg$KYgw==                              |\n---------------------------------------------------+\n\nCREATE OR REPLACE TABLE base64_table (v VARCHAR, base64_string VARCHAR);\nINSERT INTO base64_table (v) VALUES ('HELLO');\nUPDATE base64_table SET base64_string = BASE64_ENCODE(v);\n\nSELECT v, base64_string, BASE64_DECODE_STRING(base64_string) \n    FROM base64_table;\n+-------+---------------+-------------------------------------+\n| V     | BASE64_STRING | BASE64_DECODE_STRING(BASE64_STRING) |\n|-------+---------------+-------------------------------------|\n| HELLO | SEVMTE8=      | HELLO                               |\n+-------+---------------+-------------------------------------+",
    "arguments": [
        {
            "name": "input",
            "description": "A string or binary expression to be encoded."
        },
        {
            "name": "max_line_length",
            "description": "A positive integer that specifies the maximum number of characters in a single line of the output. Default: 0 (specifies that no line breaks are inserted (i.e. the maximum line length is infinite))"
        },
        {
            "name": "alphabet",
            "description": "A string consisting of up to three ASCII characters: The first two characters in the string specify the last two characters (indexes 62 and 63) in the alphabet used to encode the input: A to Z (indexes 0-25) a to z (indexes 26-51) 0 to 9 (indexes 52-61) + and / (indexes 62, 63) Defaults: + and / The third character in the string specifies the character used for padding. Default: ="
        }
    ],
    "returns": "Returns a string (regardless of whether the input was a string or BINARY)."
},
{
    "function_name": "BASE64_DECODE_STRING",
    "summary": "Decodes a Base64-encoded string to a string.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/base64_decode_string",
    "title": "BASE64_DECODE_STRING",
    "description": "Decodes a Base64-encoded string to a string.",
    "syntax": "BASE64_DECODE_STRING( <input> [ , <alphabet> ] )",
    "example": "SELECT BASE64_DECODE_STRING('U25vd2ZsYWtl');\n+--------------------------------------+\n| BASE64_DECODE_STRING('U25VD2ZSYWTL') |\n|--------------------------------------|\n| Snowflake                            |\n+--------------------------------------+\n\nCREATE OR REPLACE TABLE base64_table (v VARCHAR, base64_string VARCHAR);\nINSERT INTO base64_table (v) VALUES ('HELLO');\nUPDATE base64_table SET base64_string = BASE64_ENCODE(v);\n\nSELECT v, base64_string, BASE64_DECODE_STRING(base64_string) \n    FROM base64_table;\n+-------+---------------+-------------------------------------+\n| V     | BASE64_STRING | BASE64_DECODE_STRING(BASE64_STRING) |\n|-------+---------------+-------------------------------------|\n| HELLO | SEVMTE8=      | HELLO                               |\n+-------+---------------+-------------------------------------+",
    "arguments": [
        {
            "name": "input",
            "description": "A Base64-encoded string expression."
        },
        {
            "name": "alphabet",
            "description": "A string consisting of up to three ASCII characters: The first two characters in the string specify the last two characters (indexes 62 and 63) in the alphabet used to encode the input: A to Z (indexes 0-25) a to z (indexes 26-51) 0 to 9 (indexes 52-61) + and / (indexes 62, 63) Defaults: + and / The third character in the string specifies the character used for padding. Default: ="
        }
    ],
    "returns": "A string."
},
{
    "function_name": "BASE64_DECODE_BINARY",
    "summary": "Decodes a Base64-encoded string to a binary.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/base64_decode_binary",
    "title": "BASE64_DECODE_BINARY",
    "description": "Decodes a Base64-encoded string to a binary.",
    "syntax": "BASE64_DECODE_BINARY( <input> [ , <alphabet> ] )",
    "example": "CREATE OR REPLACE TABLE binary_table (v VARCHAR, b BINARY, b64_string VARCHAR);\nINSERT INTO binary_table (v) VALUES ('HELP');\nUPDATE binary_table SET b = TO_BINARY(v, 'UTF-8');\nUPDATE binary_table SET b64_string = BASE64_ENCODE(b);\n\n-- Note that the binary data in column b is displayed in hexadecimal\n--   format to make it human-readable.\nSELECT v, b, b64_string FROM binary_table;\n+------+----------+------------+\n| V    | B        | B64_STRING |\n|------+----------+------------|\n| HELP | 48454C50 | SEVMUA==   |\n+------+----------+------------+\n\nSELECT v, b, b64_string, \n        BASE64_DECODE_BINARY(b64_string) AS FROM_BASE64_BACK_TO_BINARY,\n        TO_VARCHAR(BASE64_DECODE_BINARY(b64_string), 'UTF-8') AS BACK_TO_STRING\n    FROM binary_table;\n+------+----------+------------+----------------------------+----------------+\n| V    | B        | B64_STRING | FROM_BASE64_BACK_TO_BINARY | BACK_TO_STRING |\n|------+----------+------------+----------------------------+----------------|\n| HELP | 48454C50 | SEVMUA==   | 48454C50                   | HELP           |\n+------+----------+------------+----------------------------+----------------+\n\nSET MY_STRING = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ!@#$%^&*()abcdefghijklmnopqrstuvwzyz1234567890[]{};:,./<>?-=~';\nCREATE OR REPLACE TABLE binary_table (v VARCHAR, b BINARY, b64_string VARCHAR);\nINSERT INTO binary_table (v) VALUES ($MY_STRING);\nUPDATE binary_table SET b = TO_BINARY(v, 'UTF-8');\nUPDATE binary_table SET b64_string = BASE64_ENCODE(b, 0, '$');\n\nSELECT v\n    FROM binary_table;\n+-----------------------------------------------------------------------------------------+\n| V                                                                                       |\n|-----------------------------------------------------------------------------------------|\n| ABCDEFGHIJKLMNOPQRSTUVWXYZ!@#$%^&*()abcdefghijklmnopqrstuvwzyz1234567890[]{};:,./<>?-=~ |\n+-----------------------------------------------------------------------------------------+\nSELECT b\n    FROM binary_table;\n+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| B                                                                                                                                                                              |\n|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| 4142434445464748494A4B4C4D4E4F505152535455565758595A21402324255E262A28296162636465666768696A6B6C6D6E6F70717273747576777A797A313233343536373839305B5D7B7D3B3A2C2E2F3C3E3F2D3D7E |\n+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\nSELECT b64_string\n    FROM binary_table;\n+----------------------------------------------------------------------------------------------------------------------+\n| B64_STRING                                                                                                           |\n|----------------------------------------------------------------------------------------------------------------------|\n| QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVohQCMkJV4mKigpYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd6eXoxMjM0NTY3ODkwW117fTs6LC4vPD4/LT1$ |\n+----------------------------------------------------------------------------------------------------------------------+\nSELECT BASE64_DECODE_BINARY(b64_string, '$') AS FROM_BASE64_BACK_TO_BINARY\n    FROM binary_table;\n+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| FROM_BASE64_BACK_TO_BINARY                                                                                                                                                     |\n|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| 4142434445464748494A4B4C4D4E4F505152535455565758595A21402324255E262A28296162636465666768696A6B6C6D6E6F70717273747576777A797A313233343536373839305B5D7B7D3B3A2C2E2F3C3E3F2D3D7E |\n+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\nSELECT TO_VARCHAR(BASE64_DECODE_BINARY(b64_string, '$'), 'UTF-8') AS BACK_TO_STRING\n    FROM binary_table;\n+-----------------------------------------------------------------------------------------+\n| BACK_TO_STRING                                                                          |\n|-----------------------------------------------------------------------------------------|\n| ABCDEFGHIJKLMNOPQRSTUVWXYZ!@#$%^&*()abcdefghijklmnopqrstuvwzyz1234567890[]{};:,./<>?-=~ |\n+-----------------------------------------------------------------------------------------+",
    "arguments": [
        {
            "name": "input",
            "description": "A Base64-encoded string expression."
        },
        {
            "name": "alphabet",
            "description": "A string consisting of up to three ASCII characters: The first two characters in the string specify the last two characters (indexes 62 and 63) in the alphabet used to encode the input: A to Z (indexes 0-25) a to z (indexes 26-51) 0 to 9 (indexes 52-61) + and / (indexes 62, 63) Defaults: + and / The third character in the string specifies the character used for padding. Default: ="
        }
    ],
    "returns": "This returns a BINARY value. The value can be inserted into a column of\ntype BINARY, for example."
},
{
    "function_name": "AVG",
    "summary": "Returns the average of non-NULL records.",
    "category": "Aggregate functions , Window functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/avg",
    "title": "AVG",
    "description": "Returns the average of non-NULL records. If all records inside a group are NULL, the function returns NULL.",
    "syntax": "AVG( [ DISTINCT ] <expr1> )",
    "example": "CREATE OR REPLACE TABLE avg_example(int_col int, d decimal(10,5), s1 varchar(10), s2 varchar(10));\nINSERT INTO avg_example VALUES\n    (1, 1.1, '1.1','one'), \n    (1, 10, '10','ten'),\n    (2, 2.4, '2.4','two'), \n    (2, NULL, NULL, 'NULL'),\n    (3, NULL, NULL, 'NULL'),\n    (NULL, 9.9, '9.9','nine');\n\nSELECT * \n    FROM avg_example \n    ORDER BY int_col, d;\n+---------+----------+------+------+\n| INT_COL |        D | S1   | S2   |\n|---------+----------+------+------|\n|       1 |  1.10000 | 1.1  | one  |\n|       1 | 10.00000 | 10   | ten  |\n|       2 |  2.40000 | 2.4  | two  |\n|       2 |     NULL | NULL | NULL |\n|       3 |     NULL | NULL | NULL |\n|    NULL |  9.90000 | 9.9  | nine |\n+---------+----------+------+------+\n\nSELECT AVG(int_col), AVG(d)\n    FROM avg_example;\n+--------------+---------------+\n| AVG(INT_COL) |        AVG(D) |\n|--------------+---------------|\n|     1.800000 | 5.85000000000 |\n+--------------+---------------+\n\nSELECT int_col, AVG(d), AVG(s1) \n    FROM avg_example \n    GROUP BY int_col\n    ORDER BY int_col;\n+---------+---------------+---------+\n| INT_COL |        AVG(D) | AVG(S1) |\n|---------+---------------+---------|\n|       1 | 5.55000000000 |    5.55 |\n|       2 | 2.40000000000 |    2.4  |\n|       3 |          NULL |    NULL |\n|    NULL | 9.90000000000 |    9.9  |\n+---------+---------------+---------+\n\nSELECT \n       int_col,\n       AVG(int_col) OVER(PARTITION BY int_col) \n    FROM avg_example\n    ORDER BY int_col;\n+---------+-----------------------------------------+\n| INT_COL | AVG(INT_COL) OVER(PARTITION BY INT_COL) |\n|---------+-----------------------------------------|\n|       1 |                                   1.000 |\n|       1 |                                   1.000 |\n|       2 |                                   2.000 |\n|       2 |                                   2.000 |\n|       3 |                                   3.000 |\n|    NULL |                                    NULL |\n+---------+-----------------------------------------+",
    "arguments": [
        {
            "name": "expr1",
            "description": "This is an expression that evaluates to a numeric data type (INTEGER, FLOAT, DECIMAL, etc.)."
        },
        {
            "name": "expr2",
            "description": "This is the optional expression to partition by."
        },
        {
            "name": "expr3",
            "description": "This is the optional expression to order by within each partition."
        }
    ]
},
{
    "function_name": "AVAILABLE_LISTING_REFRESH_HISTORY",
    "summary": "Returns the past 14 days of refresh history for an available listing or a database mounted from a listing using cross-cloud auto-fulfillment.",
    "category": "Information Schema , Table functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/available_listing_refresh_history",
    "title": "AVAILABLE_LISTING_REFRESH_HISTORY",
    "description": "Returns the past 14 days of refresh history for an available listing or a database mounted from a listing using cross-cloud\nauto-fulfillment. The information returned contains replication details for data added to the listing database in each refresh event. This\nfunction is available to consumers of listings who have any privilege on the available listing or mounted database.",
    "syntax": "AVAILABLE_LISTING_REFRESH_HISTORY(\n  OBJECT_TYPE => '<object_type>',\n  OBJECT_NAME => '<object_name>' )",
    "example": "SELECT * FROM TABLE(\n  INFORMATION_SCHEMA.AVAILABLE_LISTING_REFRESH_HISTORY(\n    OBJECT_TYPE=>'database',\n    OBJECT_NAME=>'my_mounted_database'\n  )\n);",
    "arguments": [
        {
            "name": "OBJECT_TYPE",
            "description": "Type of the object, either listing or database ."
        },
        {
            "name": "OBJECT_NAME",
            "description": "Name of the object, which can be either the listing’s global name or the mounted database name, depending on the object type."
        }
    ]
},
{
    "function_name": "AUTOMATIC_CLUSTERING_HISTORY",
    "summary": "This table function is used for querying the Automatic Clustering history for given tables within a specified date range.",
    "category": "Information Schema , Table functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/automatic_clustering_history",
    "title": "AUTOMATIC_CLUSTERING_HISTORY",
    "description": "This table function is used for querying the",
    "syntax": "AUTOMATIC_CLUSTERING_HISTORY(\n      [ DATE_RANGE_START => <constant_expr> ]\n      [ , DATE_RANGE_END => <constant_expr> ]\n      [ , TABLE_NAME => '<string>' ] )",
    "example": "select *\n  from table(information_schema.automatic_clustering_history(\n    date_range_start=>'2018-04-10 13:00:00.000 -0700',\n    date_range_end=>'2018-04-10 14:00:00.000 -0700'));\n\nselect *\n  from table(information_schema.automatic_clustering_history(\n    date_range_start=>dateadd(H, -12, current_timestamp)));\n\nselect *\n  from table(information_schema.automatic_clustering_history(\n    date_range_start=>dateadd(D, -7, current_date),\n    date_range_end=>current_date));\n\nselect *\n  from table(information_schema.automatic_clustering_history(\n    date_range_start=>dateadd(D, -7, current_date),\n    date_range_end=>current_date,\n    table_name=>'mydb.myschema.mytable'));",
    "arguments": [
        {
            "name": "DATE_RANGE_START",
            "description": "The date/time range to display the Automatic Clustering history.\nFor example, if you specify that the start date is 2019-04-03 and the end date is 2019-04-05, then you get data for\nApril 3, April 4, and April 5. (The endpoints are included.) If neither a start date nor an end date is specified, the default is the last 12 hours. If an end date is not specified, but a start date is specified, then CURRENT_DATE at midnight is used as the end of the range. If a start date is not specified, but an end date is specified, then the range starts 12 hours prior to the start\nof DATE_RANGE_END ."
        },
        {
            "name": "TABLE_NAME",
            "description": "Table name. If specified, only shows the history for the specified table.\nThe table name can include the schema name and the database name. If a table name is not specified, then the results include history for each table maintained by the\nAutomatic Clustering Service within the specified time range."
        }
    ]
},
{
    "function_name": "AUTO_REFRESH_REGISTRATION_HISTORY",
    "summary": "This table function can be used to query the history of data files registered in the metadata for a specified external table or directory table and the credits billed for these operations.",
    "category": "Information Schema , Table functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/auto_refresh_registration_history",
    "title": "AUTO_REFRESH_REGISTRATION_HISTORY",
    "description": "This table function can be used to query the history of data files registered in the metadata for a specified external table\nor directory table and the credits billed\nfor these operations. The table function returns the billing history for a specified range\nwithin the last 14 days for your entire Snowflake account.",
    "syntax": "AUTO_REFRESH_REGISTRATION_HISTORY(\n      [ DATE_RANGE_START => <constant_expr> ]\n      [, DATE_RANGE_END => <constant_expr> ]\n      [, OBJECT_TYPE => '<string>' [, OBJECT_NAME => '<string>'] ])",
    "example": "select *\n  from table(information_schema.auto_refresh_registration_history(\n    date_range_start=>to_timestamp_tz('2021-06-17 12:00:00.000 -0700'),\n    date_range_end=>to_timestamp_tz('2021-06-17 12:30:00.000 -0700'),\n    object_type=>'external_table'));\n\nselect *\n  from table(information_schema.auto_refresh_registration_history(\n    date_range_start=>dateadd('day',-14,current_date()),\n    date_range_end=>current_date(),\n    object_type=>'external_table'));\n\nselect *\n  from table(information_schema.auto_refresh_registration_history(\n    date_range_start=>dateadd('day',-14,current_date()),\n    date_range_end=>current_date(),\n    object_type=>'external_table'));\n\nselect *\n  from table(information_schema.auto_refresh_registration_history(\n    date_range_start=>dateadd('hour',-12,current_timestamp()),\n    object_type=>'external_table',\n    object_name=>'myexttable'));\n\nselect *\n  from table(information_schema.auto_refresh_registration_history(\n    date_range_start=>dateadd('hour',-12,current_timestamp()),\n    object_type=>'external_table',\n    object_name=>'mydb.myschema.myexttable'));",
    "arguments": [
        {
            "name": "DATE_RANGE_START",
            "description": "The date/time range of the billing window: If an end date is not specified, then CURRENT_DATE is used as the end of the range. If a start date is not specified, then the range starts 10 minutes prior to the start of DATE_RANGE_END (i.e. the default is to\nshow the previous 10 minutes of the billing history). For example, if DATE_RANGE_END is CURRENT_DATE , then the default DATE_RANGE_START is 11:50 PM on the previous day. History is displayed in increments of 5 minutes, 1 hour, or 24 hours (depending on the length of the specified range)."
        },
        {
            "name": "OBJECT_TYPE",
            "description": "Type of object for which credits are billed. The following value is supported: Directory tables that are configured for automatic metadata refreshes. External tables that are configured for automatic metadata refreshes."
        },
        {
            "name": "DIRECTORY_TABLE",
            "description": "Directory tables that are configured for automatic metadata refreshes."
        },
        {
            "name": "EXTERNAL_TABLE",
            "description": "External tables that are configured for automatic metadata refreshes."
        },
        {
            "name": "OBJECT_NAME",
            "description": "A string specifying the name of the external table or directory table for which credits are billed."
        }
    ]
},
{
    "function_name": "ATANH",
    "summary": "Computes the inverse (arc) hyperbolic tangent of its argument.",
    "category": "Numeric functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/atanh",
    "title": "ATANH",
    "description": "Computes the inverse (arc) hyperbolic tangent of its argument.",
    "syntax": "ATANH( <real_expr> )",
    "example": "SELECT ATANH(0.9051482536);\n\n---------------------+\n ATANH(0.9051482536) |\n---------------------+\n 1.5                 |\n---------------------+",
    "arguments": [
        {
            "name": "real_expr",
            "description": "This expression should evaluate to a real number between -1.0 and +1.0\n(inclusive)."
        }
    ]
},
{
    "function_name": "ATAN2",
    "summary": "Computes the inverse tangent (arc tangent) of the ratio of its two arguments.",
    "category": "Numeric functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/atan2",
    "title": "ATAN2",
    "description": "Computes the inverse tangent (arc tangent) of the ratio of its two arguments.\nFor example, if x > 0, then the expression",
    "syntax": "ATAN2( <y> , <x> )",
    "example": "SELECT ATAN2(5, 5);\n\n--------------+\n ATAN2(5, 5)  |\n--------------+\n 0.7853981634 |\n--------------+",
    "arguments": [
        {
            "name": "y",
            "description": "This parameter is the Y coordinate of the point at the end of the ray. The data type is DOUBLE."
        },
        {
            "name": "x",
            "description": "This parameter is the X coordinate of the point at the end of the ray. The data type is DOUBLE."
        }
    ],
    "returns": "The data type of the returned value is DOUBLE."
},
{
    "function_name": "ATAN",
    "summary": "Computes the inverse tangent (arc tangent) of its argument; the result is a number in the interval [-pi, pi].",
    "category": "Numeric functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/atan",
    "title": "ATAN",
    "description": "Computes the inverse tangent (arc tangent) of its argument; the result is a number in the interval",
    "syntax": "ATAN( <real_expr> )",
    "example": "SELECT ATAN(1);\n\n--------------+\n   ATAN(1)    |\n--------------+\n 0.7853981634 |\n--------------+",
    "arguments": [
        {
            "name": "real_expr",
            "description": "This expression should evaluate to a real number."
        }
    ],
    "returns": "Returns the arc tangent in radians (not degrees) in the range [-pi, pi]."
},
{
    "function_name": "ASINH",
    "summary": "Computes the inverse (arc) hyperbolic sine of its argument.",
    "category": "Numeric functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/asinh",
    "title": "ASINH",
    "description": "Computes the inverse (arc) hyperbolic sine of its argument.",
    "syntax": "ASINH( <real_expr> )",
    "example": "SELECT ASINH(2.129279455);\n\n--------------------+\n ASINH(2.129279455) |\n--------------------+\n 1.5                |\n--------------------+",
    "arguments": [
        {
            "name": "real_expr",
            "description": "This expression should evaluate to a real number."
        }
    ]
},
{
    "function_name": "ASIN",
    "summary": "Computes the inverse sine (arc sine) of its argument; the result is a number in the interval [-pi/2, pi/2].",
    "category": "Numeric functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/asin",
    "title": "ASIN",
    "description": "Computes the inverse sine (arc sine) of its argument; the result is a number in the interval",
    "syntax": "ASIN( <real_expr> )",
    "example": "SELECT ASIN(0), ASIN(0.5), ASIN(1);\n\n---------+--------------+-------------+\n ASIN(0) |  ASIN(0.5)   |   ASIN(1)   |\n---------+--------------+-------------+\n 0       | 0.5235987756 | 1.570796327 |\n---------+--------------+-------------+",
    "arguments": [
        {
            "name": "real_expr",
            "description": "This expression should evaluate to a real number greater than or equal\nto -1.0 and less than or equal to +1.0."
        }
    ],
    "returns": "The data type of the return value is FLOAT."
},
{
    "function_name": "ASCII",
    "summary": "Returns the ASCII code for the first character of a string.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/ascii",
    "title": "ASCII",
    "description": "Returns the ASCII code for the first character of a string. If the string is empty, a value of",
    "syntax": "ASCII( <input> )",
    "example": "SELECT column1, ASCII(column1)\n  FROM (values('!'), ('A'), ('a'), ('bcd'), (''), (null));\n+---------+----------------+\n| COLUMN1 | ASCII(COLUMN1) |\n|---------+----------------|\n| !       |             33 |\n| A       |             65 |\n| a       |             97 |\n| bcd     |             98 |\n|         |              0 |\n| NULL    |           NULL |\n+---------+----------------+",
    "arguments": [
        {
            "name": "input",
            "description": "The string for which the ASCII code for the first character in the string is returned."
        }
    ],
    "returns": "The value is an integer that is the numeric representation of the ASCII character. For example, if the\ninput is the letter ‘a’, then the return value is 97."
},
{
    "function_name": "AS_TIMESTAMP_*",
    "summary": "Casts a VARIANT value to the respective timestamp value.",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/as_timestamp",
    "title": "AS_TIMESTAMP_*",
    "description": "Casts a",
    "syntax": "AS_TIMESTAMP_LTZ( <variant_expr> )\n\nAS_TIMESTAMP_NTZ( <variant_expr> )\n\nAS_TIMESTAMP_TZ( <variant_expr> )",
    "example": "CREATE OR REPLACE TABLE as_timestamp_example (timestamp1 VARIANT);\n\nINSERT INTO as_timestamp_example (timestamp1)\n  SELECT TO_VARIANT(TO_TIMESTAMP_NTZ('2024-10-10 12:34:56'));\n\nSELECT AS_TIMESTAMP_NTZ(timestamp1) AS timestamp_value\n  FROM as_timestamp_example;\n\n+-------------------------+\n| TIMESTAMP_VALUE         |\n|-------------------------|\n| 2024-10-10 12:34:56.000 |\n+-------------------------+",
    "arguments": [
        {
            "name": "variant_expr",
            "description": "An expression that evaluates to a value of type VARIANT."
        }
    ],
    "returns": "The function returns a value of a timestamp type or NULL:"
},
{
    "function_name": "AS_TIME",
    "summary": "Casts a VARIANT value to a TIME value.",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/as_time",
    "title": "AS_TIME",
    "description": "Casts a",
    "syntax": "AS_TIME( <variant_expr> )",
    "example": "CREATE OR REPLACE TABLE as_time_example (time1 VARIANT);\n\nINSERT INTO as_time_example (time1)\n  SELECT TO_VARIANT(TO_TIME('12:34:56'));\n\nSELECT AS_TIME(time1) AS time_value\n  FROM as_time_example;\n\n+------------+\n| TIME_VALUE |\n|------------|\n| 12:34:56   |\n+------------+",
    "arguments": [
        {
            "name": "variant_expr",
            "description": "An expression that evaluates to a value of type VARIANT."
        }
    ],
    "returns": "The function returns a value of type TIME or NULL:"
},
{
    "function_name": "AS_OBJECT",
    "summary": "Casts a VARIANT value to an OBJECT value.",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/as_object",
    "title": "AS_OBJECT",
    "description": "Casts a",
    "syntax": "AS_OBJECT( <variant_expr> )",
    "example": "CREATE OR REPLACE TABLE as_object_example (object1 VARIANT);\n\nINSERT INTO as_object_example (object1)\n  SELECT TO_VARIANT(TO_OBJECT(PARSE_JSON('{\"Tree\": \"Pine\"}')));\n\nSELECT AS_OBJECT(object1) AS object_value\n  FROM as_object_example;\n\n+------------------+\n| OBJECT_VALUE     |\n|------------------|\n| {                |\n|   \"Tree\": \"Pine\" |\n| }                |\n+------------------+",
    "arguments": [
        {
            "name": "variant_expr",
            "description": "An expression that evaluates to a value of type VARIANT."
        }
    ],
    "returns": "The function returns a value of type OBJECT or NULL:"
},
{
    "function_name": "AS_INTEGER",
    "summary": "Casts a VARIANT value to an INTEGER.",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/as_integer",
    "title": "AS_INTEGER",
    "description": "Casts a",
    "syntax": "AS_INTEGER( <variant_expr> )",
    "example": "CREATE OR REPLACE TABLE as_integer_example (integer1 VARIANT);\n\nINSERT INTO as_integer_example (integer1)\n  SELECT TO_VARIANT(15);\n\nSELECT AS_INTEGER(integer1) AS integer_value\n  FROM as_integer_example;\n\n+---------------+\n| INTEGER_VALUE |\n|---------------|\n|            15 |\n+---------------+",
    "arguments": [
        {
            "name": "variant_expr",
            "description": "An expression that evaluates to a value of type VARIANT."
        }
    ],
    "returns": "The function returns a value of type INTEGER or NULL:"
},
{
    "function_name": "AS_DOUBLE , AS_REAL",
    "summary": "Casts a VARIANT value to a floating-point value.",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/as_double-real",
    "title": "AS_DOUBLE , AS_REAL",
    "description": "Casts a",
    "syntax": "AS_DOUBLE( <variant_expr> )\n\nAS_REAL( <variant_expr> )",
    "example": "CREATE OR REPLACE TABLE as_double_example (double1 VARIANT);\n\nINSERT INTO as_double_example (double1)\n  SELECT TO_VARIANT(TO_DOUBLE(1.23));\n\nSELECT AS_DOUBLE(double1) double_value\n  FROM as_double_float_example;\n\n+--------------+\n| DOUBLE_VALUE |\n|--------------|\n|         1.23 |\n+--------------+",
    "arguments": [
        {
            "name": "variant_expr",
            "description": "An expression that evaluates to a value of type VARIANT."
        }
    ],
    "returns": "The function returns a floating-point value or NULL:"
},
{
    "function_name": "AS_DECIMAL , AS_NUMBER",
    "summary": "Casts a VARIANT value to a fixed-point NUMBER value, with optional precision and scale.",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/as_decimal-number",
    "title": "AS_DECIMAL , AS_NUMBER",
    "description": "Casts a",
    "syntax": "AS_DECIMAL( <variant_expr> [ , <precision> [ , <scale> ] ] )\n\nAS_NUMBER( <variant_expr> [ , <precision> [ , <scale> ] ] )",
    "example": "CREATE OR REPLACE TABLE as_number_example (number1 VARIANT);\n\nINSERT INTO as_number_example (number1)\n  SELECT TO_VARIANT(TO_NUMBER(2.34, 6, 3));\n\nSELECT AS_NUMBER(number1, 6, 3) number_value\n  FROM as_number_example;\n\n+--------------+\n| NUMBER_VALUE |\n|--------------|\n|        2.340 |\n+--------------+",
    "arguments": [
        {
            "name": "variant_expr",
            "description": "An expression that evaluates to a value of type VARIANT."
        },
        {
            "name": "precision",
            "description": "The number of significant digits of the decimal number to store. The default is 38 ."
        },
        {
            "name": "scale",
            "description": "The number of significant digits after the decimal point. The default is 0 ."
        }
    ],
    "returns": "The function returns a value of type NUMBER or NULL:"
},
{
    "function_name": "AS_DATE",
    "summary": "Casts a VARIANT value to a DATE value.",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/as_date",
    "title": "AS_DATE",
    "description": "Casts a",
    "syntax": "AS_DATE( <variant_expr> )",
    "example": "CREATE OR REPLACE TABLE as_date_example (date1 VARIANT);\n\nINSERT INTO as_date_example (date1)\n SELECT TO_VARIANT(TO_DATE('2024-10-10'));\n\nSELECT AS_DATE(date1) date_value\n  FROM as_date_example;\n\n+------------+\n| DATE_VALUE |\n|------------|\n| 2024-10-10 |\n+------------+",
    "arguments": [
        {
            "name": "variant_expr",
            "description": "An expression that evaluates to a value of type VARIANT."
        }
    ],
    "returns": "The function returns a value of type DATE or NULL:"
},
{
    "function_name": "AS_CHAR , AS_VARCHAR",
    "summary": "Casts a VARIANT value to a VARCHAR value.",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/as_char-varchar",
    "title": "AS_CHAR , AS_VARCHAR",
    "description": "Casts a",
    "syntax": "AS_CHAR( <variant_expr> )\n\nAS_VARCHAR( <variant_expr> )",
    "example": "CREATE OR REPLACE TABLE as_varchar_example (varchar1 VARIANT);\n\nINSERT INTO as_varchar_example (varchar1)\n  SELECT TO_VARIANT('My VARCHAR value');\n\nSELECT AS_VARCHAR(varchar1) varchar_value\n  FROM as_varchar_example;\n\n+------------------+\n| VARCHAR_VALUE    |\n|------------------|\n| My VARCHAR value |\n+------------------+",
    "arguments": [
        {
            "name": "variant_expr",
            "description": "An expression that evaluates to a value of type VARIANT."
        }
    ],
    "returns": "The function returns a value of type VARCHAR or NULL:"
},
{
    "function_name": "AS_BOOLEAN",
    "summary": "Casts a VARIANT value to a BOOLEAN value.",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/as_boolean",
    "title": "AS_BOOLEAN",
    "description": "Casts a",
    "syntax": "AS_BOOLEAN( <variant_expr> )",
    "example": "CREATE OR REPLACE TABLE as_boolean_example (\n  boolean1 VARIANT,\n  boolean2 VARIANT);\n\nINSERT INTO as_boolean_example (boolean1, boolean2)\n  SELECT\n    TO_VARIANT(TO_BOOLEAN(TRUE)),\n    TO_VARIANT(TO_BOOLEAN(FALSE));\n\nSELECT AS_BOOLEAN(boolean1) boolean_true,\n       AS_BOOLEAN(boolean2) boolean_false\n  FROM as_boolean_example;\n\n+--------------+---------------+\n| BOOLEAN_TRUE | BOOLEAN_FALSE |\n|--------------+---------------|\n| True         | False         |\n+--------------+---------------+",
    "arguments": [
        {
            "name": "variant_expr",
            "description": "An expression that evaluates to a value of type VARIANT."
        }
    ],
    "returns": "The function returns a value of type BOOLEAN or NULL:"
},
{
    "function_name": "AS_BINARY",
    "summary": "Casts a VARIANT value to a BINARY value.",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/as_binary",
    "title": "AS_BINARY",
    "description": "Casts a",
    "syntax": "AS_BINARY( <variant_expr> )",
    "example": "CREATE OR REPLACE TABLE as_binary_example (binary1 VARIANT);\n\nINSERT INTO as_binary_example (binary1)\n  SELECT TO_VARIANT(TO_BINARY('F0A5'));\n\nSELECT AS_BINARY(binary1) AS binary_value\n  FROM as_binary_example;\n\n+--------------+\n| BINARY_VALUE |\n|--------------|\n| F0A5         |\n+--------------+",
    "arguments": [
        {
            "name": "variant_expr",
            "description": "An expression that evaluates to a value of type VARIANT."
        }
    ],
    "returns": "The function returns a value of type BINARY or NULL:"
},
{
    "function_name": "AS_ARRAY",
    "summary": "Casts a VARIANT value to an ARRAY value.",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/as_array",
    "title": "AS_ARRAY",
    "description": "Casts a",
    "syntax": "AS_ARRAY( <variant_expr> )",
    "example": "CREATE OR REPLACE TABLE as_array_example (\n  array1 VARIANT,\n  array2 VARIANT);\n\nINSERT INTO as_array_example (array1, array2)\n  SELECT\n    TO_VARIANT(TO_ARRAY('Example')),\n    TO_VARIANT(ARRAY_CONSTRUCT('Array-like', 'example'));\n\nSELECT AS_ARRAY(array1) AS array1,\n       AS_ARRAY(array2) AS array2\n  FROM as_array_example;\n\n+-------------+-----------------+\n| ARRAY1      | ARRAY2          |\n|-------------+-----------------|\n| [           | [               |\n|   \"Example\" |   \"Array-like\", |\n| ]           |   \"example\"     |\n|             | ]               |\n+-------------+-----------------+",
    "arguments": [
        {
            "name": "variant_expr",
            "description": "An expression that evaluates to a value of type VARIANT."
        }
    ],
    "returns": "The function returns a value of type ARRAY or NULL:"
},
{
    "function_name": "AS_<object_type>",
    "summary": "You can use this family of functions to perform strict casting of VARIANT values to values of other data types.",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/as",
    "title": "AS_",
    "description": "You can use this family of functions to perform strict casting of VARIANT values to values of other data types:",
    "example": "CREATE OR REPLACE TABLE multiple_types_example (\n  array1 VARIANT,\n  array2 VARIANT,\n  boolean1 VARIANT,\n  char1 VARIANT,\n  varchar1 VARIANT,\n  decimal1 VARIANT,\n  double1 VARIANT,\n  integer1 VARIANT,\n  object1 VARIANT);\n\nINSERT INTO multiple_types_example\n  (array1, array2, boolean1, char1, varchar1,\n   decimal1, double1, integer1, object1)\n  SELECT\n    TO_VARIANT(TO_ARRAY('Example')),\n    TO_VARIANT(ARRAY_CONSTRUCT('Array-like', 'example')),\n    TO_VARIANT(TRUE),\n    TO_VARIANT('X'),\n    TO_VARIANT('Y'),\n    TO_VARIANT(1.23::DECIMAL(6, 3)),\n    TO_VARIANT(3.21::DOUBLE),\n    TO_VARIANT(15),\n    TO_VARIANT(TO_OBJECT(PARSE_JSON('{\"Tree\": \"Pine\"}')));\n\nSELECT AS_ARRAY(array1) AS array1,\n       AS_ARRAY(array2) AS array2,\n       AS_BOOLEAN(boolean1) AS boolean,\n       AS_CHAR(char1) AS char,\n       AS_VARCHAR(varchar1) AS varchar,\n       AS_DECIMAL(decimal1, 6, 3) AS decimal,\n       AS_DOUBLE(double1) AS double,\n       AS_INTEGER(integer1) AS integer,\n       AS_OBJECT(object1) AS object\n  FROM multiple_types_example;\n\n+-------------+-----------------+---------+------+---------+---------+--------+---------+------------------+\n| ARRAY1      | ARRAY2          | BOOLEAN | CHAR | VARCHAR | DECIMAL | DOUBLE | INTEGER | OBJECT           |\n|-------------+-----------------+---------+------+---------+---------+--------+---------+------------------|\n| [           | [               | True    | X    | Y       |   1.230 |   3.21 |      15 | {                |\n|   \"Example\" |   \"Array-like\", |         |      |         |         |        |         |   \"Tree\": \"Pine\" |\n| ]           |   \"example\"     |         |      |         |         |        |         | }                |\n|             | ]               |         |      |         |         |        |         |                  |\n+-------------+-----------------+---------+------+---------+---------+--------+---------+------------------+\n\nCREATE OR REPLACE TABLE vartab (n NUMBER(2), v VARIANT);\n\nINSERT INTO vartab\n  SELECT column1 AS n, PARSE_JSON(column2) AS v\n    FROM VALUES (1, 'null'), \n                (2, null), \n                (3, 'true'),\n                (4, '-17'), \n                (5, '123.12'), \n                (6, '1.912e2'),\n                (7, '\"Om ara pa ca na dhih\"  '), \n                (8, '[-1, 12, 289, 2188, false,]'), \n                (9, '{ \"x\" : \"abc\", \"y\" : false, \"z\": 10} ') \n       AS vals;\n\nSELECT n, AS_REAL(v), TYPEOF(v)\n  FROM vartab\n  ORDER BY n;\n\n+---+------------+------------+\n| N | AS_REAL(V) | TYPEOF(V)  |\n|---+------------+------------|\n| 1 |       NULL | NULL_VALUE |\n| 2 |       NULL | NULL       |\n| 3 |       NULL | BOOLEAN    |\n| 4 |     -17    | INTEGER    |\n| 5 |     123.12 | DECIMAL    |\n| 6 |     191.2  | DOUBLE     |\n| 7 |       NULL | VARCHAR    |\n| 8 |       NULL | ARRAY      |\n| 9 |       NULL | OBJECT     |\n+---+------------+------------+\n\nSELECT AVG(AS_REAL(v)) FROM vartab;\n\n+-----------------+\n| AVG(AS_REAL(V)) |\n|-----------------|\n|    99.106666667 |\n+-----------------+"
},
{
    "function_name": "ARRAYS_ZIP",
    "summary": "Returns an array of objects, each of which contains key-value pairs for an nth element in the input arrays.",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/arrays_zip",
    "title": "ARRAYS_ZIP",
    "description": "Returns an",
    "syntax": "ARRAYS_ZIP( <array> [ , <array> ... ] )",
    "example": "SELECT ARRAYS_ZIP(\n  [1, 2, 3]\n) AS zipped_array;\n\n+--------------+\n| ZIPPED_ARRAY |\n|--------------|\n| [            |\n|   {          |\n|     \"$1\": 1  |\n|   },         |\n|   {          |\n|     \"$1\": 2  |\n|   },         |\n|   {          |\n|     \"$1\": 3  |\n|   }          |\n| ]            |\n+--------------+\n\nSELECT ARRAYS_ZIP(\n  [1, 2, 3],\n  [10, 20, 30],\n  [100, 200, 300]\n) AS zipped_array;\n\n+---------------+\n| ZIPPED_ARRAY  |\n|---------------|\n| [             |\n|   {           |\n|     \"$1\": 1,  |\n|     \"$2\": 10, |\n|     \"$3\": 100 |\n|   },          |\n|   {           |\n|     \"$1\": 2,  |\n|     \"$2\": 20, |\n|     \"$3\": 200 |\n|   },          |\n|   {           |\n|     \"$1\": 3,  |\n|     \"$2\": 30, |\n|     \"$3\": 300 |\n|   }           |\n| ]             |\n+---------------+\n\nSELECT ARRAYS_ZIP(\n  [1, 2, 3],\n  ['one'],\n  ['I', 'II']\n) AS zipped_array;\n\n+------------------+\n| ZIPPED_ARRAY     |\n|------------------|\n| [                |\n|   {              |\n|     \"$1\": 1,     |\n|     \"$2\": \"one\", |\n|     \"$3\": \"I\"    |\n|   },             |\n|   {              |\n|     \"$1\": 2,     |\n|     \"$2\": null,  |\n|     \"$3\": \"II\"   |\n|   },             |\n|   {              |\n|     \"$1\": 3,     |\n|     \"$2\": null,  |\n|     \"$3\": null   |\n|   }              |\n| ]                |\n+------------------+\n\nSELECT ARRAYS_ZIP(\n  [1, 2, 3],\n  NULL,\n  [100, 200, 300]\n) AS zipped_array;\n\n+--------------+\n| ZIPPED_ARRAY |\n|--------------|\n| NULL         |\n+--------------+\n\nSELECT ARRAYS_ZIP(\n  [], [], []\n) AS zipped_array;\n\n+--------------+\n| ZIPPED_ARRAY |\n|--------------|\n| [            |\n|   {}         |\n| ]            |\n+--------------+\n\nSELECT ARRAYS_ZIP(\n  [1, NULL, 3],\n  [NULL, 20, NULL],\n  [100, NULL, 300]\n) AS zipped_array;\n\n+-----------------+\n| ZIPPED_ARRAY    |\n|-----------------|\n| [               |\n|   {             |\n|     \"$1\": 1,    |\n|     \"$2\": null, |\n|     \"$3\": 100   |\n|   },            |\n|   {             |\n|     \"$1\": null, |\n|     \"$2\": 20,   |\n|     \"$3\": null  |\n|   },            |\n|   {             |\n|     \"$1\": 3,    |\n|     \"$2\": null, |\n|     \"$3\": 300   |\n|   }             |\n| ]               |\n+-----------------+",
    "arguments": [
        {
            "name": "array",
            "description": "An input array. The input arrays can be of different lengths. If any of the input arrays is a structured array , all input arrays must be\nstructured arrays."
        }
    ],
    "returns": "Returns a value of one of the following types:"
},
{
    "function_name": "ARRAYS_TO_OBJECT",
    "summary": "Returns an OBJECT that contains the keys specified by one input ARRAY and the values specified by another input ARRAY.",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/arrays_to_object",
    "title": "ARRAYS_TO_OBJECT",
    "description": "Returns an",
    "syntax": "ARRAYS_TO_OBJECT( <key_array> , <value_array> )",
    "example": "SELECT ARRAYS_TO_OBJECT(['key1', 'key2', 'key3'], [1, 2, 3]);\n\n+-------------------------------------------------------+\n| ARRAYS_TO_OBJECT(['KEY1', 'KEY2', 'KEY3'], [1, 2, 3]) |\n|-------------------------------------------------------|\n| {                                                     |\n|   \"key1\": 1,                                          |\n|   \"key2\": 2,                                          |\n|   \"key3\": 3                                           |\n| }                                                     |\n+-------------------------------------------------------+\n\nSELECT ARRAYS_TO_OBJECT(['key1', NULL, 'key3'], [1, 2, 3]);\n\n+-----------------------------------------------------+\n| ARRAYS_TO_OBJECT(['KEY1', NULL, 'KEY3'], [1, 2, 3]) |\n|-----------------------------------------------------|\n| {                                                   |\n|   \"key1\": 1,                                        |\n|   \"key3\": 3                                         |\n| }                                                   |\n+-----------------------------------------------------+\n\nSELECT ARRAYS_TO_OBJECT(['key1', 'key2', 'key3'], [1, NULL, 3]);\n\n+----------------------------------------------------------+\n| ARRAYS_TO_OBJECT(['KEY1', 'KEY2', 'KEY3'], [1, NULL, 3]) |\n|----------------------------------------------------------|\n| {                                                        |\n|   \"key1\": 1,                                             |\n|   \"key2\": null,                                          |\n|   \"key3\": 3                                              |\n| }                                                        |\n+----------------------------------------------------------+",
    "arguments": [
        {
            "name": "key_array",
            "description": "ARRAY of VARCHAR values that specify the keys for the new OBJECT."
        },
        {
            "name": "value_array",
            "description": "ARRAY of values for the new OBJECT. This ARRAY must be the same length as key_array . The values in this ARRAY should\ncorrespond to the keys in key_array ."
        }
    ],
    "returns": "The function returns a value of the type OBJECT. The OBJECT contains the keys and values specified by the input ARRAYs."
},
{
    "function_name": "ARRAYS_OVERLAP",
    "summary": "Compares whether two arrays have at least one element in common.",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/arrays_overlap",
    "title": "ARRAYS_OVERLAP",
    "description": "Compares whether two arrays have at least one element in common. Returns TRUE if there is at least one element in common; otherwise returns FALSE. The function is NULL-safe, meaning it treats NULLs as known values for comparing equality.",
    "syntax": "ARRAYS_OVERLAP( <array1> , <array2> )",
    "example": "SELECT ARRAYS_OVERLAP(array_construct('hello', 'aloha'), \n                      array_construct('hello', 'hi', 'hey'))\n  AS Overlap;\n+---------+\n| OVERLAP |\n|---------|\n| True    |\n+---------+\nSELECT ARRAYS_OVERLAP(array_construct('hello', 'aloha'), \n                      array_construct('hola', 'bonjour', 'ciao'))\n  AS Overlap;\n+---------+\n| OVERLAP |\n|---------|\n| False   |\n+---------+\nSELECT ARRAYS_OVERLAP(array_construct(object_construct('a',1,'b',2), 1, 2), \n                      array_construct(object_construct('b',2,'c',3), 3, 4))\n  AS Overlap;\n+---------+\n| OVERLAP |\n|---------|\n| False   |\n+---------+\nSELECT ARRAYS_OVERLAP(array_construct(object_construct('a',1,'b',2), 1, 2), \n                      array_construct(object_construct('a',1,'b',2), 3, 4))\n  AS Overlap;\n+---------+\n| OVERLAP |\n|---------|\n| True    |\n+---------+\n\nSELECT ARRAYS_OVERLAP(ARRAY_CONSTRUCT(1, 2, NULL),\n                      ARRAY_CONSTRUCT(3, NULL, 5))\n AS Overlap;\n+---------+\n| OVERLAP |\n|---------|\n| True    |\n+---------+"
},
{
    "function_name": "ARRAY_UNIQUE_AGG",
    "summary": "Returns an ARRAY that contains all of the distinct values from the specified column.",
    "category": "Aggregate functions , Window functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/array_unique_agg",
    "title": "ARRAY_UNIQUE_AGG",
    "description": "Returns an",
    "syntax": "ARRAY_UNIQUE_AGG( <column> )",
    "arguments": [
        {
            "name": "column",
            "description": "The column containing the values."
        }
    ],
    "returns": "The function returns an ARRAY containing the distinct values in the specified column. The values in the ARRAY are in no particular\norder, and the order is not deterministic."
},
{
    "function_name": "ARRAY_UNION_AGG",
    "summary": "Returns an ARRAY that contains the union of the distinct values from the input ARRAYs in a column.",
    "category": "Aggregate functions , Window functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/array_union_agg",
    "title": "ARRAY_UNION_AGG",
    "description": "Returns an",
    "syntax": "ARRAY_UNION_AGG( <column> )",
    "example": "CREATE TABLE union_test(a array);\n\nINSERT INTO union_test\n    SELECT PARSE_JSON('[ 1, 1, 2]')\n    UNION ALL\n    SELECT PARSE_JSON('[ 1, 2, 3]');\n\nSELECT ARRAY_UNION_AGG(a) FROM union_test;\n+-------------------------+\n| ARRAY_UNION_AGG(A)      |\n+-------------------------+\n| [ 1, 1, 2, 3]           |\n+-------------------------+",
    "arguments": [
        {
            "name": "column",
            "description": "The column containing the ARRAYs with the distinct values (the ARRAYs produced by ARRAY_UNIQUE_AGG )."
        }
    ],
    "returns": "The function returns an ARRAY containing the distinct values from the ARRAYs in column. The values in the ARRAY are in\nno particular order, and the order is not deterministic."
},
{
    "function_name": "ARRAY_TO_STRING",
    "summary": "Returns an input array converted to a string by casting all values to strings (using TO_VARCHAR) and concatenating them (using the string from the second argument to separate the elements).",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/array_to_string",
    "title": "ARRAY_TO_STRING",
    "description": "Returns an input array converted to a string by casting all values to strings (using",
    "syntax": "ARRAY_TO_STRING( <array> , <separator_string> )",
    "example": "SELECT column1,\n       ARRAY_TO_STRING(PARSE_JSON(column1), '') AS no_separation,\n       ARRAY_TO_STRING(PARSE_JSON(column1), ', ') AS comma_separated\n  FROM VALUES\n    (NULL),\n    ('[]'),\n    ('[1]'),\n    ('[1, 2]'),\n    ('[true, 1, -1.2e-3, \"Abc\", [\"x\",\"y\"], {\"a\":1}]'),\n    ('[, 1]'),\n    ('[1, ]'),\n    ('[1, , ,2]');\n\n+-----------------------------------------------+---------------------------------+-------------------------------------------+\n| COLUMN1                                       | NO_SEPARATION                   | COMMA_SEPARATED                           |\n|-----------------------------------------------+---------------------------------+-------------------------------------------|\n| NULL                                          | NULL                            | NULL                                      |\n| []                                            |                                 |                                           |\n| [1]                                           | 1                               | 1                                         |\n| [1, 2]                                        | 12                              | 1, 2                                      |\n| [true, 1, -1.2e-3, \"Abc\", [\"x\",\"y\"], {\"a\":1}] | true1-0.0012Abc[\"x\",\"y\"]{\"a\":1} | true, 1, -0.0012, Abc, [\"x\",\"y\"], {\"a\":1} |\n| [, 1]                                         | 1                               | , 1                                       |\n| [1, ]                                         | 1                               | 1,                                        |\n| [1, , ,2]                                     | 12                              | 1, , , 2                                  |\n+-----------------------------------------------+---------------------------------+-------------------------------------------+\n\nCREATE TABLE test_array_to_string_with_null(a ARRAY);\n\nINSERT INTO test_array_to_string_with_null\n  SELECT (['A', NULL, 'B']);\n\nSELECT a,\n       ARRAY_TO_STRING(a, ''),\n       ARRAY_TO_STRING(a, ', ')\n  FROM test_array_to_string_with_null;\n\n+--------------+------------------------+--------------------------+\n| A            | ARRAY_TO_STRING(A, '') | ARRAY_TO_STRING(A, ', ') |\n|--------------+------------------------+--------------------------|\n| [            | AB                     | A, , B                   |\n|   \"A\",       |                        |                          |\n|   undefined, |                        |                          |\n|   \"B\"        |                        |                          |\n| ]            |                        |                          |\n+--------------+------------------------+--------------------------+",
    "arguments": [
        {
            "name": "array",
            "description": "The array of elements to convert to a string."
        },
        {
            "name": "separator_string",
            "description": "The string to put between each element, typically a space, comma, or other human-readable separator."
        }
    ],
    "returns": "This function returns a value of type VARCHAR."
},
{
    "function_name": "ARRAY_SLICE",
    "summary": "Returns an array constructed from a specified subset of elements of the input array.",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/array_slice",
    "title": "ARRAY_SLICE",
    "description": "Returns an array constructed from a specified subset of elements of the input array.",
    "syntax": "ARRAY_SLICE( <array> , <from> , <to> )",
    "example": "SELECT ARRAY_SLICE([0,1,2,3,4,5,6], 0, 2);\n\n+------------------------------------+\n| ARRAY_SLICE([0,1,2,3,4,5,6], 0, 2) |\n|------------------------------------|\n| [                                  |\n|   0,                               |\n|   1                                |\n| ]                                  |\n+------------------------------------+\n\nSELECT ARRAY_SLICE([0,1,2,3,4,5,6], 3, ARRAY_SIZE([0,1,2,3,4,5,6])) AS slice_to_last_index;\n\n+---------------------+\n| SLICE_TO_LAST_INDEX |\n|---------------------|\n| [                   |\n|   3,                |\n|   4,                |\n|   5,                |\n|   6                 |\n| ]                   |\n+---------------------+\n\nSELECT ARRAY_SLICE(['foo','snow','flake','bar'], 1, 3);\n\n+-------------------------------------------------+\n| ARRAY_SLICE(['FOO','SNOW','FLAKE','BAR'], 1, 3) |\n|-------------------------------------------------|\n| [                                               |\n|   \"snow\",                                       |\n|   \"flake\"                                       |\n| ]                                               |\n+-------------------------------------------------+\n\nSELECT ARRAY_SLICE(NULL, 2, 3);\n\n+-------------------------+\n| ARRAY_SLICE(NULL, 2, 3) |\n|-------------------------|\n| NULL                    |\n+-------------------------+\n\nSELECT ARRAY_SLICE([0,1,2,3,4,5,6], NULL, 2);\n\n+---------------------------------------+\n| ARRAY_SLICE([0,1,2,3,4,5,6], NULL, 2) |\n|---------------------------------------|\n| NULL                                  |\n+---------------------------------------+\n\nSELECT ARRAY_SLICE([0,1,2,3,4,5,6], 0, -2);\n\n+-------------------------------------+\n| ARRAY_SLICE([0,1,2,3,4,5,6], 0, -2) |\n|-------------------------------------|\n| [                                   |\n|   0,                                |\n|   1,                                |\n|   2,                                |\n|   3,                                |\n|   4                                 |\n| ]                                   |\n+-------------------------------------+\n\nSELECT ARRAY_SLICE([0,1,2,3,4,5,6], -5, -3);\n\n+--------------------------------------+\n| ARRAY_SLICE([0,1,2,3,4,5,6], -5, -3) |\n|--------------------------------------|\n| [                                    |\n|   2,                                 |\n|   3                                  |\n| ]                                    |\n+--------------------------------------+\n\nSELECT ARRAY_SLICE([0,1,2,3,4,5,6], 10, 12);\n\n+--------------------------------------+\n| ARRAY_SLICE([0,1,2,3,4,5,6], 10, 12) |\n|--------------------------------------|\n| []                                   |\n+--------------------------------------+\n\nSELECT ARRAY_SLICE([0,1,2,3,4,5,6], -10, -12);\n\n+----------------------------------------+\n| ARRAY_SLICE([0,1,2,3,4,5,6], -10, -12) |\n|----------------------------------------|\n| []                                     |\n+----------------------------------------+",
    "arguments": [
        {
            "name": "array",
            "description": "The source array of which a subset of the elements are used to construct the resulting array."
        },
        {
            "name": "from",
            "description": "A position in the source array. The position of the first element is 0 . Elements from positions less than from aren’t included in the resulting array."
        },
        {
            "name": "to",
            "description": "A position in the source array. Elements from positions equal to or greater than to are not included in\nthe resulting array."
        }
    ],
    "returns": "This function returns a value of type ARRAY."
},
{
    "function_name": "ARRAY_SORT",
    "summary": "Returns an ARRAY that contains the elements of the input ARRAY sorted in ascending or descending order.",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/array_sort",
    "title": "ARRAY_SORT",
    "description": "Returns an",
    "syntax": "ARRAY_SORT( <array> [ , <sort_ascending> [ , <nulls_first> ] ] )",
    "example": "SELECT ARRAY_SORT([20, PARSE_JSON('null'), 0, NULL, 10]);\n\n+---------------------------------------------------+\n| ARRAY_SORT([20, PARSE_JSON('NULL'), 0, NULL, 10]) |\n|---------------------------------------------------|\n| [                                                 |\n|   0,                                              |\n|   10,                                             |\n|   20,                                             |\n|   null,                                           |\n|   undefined                                       |\n| ]                                                 |\n+---------------------------------------------------+\n\nSELECT ARRAY_SORT([20, PARSE_JSON('null'), 0, NULL, 10], FALSE);\n\n+----------------------------------------------------------+\n| ARRAY_SORT([20, PARSE_JSON('NULL'), 0, NULL, 10], FALSE) |\n|----------------------------------------------------------|\n| [                                                        |\n|   undefined,                                             |\n|   null,                                                  |\n|   20,                                                    |\n|   10,                                                    |\n|   0                                                      |\n| ]                                                        |\n+----------------------------------------------------------+\n\nSELECT ARRAY_SORT([20, PARSE_JSON('null'), 0, NULL, 10], TRUE, TRUE);\n\n+---------------------------------------------------------------+\n| ARRAY_SORT([20, PARSE_JSON('NULL'), 0, NULL, 10], TRUE, TRUE) |\n|---------------------------------------------------------------|\n| [                                                             |\n|   undefined,                                                  |\n|   0,                                                          |\n|   10,                                                         |\n|   20,                                                         |\n|   null                                                        |\n| ]                                                             |\n+---------------------------------------------------------------+\n\nSELECT ARRAY_SORT([20, PARSE_JSON('null'), 0, NULL, 10], FALSE, FALSE);\n\n+-----------------------------------------------------------------+\n| ARRAY_SORT([20, PARSE_JSON('NULL'), 0, NULL, 10], FALSE, FALSE) |\n|-----------------------------------------------------------------|\n| [                                                               |\n|   null,                                                         |\n|   20,                                                           |\n|   10,                                                           |\n|   0,                                                            |\n|   undefined                                                     |\n| ]                                                               |\n+-----------------------------------------------------------------+\n\nSELECT ARRAY_INSERT(ARRAY_INSERT(ARRAY_CONSTRUCT(), 3, 2), 6, 1) arr, ARRAY_SORT(arr);\n\n+--------------+-----------------+\n| ARR          | ARRAY_SORT(ARR) |\n|--------------+-----------------|\n| [            | [               |\n|   undefined, |   1,            |\n|   undefined, |   2,            |\n|   undefined, |   undefined,    |\n|   2,         |   undefined,    |\n|   undefined, |   undefined,    |\n|   undefined, |   undefined,    |\n|   1          |   undefined     |\n| ]            | ]               |\n+--------------+-----------------+\n\nSELECT ARRAY_SORT([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1e0::REAL]) AS array_of_different_numeric_types;\n\n+----------------------------------+\n| ARRAY_OF_DIFFERENT_NUMERIC_TYPES |\n|----------------------------------|\n| [                                |\n|   1,                             |\n|   1.000000000000000e+00,         |\n|   1,                             |\n|   1,                             |\n|   1,                             |\n|   1,                             |\n|   1,                             |\n|   1,                             |\n|   1,                             |\n|   1,                             |\n|   1,                             |\n|   1,                             |\n|   1,                             |\n|   1,                             |\n|   1,                             |\n|   1,                             |\n|   1                              |\n| ]                                |\n+----------------------------------+",
    "arguments": [
        {
            "name": "array",
            "description": "The ARRAY of elements to sort."
        },
        {
            "name": "sort_ascending",
            "description": "Specifies whether to sort the elements in ascending or descending order: Specify TRUE to sort the elements in ascending order. Specify FALSE to sort the elements in descending order. Default: TRUE"
        },
        {
            "name": "nulls_first",
            "description": "Specifies whether to place SQL NULL elements at the beginning or end of the sorted ARRAY: Specify TRUE to place the SQL NULL elements first in the ARRAY. Specify FALSE to place the SQL NULL elements last in the ARRAY. Default: FALSE if the ARRAY is sorted in ascending order; TRUE if the ARRAY is sorted in descending order. This argument only affects the order of SQL NULL elements. This does not affect the order of JSON null elements."
        }
    ],
    "returns": "This function returns an ARRAY that contains the elements of array in sorted order."
},
{
    "function_name": "ARRAY_SIZE",
    "summary": "Returns the size of the input array.",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/array_size",
    "title": "ARRAY_SIZE",
    "description": "Returns the size of the input array.",
    "syntax": "ARRAY_SIZE( <array> )\n\nARRAY_SIZE( <variant> )",
    "example": "SELECT ARRAY_SIZE(ARRAY_CONSTRUCT(1, 2, 3)) AS SIZE;\n+------+\n| SIZE |\n|------|\n|    3 |\n+------+\n\nCREATE OR replace TABLE colors (v variant);\n\nINSERT INTO\n   colors\n   SELECT\n      parse_json(column1) AS v\n   FROM\n   VALUES\n     ('[{r:255,g:12,b:0},{r:0,g:255,b:0},{r:0,g:0,b:255}]'),\n     ('[{r:255,g:128,b:0},{r:128,g:255,b:0},{r:0,g:255,b:128},{r:0,g:128,b:255},{r:128,g:0,b:255},{r:255,g:0,b:128}]')\n    v;\n\nSELECT ARRAY_SIZE(v) from colors;\n+---------------+\n| ARRAY_SIZE(V) |\n|---------------|\n|             3 |\n|             6 |\n+---------------+\n\nSELECT GET(v, ARRAY_SIZE(v)-1) FROM colors;\n+-------------------------+\n| GET(V, ARRAY_SIZE(V)-1) |\n|-------------------------|\n| {                       |\n|   \"b\": 255,             |\n|   \"g\": 0,               |\n|   \"r\": 0                |\n| }                       |\n| {                       |\n|   \"b\": 128,             |\n|   \"g\": 0,               |\n|   \"r\": 255              |\n| }                       |\n+-------------------------+",
    "returns": "The data type of the returned value is INTEGER."
},
{
    "function_name": "ARRAY_REVERSE",
    "summary": "Returns an array with the elements of the input array in reverse order.",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/array_reverse",
    "title": "ARRAY_REVERSE",
    "description": "Returns an",
    "syntax": "ARRAY_REVERSE( <array> )",
    "example": "SELECT ARRAY_REVERSE([1,2,3,4]);\n\n+--------------------------+\n| ARRAY_REVERSE([1,2,3,4]) |\n|--------------------------|\n| [                        |\n|   4,                     |\n|   3,                     |\n|   2,                     |\n|   1                      |\n| ]                        |\n+--------------------------+",
    "arguments": [
        {
            "name": "array",
            "description": "The source array."
        }
    ],
    "returns": "An array containing the elements of the input array in reverse order."
},
{
    "function_name": "ARRAY_REMOVE_AT",
    "summary": "Given a source ARRAY, returns an ARRAY with the element at the specified position removed.",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/array_remove_at",
    "title": "ARRAY_REMOVE_AT",
    "description": "Given a source",
    "syntax": "ARRAY_REMOVE_AT( <array> , <position> )",
    "example": "SELECT ARRAY_REMOVE_AT(\n  [2, 5, 7],\n  0);\n\n+-------------------------------+\n| ARRAY_REMOVE_AT([2, 5, 7], 0) |\n|-------------------------------|\n| [                             |\n|   5,                          |\n|   7                           |\n| ]                             |\n+-------------------------------+\n\nSELECT ARRAY_REMOVE_AT(\n  [2, 5, 7],\n  -1);\n\n+--------------------------------+\n| ARRAY_REMOVE_AT([2, 5, 7], -1) |\n|--------------------------------|\n| [                              |\n|   2,                           |\n|   5                            |\n| ]                              |\n+--------------------------------+\n\nSELECT ARRAY_REMOVE_AT(\n  [2, 5, 7],\n  10);\n\n+------------------+\n| ARRAY_REMOVE_AT( |\n|   [2, 5, 7],     |\n|   10)            |\n|------------------|\n| [                |\n|   2,             |\n|   5,             |\n|   7              |\n| ]                |\n+------------------+",
    "arguments": [
        {
            "name": "array",
            "description": "The source array."
        },
        {
            "name": "position",
            "description": "The (zero-based) position of the element to be removed. The function removes the element at this position. A negative position is interpreted as an index from the back of the array (e.g. -1 removes the last element in the array)."
        }
    ],
    "returns": "An ARRAY with the element at the specified position removed."
},
{
    "function_name": "ARRAY_REMOVE",
    "summary": "Given a source ARRAY, returns an ARRAY with elements of the specified value removed.",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/array_remove",
    "title": "ARRAY_REMOVE",
    "description": "Given a source",
    "syntax": "ARRAY_REMOVE( <array> , <value_of_elements_to_remove> )",
    "example": "SELECT ARRAY_REMOVE(\n  [1, 5, 5.00, 5.00::DOUBLE, '5', 5, NULL],\n  5);\n\n+---------------------------------------------+\n| ARRAY_REMOVE(                               |\n|   [1, 5, 5.00, 5.00::DOUBLE, '5', 5, NULL], |\n|   5)                                        |\n|---------------------------------------------|\n| [                                           |\n|   1,                                        |\n|   \"5\",                                      |\n|   undefined                                 |\n| ]                                           |\n+---------------------------------------------+\n\nSELECT ARRAY_REMOVE([5, 5], 5);\n\n+-------------------------+\n| ARRAY_REMOVE([5, 5], 5) |\n|-------------------------|\n| []                      |\n+-------------------------+\n\nSELECT ARRAY_REMOVE(\n  ['a', 'b', 'a', 'c', 'd', 'a'],\n  'a'::VARIANT);\n\n+-----------------------------------+\n| ARRAY_REMOVE(                     |\n|   ['A', 'B', 'A', 'C', 'D', 'A'], |\n|   'A'::VARIANT)                   |\n|-----------------------------------|\n| [                                 |\n|   \"b\",                            |\n|   \"c\",                            |\n|   \"d\"                             |\n| ]                                 |\n+-----------------------------------+",
    "arguments": [
        {
            "name": "array",
            "description": "The source array."
        },
        {
            "name": "value_of_elements_to_remove",
            "description": "The VARIANT value of the elements to be removed. The function removes elements equal to this value. If you specify a VARCHAR value, you must first cast the value to VARIANT."
        }
    ],
    "returns": "An ARRAY with all elements equal to the specified value removed."
},
{
    "function_name": "ARRAY_PREPEND",
    "summary": "Returns an array containing the new element as well as all elements from the source array.",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/array_prepend",
    "title": "ARRAY_PREPEND",
    "description": "Returns an array containing the new element as well as all elements from the source array. The new element is positioned at the beginning of the array.",
    "syntax": "ARRAY_PREPEND( <array> , <new_element> )",
    "example": "SELECT ARRAY_PREPEND(ARRAY_CONSTRUCT(0,1,2,3),'hello');\n+-------------------------------------------------+\n| ARRAY_PREPEND(ARRAY_CONSTRUCT(0,1,2,3),'HELLO') |\n|-------------------------------------------------|\n| [                                               |\n|   \"hello\",                                      |\n|   0,                                            |\n|   1,                                            |\n|   2,                                            |\n|   3                                             |\n| ]                                               |\n+-------------------------------------------------+",
    "arguments": [
        {
            "name": "array",
            "description": "The source array."
        },
        {
            "name": "new_element",
            "description": "The element to be prepended."
        }
    ],
    "returns": "This returns the updated array."
},
{
    "function_name": "ARRAY_MIN",
    "summary": "Given an input ARRAY, returns the element with the lowest value that is not a SQL NULL.",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/array_min",
    "title": "ARRAY_MIN",
    "description": "Given an input",
    "syntax": "ARRAY_MIN( <array> )",
    "example": "SELECT ARRAY_MIN([20, 0, NULL, 10, NULL]);\n\n+------------------------------------+\n| ARRAY_MIN([20, 0, NULL, 10, NULL]) |\n|------------------------------------|\n| 0                                  |\n+------------------------------------+\n\nSELECT ARRAY_MIN([]);\n\n+---------------+\n| ARRAY_MIN([]) |\n|---------------|\n| NULL          |\n+---------------+\n\nSELECT ARRAY_MIN([NULL, NULL, NULL]);\n\n+-------------------------+\n| ARRAY_MIN([NULL, NULL]) |\n|-------------------------|\n| NULL                    |\n+-------------------------+\n\nSELECT ARRAY_MIN([date1::TIMESTAMP, timestamp1]) AS array_min\n  FROM (\n      VALUES ('1999-01-01'::DATE, '2023-12-09 22:09:26.000000000'::TIMESTAMP),\n             ('2023-12-09'::DATE, '1999-01-01 22:09:26.000000000'::TIMESTAMP)\n          AS t(date1, timestamp1)\n      );\n\n+---------------------------+\n| ARRAY_MIN                 |\n|---------------------------|\n| \"1999-01-01 00:00:00.000\" |\n| \"1999-01-01 22:09:26.000\" |\n+---------------------------+",
    "arguments": [
        {
            "name": "array",
            "description": "The input ARRAY."
        }
    ],
    "returns": "This function returns a VARIANT that contains the element with the lowest value that is not a SQL NULL."
},
{
    "function_name": "ARRAY_POSITION",
    "summary": "Returns the index of the first occurrence of an element in an array.",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/array_position",
    "title": "ARRAY_POSITION",
    "description": "Returns the index of the first occurrence of an element in an array.",
    "syntax": "ARRAY_POSITION( <variant_expr> , <array> )",
    "example": "SELECT ARRAY_POSITION('hello'::variant, array_construct('hello', 'hi'));\n+------------------------------------------------------------------+\n| ARRAY_POSITION('HELLO'::VARIANT, ARRAY_CONSTRUCT('HELLO', 'HI')) |\n|------------------------------------------------------------------|\n|                                                                0 |\n+------------------------------------------------------------------+\n\nSELECT ARRAY_POSITION('hi'::variant, array_construct('hello', 'hi'));\n+---------------------------------------------------------------+\n| ARRAY_POSITION('HI'::VARIANT, ARRAY_CONSTRUCT('HELLO', 'HI')) |\n|---------------------------------------------------------------|\n|                                                             1 |\n+---------------------------------------------------------------+\n\nSELECT ARRAY_POSITION('hello'::variant, array_construct('hola', 'bonjour'));\n+----------------------------------------------------------------------+\n| ARRAY_POSITION('HELLO'::VARIANT, ARRAY_CONSTRUCT('HOLA', 'BONJOUR')) |\n|----------------------------------------------------------------------|\n|                                                                 NULL |\n+----------------------------------------------------------------------+",
    "arguments": [
        {
            "name": "value_expr",
            "description": "Value to find in array . If array is a semi-structured ARRAY , value_expr must evaluate to a VARIANT . If array is a structured ARRAY , value_expr must evaluate\nto a type that is comparable to the type of the ARRAY."
        },
        {
            "name": "array",
            "description": "The ARRAY to search."
        }
    ],
    "returns": "The function returns an INTEGER specifying the position of value_expr in array."
},
{
    "function_name": "ARRAY_MAX",
    "summary": "Given an input ARRAY, returns the element with the highest value that is not a SQL NULL.",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/array_max",
    "title": "ARRAY_MAX",
    "description": "Given an input",
    "syntax": "ARRAY_MAX( <array> )",
    "example": "SELECT ARRAY_MAX([20, 0, NULL, 10, NULL]);\n\n+------------------------------------+\n| ARRAY_MAX([20, 0, NULL, 10, NULL]) |\n|------------------------------------|\n| 20                                 |\n+------------------------------------+\n\nSELECT ARRAY_MAX([NULL, PARSE_JSON('null'), NULL]);\n\n+--------------------------------------------------+\n| ARRAY_MAX([20, 0, PARSE_JSON('NULL'), 10, NULL]) |\n|--------------------------------------------------|\n| null                                             |\n+--------------------------------------------------+\n\nSELECT ARRAY_MAX([]);\n\n+---------------+\n| ARRAY_MAX([]) |\n|---------------|\n| NULL          |\n+---------------+\n\nSELECT ARRAY_MAX([NULL, NULL, NULL]);\n\n+-------------------------+\n| ARRAY_MAX([NULL, NULL]) |\n|-------------------------|\n| NULL                    |\n+-------------------------+\n\nSELECT ARRAY_MAX([date1::TIMESTAMP, timestamp1]) AS array_max\n  FROM (\n      VALUES ('1999-01-01'::DATE, '2023-12-09 22:09:26.000000000'::TIMESTAMP),\n             ('2023-12-09'::DATE, '1999-01-01 22:09:26.000000000'::TIMESTAMP)\n          AS t(date1, timestamp1)\n      );\n\n+---------------------------+\n| ARRAY_MAX                 |\n|---------------------------|\n| \"2023-12-09 22:09:26.000\" |\n| \"2023-12-09 00:00:00.000\" |\n+---------------------------+",
    "arguments": [
        {
            "name": "array",
            "description": "The input ARRAY."
        }
    ],
    "returns": "This function returns a VARIANT that contains the element with the highest value that is not a SQL NULL."
},
{
    "function_name": "ARRAY_INTERSECTION",
    "summary": "Returns an array that contains the matching elements in the two input arrays.",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/array_intersection",
    "title": "ARRAY_INTERSECTION",
    "description": "Returns an array that contains the matching elements in the two input arrays.",
    "syntax": "ARRAY_INTERSECTION( <array1> , <array2> )",
    "example": "SELECT array_intersection(ARRAY_CONSTRUCT('A', 'B'), \n                          ARRAY_CONSTRUCT('B', 'C'));\n+------------------------------------------------------+\n| ARRAY_INTERSECTION(ARRAY_CONSTRUCT('A', 'B'),        |\n|                           ARRAY_CONSTRUCT('B', 'C')) |\n|------------------------------------------------------|\n| [                                                    |\n|   \"B\"                                                |\n| ]                                                    |\n+------------------------------------------------------+\n\nSELECT array_intersection(ARRAY_CONSTRUCT('A', 'B', 'C'), \n                          ARRAY_CONSTRUCT('B', 'C'));\n+------------------------------------------------------+\n| ARRAY_INTERSECTION(ARRAY_CONSTRUCT('A', 'B', 'C'),   |\n|                           ARRAY_CONSTRUCT('B', 'C')) |\n|------------------------------------------------------|\n| [                                                    |\n|   \"B\",                                               |\n|   \"C\"                                                |\n| ]                                                    |\n+------------------------------------------------------+\n\nSELECT array_intersection(ARRAY_CONSTRUCT('A', 'B', 'B', 'B', 'C'), \n                          ARRAY_CONSTRUCT('B', 'B'));\n+---------------------------------------------------------------+\n| ARRAY_INTERSECTION(ARRAY_CONSTRUCT('A', 'B', 'B', 'B', 'C'),  |\n|                           ARRAY_CONSTRUCT('B', 'B'))          |\n|---------------------------------------------------------------|\n| [                                                             |\n|   \"B\",                                                        |\n|   \"B\"                                                         |\n| ]                                                             |\n+---------------------------------------------------------------+\n\nCREATE OR REPLACE TABLE array_demo (ID INTEGER, array1 ARRAY, array2 ARRAY, tip VARCHAR);\n\nINSERT INTO array_demo (ID, array1, array2, tip)\n    SELECT 1, ARRAY_CONSTRUCT(1, 2), ARRAY_CONSTRUCT(3, 4), 'non-overlapping';\nINSERT INTO array_demo (ID, array1, array2, tip)\n    SELECT 2, ARRAY_CONSTRUCT(1, 2, 3), ARRAY_CONSTRUCT(3, 4, 5), 'value 3 overlaps';\nINSERT INTO array_demo (ID, array1, array2, tip)\n    SELECT 3, ARRAY_CONSTRUCT(1, 2, 3, 4), ARRAY_CONSTRUCT(3, 4, 5), 'values 3 and 4 overlap';\nINSERT INTO array_demo (ID, array1, array2, tip)\n    SELECT 4, ARRAY_CONSTRUCT(NULL, 102, NULL), ARRAY_CONSTRUCT(NULL, NULL, 103), 'NULLs overlap';\nINSERT INTO array_demo (ID, array1, array2, tip)\n    SELECT 5, array_construct(object_construct('a',1,'b',2), 1, 2),\n              array_construct(object_construct('a',1,'b',2), 3, 4), \n              'the objects in the array match';\nINSERT INTO array_demo (ID, array1, array2, tip)\n    SELECT 6, array_construct(object_construct('a',1,'b',2), 1, 2),\n              array_construct(object_construct('b',2,'c',3), 3, 4), \n              'neither the objects nor any other values match';\nINSERT INTO array_demo (ID, array1, array2, tip)\n    SELECT 7, array_construct(object_construct('a',1, 'b',2, 'c',3)),\n              array_construct(object_construct('c',3, 'b',2, 'a',1)), \n              'the objects contain the same values, but in different order';\n\nSELECT ID, array1, array2, tip, ARRAY_INTERSECTION(array1, array2) \n    FROM array_demo\n    WHERE ID <= 3\n    ORDER BY ID;\n+----+--------+--------+------------------------+------------------------------------+\n| ID | ARRAY1 | ARRAY2 | TIP                    | ARRAY_INTERSECTION(ARRAY1, ARRAY2) |\n|----+--------+--------+------------------------+------------------------------------|\n|  1 | [      | [      | non-overlapping        | []                                 |\n|    |   1,   |   3,   |                        |                                    |\n|    |   2    |   4    |                        |                                    |\n|    | ]      | ]      |                        |                                    |\n|  2 | [      | [      | value 3 overlaps       | [                                  |\n|    |   1,   |   3,   |                        |   3                                |\n|    |   2,   |   4,   |                        | ]                                  |\n|    |   3    |   5    |                        |                                    |\n|    | ]      | ]      |                        |                                    |\n|  3 | [      | [      | values 3 and 4 overlap | [                                  |\n|    |   1,   |   3,   |                        |   3,                               |\n|    |   2,   |   4,   |                        |   4                                |\n|    |   3,   |   5    |                        | ]                                  |\n|    |   4    | ]      |                        |                                    |\n|    | ]      |        |                        |                                    |\n+----+--------+--------+------------------------+------------------------------------+\n\nSELECT ID, array1, array2, tip, ARRAY_INTERSECTION(array1, array2) \n    FROM array_demo\n    WHERE ID = 4\n    ORDER BY ID;\n+----+--------------+--------------+---------------+------------------------------------+\n| ID | ARRAY1       | ARRAY2       | TIP           | ARRAY_INTERSECTION(ARRAY1, ARRAY2) |\n|----+--------------+--------------+---------------+------------------------------------|\n|  4 | [            | [            | NULLs overlap | [                                  |\n|    |   undefined, |   undefined, |               |   undefined,                       |\n|    |   102,       |   undefined, |               |   undefined                        |\n|    |   undefined  |   103        |               | ]                                  |\n|    | ]            | ]            |               |                                    |\n+----+--------------+--------------+---------------+------------------------------------+\n\nSELECT ID, array1, array2, tip, ARRAY_INTERSECTION(array1, array2) \n    FROM array_demo\n    WHERE ID >= 5 and ID <= 7\n    ORDER BY ID;\n+----+-------------+-------------+-------------------------------------------------------------+------------------------------------+\n| ID | ARRAY1      | ARRAY2      | TIP                                                         | ARRAY_INTERSECTION(ARRAY1, ARRAY2) |\n|----+-------------+-------------+-------------------------------------------------------------+------------------------------------|\n|  5 | [           | [           | the objects in the array match                              | [                                  |\n|    |   {         |   {         |                                                             |   {                                |\n|    |     \"a\": 1, |     \"a\": 1, |                                                             |     \"a\": 1,                        |\n|    |     \"b\": 2  |     \"b\": 2  |                                                             |     \"b\": 2                         |\n|    |   },        |   },        |                                                             |   }                                |\n|    |   1,        |   3,        |                                                             | ]                                  |\n|    |   2         |   4         |                                                             |                                    |\n|    | ]           | ]           |                                                             |                                    |\n|  6 | [           | [           | neither the objects nor any other values match              | []                                 |\n|    |   {         |   {         |                                                             |                                    |\n|    |     \"a\": 1, |     \"b\": 2, |                                                             |                                    |\n|    |     \"b\": 2  |     \"c\": 3  |                                                             |                                    |\n|    |   },        |   },        |                                                             |                                    |\n|    |   1,        |   3,        |                                                             |                                    |\n|    |   2         |   4         |                                                             |                                    |\n|    | ]           | ]           |                                                             |                                    |\n|  7 | [           | [           | the objects contain the same values, but in different order | [                                  |\n|    |   {         |   {         |                                                             |   {                                |\n|    |     \"a\": 1, |     \"a\": 1, |                                                             |     \"a\": 1,                        |\n|    |     \"b\": 2, |     \"b\": 2, |                                                             |     \"b\": 2,                        |\n|    |     \"c\": 3  |     \"c\": 3  |                                                             |     \"c\": 3                         |\n|    |   }         |   }         |                                                             |   }                                |\n|    | ]           | ]           |                                                             | ]                                  |\n+----+-------------+-------------+-------------------------------------------------------------+------------------------------------+\n\nSELECT array_intersection(ARRAY_CONSTRUCT('A', 'B'), \n                          NULL);\n+------------------------------------------------+\n| ARRAY_INTERSECTION(ARRAY_CONSTRUCT('A', 'B'),  |\n|                           NULL)                |\n|------------------------------------------------|\n| NULL                                           |\n+------------------------------------------------+",
    "arguments": [
        {
            "name": "array1",
            "description": "An array that contains elements to be compared."
        },
        {
            "name": "array2",
            "description": "An array that contains elements to be compared."
        }
    ],
    "returns": "This function returns an ARRAY that contains the elements of the input arrays that match."
},
{
    "function_name": "ARRAY_INSERT",
    "summary": "Returns an array containing all elements from the source array as well as the new element.",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/array_insert",
    "title": "ARRAY_INSERT",
    "description": "Returns an array containing all elements from the source array as well as the new element.",
    "syntax": "ARRAY_INSERT( <array> , <pos> , <new_element> )",
    "example": "SELECT ARRAY_INSERT(ARRAY_CONSTRUCT(0,1,2,3),2,'hello');\n+--------------------------------------------------+\n| ARRAY_INSERT(ARRAY_CONSTRUCT(0,1,2,3),2,'HELLO') |\n|--------------------------------------------------|\n| [                                                |\n|   0,                                             |\n|   1,                                             |\n|   \"hello\",                                       |\n|   2,                                             |\n|   3                                              |\n| ]                                                |\n+--------------------------------------------------+\n\nSELECT ARRAY_INSERT(ARRAY_CONSTRUCT(0,1,2,3),5,'hello');\n+--------------------------------------------------+\n| ARRAY_INSERT(ARRAY_CONSTRUCT(0,1,2,3),5,'HELLO') |\n|--------------------------------------------------|\n| [                                                |\n|   0,                                             |\n|   1,                                             |\n|   2,                                             |\n|   3,                                             |\n|   undefined,                                     |\n|   \"hello\"                                        |\n| ]                                                |\n+--------------------------------------------------+\n\nSELECT ARRAY_INSERT(ARRAY_CONSTRUCT(0,1,2,3),-1,'hello');\n+---------------------------------------------------+\n| ARRAY_INSERT(ARRAY_CONSTRUCT(0,1,2,3),-1,'HELLO') |\n|---------------------------------------------------|\n| [                                                 |\n|   0,                                              |\n|   1,                                              |\n|   2,                                              |\n|   \"hello\",                                        |\n|   3                                               |\n| ]                                                 |\n+---------------------------------------------------+",
    "arguments": [
        {
            "name": "array",
            "description": "The source array."
        },
        {
            "name": "pos",
            "description": "A (zero-based) position in the source array. The new element is inserted at this position. The original element from this position (if any) and all subsequent elements (if any) are shifted by\none position to the right in the resulting array (i.e. inserting at position 0 has the same effect as using ARRAY_PREPEND ). A negative position is interpreted as an index from the back of the array (e.g. -1 results in insertion before the last element in the array)."
        },
        {
            "name": "new_element",
            "description": "The element to be inserted. The new element is located at position pos . The relative order of the other elements from the source array is preserved."
        }
    ],
    "returns": "The data type of the returned value is ARRAY."
},
{
    "function_name": "ARRAY_GENERATE_RANGE",
    "summary": "Returns an ARRAY of integer values within a specified range (e.g. [2, 3, 4]).",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/array_generate_range",
    "title": "ARRAY_GENERATE_RANGE",
    "description": "Returns an",
    "syntax": "ARRAY_GENERATE_RANGE( <start> , <stop> [ , <step> ] )",
    "example": "SELECT ARRAY_GENERATE_RANGE(2, 5);\n\n+----------------------------+\n| ARRAY_GENERATE_RANGE(2, 5) |\n|----------------------------|\n| [                          |\n|   2,                       |\n|   3,                       |\n|   4                        |\n| ]                          |\n+----------------------------+\n\nSELECT ARRAY_GENERATE_RANGE(5, 25, 10);\n\n+---------------------------------+\n| ARRAY_GENERATE_RANGE(5, 25, 10) |\n|---------------------------------|\n| [                               |\n|   5,                            |\n|   15                            |\n| ]                               |\n+---------------------------------+\n\nSELECT ARRAY_GENERATE_RANGE(-5, -25, -10);\n\n+------------------------------------+\n| ARRAY_GENERATE_RANGE(-5, -25, -10) |\n|------------------------------------|\n| [                                  |\n|   -5,                              |\n|   -15                              |\n| ]                                  |\n+------------------------------------+",
    "arguments": [
        {
            "name": "start",
            "description": "The first number in the range of numbers to return. You must specify an expression that evaluates to an INTEGER value."
        },
        {
            "name": "stop",
            "description": "The last number in the range. Note that this number is not included in the range of numbers returned. For example, ARRAY_GENERATE_RANGE(1, 5) returns [1, 2, 3, 4] (which does not include 5 ). You must specify an expression that evaluates to an INTEGER value."
        },
        {
            "name": "step",
            "description": "The amount to increment or decrement each subsequent number in the array. For example: ARRAY_GENERATE_RANGE(0, 16, 5) returns [0, 5, 10, 15] ARRAY_GENERATE_RANGE(0, -16, -5) returns [0, -5, -10, -15] You can specify a positive or negative number. You cannot specify 0. The default value is 1 ."
        }
    ],
    "returns": "An ARRAY of integers in the specified range."
},
{
    "function_name": "ARRAY_FLATTEN",
    "summary": "Flattens an ARRAY of ARRAYs into a single ARRAY.",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/array_flatten",
    "title": "ARRAY_FLATTEN",
    "description": "Flattens an",
    "syntax": "ARRAY_FLATTEN( <array> )",
    "example": "SELECT ARRAY_FLATTEN([[1, 2, 3], [4], [5, 6]]);\n\n+-----------------------------------------+\n| ARRAY_FLATTEN([[1, 2, 3], [4], [5, 6]]) |\n|-----------------------------------------|\n| [                                       |\n|   1,                                    |\n|   2,                                    |\n|   3,                                    |\n|   4,                                    |\n|   5,                                    |\n|   6                                     |\n| ]                                       |\n+-----------------------------------------+\n\nSELECT ARRAY_FLATTEN([[[1, 2], [3]], [[4], [5]]]);\n\n+--------------------------------------------+\n| ARRAY_FLATTEN([[[1, 2], [3]], [[4], [5]]]) |\n|--------------------------------------------|\n| [                                          |\n|   [                                        |\n|     1,                                     |\n|     2                                      |\n|   ],                                       |\n|   [                                        |\n|     3                                      |\n|   ],                                       |\n|   [                                        |\n|     4                                      |\n|   ],                                       |\n|   [                                        |\n|     5                                      |\n|   ]                                        |\n| ]                                          |\n+--------------------------------------------+\n\nSELECT ARRAY_FLATTEN([[1, 2, 3], 4, [5, 6]]);\n\n100107 (22000): Not an array: 'Input argument to ARRAY_FLATTEN is not an array of arrays'\n\nSELECT ARRAY_FLATTEN([[1, 2, 3], NULL, [5, 6]]);\n\n+------------------------------------------+\n| ARRAY_FLATTEN([[1, 2, 3], NULL, [5, 6]]) |\n|------------------------------------------|\n| NULL                                     |\n+------------------------------------------+\n\nSELECT ARRAY_FLATTEN([[1, 2, 3], [NULL], [5, 6]]);\n\n+--------------------------------------------+\n| ARRAY_FLATTEN([[1, 2, 3], [NULL], [5, 6]]) |\n|--------------------------------------------|\n| [                                          |\n|   1,                                       |\n|   2,                                       |\n|   3,                                       |\n|   undefined,                               |\n|   5,                                       |\n|   6                                        |\n| ]                                          |\n+--------------------------------------------+",
    "arguments": [
        {
            "name": "array",
            "description": "The ARRAY of ARRAYs to flatten. If any element of array is not an ARRAY, the function reports an error."
        }
    ],
    "returns": "This function returns an ARRAY that is constructed by concatenating the ARRAYs in array."
},
{
    "function_name": "ARRAY_EXCEPT",
    "summary": "Returns a new ARRAY that contains the elements from one input ARRAY that are not in another input ARRAY.",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/array_except",
    "title": "ARRAY_EXCEPT",
    "description": "Returns a new",
    "syntax": "ARRAY_EXCEPT( <source_array> , <array_of_elements_to_exclude> )",
    "example": "SELECT ARRAY_EXCEPT(['A', 'B'], ['B', 'C']);\n\n+--------------------------------------+\n| ARRAY_EXCEPT(['A', 'B'], ['B', 'C']) |\n|--------------------------------------|\n| [                                    |\n|   \"A\"                                |\n| ]                                    |\n+--------------------------------------+\n\nSELECT ARRAY_EXCEPT(['A', 'B', 'C'], ['B', 'C']);\n\n+-------------------------------------------+\n| ARRAY_EXCEPT(['A', 'B', 'C'], ['B', 'C']) |\n|-------------------------------------------|\n| [                                         |\n|   \"A\"                                     |\n| ]                                         |\n+-------------------------------------------+\n\nSELECT ARRAY_EXCEPT(['A', 'B', 'B', 'B', 'C'], ['B']);\n\n+------------------------------------------------+\n| ARRAY_EXCEPT(['A', 'B', 'B', 'B', 'C'], ['B']) |\n|------------------------------------------------|\n| [                                              |\n|   \"A\",                                         |\n|   \"B\",                                         |\n|   \"B\",                                         |\n|   \"C\"                                          |\n| ]                                              |\n+------------------------------------------------+\n\nSELECT ARRAY_EXCEPT(['A', 'B'], ['A', 'B']);\n\n+--------------------------------------+\n| ARRAY_EXCEPT(['A', 'B'], ['A', 'B']) |\n|--------------------------------------|\n| []                                   |\n+--------------------------------------+\n\nSELECT ARRAY_EXCEPT(['A', NULL, NULL], ['B', NULL]);\n\n+----------------------------------------------+\n| ARRAY_EXCEPT(['A', NULL, NULL], ['B', NULL]) |\n|----------------------------------------------|\n| [                                            |\n|   \"A\",                                       |\n|   undefined                                  |\n| ]                                            |\n+----------------------------------------------+\n\nSELECT ARRAY_EXCEPT(['A', NULL, NULL], [NULL, 'B', NULL]);\n\n+----------------------------------------------------+\n| ARRAY_EXCEPT(['A', NULL, NULL], [NULL, 'B', NULL]) |\n|----------------------------------------------------|\n| [                                                  |\n|   \"A\"                                              |\n| ]                                                  |\n+----------------------------------------------------+\n\nSELECT ARRAY_EXCEPT([{'a': 1, 'b': 2}, 1], [{'a': 1, 'b': 2}, 3]);\n\n+------------------------------------------------------------+\n| ARRAY_EXCEPT([{'A': 1, 'B': 2}, 1], [{'A': 1, 'B': 2}, 3]) |\n|------------------------------------------------------------|\n| [                                                          |\n|   1                                                        |\n| ]                                                          |\n+------------------------------------------------------------+\n\nSELECT ARRAY_EXCEPT(['A', 'B'], NULL);\n\n+--------------------------------+\n| ARRAY_EXCEPT(['A', 'B'], NULL) |\n|--------------------------------|\n| NULL                           |\n+--------------------------------+",
    "arguments": [
        {
            "name": "source_array",
            "description": "An array that contains elements to be included in the new ARRAY."
        },
        {
            "name": "array_of_elements_to_exclude",
            "description": "An array that contains elements to be excluded from the new ARRAY."
        }
    ],
    "returns": "This function returns an ARRAY that contains the elements from source_array that are not in\narray_of_elements_to_exclude."
},
{
    "function_name": "ARRAY_DISTINCT",
    "summary": "Returns a new ARRAY that contains only the distinct elements from the input ARRAY.",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/array_distinct",
    "title": "ARRAY_DISTINCT",
    "description": "Returns a new",
    "syntax": "ARRAY_DISTINCT( <array> )",
    "example": "SELECT ARRAY_DISTINCT(['A', 'A', 'B', NULL, NULL]);\n\n+---------------------------------------------+\n| ARRAY_DISTINCT(['A', 'A', 'B', NULL, NULL]) |\n|---------------------------------------------|\n| [                                           |\n|   \"A\",                                      |\n|   \"B\",                                      |\n|   undefined                                 |\n| ]                                           |\n+---------------------------------------------+\n\nSELECT ARRAY_DISTINCT(NULL);\n\n+----------------------+\n| ARRAY_DISTINCT(NULL) |\n|----------------------|\n| NULL                 |\n+----------------------+\n\nSELECT ARRAY_DISTINCT( [ {'a': 1, 'b': 2}, {'a': 1, 'b': 2}, {'a': 1, 'b': 3} ] );\n\n+----------------------------------------------------------------------------+\n| ARRAY_DISTINCT( [ {'A': 1, 'B': 2}, {'A': 1, 'B': 2}, {'A': 1, 'B': 3} ] ) |\n|----------------------------------------------------------------------------|\n| [                                                                          |\n|   {                                                                        |\n|     \"a\": 1,                                                                |\n|     \"b\": 2                                                                 |\n|   },                                                                       |\n|   {                                                                        |\n|     \"a\": 1,                                                                |\n|     \"b\": 3                                                                 |\n|   }                                                                        |\n| ]                                                                          |\n+----------------------------------------------------------------------------+",
    "arguments": [
        {
            "name": "array",
            "description": "An array that might contain duplicate elements to be removed."
        }
    ],
    "returns": "This function returns an ARRAY that contains the elements of the input array without any duplicate elements. For example, if the\nvalue 'x' appears multiple times in the input ARRAY, only one element has the value 'x' in the returned ARRAY."
},
{
    "function_name": "ARRAY_CONTAINS",
    "summary": "Returns TRUE if the specified value is found in the specified array.",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/array_contains",
    "title": "ARRAY_CONTAINS",
    "description": "Returns TRUE if the specified value is found in the specified array.",
    "syntax": "ARRAY_CONTAINS( <value_expr> , <array> )",
    "example": "SELECT ARRAY_CONTAINS('hello'::VARIANT, ARRAY_CONSTRUCT('hello', 'hi'));\n\n+------------------------------------------------------------------+\n| ARRAY_CONTAINS('HELLO'::VARIANT, ARRAY_CONSTRUCT('HELLO', 'HI')) |\n|------------------------------------------------------------------|\n| True                                                             |\n+------------------------------------------------------------------+\n\nSELECT ARRAY_CONTAINS('hello'::VARIANT, ARRAY_CONSTRUCT('hola', 'bonjour'));\n\n+----------------------------------------------------------------------+\n| ARRAY_CONTAINS('HELLO'::VARIANT, ARRAY_CONSTRUCT('HOLA', 'BONJOUR')) |\n|----------------------------------------------------------------------|\n| False                                                                |\n+----------------------------------------------------------------------+\n\nSELECT ARRAY_CONTAINS(NULL, ARRAY_CONSTRUCT('hola', 'bonjour'));\n\n+----------------------------------------------------------+\n| ARRAY_CONTAINS(NULL, ARRAY_CONSTRUCT('HOLA', 'BONJOUR')) |\n|----------------------------------------------------------|\n| NULL                                                     |\n+----------------------------------------------------------+\n\nSELECT ARRAY_CONTAINS(NULL, ARRAY_CONSTRUCT('hola', NULL));\n\n+-----------------------------------------------------+\n| ARRAY_CONTAINS(NULL, ARRAY_CONSTRUCT('HOLA', NULL)) |\n|-----------------------------------------------------|\n| True                                                |\n+-----------------------------------------------------+\n\nSELECT ARRAY_CONTAINS(PARSE_JSON('null'), ARRAY_CONSTRUCT('hola', PARSE_JSON('null')));\n\n+---------------------------------------------------------------------------------+\n| ARRAY_CONTAINS(PARSE_JSON('NULL'), ARRAY_CONSTRUCT('HOLA', PARSE_JSON('NULL'))) |\n|---------------------------------------------------------------------------------|\n| True                                                                            |\n+---------------------------------------------------------------------------------+\n\nSELECT ARRAY_CONTAINS(NULL, ARRAY_CONSTRUCT('hola', PARSE_JSON('null')));\n\n+-------------------------------------------------------------------+\n| ARRAY_CONTAINS(NULL, ARRAY_CONSTRUCT('HOLA', PARSE_JSON('NULL'))) |\n|-------------------------------------------------------------------|\n| NULL                                                              |\n+-------------------------------------------------------------------+\n\nCREATE OR REPLACE TABLE array_example (id INT, array_column ARRAY);\n\nINSERT INTO array_example (id, array_column)\n  SELECT 1, ARRAY_CONSTRUCT(1, 2, 3);\n\nINSERT INTO array_example (id, array_column)\n  SELECT 2, ARRAY_CONSTRUCT(4, 5, 6);\n\nSELECT * FROM array_example;\n\n+----+--------------+\n| ID | ARRAY_COLUMN |\n|----+--------------|\n|  1 | [            |\n|    |   1,         |\n|    |   2,         |\n|    |   3          |\n|    | ]            |\n|  2 | [            |\n|    |   4,         |\n|    |   5,         |\n|    |   6          |\n|    | ]            |\n+----+--------------+\n\nSELECT * FROM array_example WHERE ARRAY_CONTAINS(5, array_column);\n\n+----+--------------+\n| ID | ARRAY_COLUMN |\n|----+--------------|\n|  2 | [            |\n|    |   4,         |\n|    |   5,         |\n|    |   6          |\n|    | ]            |\n+----+--------------+",
    "arguments": [
        {
            "name": "value_expr",
            "description": "Value to find in array . If array is a semi-structured array , value_expr must evaluate to a VARIANT . If array is a structured array , value_expr must evaluate\nto a type that is comparable to the type of the array."
        },
        {
            "name": "array",
            "description": "The array to search."
        }
    ],
    "returns": "This function returns a value of BOOLEAN type or NULL:"
},
{
    "function_name": "ARRAY_CONSTRUCT_COMPACT",
    "summary": "Returns an array constructed from zero, one, or more inputs; the constructed array omits any NULL input values.",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/array_construct_compact",
    "title": "ARRAY_CONSTRUCT_COMPACT",
    "description": "Returns an array constructed from zero, one, or more inputs; the constructed\narray omits any NULL input values.",
    "syntax": "ARRAY_CONSTRUCT_COMPACT( [ <expr1> ] [ , <expr2> [ , ... ] ] )",
    "example": "SELECT ARRAY_CONSTRUCT_COMPACT(null,'hello',3::double,4,5);\n+-----------------------------------------------------+\n| ARRAY_CONSTRUCT_COMPACT(NULL,'HELLO',3::DOUBLE,4,5) |\n|-----------------------------------------------------|\n| [                                                   |\n|   \"hello\",                                          |\n|   3.000000000000000e+00,                            |\n|   4,                                                |\n|   5                                                 |\n| ]                                                   |\n+-----------------------------------------------------+",
    "arguments": [
        {
            "name": "expr#",
            "description": "These are the input expressions to evaluate; the resulting values are put into the array.\nThe expressions do not all need to evaluate to the same data type."
        }
    ],
    "returns": "The data type of the returned value is ARRAY."
},
{
    "function_name": "ARRAY_CONSTRUCT",
    "summary": "Returns an array constructed from zero, one, or more inputs.",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/array_construct",
    "title": "ARRAY_CONSTRUCT",
    "description": "Returns an array constructed from zero, one, or more inputs.",
    "syntax": "ARRAY_CONSTRUCT( [ <expr1> ] [ , <expr2> [ , ... ] ] )",
    "example": "SELECT ARRAY_CONSTRUCT(10, 20, 30);\n\n+-----------------------------+\n| ARRAY_CONSTRUCT(10, 20, 30) |\n|-----------------------------|\n| [                           |\n|   10,                       |\n|   20,                       |\n|   30                        |\n| ]                           |\n+-----------------------------+\n\nSELECT ARRAY_CONSTRUCT(NULL, PARSE_JSON('null'), 'hello', 3::DOUBLE, 4, 5);\n\n+---------------------------------------------------------------------+\n| ARRAY_CONSTRUCT(NULL, PARSE_JSON('NULL'), 'HELLO', 3::DOUBLE, 4, 5) |\n|---------------------------------------------------------------------|\n| [                                                                   |\n|   undefined,                                                        |\n|   null,                                                             |\n|   \"hello\",                                                          |\n|   3.000000000000000e+00,                                            |\n|   4,                                                                |\n|   5                                                                 |\n| ]                                                                   |\n+---------------------------------------------------------------------+\n\nSELECT ARRAY_CONSTRUCT();\n\n+-------------------+\n| ARRAY_CONSTRUCT() |\n|-------------------|\n| []                |\n+-------------------+\n\nCREATE OR REPLACE TABLE construct_array_example (id INT, array_column ARRAY);\n\nINSERT INTO construct_array_example (id, array_column)\n  SELECT 1,\n         ARRAY_CONSTRUCT(1, 2, 3);\n\nINSERT INTO construct_array_example (id, array_column)\n  SELECT 2,\n         ARRAY_CONSTRUCT(4, 5, 6);\n\nINSERT INTO construct_array_example (id, array_column)\n  SELECT 3,\n         ARRAY_CONSTRUCT(7, 8, 9);\n\nSELECT * FROM construct_array_example;\n\n+----+--------------+\n| ID | ARRAY_COLUMN |\n|----+--------------|\n|  1 | [            |\n|    |   1,         |\n|    |   2,         |\n|    |   3          |\n|    | ]            |\n|  2 | [            |\n|    |   4,         |\n|    |   5,         |\n|    |   6          |\n|    | ]            |\n|  3 | [            |\n|    |   7,         |\n|    |   8,         |\n|    |   9          |\n|    | ]            |\n+----+--------------+",
    "returns": "The data type of the returned value is ARRAY."
},
{
    "function_name": "ARRAY_COMPACT",
    "summary": "Returns a compacted array with missing and null values removed, effectively converting sparse arrays into dense arrays.",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/array_compact",
    "title": "ARRAY_COMPACT",
    "description": "Returns a compacted array with missing and null values removed, effectively converting sparse arrays into dense arrays.",
    "syntax": "ARRAY_COMPACT( <array1> )",
    "example": "CREATE TABLE array_demo (ID INTEGER, array1 ARRAY, array2 ARRAY);\n\nINSERT INTO array_demo (ID, array1, array2) \n    SELECT 2, ARRAY_CONSTRUCT(10, NULL, 30), ARRAY_CONSTRUCT(40);\n\nSELECT array1, ARRAY_COMPACT(array1) FROM array_demo WHERE ID = 2;\n+--------------+-----------------------+\n| ARRAY1       | ARRAY_COMPACT(ARRAY1) |\n|--------------+-----------------------|\n| [            | [                     |\n|   10,        |   10,                 |\n|   undefined, |   30                  |\n|   30         | ]                     |\n| ]            |                       |\n+--------------+-----------------------+",
    "arguments": [
        {
            "name": "array1",
            "description": "The source array."
        }
    ]
},
{
    "function_name": "ARRAY_CAT",
    "summary": "Returns a concatenation of two arrays.",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/array_cat",
    "title": "ARRAY_CAT",
    "description": "Returns a concatenation of two arrays.",
    "syntax": "ARRAY_CAT( <array1> , <array2> )",
    "example": "CREATE TABLE array_demo (ID INTEGER, array1 ARRAY, array2 ARRAY);\n\nINSERT INTO array_demo (ID, array1, array2) \n    SELECT 1, ARRAY_CONSTRUCT(1, 2), ARRAY_CONSTRUCT(3, 4);\n\nSELECT ARRAY_CAT(array1, array2) FROM array_demo;\n+---------------------------+\n| ARRAY_CAT(ARRAY1, ARRAY2) |\n|---------------------------|\n| [                         |\n|   1,                      |\n|   2,                      |\n|   3,                      |\n|   4                       |\n| ]                         |\n+---------------------------+",
    "arguments": [
        {
            "name": "array1",
            "description": "The source array."
        },
        {
            "name": "array2",
            "description": "The array to be appended to array1 ."
        }
    ],
    "returns": "An ARRAY containing the elements from array2 appended after the elements of array1."
},
{
    "function_name": "ARRAY_APPEND",
    "summary": "Returns an array containing all elements from the source array as well as the new element.",
    "category": "Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/array_append",
    "title": "ARRAY_APPEND",
    "description": "Returns an array containing all elements from the source array as well as the new element. The new element is located at the end of the array.",
    "syntax": "ARRAY_APPEND( <array> , <new_element> )",
    "example": "CREATE OR REPLACE TABLE array_append_examples (array_column ARRAY);\n\nINSERT INTO array_append_examples (array_column)\n  SELECT ARRAY_CONSTRUCT(1, 2, 3);\n\nSELECT * FROM array_append_examples;\n\n+--------------+\n| ARRAY_COLUMN |\n|--------------|\n| [            |\n|   1,         |\n|   2,         |\n|   3          |\n| ]            |\n+--------------+\n\nUPDATE array_append_examples\n  SET array_column = ARRAY_APPEND(array_column, 4);\n\nSELECT * FROM array_append_examples;\n\n+--------------+\n| ARRAY_COLUMN |\n|--------------|\n| [            |\n|   1,         |\n|   2,         |\n|   3,         |\n|   4          |\n| ]            |\n+--------------+\n\nUPDATE array_append_examples\n  SET array_column = ARRAY_APPEND(array_column, 'five');\n\nSELECT array_column,\n       ARRAY_CONSTRUCT(\n        TYPEOF(array_column[0]),\n        TYPEOF(array_column[1]),\n        TYPEOF(array_column[2]),\n        TYPEOF(array_column[3]),\n        TYPEOF(array_column[4])) AS type\n  FROM array_append_examples;\n\n+--------------+--------------+\n| ARRAY_COLUMN | TYPE         |\n|--------------+--------------|\n| [            | [            |\n|   1,         |   \"INTEGER\", |\n|   2,         |   \"INTEGER\", |\n|   3,         |   \"INTEGER\", |\n|   4,         |   \"INTEGER\", |\n|   \"five\"     |   \"VARCHAR\"  |\n| ]            | ]            |\n+--------------+--------------+",
    "arguments": [
        {
            "name": "array",
            "description": "The source array."
        },
        {
            "name": "new_element",
            "description": "The element to be appended. The type of the element depends on the type of the array: If array is a semi-structured array , the element can be of almost any data type.\nThe data type can be different from the data type(s) of the existing elements in the array. If array is a structured array , the type of the new element must\nbe coercible to the type of the array."
        }
    ],
    "returns": "The data type of the returned value is ARRAY."
},
{
    "function_name": "ARRAY_AGG",
    "summary": "Returns the input values, pivoted into an array.",
    "category": "Aggregate functions , Window functions , Semi-structured and structured data functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/array_agg",
    "title": "ARRAY_AGG",
    "description": "Returns the input values, pivoted into an array. If the input is empty, the function returns an empty array.",
    "syntax": "ARRAY_AGG( [ DISTINCT ] <expr1> ) [ WITHIN GROUP ( <orderby_clause> ) ]",
    "example": "CREATE TABLE orders (\n    o_orderkey INTEGER,         -- unique ID for each order.\n    o_clerk VARCHAR,            -- identifies which clerk is responsible.\n    o_totalprice NUMBER(12, 2), -- total price.\n    o_orderstatus CHAR(1)       -- 'F' = Fulfilled (sent); \n                                -- 'O' = 'Ordered but not yet Fulfilled'.\n    );\n\nINSERT INTO orders (o_orderkey, o_orderstatus, o_clerk, o_totalprice) \n  VALUES \n    ( 32123, 'O', 'Clerk#000000321',     321.23),\n    ( 41445, 'F', 'Clerk#000000386', 1041445.00),\n    ( 55937, 'O', 'Clerk#000000114', 1055937.00),\n    ( 67781, 'F', 'Clerk#000000521', 1067781.00),\n    ( 80550, 'O', 'Clerk#000000411', 1080550.00),\n    ( 95808, 'F', 'Clerk#000000136', 1095808.00),\n    (101700, 'O', 'Clerk#000000220', 1101700.00),\n    (103136, 'F', 'Clerk#000000508', 1103136.00);\n\nSELECT O_ORDERKEY AS order_keys\n  FROM orders\n  WHERE O_TOTALPRICE > 450000\n  ORDER BY O_ORDERKEY;\n+------------+\n| ORDER_KEYS |\n|------------|\n|      41445 |\n|      55937 |\n|      67781 |\n|      80550 |\n|      95808 |\n|     101700 |\n|     103136 |\n+------------+\n\nSELECT ARRAY_AGG(O_ORDERKEY) WITHIN GROUP (ORDER BY O_ORDERKEY ASC)\n  FROM orders \n  WHERE O_TOTALPRICE > 450000;\n+--------------------------------------------------------------+\n| ARRAY_AGG(O_ORDERKEY) WITHIN GROUP (ORDER BY O_ORDERKEY ASC) |\n|--------------------------------------------------------------|\n| [                                                            |\n|   41445,                                                     |\n|   55937,                                                     |\n|   67781,                                                     |\n|   80550,                                                     |\n|   95808,                                                     |\n|   101700,                                                    |\n|   103136                                                     |\n| ]                                                            |\n+--------------------------------------------------------------+\n\nSELECT ARRAY_AGG(DISTINCT O_ORDERSTATUS) WITHIN GROUP (ORDER BY O_ORDERSTATUS ASC)\n  FROM orders \n  WHERE O_TOTALPRICE > 450000\n  ORDER BY O_ORDERSTATUS ASC;\n+-----------------------------------------------------------------------------+\n| ARRAY_AGG(DISTINCT O_ORDERSTATUS) WITHIN GROUP (ORDER BY O_ORDERSTATUS ASC) |\n|-----------------------------------------------------------------------------|\n| [                                                                           |\n|   \"F\",                                                                      |\n|   \"O\"                                                                       |\n| ]                                                                           |\n+-----------------------------------------------------------------------------+\n\nSELECT \n    O_ORDERSTATUS, \n    ARRAYAGG(O_CLERK) WITHIN GROUP (ORDER BY O_TOTALPRICE DESC)\n  FROM orders \n  WHERE O_TOTALPRICE > 450000\n  GROUP BY O_ORDERSTATUS\n  ORDER BY O_ORDERSTATUS DESC;\n+---------------+-------------------------------------------------------------+\n| O_ORDERSTATUS | ARRAYAGG(O_CLERK) WITHIN GROUP (ORDER BY O_TOTALPRICE DESC) |\n|---------------+-------------------------------------------------------------|\n| O             | [                                                           |\n|               |   \"Clerk#000000220\",                                        |\n|               |   \"Clerk#000000411\",                                        |\n|               |   \"Clerk#000000114\"                                         |\n|               | ]                                                           |\n| F             | [                                                           |\n|               |   \"Clerk#000000508\",                                        |\n|               |   \"Clerk#000000136\",                                        |\n|               |   \"Clerk#000000521\",                                        |\n|               |   \"Clerk#000000386\"                                         |\n|               | ]                                                           |\n+---------------+-------------------------------------------------------------+\n\nCREATE OR REPLACE TABLE array_data AS (\nWITH data AS (\n  SELECT 1 a, [1,3,2,4,7,8,10] b\n  UNION ALL\n  SELECT 2, [1,3,2,4,7,8,10]\n  )\nSELECT 'Ord'||a o_orderkey, 'c'||value o_clerk, index\n  FROM data, TABLE(FLATTEN(b))\n);\n\nSELECT o_orderkey,\n    ARRAY_AGG(o_clerk) OVER(PARTITION BY o_orderkey ORDER BY o_orderkey\n      ROWS BETWEEN 3 PRECEDING AND CURRENT ROW) AS result\n  FROM array_data;\n\n+------------+---------+\n| O_ORDERKEY | RESULT  |\n|------------+---------|\n| Ord1       | [       |\n|            |   \"c1\"  |\n|            | ]       |\n| Ord1       | [       |\n|            |   \"c1\", |\n|            |   \"c3\"  |\n|            | ]       |\n| Ord1       | [       |\n|            |   \"c1\", |\n|            |   \"c3\", |\n|            |   \"c2\"  |\n|            | ]       |\n| Ord1       | [       |\n|            |   \"c1\", |\n|            |   \"c3\", |\n|            |   \"c2\", |\n|            |   \"c4\"  |\n|            | ]       |\n| Ord1       | [       |\n|            |   \"c3\", |\n|            |   \"c2\", |\n|            |   \"c4\", |\n|            |   \"c7\"  |\n|            | ]       |\n| Ord1       | [       |\n|            |   \"c2\", |\n|            |   \"c4\", |\n|            |   \"c7\", |\n|            |   \"c8\"  |\n|            | ]       |\n| Ord1       | [       |\n|            |   \"c4\", |\n|            |   \"c7\", |\n|            |   \"c8\", |\n|            |   \"c10\" |\n|            | ]       |\n| Ord2       | [       |\n|            |   \"c1\"  |\n|            | ]       |\n| Ord2       | [       |\n|            |   \"c1\", |\n|            |   \"c3\"  |\n|            | ]       |\n...",
    "arguments": [
        {
            "name": "expr1",
            "description": "An expression (typically a column name) that determines the values to be put into the array."
        },
        {
            "name": "OVER()",
            "description": "The OVER clause specifies that the function is being used as a window function.\nFor details, see Window function syntax and usage ."
        },
        {
            "name": "DISTINCT",
            "description": "Removes duplicate values from the array."
        },
        {
            "name": "WITHIN",
            "description": "Clause that contains one or more expressions (typically column names) that determine the order of the values in each array. The WITHIN GROUP(ORDER BY) syntax supports the same parameters as the main ORDER BY clause in a SELECT statement.\nSee ORDER BY ."
        },
        {
            "name": "PARTITION",
            "description": "Window function clause that specifies an expression (typically a column name).\nThis expression defines partitions that group the input rows before the function is applied.\nFor details, see Window function syntax and usage ."
        },
        {
            "name": "ORDER",
            "description": "Optional expression to order by within each partition, followed by an optional window frame. For detailed window_frame syntax, see Window function syntax and usage . When this function is used with a range-based frame, the ORDER BY clause supports only a single column.\nRow-based frames do not have this restriction."
        }
    ],
    "returns": "Returns a value of type ARRAY."
},
{
    "function_name": "APPROXIMATE_SIMILARITY",
    "summary": "Returns an estimation of the similarity (Jaccard index) of inputs based on their MinHash states.",
    "category": "Aggregate functions , Window function syntax and usage",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/approximate_similarity",
    "title": "APPROXIMATE_SIMILARITY",
    "description": "Returns an estimation of the similarity (Jaccard index) of inputs based on their MinHash states. For more information about MinHash states, see",
    "syntax": "APPROXIMATE_SIMILARITY( [ DISTINCT ] <expr> [ , ... ] )\n\nAPPROXIMATE_SIMILARITY(*)",
    "example": "USE SCHEMA snowflake_sample_data.tpch_sf1;\n\nSELECT APPROXIMATE_SIMILARITY(mh) FROM\n    (\n      (SELECT MINHASH(100, C5) mh FROM orders WHERE c2 <= 50000)\n         UNION\n      (SELECT MINHASH(100, C5) mh FROM orders WHERE C2 > 50000)\n    );\n\n+----------------------------+\n| APPROXIMATE_SIMILARITY(MH) |\n|----------------------------|\n|                       0.97 |\n+----------------------------+\n\nCREATE TABLE ta (i INTEGER);\nCREATE TABLE tb (i INTEGER);\nCREATE TABLE tc (i INTEGER);\n\n-- Insert values into the 3 tables.\nINSERT INTO ta (i) VALUES (1), (2), (3), (4), (5), (6), (7), (8), (9), (10);\n-- Almost the same as the preceding values.\nINSERT INTO tb (i) VALUES (1), (2), (3), (4), (5), (6), (7), (8), (9), (11);\n-- Different values and different number of values.\nINSERT INTO tc (i) VALUES (-1), (-20), (-300), (-4000);\n\nCREATE TABLE minhash_a_1 (mh) AS SELECT MINHASH(100, i) FROM ta;\nCREATE TABLE minhash_b (mh) AS SELECT MINHASH(100, i) FROM tb;\nCREATE TABLE minhash_c (mh) AS SELECT MINHASH(100, i) FROM tc;\n\nINSERT INTO ta (i) VALUES (12);\n\n-- Record minhash information about only the new rows:\nCREATE TABLE minhash_a_2 (mh) AS SELECT MINHASH(100, i) FROM ta WHERE i > 10;\n\n-- Now combine all the minhash info for the old and new rows in table ta.\nCREATE TABLE minhash_a (mh) AS\n  SELECT MINHASH_COMBINE(mh) FROM\n    (\n      (SELECT mh FROM minhash_a_1)\n      UNION ALL\n      (SELECT mh FROM minhash_a_2)\n    );\n\nSELECT APPROXIMATE_SIMILARITY (mh) FROM\n  (\n    (SELECT mh FROM minhash_a)\n    UNION ALL\n    (SELECT mh FROM minhash_b)\n  );\n+-----------------------------+\n| APPROXIMATE_SIMILARITY (MH) |\n|-----------------------------|\n|                        0.75 |\n+-----------------------------+\n\nSELECT APPROXIMATE_SIMILARITY (mh) FROM\n  (\n    (SELECT mh FROM minhash_a)\n    UNION ALL\n    (SELECT mh FROM minhash_c)\n  );\n+-----------------------------+\n| APPROXIMATE_SIMILARITY (MH) |\n|-----------------------------|\n|                           0 |\n+-----------------------------+",
    "arguments": [
        {
            "name": "expr",
            "description": "The expression(s) should be one or more MinHash states returned by calls to\nthe MINHASH function. In other words, the\nexpressions must be MinHash state information, not the column or\nexpression for which you want the approximate similarity. (The example below\nhelps make this clear.) For more information about MinHash states, see Estimating Similarity of Two or More Sets ."
        }
    ],
    "returns": "A floating point number between 0.0 and 1.0 (inclusive), where 1.0 indicates\nthat the sets are identical, and 0.0 indicates that the sets have no overlap."
},
{
    "function_name": "APPROXIMATE_JACCARD_INDEX",
    "summary": "Returns an estimation of the similarity (Jaccard index) of inputs based on their MinHash states.",
    "category": "Aggregate functions , Window functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/approximate_jaccard_index",
    "title": "APPROXIMATE_JACCARD_INDEX",
    "description": "Returns an estimation of the similarity (Jaccard index) of inputs based on their MinHash states. For more information about Jaccard indexes and the related\nfunction",
    "syntax": "APPROXIMATE_JACCARD_INDEX( [ DISTINCT ] <expr> [ , ... ] )\n\nAPPROXIMATE_JACCARD_INDEX(*)",
    "example": "USE SCHEMA snowflake_sample_data.tpch_sf1;\n\nSELECT APPROXIMATE_JACCARD_INDEX(mh) FROM\n    (\n      (SELECT MINHASH(100, C5) mh FROM orders WHERE c2 <= 50000)\n         UNION\n      (SELECT MINHASH(100, C5) mh FROM orders WHERE C2 > 50000)\n    );\n\n+-------------------------------+\n| APPROXIMATE_JACCARD_INDEX(MH) |\n|-------------------------------|\n|                          0.97 |\n+-------------------------------+",
    "arguments": [
        {
            "name": "expr",
            "description": "The expression(s) should be one or more MinHash states returned by calls to\nthe MINHASH function. In other words, the\nexpressions must be MinHash state information, not the column or\nexpression for which you want the approximate similarity. (The example below\nhelps make this clear.) For more information about MinHash states, see Estimating Similarity of Two or More Sets ."
        }
    ],
    "returns": "A floating point number between 0.0 and 1.0 (inclusive), where 1.0 indicates\nthat the sets are identical, and 0.0 indicates that the sets have no overlap."
},
{
    "function_name": "APPROX_TOP_K_ESTIMATE",
    "summary": "Returns the approximate most frequent values and their estimated frequency for the given Space-Saving state.",
    "category": "Aggregate functions , Window function syntax and usage",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/approx_top_k_estimate",
    "title": "APPROX_TOP_K_ESTIMATE",
    "description": "Returns the approximate most frequent values and their estimated frequency for the given Space-Saving state. (For more information about the Space-Saving\nsummary, see",
    "syntax": "APPROX_TOP_K_ESTIMATE( <state> [ , <k> ] )",
    "example": "-- Create a sequence to use to generate values for the table.\nCREATE OR REPLACE SEQUENCE seq91;\nCREATE OR REPLACE TABLE sequence_demo (c1 INTEGER DEFAULT seq91.nextval, dummy SMALLINT);\nINSERT INTO sequence_demo (dummy) VALUES (0);\n\n-- Double the number of rows a few times, until there are 8 rows:\nINSERT INTO sequence_demo (dummy) SELECT dummy FROM sequence_demo;\nINSERT INTO sequence_demo (dummy) SELECT dummy FROM sequence_demo;\nINSERT INTO sequence_demo (dummy) SELECT dummy FROM sequence_demo;\n\nCREATE OR REPLACE TABLE resultstate1 AS (\n     SELECT approx_top_k_accumulate(c1, 50) AS rs1\n        FROM sequence_demo);\n\nCREATE OR REPLACE TABLE test_table2 (c1 INTEGER);\n-- Insert data.\nINSERT INTO test_table2 (c1) SELECT c1 + 4 FROM sequence_demo;\n\nCREATE OR REPLACE TABLE resultstate2 AS \n  (SELECT approx_top_k_accumulate(c1, 50) AS rs1 \n     FROM test_table2);\n\nCREATE OR REPLACE TABLE combined_resultstate (c1) AS \n  SELECT approx_top_k_combine(rs1) AS apc1\n    FROM (\n        SELECT rs1 FROM resultstate1\n        UNION ALL\n        SELECT rs1 FROM resultstate2\n      )\n      ;\n\nSELECT approx_top_k_estimate(c1, 4) FROM combined_resultstate;\n\n+------------------------------+\n| APPROX_TOP_K_ESTIMATE(C1, 4) |\n|------------------------------|\n| [                            |\n|   [                          |\n|     5,                       |\n|     2                        |\n|   ],                         |\n|   [                          |\n|     6,                       |\n|     2                        |\n|   ],                         |\n|   [                          |\n|     7,                       |\n|     2                        |\n|   ],                         |\n|   [                          |\n|     8,                       |\n|     2                        |\n|   ]                          |\n| ]                            |\n+------------------------------+",
    "arguments": [
        {
            "name": "state",
            "description": "An expression that contains state information generated\nby a call to APPROX_TOP_K_ACCUMULATE or APPROX_TOP_K_COMBINE ."
        },
        {
            "name": "k",
            "description": "The number of values whose counts you want approximated.\nFor example, if you want to see the top 10 most common values, then\nset k to 10. If k is omitted, the default is 1 . The maximum value is 100000 (100,000), and is automatically reduced if\nitems cannot fit in the output."
        }
    ],
    "returns": "Returns a value of type ARRAY."
},
{
    "function_name": "AI_COMPLETE",
    "summary": "Generates a response (completion) using a supported language model.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/ai_complete",
    "title": "AI_COMPLETE"
},
{
    "function_name": "AI_COMPLETE (Single string)",
    "summary": "Generates a response (completion) for a text prompt using a supported language model.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/ai_complete-single-string",
    "title": "AI_COMPLETE (Single string)",
    "syntax": "AI_COMPLETE(\n    <model>, <prompt> [ , <model_parameters>, <response_format>, <show_details> ] )",
    "example": "SELECT AI_COMPLETE('snowflake-arctic', 'What are large language models?');\n\nSELECT AI_COMPLETE(\n    'mistral-large',\n        CONCAT('Critique this review in bullet points: <review>', content, '</review>')\n) FROM reviews LIMIT 10;\n\nSELECT AI_COMPLETE(\n    model => 'llama2-70b-chat',\n    prompt => 'how does a snowflake get its unique pattern?',\n    model_parameters => {\n        'temperature': 0.7,\n        'max_tokens': 10\n    }\n);\n\n\"The unique pattern on a snowflake is\"\n\nSELECT AI_COMPLETE(\n    model => 'llama2-70b-chat',\n    prompt => 'how does a snowflake get its unique pattern?',\n    model_parameters => {\n        'temperature': 0.7,\n        'max_tokens': 10\n    },\n    show_details => true\n);\n\n{\n    \"choices\": [\n        {\n            \"messages\": \" The unique pattern on a snowflake is\"\n        }\n    ],\n    \"created\": 1708536426,\n    \"model\": \"llama2-70b-chat\",\n    \"usage\": {\n        \"completion_tokens\": 10,\n        \"prompt_tokens\": 22,\n        \"guardrail_tokens\": 0,\n        \"total_tokens\": 32\n    }\n}\n\nSELECT AI_COMPLETE(\n    model => 'llama2-70b-chat',\n    prompt => 'Extract structured data from this customer interaction note: Customer Sarah Jones complained about the mobile app crashing during checkout. She tried to purchase 3 items: a red XL jacket ($89.99), blue running shoes ($129.50), and a fitness tracker ($199.00). The app crashed after she entered her shipping address at 123 Main St, Portland OR, 97201. She has been a premium member since January 2024.',\n    model_parameters => {\n        'temperature': 0,\n        'max_tokens': 4096\n    },\n    response_format => {\n            'type':'json',\n            'schema':{'type' : 'object','properties' : {'sentiment_categories':{'type':'array','items':{'type':'object','properties':\n            {'food_quality' : {'type' : 'string'},'food_taste': {'type':'string'}, 'wait_time': {'type':'string'}, 'food_cost': {'type':'string'}},'required':['food_quality','food_taste' ,'wait_time','food_cost']}}}}\n    }\n);\n\n{\n    \"sentiment_categories\": [\n        {\n            \"food_cost\": \"negative\",\n            \"food_quality\": \"positive\",\n            \"food_taste\": \"positive\",\n            \"wait_time\": \"neutral\"\n        }\n    ]\n}\n\nSELECT AI_COMPLETE(\n    model => 'llama2-70b-chat',\n    prompt => 'Extract structured data from this customer interaction note: Customer Sarah Jones complained about the mobile app crashing during checkout. She tried to purchase 3 items: a red XL jacket ($89.99), blue running shoes ($129.50), and a fitness tracker ($199.00). The app crashed after she entered her shipping address at 123 Main St, Portland OR, 97201. She has been a premium member since January 2024.',\n    model_parameters => {\n        'temperature': 0,\n        'max_tokens': 4096\n    },\n    response_format => {\n            'type':'json',\n            'schema':{'type' : 'object','properties' : {'sentiment_categories':{'type':'array','items':{'type':'object','properties':\n            {'food_quality' : {'type' : 'string'},'food_taste': {'type':'string'}, 'wait_time': {'type':'string'}, 'food_cost': {'type':'string'}},'required':['food_quality','food_taste' ,'wait_time','food_cost']}}}}\n    },\n    show_details => true\n);\n\n{\n    \"created\": 1738683744,\n    \"model\": \"mistral-large2\",\n    \"structured_output\": [\n        {\n            \"raw_message\": {\n                \"sentiment_categories\": [\n                    {\n                        \"food_cost\": \"negative\",\n                        \"food_quality\": \"positive\",\n                        \"food_taste\": \"positive\",\n                        \"wait_time\": \"neutral\"\n                    }\n                ]\n            },\n            \"type\": \"json\"\n        }\n    ],\n    \"usage\": {\n        \"completion_tokens\": 60,\n        \"prompt_tokens\": 94,\n        \"total_tokens\": 154\n    }\n}",
    "arguments": [
        {
            "name": "model",
            "description": "A string specifying the model to be used. Specify one of the following models: claude-4-opus claude-4-sonnet claude-3-7-sonnet claude-3-5-sonnet deepseek-r1 gemma-7b jamba-1.5-mini jamba-1.5-large jamba-instruct llama2-70b-chat llama3-8b llama3-70b llama3.1-8b llama3.1-70b llama3.1-405b llama3.2-1b llama3.2-3b llama3.3-70b llama4-maverick llama4-scout mistral-large mistral-large2 mistral-7b mixtral-8x7b openai-gpt-4.1 openai-o4-mini reka-core reka-flash snowflake-arctic snowflake-llama-3.1-405b snowflake-llama-3.3-70b Supported models might have different costs ."
        },
        {
            "name": "prompt",
            "description": "A string prompt"
        },
        {
            "name": "model_parameters",
            "description": "An object containing zero or more of the following options that affect the model’s\nhyperparameters. See LLM Settings . temperature : A value from 0 to 1 (inclusive) that controls the randomness of the output of the language model. A\nhigher temperature (for example, 0.7) results in more diverse and random output, while a lower temperature (such as\n0.2) makes the output more deterministic and focused. Default: 0 top_p : A value from 0 to 1 (inclusive) that controls the randomness and diversity of the language model,\ngenerally used as an alternative to temperature . The difference is that top_p restricts the set of possible tokens\nthat the model outputs, while temperature influences which tokens are chosen at each step. Default: 0 max_tokens : Sets the maximum number of output tokens in the response. Small values can result in truncated responses. Default: 4096\nMaximum allowed value: 8192 guardrails : Filters potentially unsafe and harmful responses from a language model using Cortex Guard .\nEither TRUE or FALSE. Default: FALSE"
        },
        {
            "name": "response_format",
            "description": "A JSON schema that the response should follow. This is a SQL\nsub-object, not a string. If response_format is not specified, the response is a string containing either the\nresponse or a serialized JSON object containing the response and information about it. For more information, see AI_COMPLETE Structured Outputs ."
        },
        {
            "name": "show_details",
            "description": "A boolean flag that indicates whether to return a serialized JSON object containing the response and information about it."
        }
    ],
    "returns": "When the show_details argument is not specified or set to FALSE and the response_format is not specified or set to NULL, returns a string containing the response."
},
{
    "function_name": "AI_COMPLETE (Single image)",
    "summary": "Generates a response (completion) for a text prompt using a supported language model.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/ai_complete-single-file",
    "title": "AI_COMPLETE (Single image)",
    "syntax": "AI_COMPLETE(\n    <model>, <predicate>, <file> [, <model_parameters> ] )",
    "example": "SELECT AI_COMPLETE('claude-3-5-sonnet',\n    'Which country will observe the largest inflation change in 2024 compared to 2023?',\n    TO_FILE('@myimages', 'highest-inflation.png'));\n\nLooking at the data, Venezuela will experience the largest change in inflation rates between 2023 and 2024.\nThe inflation rate in Venezuela is projected to decrease significantly from 337.46% in 2023 to 99.98% in 2024,\nrepresenting a reduction of approximately 237.48 percentage points. This is the most dramatic change among\nall countries shown in the chart, even though Zimbabwe has higher absolute inflation rates.\n\nSELECT AI_COMPLETE('claude-3-5-sonnet',\n    'Extract the kitchen appliances identified in this image. Respond in JSON only with the identified appliances.',\n    TO_FILE('@myimages', 'kitchen.png'));\n\n{\n    \"appliances\": [ \"microwave\",\"electric stove\",\"oven\",\"refrigerator\" ]\n}",
    "arguments": [
        {
            "name": "model",
            "description": "A string specifying the model to be used. Specify one of the following models: claude-4-opus claude-4-sonnet claude-3-7-sonnet claude-3-5-sonnet llama4-maverick llama4-scout openai-o4-mini openai-gpt-4.1 pixtral-large Supported models might have different costs ."
        },
        {
            "name": "predicate",
            "description": "A string prompt"
        },
        {
            "name": "file",
            "description": "A FILE type object representing an image"
        }
    ],
    "returns": "Returns the string response from the language model."
},
{
    "function_name": "AI_COMPLETE (Prompt object)",
    "summary": "Generates a response (completion) for a prompt object.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/ai_complete-prompt-object",
    "title": "AI_COMPLETE (Prompt object)",
    "syntax": "AI_COMPLETE(\n    <model>, <prompt> [ , <model_parameters> ] )",
    "arguments": [
        {
            "name": "model",
            "description": "A string specifying the model to be used. For text only inputs, you can use one of the following models: claude-4-opus claude-4-sonnet claude-3-7-sonnet claude-3-5-sonnet deepseek-r1 gemma-7b jamba-1.5-mini jamba-1.5-large jamba-instruct llama2-70b-chat llama3-8b llama3-70b llama3.1-8b llama3.1-70b llama3.1-405b llama3.2-1b llama3.2-3b llama3.3-70b llama4-maverick llama4-scout mistral-large mistral-large2 mistral-7b mixtral-8x7b openai-gpt-4.1 openai-o4-mini reka-core reka-flash snowflake-arctic snowflake-llama-3.1-405b snowflake-llama-3.3-70b claude-4-opus claude-4-sonnet claude-3-7-sonnet claude-3-5-sonnet llama4-maverick llama4-scout openai-o4-mini openai-gpt-4.1 pixtral-large Supported models might have different costs ."
        },
        {
            "name": "prompt",
            "description": "A prompt object containing text and/or images"
        }
    ]
},
{
    "function_name": "AI_CLASSIFY",
    "summary": "Classifies text or images into categories that you specify.",
    "category": "String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/ai_classify",
    "title": "AI_CLASSIFY",
    "syntax": "AI_CLASSIFY( <input> , <list_of_categories> [, <config_object>] )",
    "example": "SELECT AI_CLASSIFY('One day I will see the world', ['travel', 'cooking']);\n\n'{\n  \"labels\": [\"travel\"]\n }';\n\nSELECT AI_CLASSIFY(\n  'One day I will see the world and learn to cook my favorite dishes',\n  ['travel', 'cooking', 'reading', 'driving'],\n  {'output_mode': 'multi'}\n);\n\n'{\n  \"labels\": [\"travel\", \"cooking\"]\n }';\n\nSELECT AI_CLASSIFY(\n  'One day I will see the world and learn to cook my favorite dishes',\n  [\n    {'label': 'travel', 'description': 'content related to traveling'},\n    {'label': 'cooking'},\n    {'label': 'reading'},\n    {'label': 'driving'}\n  ],\n  {\n    'task_description': 'Determine topics related to the given text',\n    'output_mode': 'multi',\n    'examples': [\n      {\n        'input': 'i love traveling with a good book',\n        'labels': ['travel', 'reading'],\n        'explanation': 'the text mentions traveling and a good book which relates to reading'\n      }\n    ]\n  });\n\n'{\n  \"labels\": [\"travel\", \"cooking\"]\n}';\n\nCREATE OR REPLACE TEMPORARY TABLE text_classification_table AS\nSELECT 'France' AS input, ['North America', 'Europe', 'Asia'] AS classes\nUNION ALL\nSELECT 'Singapore', ['North America', 'Europe', 'Asia']\nUNION ALL\nSELECT 'one day I will see the world', ['travel', 'cooking', 'dancing']\nUNION ALL\nSELECT 'my lobster bisque is second to none', ['travel', 'cooking', 'dancing'];\n\nSELECT input,\n    classes,\n    AI_CLASSIFY(input, classes):labels AS classification\nFROM text_classification_table;\n\nWITH food_pictures AS (\n  SELECT\n      TO_FILE(file_url) AS img\n  FROM DIRECTORY(@file_stage)\n)\nSELECT\n*,\nAI_CLASSIFY(img, ['dessert', 'drink', 'main dish', 'side dish']):labels AS classification\nFROM food_pictures;\n\nWITH food_pictures AS (\n  SELECT\n      TO_FILE(file_url) AS img\n  FROM DIRECTORY(@file_stage)\n)\nSELECT\n*,\nAI_CLASSIFY(PROMPT('Please help me classify the food within this image {0}', img),\n  ['dessert', 'drink', 'main dish', 'side dish']):labels AS classification\nFROM food_pictures;",
    "arguments": [
        {
            "name": "input",
            "description": "The string, image, or prompt object that you’re classifying. For text classification, the input string is case sensitive. Results may vary based on capitalization."
        },
        {
            "name": "list_of_categories",
            "description": "An array of categories with at least one and at most 500 unique values. Categories are case sensitive. Categories can be simple strings or SQL objects of the same type.\nIf you’re using objects, you can provide a description for one or more categories to improve classification accuracy. For each category, specify the following: label (Required): The name of the category. description (Optional): Describes the category in no more than 25 words. Note Descriptions count as input tokens, which increases the cost of the classification operation.\nFor more information, see Cost considerations ."
        },
        {
            "name": "config_object",
            "description": "Configuration settings specified as key/value pairs. Supported keys: task_description : A explanation of the classification task that is 50 words or fewer. This can help the model understand the context of the classification task and improve accuracy. output_mode : Set to 'multi' for multi-label classification. Defaults to 'single' for single-label classification. examples : A list of example objects for few-shot learning. Each example must include: input : Example text to classify. labels : List of correct categories for the input. explanation : Explanation of why the input maps to those categories."
        }
    ],
    "returns": "A serialized object. The object’s labels field is an array that specifies the list of categories to which the input belongs."
},
{
    "function_name": "AI_AGG",
    "summary": "Reduces a column of text data using a natural language task description.",
    "category": "Aggregate functions , String & binary functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/ai_agg",
    "title": "AI_AGG",
    "syntax": "AI_AGG( <expr>, <task_description> )",
    "example": "SELECT AI_AGG('[Excellent, Excellent, Great, Mediocre]',\n              'Summarize the product ratings for a blog post targeting consumers');\n\nThis product has a generally positive rating, with most reviewers praising its quality. Key strengths include high satisfaction levels, with 2 reviewers giving it an \"Excellent\" rating. However, some reviewers had a more neutral experience, with 1 rating it \"Mediocre\". Overall, it's a solid choice, but may not exceed expectations for everyone.\n\nWITH reviews AS (\n            SELECT 'Excellent' AS review\n  UNION ALL SELECT 'Excellent'\n  UNION ALL SELECT 'Great'\n  UNION ALL SELECT 'Mediocre'\n)\nSELECT AI_AGG(review,\n              'Summarize the product ratings for a blog post targeting consumers')\n  FROM reviews;\n\nThis product has a 4.25/5 overall rating, with most reviewers (2) giving it an \"Excellent\" rating and one reviewer giving it a \"Great\" rating. The majority of consumers are impressed with its performance, suggesting it's a reliable and high-quality option. However, one reviewer had a mediocre experience, indicating it may not meet everyone's expectations.\n\nWITH reviews AS (\n            SELECT 1 AS product_id, 'Excellent' AS review\n  UNION ALL SELECT 1, 'Excellent'\n  UNION ALL SELECT 1, 'Great'\n  UNION ALL SELECT 1, 'Mediocre'\n  UNION ALL SELECT 2, 'Terrible'\n  UNION ALL SELECT 2, 'Bad'\n)\nSELECT product_id,\n       AI_AGG(review, 'Summarize the product ratings for a blog post targeting consumers') AS summarized_review\n  FROM reviews\n GROUP BY 1;\n\n+------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| PRODUCT_ID | SUMMARIZED_REVIEW                                                                                                                                                                                                                                                                                                                                                     |\n|------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| 1          | This product has a 4.25/5 overall rating, with most reviewers (2) giving it an \"Excellent\" rating and one reviewer giving it a \"Great\" rating. The majority of consumers are impressed with its performance, suggesting it's a reliable and high-quality option. However, one reviewer had a mediocre experience, indicating it may not meet everyone's expectations. |\n+------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| 2          | This product has received extremely negative reviews, with a 1/5-star rating based on 2 reviews. Consumers have rated it as \"Terrible\" and \"Bad\", citing no redeeming qualities or positive aspects. The product has failed to meet user expectations, and potential buyers are advised to exercise caution before purchasing.                                        |\n+------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n\nWITH reviews AS (\n            SELECT 1 AS product_id, 'Excellent' AS review\n  UNION ALL SELECT 1, 'Excellent'\n  UNION ALL SELECT 1, 'Great'\n  UNION ALL SELECT 1, 'Mediocre'\n  UNION ALL SELECT 2, 'Terrible'\n  UNION ALL SELECT 2, 'Bad'\n  UNION ALL SELECT 2, 'Average'\n)\nSELECT product_id,\n       AI_AGG(review, 'Identify the most positive rating and translate it into French and Polish, one word only') AS summarized_review\n  FROM reviews\n GROUP BY 1;\n\n+------------+--------------------+\n| PRODUCT_ID | SUMMARIZED_REVIEW  |\n|------------+--------------------+\n| 1          | French: Excellent  |\n|            | Polish: Doskonały  |\n+------------+--------------------+\n| 2          | French: Moyen      |\n|            | Polish: Przeciętny |\n+------------+--------------------+",
    "arguments": [
        {
            "name": "expr",
            "description": "This is an expression that contains text on which an aggregation operation is to be performed, such as restaurant reviews or phone transcripts."
        },
        {
            "name": "task_description",
            "description": "A string containing a natural language description of the aggregation to perform, for example “Summarize the reviews” or “Identify all people mentioned and write a short biography for each of them”."
        }
    ],
    "returns": "Returns a string containing the result of the aggregation."
},
{
    "function_name": "ADD_MONTHS",
    "summary": "Adds or subtracts a specified number of months to a date or timestamp, preserving the end-of-month information.",
    "category": "Date & time functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/add_months",
    "title": "ADD_MONTHS",
    "description": "Adds or subtracts a specified number of months to a date or timestamp, preserving the end-of-month information.",
    "syntax": "ADD_MONTHS( <date_or_timestamp_expr> , <num_months_expr> )",
    "example": "SELECT ADD_MONTHS('2016-05-15'::timestamp_ntz, 2) AS RESULT;\n+-------------------------+\n| RESULT                  |\n|-------------------------|\n| 2016-07-15 00:00:00.000 |\n+-------------------------+\n\nSELECT ADD_MONTHS('2016-02-29'::date, 1) AS RESULT;\n+------------+\n| RESULT     |\n|------------|\n| 2016-03-31 |\n+------------+\n\nSELECT ADD_MONTHS('2016-05-31'::date, -1) AS RESULT;\n+------------+\n| RESULT     |\n|------------|\n| 2016-04-30 |\n+------------+",
    "arguments": [
        {
            "name": "date_or_timestamp_expr",
            "description": "This is the date or timestamp expression to which you want to add\na specified number of months."
        },
        {
            "name": "num_months_expr",
            "description": "This is the number of months you want to add. This should be an\ninteger. It may be positive or negative. If the value is a\nnon-integer numeric value (for example, FLOAT) the value will be\nrounded to the nearest integer."
        }
    ],
    "returns": "The data type of the returned value is the same as the data type of the\nfirst parameter. For example, if the input is a DATE, then the\noutput is a DATE. If the input is a TIMESTAMP_NTZ, then the\noutput is a TIMESTAMP_NTZ."
},
{
    "function_name": "ACOSH",
    "summary": "Computes the inverse (arc) hyperbolic cosine of its input.",
    "category": "Numeric functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/acosh",
    "title": "ACOSH",
    "description": "Computes the inverse (arc) hyperbolic cosine of its input.",
    "syntax": "ACOSH( <real_expr> )",
    "example": "SELECT ACOSH(2.352409615);\n+--------------------+\n| ACOSH(2.352409615) |\n|--------------------|\n|                1.5 |\n+--------------------+",
    "arguments": [
        {
            "name": "real_expr",
            "description": "This expression should evaluate to a FLOAT number greater than or equal to\n1.0."
        }
    ],
    "returns": "The data type of the returned value is FLOAT."
},
{
    "function_name": "ACOS",
    "summary": "Computes the inverse cosine (arc cosine) of its input; the result is a number in the interval [0, pi].",
    "category": "Numeric functions",
    "url": "https://docs.snowflake.com/en/sql-reference/functions/acos",
    "title": "ACOS",
    "description": "Computes the inverse cosine (arc cosine) of its input; the result is a number in the interval",
    "syntax": "ACOS( <real_expr> )",
    "example": "SELECT ACOS(0), ACOS(0.5), ACOS(1);\n+-------------+-------------+---------+\n|     ACOS(0) |   ACOS(0.5) | ACOS(1) |\n|-------------+-------------+---------|\n| 1.570796327 | 1.047197551 |       0 |\n+-------------+-------------+---------+",
    "arguments": [
        {
            "name": "real_expr",
            "description": "This expression should evaluate to a real number greater than or equal\nto -1.0 and less than or equal to +1.0."
        }
    ],
    "returns": "The data type of the return value is FLOAT."
}
]