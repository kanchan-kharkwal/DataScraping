[
{
    "url": "https://docs.snowflake.com/en/sql-reference/constructs/with",
    "title": "WITH",
    "description": "The WITH clause is an optional clause that precedes the body of the",
    "syntax": "[ WITH\n       <cte_name1> [ ( <cte_column_list> ) ] AS ( SELECT ...  )\n   [ , <cte_name2> [ ( <cte_column_list> ) ] AS ( SELECT ...  ) ]\n   [ , <cte_nameN> [ ( <cte_column_list> ) ] AS ( SELECT ...  ) ]\n]\nSELECT ...",
    "example": "with\n  albums_1976 as (select * from music_albums where album_year = 1976)\nselect album_name from albums_1976 order by album_name;\n+----------------------+\n| ALBUM_NAME           |\n|----------------------|\n| Amigos               |\n| Look Into The Future |\n+----------------------+\n\nwith\n   album_info_1976 as (select m.album_ID, m.album_name, b.band_name\n      from music_albums as m inner join music_bands as b\n      where m.band_id = b.band_id and album_year = 1976),\n   Journey_album_info_1976 as (select *\n      from album_info_1976 \n      where band_name = 'Journey')\nselect album_name, band_name \n   from Journey_album_info_1976;\n+----------------------+-----------+\n| ALBUM_NAME           | BAND_NAME |\n|----------------------+-----------|\n| Look Into The Future | Journey   |\n+----------------------+-----------+\n\nselect distinct musicians.musician_id, musician_name\n from musicians inner join musicians_and_albums inner join music_albums inner join music_bands\n where musicians.musician_ID = musicians_and_albums.musician_ID\n   and musicians_and_albums.album_ID = music_albums.album_ID\n   and music_albums.band_ID = music_bands.band_ID\n   and music_bands.band_name = 'Santana'\nintersect\nselect distinct musicians.musician_id, musician_name\n from musicians inner join musicians_and_albums inner join music_albums inner join music_bands\n where musicians.musician_ID = musicians_and_albums.musician_ID\n   and musicians_and_albums.album_ID = music_albums.album_ID\n   and music_albums.band_ID = music_bands.band_ID\n   and music_bands.band_name = 'Journey'\norder by musician_ID;\n+-------------+---------------+\n| MUSICIAN_ID | MUSICIAN_NAME |\n|-------------+---------------|\n|         305 | Gregg Rolie   |\n|         306 | Neal Schon    |\n+-------------+---------------+\n\ncreate or replace view view_musicians_in_bands AS\n  select distinct musicians.musician_id, musician_name, band_name\n    from musicians inner join musicians_and_albums inner join music_albums inner join music_bands\n    where musicians.musician_ID = musicians_and_albums.musician_ID\n      and musicians_and_albums.album_ID = music_albums.album_ID\n      and music_albums.band_ID = music_bands.band_ID;\n\nselect musician_id, musician_name from view_musicians_in_bands where band_name = 'Santana'\nintersect\nselect musician_id, musician_name from view_musicians_in_bands where band_name = 'Journey'\norder by musician_ID;\n+-------------+---------------+\n| MUSICIAN_ID | MUSICIAN_NAME |\n|-------------+---------------|\n|         305 | Gregg Rolie   |\n|         306 | Neal Schon    |\n+-------------+---------------+\n\nwith\n  musicians_in_bands as (\n     select distinct musicians.musician_id, musician_name, band_name\n      from musicians inner join musicians_and_albums inner join music_albums inner join music_bands\n      where musicians.musician_ID = musicians_and_albums.musician_ID\n        and musicians_and_albums.album_ID = music_albums.album_ID\n        and music_albums.band_ID = music_bands.band_ID)\nselect musician_ID, musician_name from musicians_in_bands where band_name = 'Santana'\nintersect\nselect musician_ID, musician_name from musicians_in_bands where band_name = 'Journey'\norder by musician_ID\n  ;\n+-------------+---------------+\n| MUSICIAN_ID | MUSICIAN_NAME |\n|-------------+---------------|\n|         305 | Gregg Rolie   |\n|         306 | Neal Schon    |\n+-------------+---------------+\n\ncreate or replace view view_album_IDs_by_bands AS\n select album_ID, music_bands.band_id, band_name\n  from music_albums inner join music_bands\n  where music_albums.band_id = music_bands.band_ID;\n\ncreate or replace view view_musicians_in_bands AS\n select distinct musicians.musician_id, musician_name, band_name\n  from musicians inner join musicians_and_albums inner join view_album_IDs_by_bands\n  where musicians.musician_ID = musicians_and_albums.musician_ID\n    and musicians_and_albums.album_ID = view_album_IDS_by_bands.album_ID;\n\nselect musician_id, musician_name from view_musicians_in_bands where band_name = 'Santana'\nintersect\nselect musician_id, musician_name from view_musicians_in_bands where band_name = 'Journey'\norder by musician_ID;\n+-------------+---------------+\n| MUSICIAN_ID | MUSICIAN_NAME |\n|-------------+---------------|\n|         305 | Gregg Rolie   |\n|         306 | Neal Schon    |\n+-------------+---------------+\n\nwith\n  album_IDs_by_bands as (select album_ID, music_bands.band_id, band_name\n                          from music_albums inner join music_bands\n                          where music_albums.band_id = music_bands.band_ID),\n  musicians_in_bands as (select distinct musicians.musician_id, musician_name, band_name\n                          from musicians inner join musicians_and_albums inner join album_IDs_by_bands\n                          where musicians.musician_ID = musicians_and_albums.musician_ID\n                            and musicians_and_albums.album_ID = album_IDS_by_bands.album_ID)\nselect musician_ID, musician_name from musicians_in_bands where band_name = 'Santana'\nintersect\nselect musician_ID, musician_name from musicians_in_bands where band_name = 'Journey'\norder by musician_ID\n  ;\n+-------------+---------------+\n| MUSICIAN_ID | MUSICIAN_NAME |\n|-------------+---------------|\n|         305 | Gregg Rolie   |\n|         306 | Neal Schon    |\n+-------------+---------------+\n\nWITH RECURSIVE current_f (current_val, previous_val) AS\n    (\n    SELECT 0, 1\n    UNION ALL \n    SELECT current_val + previous_val, current_val FROM current_f\n      WHERE current_val + previous_val < 100\n    )\n  SELECT current_val FROM current_f ORDER BY current_val;\n+-------------+\n| CURRENT_VAL |\n|-------------|\n|           0 |\n|           1 |\n|           1 |\n|           2 |\n|           3 |\n|           5 |\n|           8 |\n|          13 |\n|          21 |\n|          34 |\n|          55 |\n|          89 |\n+-------------+\n\n-- The components of a car.\nCREATE TABLE components (\n    description VARCHAR,\n    component_ID INTEGER,\n    quantity INTEGER,\n    parent_component_ID INTEGER\n    );\n\nINSERT INTO components (description, quantity, component_ID, parent_component_ID) VALUES\n    ('car', 1, 1, 0),\n       ('wheel', 4, 11, 1),\n          ('tire', 1, 111, 11),\n          ('#112 bolt', 5, 112, 11),\n          ('brake', 1, 113, 11),\n             ('brake pad', 1, 1131, 113),\n       ('engine', 1, 12, 1),\n          ('piston', 4, 121, 12),\n          ('cylinder block', 1, 122, 12),\n          ('#112 bolt', 16, 112, 12)   -- Can use same type of bolt in multiple places\n    ;\n\nWITH RECURSIVE current_layer (indent, layer_ID, parent_component_ID, component_id, description, sort_key) AS (\n  SELECT \n      '...', \n      1, \n      parent_component_ID, \n      component_id, \n      description, \n      '0001'\n    FROM components WHERE component_id = 1\n  UNION ALL\n  SELECT indent || '...',\n      layer_ID + 1,\n      components.parent_component_ID,\n      components.component_id, \n      components.description,\n      sort_key || SUBSTRING('000' || components.component_ID, -4)\n    FROM current_layer JOIN components \n      ON (components.parent_component_id = current_layer.component_id)\n  )\nSELECT\n  -- The indentation gives us a sort of \"side-ways tree\" view, with\n  -- sub-components indented under their respective components.\n  indent || description AS description, \n  component_id,\n  parent_component_ID\n  -- The layer_ID and sort_key are useful for debugging, but not\n  -- needed in the report.\n--  , layer_ID, sort_key\n  FROM current_layer\n  ORDER BY sort_key;\n+-------------------------+--------------+---------------------+\n| DESCRIPTION             | COMPONENT_ID | PARENT_COMPONENT_ID |\n|-------------------------+--------------+---------------------|\n| ...car                  |            1 |                   0 |\n| ......wheel             |           11 |                   1 |\n| .........tire           |          111 |                  11 |\n| .........#112 bolt      |          112 |                  11 |\n| .........brake          |          113 |                  11 |\n| ............brake pad   |         1131 |                 113 |\n| ......engine            |           12 |                   1 |\n| .........#112 bolt      |          112 |                  12 |\n| .........piston         |          121 |                  12 |\n| .........cylinder block |          122 |                  12 |\n+-------------------------+--------------+---------------------+"
},
{
    "url": "https://docs.snowflake.com/en/sql-reference/constructs/for-update",
    "title": "FOR UPDATE",
    "description": "Locks the rows that the query selects until the transaction that contains the query commits or\naborts.",
    "example": "BEGIN;\n...\nSELECT * FROM ht ORDER BY c1 FOR UPDATE;\n...\nUPDATE ht set c1 = c1 + 10 WHERE c1 = 0;\n...\nSELECT ... ;\n...\nCOMMIT;\n\nBEGIN;\n...\nSELECT * FROM ht FOR UPDATE WAIT 60;\n...\nCOMMIT;"
},
{
    "url": "https://docs.snowflake.com/en/sql-reference/constructs/limit",
    "title": "LIMIT / FETCH",
    "description": "Constrains the maximum number of rows returned by a statement or subquery. Both LIMIT (PostgreSQL syntax) and FETCH (ANSI syntax) are supported, and produce the same result.",
    "syntax": "SELECT ...\nFROM ...\n[ ORDER BY ... ]\nLIMIT <count> [ OFFSET <start> ]\n[ ... ]",
    "example": "select c1 from testtable;\n\n+------+\n|   C1 |\n|------|\n|    1 |\n|    2 |\n|    3 |\n|   20 |\n|   19 |\n|   18 |\n|    1 |\n|    2 |\n|    3 |\n|    4 |\n| NULL |\n|   30 |\n| NULL |\n+------+\n\nselect c1 from testtable limit 3 offset 3;\n\n+----+\n| C1 |\n|----|\n| 20 |\n| 19 |\n| 18 |\n+----+\n\nselect c1 from testtable order by c1;\n\n+------+\n|   C1 |\n|------|\n|    1 |\n|    1 |\n|    2 |\n|    2 |\n|    3 |\n|    3 |\n|    4 |\n|   18 |\n|   19 |\n|   20 |\n|   30 |\n| NULL |\n| NULL |\n+------+\n\nselect c1 from testtable order by c1 limit 3 offset 3;\n\n+----+\n| ID |\n|----|\n|  2 |\n|  3 |\n|  3 |\n+----+\n\nCREATE TABLE demo1 (i INTEGER);\nINSERT INTO demo1 (i) VALUES (1), (2);\n\nSELECT * FROM demo1 ORDER BY i LIMIT NULL OFFSET NULL;\n+---+\n| I |\n|---|\n| 1 |\n| 2 |\n+---+\n\nSELECT * FROM demo1 ORDER BY i LIMIT '' OFFSET '';\n+---+\n| I |\n|---|\n| 1 |\n| 2 |\n+---+\n\nSELECT * FROM demo1 ORDER BY i LIMIT $$$$ OFFSET $$$$;\n+---+\n| I |\n|---|\n| 1 |\n| 2 |\n+---+"
},
{
    "url": "https://docs.snowflake.com/en/sql-reference/constructs/order-by",
    "title": "ORDER BY",
    "description": "Specifies an ordering of the rows of the result table from a",
    "syntax": "SELECT ...\nFROM ...\nORDER BY orderItem [ , orderItem , ... ]\n[ ... ]",
    "example": "SELECT column1\n  FROM VALUES ('a'), ('1'), ('B'), (null), ('2'), ('01'), ('05'), (' this'), ('this'), ('this and that'), ('&'), ('%')\n  ORDER BY column1;\n\n+---------------+\n| COLUMN1       |\n|---------------|\n|  this         |\n| %             |\n| &             |\n| 01            |\n| 05            |\n| 1             |\n| 2             |\n| B             |\n| a             |\n| this          |\n| this and that |\n| NULL          |\n+---------------+\n\nSELECT column1\n  FROM VALUES (3), (4), (null), (1), (2), (6), (5), (0005), (.05), (.5), (.5000)\n  ORDER BY column1;\n\n+---------+\n| COLUMN1 |\n|---------|\n|    0.05 |\n|    0.50 |\n|    0.50 |\n|    1.00 |\n|    2.00 |\n|    3.00 |\n|    4.00 |\n|    5.00 |\n|    5.00 |\n|    6.00 |\n|    NULL |\n+---------+\n\nALTER SESSION SET DEFAULT_NULL_ORDERING = 'LAST';\n\nSELECT column1\n  FROM VALUES (1), (null), (2), (null), (3)\n  ORDER BY column1;\n\n+---------+\n| COLUMN1 |\n|---------|\n|       1 |\n|       2 |\n|       3 |\n|    NULL |\n|    NULL |\n+---------+\n\nSELECT column1\n  FROM VALUES (1), (null), (2), (null), (3)\n  ORDER BY column1 DESC;\n\n+---------+\n| COLUMN1 |\n|---------|\n|    NULL |\n|    NULL |\n|       3 |\n|       2 |\n|       1 |\n+---------+\n\nSELECT column1\n  FROM VALUES (1), (null), (2), (null), (3)\n  ORDER BY column1 NULLS FIRST;\n\n+---------+\n| COLUMN1 |\n|---------|\n|    NULL |\n|    NULL |\n|       1 |\n|       2 |\n|       3 |\n+---------+\n\nALTER SESSION SET DEFAULT_NULL_ORDERING = 'FIRST';\n\nSELECT column1\n  FROM VALUES (1), (null), (2), (null), (3)\n  ORDER BY column1;\n\n+---------+\n| COLUMN1 |\n|---------|\n|    NULL |\n|    NULL |\n|       1 |\n|       2 |\n|       3 |\n+---------+\n\nSELECT column1\n  FROM VALUES (1), (null), (2), (null), (3)\n  ORDER BY column1 DESC;\n\n+---------+\n| COLUMN1 |\n|---------|\n|       3 |\n|       2 |\n|       1 |\n|    NULL |\n|    NULL |\n+---------+\n\nSELECT column1\n  FROM VALUES (1), (null), (2), (null), (3)\n  ORDER BY column1 NULLS LAST;\n\n+---------+\n| COLUMN1 |\n|---------|\n|       1 |\n|       2 |\n|       3 |\n|    NULL |\n|    NULL |\n+---------+"
},
{
    "url": "https://docs.snowflake.com/en/sql-reference/constructs/qualify",
    "title": "QUALIFY",
    "description": "In a SELECT statement, the QUALIFY clause filters the results of window functions.",
    "syntax": "QUALIFY <predicate>",
    "example": "CREATE TABLE qt (i INTEGER, p CHAR(1), o INTEGER);\nINSERT INTO qt (i, p, o) VALUES\n    (1, 'A', 1),\n    (2, 'A', 2),\n    (3, 'B', 1),\n    (4, 'B', 2);\n\nSELECT * \n    FROM (\n         SELECT i, p, o, \n                ROW_NUMBER() OVER (PARTITION BY p ORDER BY o) AS row_num\n            FROM qt\n        )\n    WHERE row_num = 1\n    ;\n+---+---+---+---------+\n| I | P | O | ROW_NUM |\n|---+---+---+---------|\n| 1 | A | 1 |       1 |\n| 3 | B | 1 |       1 |\n+---+---+---+---------+\n\nSELECT i, p, o\n    FROM qt\n    QUALIFY ROW_NUMBER() OVER (PARTITION BY p ORDER BY o) = 1\n    ;\n+---+---+---+\n| I | P | O |\n|---+---+---|\n| 1 | A | 1 |\n| 3 | B | 1 |\n+---+---+---+\n\nSELECT i, p, o, ROW_NUMBER() OVER (PARTITION BY p ORDER BY o) AS row_num\n    FROM qt\n    QUALIFY row_num = 1\n    ;\n+---+---+---+---------+\n| I | P | O | ROW_NUM |\n|---+---+---+---------|\n| 1 | A | 1 |       1 |\n| 3 | B | 1 |       1 |\n+---+---+---+---------+\n\nSELECT i, p, o, ROW_NUMBER() OVER (PARTITION BY p ORDER BY o) AS row_num\n    FROM qt\n    ;\n+---+---+---+---------+\n| I | P | O | ROW_NUM |\n|---+---+---+---------|\n| 1 | A | 1 |       1 |\n| 2 | A | 2 |       2 |\n| 3 | B | 1 |       1 |\n| 4 | B | 2 |       2 |\n+---+---+---+---------+\n\nSELECT c2, SUM(c3) OVER (PARTITION BY c2) as r\n  FROM t1\n  WHERE c3 < 4\n  GROUP BY c2, c3\n  HAVING SUM(c1) > 3\n  QUALIFY r IN (\n    SELECT MIN(c1)\n      FROM test\n      GROUP BY c2\n      HAVING MIN(c1) > 3);"
},
{
    "url": "https://docs.snowflake.com/en/sql-reference/constructs/having",
    "title": "HAVING",
    "description": "Filters rows produced by",
    "syntax": "SELECT ...\nFROM ...\nGROUP BY ...\nHAVING <predicate>\n[ ... ]",
    "example": "SELECT department_id\nFROM employees\nGROUP BY department_id\nHAVING count(*) < 10;"
},
{
    "url": "https://docs.snowflake.com/en/sql-reference/constructs/group-by-rollup",
    "title": "GROUP BY ROLLUP",
    "description": "GROUP BY ROLLUP is an extension of the",
    "syntax": "SELECT ...\nFROM ...\n[ ... ]\nGROUP BY ROLLUP ( groupRollup [ , groupRollup [ , ... ] ] )\n[ ... ]",
    "example": "-- Create some tables and insert some rows.\nCREATE TABLE products (product_ID INTEGER, wholesale_price REAL);\nINSERT INTO products (product_ID, wholesale_price) VALUES \n    (1, 1.00),\n    (2, 2.00);\n\nCREATE TABLE sales (product_ID INTEGER, retail_price REAL, \n    quantity INTEGER, city VARCHAR, state VARCHAR);\nINSERT INTO sales (product_id, retail_price, quantity, city, state) VALUES \n    (1, 2.00,  1, 'SF', 'CA'),\n    (1, 2.00,  2, 'SJ', 'CA'),\n    (2, 5.00,  4, 'SF', 'CA'),\n    (2, 5.00,  8, 'SJ', 'CA'),\n    (2, 5.00, 16, 'Miami', 'FL'),\n    (2, 5.00, 32, 'Orlando', 'FL'),\n    (2, 5.00, 64, 'SJ', 'PR');\n\nSELECT state, city, SUM((s.retail_price - p.wholesale_price) * s.quantity) AS profit \n FROM products AS p, sales AS s\n WHERE s.product_ID = p.product_ID\n GROUP BY ROLLUP (state, city)\n ORDER BY state, city NULLS LAST\n ;\n+-------+---------+--------+\n| STATE | CITY    | PROFIT |\n|-------+---------+--------|\n| CA    | SF      |     13 |\n| CA    | SJ      |     26 |\n| CA    | NULL    |     39 |\n| FL    | Miami   |     48 |\n| FL    | Orlando |     96 |\n| FL    | NULL    |    144 |\n| PR    | SJ      |    192 |\n| PR    | NULL    |    192 |\n| NULL  | NULL    |    375 |\n+-------+---------+--------+"
},
{
    "url": "https://docs.snowflake.com/en/sql-reference/constructs/group-by-grouping-sets",
    "title": "GROUP BY GROUPING SETS",
    "description": "GROUP BY GROUPING SETS is a powerful extension of the",
    "syntax": "SELECT ...\nFROM ...\n[ ... ]\nGROUP BY GROUPING SETS ( groupSet [ , groupSet [ , ... ] ] )\n[ ... ]",
    "example": "CREATE or replace TABLE nurses (\n  ID INTEGER,\n  full_name VARCHAR,\n  medical_license VARCHAR,   -- LVN, RN, etc.\n  radio_license VARCHAR      -- Technician, General, Amateur Extra\n  )\n  ;\n\nINSERT INTO nurses\n    (ID, full_name, medical_license, radio_license)\n  VALUES\n    (201, 'Thomas Leonard Vicente', 'LVN', 'Technician'),\n    (202, 'Tamara Lolita VanZant', 'LVN', 'Technician'),\n    (341, 'Georgeann Linda Vente', 'LVN', 'General'),\n    (471, 'Andrea Renee Nouveau', 'RN', 'Amateur Extra')\n    ;\n\nSELECT COUNT(*), medical_license, radio_license\n  FROM nurses\n  GROUP BY GROUPING SETS (medical_license, radio_license);\n\n+----------+-----------------+---------------+\n| COUNT(*) | MEDICAL_LICENSE | RADIO_LICENSE |\n|----------+-----------------+---------------|\n|        3 | LVN             | NULL          |\n|        1 | RN              | NULL          |\n|        2 | NULL            | Technician    |\n|        1 | NULL            | General       |\n|        1 | NULL            | Amateur Extra |\n+----------+-----------------+---------------+\n\nINSERT INTO nurses\n    (ID, full_name, medical_license, radio_license)\n  VALUES\n    (101, 'Lily Vine', 'LVN', NULL),\n    (102, 'Larry Vancouver', 'LVN', NULL),\n    (172, 'Rhonda Nova', 'RN', NULL)\n    ;\n\nSELECT COUNT(*), medical_license, radio_license\n  FROM nurses\n  GROUP BY GROUPING SETS (medical_license, radio_license);\n\n+----------+-----------------+---------------+\n| COUNT(*) | MEDICAL_LICENSE | RADIO_LICENSE |\n|----------+-----------------+---------------|\n|        5 | LVN             | NULL          |\n|        2 | RN              | NULL          |\n|        2 | NULL            | Technician    |\n|        1 | NULL            | General       |\n|        1 | NULL            | Amateur Extra |\n|        3 | NULL            | NULL          |\n+----------+-----------------+---------------+\n\nSELECT COUNT(*), medical_license, radio_license\n  FROM nurses\n  GROUP BY medical_license, radio_license;\n\n+----------+-----------------+---------------+\n| COUNT(*) | MEDICAL_LICENSE | RADIO_LICENSE |\n|----------+-----------------+---------------|\n|        2 | LVN             | Technician    |\n|        1 | LVN             | General       |\n|        1 | RN              | Amateur Extra |\n|        2 | LVN             | NULL          |\n|        1 | RN              | NULL          |\n+----------+-----------------+---------------+"
},
{
    "url": "https://docs.snowflake.com/en/sql-reference/constructs/group-by-cube",
    "title": "GROUP BY CUBE",
    "description": "GROUP BY CUBE is an extension of the",
    "syntax": "SELECT ...\nFROM ...\n[ ... ]\nGROUP BY CUBE ( groupCube [ , groupCube [ , ... ] ] )\n[ ... ]",
    "example": "-- Create some tables and insert some rows.\nCREATE TABLE products (product_ID INTEGER, wholesale_price REAL);\nINSERT INTO products (product_ID, wholesale_price) VALUES \n    (1, 1.00),\n    (2, 2.00);\n\nCREATE TABLE sales (product_ID INTEGER, retail_price REAL, \n    quantity INTEGER, city VARCHAR, state VARCHAR);\nINSERT INTO sales (product_id, retail_price, quantity, city, state) VALUES \n    (1, 2.00,  1, 'SF', 'CA'),\n    (1, 2.00,  2, 'SJ', 'CA'),\n    (2, 5.00,  4, 'SF', 'CA'),\n    (2, 5.00,  8, 'SJ', 'CA'),\n    (2, 5.00, 16, 'Miami', 'FL'),\n    (2, 5.00, 32, 'Orlando', 'FL'),\n    (2, 5.00, 64, 'SJ', 'PR');\n\nSELECT state, city, SUM((s.retail_price - p.wholesale_price) * s.quantity) AS profit \n FROM products AS p, sales AS s\n WHERE s.product_ID = p.product_ID\n GROUP BY CUBE (state, city)\n ORDER BY state, city NULLS LAST\n ;\n+-------+---------+--------+\n| STATE | CITY    | PROFIT |\n|-------+---------+--------|\n| CA    | SF      |     13 |\n| CA    | SJ      |     26 |\n| CA    | NULL    |     39 |\n| FL    | Miami   |     48 |\n| FL    | Orlando |     96 |\n| FL    | NULL    |    144 |\n| PR    | SJ      |    192 |\n| PR    | NULL    |    192 |\n| NULL  | Miami   |     48 |\n| NULL  | Orlando |     96 |\n| NULL  | SF      |     13 |\n| NULL  | SJ      |    218 |\n| NULL  | NULL    |    375 |\n+-------+---------+--------+"
},
{
    "url": "https://docs.snowflake.com/en/sql-reference/constructs/group-by",
    "title": "GROUP BY",
    "description": "Groups rows with the same group-by-item expressions and computes aggregate functions for the resulting group. A GROUP BY\nexpression can be:",
    "syntax": "SELECT ...\n  FROM ...\n  [ ... ]\n  GROUP BY groupItem [ , groupItem [ , ... ] ]\n  [ ... ]",
    "example": "CREATE TABLE sales (\n  product_ID INTEGER,\n  retail_price REAL,\n  quantity INTEGER,\n  city VARCHAR,\n  state VARCHAR);\n\nINSERT INTO sales (product_id, retail_price, quantity, city, state) VALUES\n  (1, 2.00,  1, 'SF', 'CA'),\n  (1, 2.00,  2, 'SJ', 'CA'),\n  (2, 5.00,  4, 'SF', 'CA'),\n  (2, 5.00,  8, 'SJ', 'CA'),\n  (2, 5.00, 16, 'Miami', 'FL'),\n  (2, 5.00, 32, 'Orlando', 'FL'),\n  (2, 5.00, 64, 'SJ', 'PR');\n\nCREATE TABLE products (\n  product_ID INTEGER,\n  wholesale_price REAL);\nINSERT INTO products (product_ID, wholesale_price) VALUES (1, 1.00);\nINSERT INTO products (product_ID, wholesale_price) VALUES (2, 2.00);\n\nSELECT product_ID, SUM(retail_price * quantity) AS gross_revenue\n  FROM sales\n  GROUP BY product_ID;\n\n+------------+---------------+\n| PRODUCT_ID | GROSS_REVENUE |\n+============+===============+\n|          1 |          6    |\n+------------+---------------+\n|          2 |        620    |\n+------------+---------------+\n\nSELECT p.product_ID, SUM((s.retail_price - p.wholesale_price) * s.quantity) AS profit\n  FROM products AS p, sales AS s\n  WHERE s.product_ID = p.product_ID\n  GROUP BY p.product_ID;\n\n+------------+--------+\n| PRODUCT_ID | PROFIT |\n+============+========+\n|          1 |      3 |\n+------------+--------+\n|          2 |    372 |\n+------------+--------+\n\nSELECT state, city, SUM(retail_price * quantity) AS gross_revenue\n  FROM sales\n  GROUP BY state, city;\n\n+-------+---------+---------------+\n| STATE |   CITY  | GROSS REVENUE |\n+=======+=========+===============+\n|   CA  | SF      |            22 |\n+-------+---------+---------------+\n|   CA  | SJ      |            44 |\n+-------+---------+---------------+\n|   FL  | Miami   |            80 |\n+-------+---------+---------------+\n|   FL  | Orlando |           160 |\n+-------+---------+---------------+\n|   PR  | SJ      |           320 |\n+-------+---------+---------------+\n\nSELECT state, city, SUM(retail_price * quantity) AS gross_revenue\n  FROM sales\n  GROUP BY ALL;\n\n+-------+---------+---------------+\n| STATE |   CITY  | GROSS REVENUE |\n+=======+=========+===============+\n|   CA  | SF      |            22 |\n+-------+---------+---------------+\n|   CA  | SJ      |            44 |\n+-------+---------+---------------+\n|   FL  | Miami   |            80 |\n+-------+---------+---------------+\n|   FL  | Orlando |           160 |\n+-------+---------+---------------+\n|   PR  | SJ      |           320 |\n+-------+---------+---------------+\n\nSELECT x, some_expression AS x\n  FROM ...\n\nCreate table employees (salary float, state varchar, employment_state varchar);\ninsert into employees (salary, state, employment_state) values\n    (60000, 'California', 'Active'),\n    (70000, 'California', 'On leave'),\n    (80000, 'Oregon', 'Active');\n\nselect sum(salary), ANY_VALUE(employment_state)\n    from employees\n    group by employment_state;\n+-------------+-----------------------------+\n| SUM(SALARY) | ANY_VALUE(EMPLOYMENT_STATE) |\n|-------------+-----------------------------|\n|      140000 | Active                      |\n|       70000 | On leave                    |\n+-------------+-----------------------------+\n\nselect sum(salary), ANY_VALUE(employment_state) as state\n    from employees\n    group by state;\n+-------------+--------+\n| SUM(SALARY) | STATE  |\n|-------------+--------|\n|      130000 | Active |\n|       80000 | Active |\n+-------------+--------+"
},
{
    "url": "https://docs.snowflake.com/en/sql-reference/constructs/where",
    "title": "WHERE",
    "description": "The",
    "syntax": "...\nWHERE <predicate>\n[ ... ]",
    "example": "SELECT * FROM invoices\n  WHERE invoice_date < '2018-01-01';\n\nSELECT * FROM invoices\n  WHERE invoice_date < '2018-01-01'\n    AND paid = FALSE;\n\nSELECT * FROM invoices\n    WHERE amount < (\n                   SELECT AVG(amount)\n                       FROM invoices\n                   )\n    ;\n\nSELECT t1.col1, t2.col1\n    FROM t1, t2\n    WHERE t2.col1 = t1.col1\n    ORDER BY 1, 2;\n+------+------+\n| COL1 | COL1 |\n|------+------|\n|    2 |    2 |\n|    2 |    2 |\n|    3 |    3 |\n+------+------+\n\nSELECT t1.col1, t2.col1\n    FROM t1 JOIN t2\n        ON t2.col1 = t1.col1\n    ORDER BY 1, 2;\n+------+------+\n| COL1 | COL1 |\n|------+------|\n|    2 |    2 |\n|    2 |    2 |\n|    3 |    3 |\n+------+------+\n\ncreate table departments (\n    department_ID INTEGER,\n    department_name VARCHAR,\n    location VARCHAR\n    );\ninsert into departments (department_id, department_name, location) values\n    (10, 'CUSTOMER SUPPORT', 'CHICAGO'),\n    (40, 'RESEARCH', 'BOSTON'),\n    (80, 'Department with no employees yet', 'CHICAGO'),\n    (90, 'Department with no projects or employees yet', 'EREHWON')\n    ;\n\ncreate table projects (\n    project_id integer,\n    project_name varchar,\n    department_id integer\n    );\ninsert into projects (project_id, project_name, department_id) values\n    (4000, 'Detect fake product reviews', 40),\n    (4001, 'Detect false insurance claims', 10),\n    (9000, 'Project with no employees yet', 80),\n    (9099, 'Project with no department or employees yet', NULL)\n    ;\n\ncreate table employees (\n    employee_ID INTEGER,\n    employee_name VARCHAR,\n    department_id INTEGER,\n    project_id INTEGER\n    );\ninsert into employees (employee_id, employee_name, department_id, project_id)\n  values\n    (1012, 'May Aidez', 10, NULL),\n    (1040, 'Devi Nobel', 40, 4000),\n    (1041, 'Alfred Mendeleev', 40, 4001)\n    ;\n\nSELECT d.department_name, p.project_name, e.employee_name\n    FROM  departments d, projects p, employees e\n    WHERE\n            p.department_id = d.department_id\n        AND\n            e.project_id = p.project_id\n    ORDER BY d.department_id, p.project_id, e.employee_id;\n+------------------+-------------------------------+------------------+\n| DEPARTMENT_NAME  | PROJECT_NAME                  | EMPLOYEE_NAME    |\n|------------------+-------------------------------+------------------|\n| CUSTOMER SUPPORT | Detect false insurance claims | Alfred Mendeleev |\n| RESEARCH         | Detect fake product reviews   | Devi Nobel       |\n+------------------+-------------------------------+------------------+\n\nSELECT d.department_name, p.project_name, e.employee_name\n    FROM  departments d, projects p, employees e\n    WHERE\n            p.department_id = d.department_id\n        AND\n            e.project_id(+) = p.project_id\n    ORDER BY d.department_id, p.project_id, e.employee_id;\n+----------------------------------+-------------------------------+------------------+\n| DEPARTMENT_NAME                  | PROJECT_NAME                  | EMPLOYEE_NAME    |\n|----------------------------------+-------------------------------+------------------|\n| CUSTOMER SUPPORT                 | Detect false insurance claims | Alfred Mendeleev |\n| RESEARCH                         | Detect fake product reviews   | Devi Nobel       |\n| Department with no employees yet | Project with no employees yet | NULL             |\n+----------------------------------+-------------------------------+------------------+\n\nSELECT d.department_name, p.project_name, e.employee_name\n    FROM  departments d, projects p, employees e\n    WHERE\n            p.department_id(+) = d.department_id\n        AND\n            e.project_id(+) = p.project_id\n    ORDER BY d.department_id, p.project_id, e.employee_id;\n+----------------------------------------------+-------------------------------+------------------+\n| DEPARTMENT_NAME                              | PROJECT_NAME                  | EMPLOYEE_NAME    |\n|----------------------------------------------+-------------------------------+------------------|\n| CUSTOMER SUPPORT                             | Detect false insurance claims | Alfred Mendeleev |\n| RESEARCH                                     | Detect fake product reviews   | Devi Nobel       |\n| Department with no employees yet             | Project with no employees yet | NULL             |\n| Department with no projects or employees yet | NULL                          | NULL             |\n+----------------------------------------------+-------------------------------+------------------+"
},
{
    "url": "https://docs.snowflake.com/en/sql-reference/constructs/semantic_view",
    "title": "SEMANTIC_VIEW",
    "syntax": "SEMANTIC_VIEW(\n  [<namespace>.]<semantic_view_name>\n  [ METRICS <metric> [ , ... ] ]\n  [ DIMENSIONS <dimension_expr>  [ , ... ] ]\n  [ WHERE <predicate> ]\n)"
},
{
    "url": "https://docs.snowflake.com/en/sql-reference/constructs/sample",
    "title": "SAMPLE / TABLESAMPLE",
    "description": "Returns a subset of rows sampled randomly from the specified table. You can specify different types of sampling methods, and\nyou can sample a fraction of a table or a fixed number of rows:",
    "syntax": "SELECT ...\nFROM ...\n  { SAMPLE | TABLESAMPLE } [ samplingMethod ]\n[ ... ]",
    "example": "SELECT * FROM testtable SAMPLE (10);\n\nSELECT * FROM testtable TABLESAMPLE BERNOULLI (20.3);\n\nSELECT * FROM testtable TABLESAMPLE (100);\n\nSELECT * FROM testtable SAMPLE ROW (0);\n\nSELECT i, j\n  FROM\n    table1 AS t1 SAMPLE (25)\n      INNER JOIN\n    table2 AS t2 SAMPLE (50)\n  WHERE t2.j = t1.i;\n\nSELECT i, j\n  FROM table1 AS t1 INNER JOIN table2 AS t2 SAMPLE (50)\n  WHERE t2.j = t1.i;\n\nSELECT *\n  FROM (\n       SELECT *\n         FROM t1 JOIN t2\n           ON t1.a = t2.c\n       ) SAMPLE (1);\n\nSELECT * FROM testtable SAMPLE SYSTEM (3) SEED (82);\n\nSELECT * FROM testtable SAMPLE BLOCK (0.012) REPEATABLE (99992);\n\nSELECT * FROM testtable SAMPLE (10 ROWS);"
},
{
    "url": "https://docs.snowflake.com/en/sql-reference/constructs/values",
    "title": "VALUES",
    "description": "In the SELECT statement, the VALUES sub-clause of the FROM clause allows the\nspecification of a set of constants to be used to form a finite set of rows.",
    "syntax": "SELECT ...\nFROM ( VALUES ( <expr> [ , <expr> [ , ... ] ] ) [ , ( ... ) ] ) [ [ AS ] <table_alias> [ ( <column_alias> [, ... ] ) ] ]\n[ ... ]",
    "example": "SELECT * FROM (VALUES (1, 'one'), (2, 'two'), (3, 'three'));\n\n+---------+---------+\n| COLUMN1 | COLUMN2 |\n|---------+---------|\n|       1 | one     |\n|       2 | two     |\n|       3 | three   |\n+---------+---------+\n\nSELECT column1, $2 FROM (VALUES (1, 'one'), (2, 'two'), (3, 'three'));\n\n+---------+-------+\n| COLUMN1 | $2    |\n|---------+-------|\n|       1 | one   |\n|       2 | two   |\n|       3 | three |\n+---------+-------+\n\nSELECT v1.$2, v2.$2\n  FROM (VALUES (1, 'one'), (2, 'two')) AS v1\n        INNER JOIN (VALUES (1, 'One'), (3, 'three')) AS v2\n  WHERE v2.$1 = v1.$1;\n\nSELECT c1, c2\n  FROM (VALUES (1, 'one'), (2, 'two')) AS v1 (c1, c2);"
},
{
    "url": "https://docs.snowflake.com/en/sql-reference/constructs/unpivot",
    "title": "UNPIVOT",
    "description": "Rotates a table by transforming columns into rows. UNPIVOT is a relational operator that accepts\ntwo columns (from a table or subquery), along with a list of columns, and generates a row for\neach column specified in the list. In a query, it is specified in the",
    "syntax": "SELECT ...\nFROM ...\n    UNPIVOT [ { INCLUDE | EXCLUDE } NULLS ]\n      ( <value_column>\n        FOR <name_column> IN ( <column_list> ) )\n\n[ ... ]",
    "example": "CREATE OR REPLACE TABLE monthly_sales(\n  empid INT,\n  dept TEXT,\n  jan INT,\n  feb INT,\n  mar INT,\n  apr INT);\n\nINSERT INTO monthly_sales VALUES\n  (1, 'electronics', 100, 200, 300, 100),\n  (2, 'clothes', 100, 300, 150, 200),\n  (3, 'cars', 200, 400, 100, 50),\n  (4, 'appliances', 100, NULL, 100, 50);\n\nSELECT * FROM monthly_sales;\n\n+-------+-------------+-----+------+------+-----+\n| EMPID | DEPT        | JAN | FEB  | MAR  | APR |\n|-------+-------------+-----+------+------+-----|\n|     1 | electronics | 100 | 200  | 300  | 100 |\n|     2 | clothes     | 100 | 300  | 150  | 200 |\n|     3 | cars        | 200 | 400  | 100  |  50 |\n|     4 | appliances  | 100 | NULL | 100  |  50 |\n+-------+-------------+-----+------+------+-----+\n\nSELECT *\n  FROM monthly_sales\n    UNPIVOT (sales FOR month IN (jan, feb, mar, apr))\n  ORDER BY empid;\n\n+-------+-------------+-------+-------+\n| EMPID | DEPT        | MONTH | SALES |\n|-------+-------------+-------+-------|\n|     1 | electronics | JAN   |   100 |\n|     1 | electronics | FEB   |   200 |\n|     1 | electronics | MAR   |   300 |\n|     1 | electronics | APR   |   100 |\n|     2 | clothes     | JAN   |   100 |\n|     2 | clothes     | FEB   |   300 |\n|     2 | clothes     | MAR   |   150 |\n|     2 | clothes     | APR   |   200 |\n|     3 | cars        | JAN   |   200 |\n|     3 | cars        | FEB   |   400 |\n|     3 | cars        | MAR   |   100 |\n|     3 | cars        | APR   |    50 |\n|     4 | appliances  | JAN   |   100 |\n|     4 | appliances  | MAR   |   100 |\n|     4 | appliances  | APR   |    50 |\n+-------+-------------+-------+-------+\n\nSELECT *\n  FROM monthly_sales\n    UNPIVOT INCLUDE NULLS (sales FOR month IN (jan, feb, mar, apr))\n  ORDER BY empid;\n\n+-------+-------------+-------+-------+\n| EMPID | DEPT        | MONTH | SALES |\n|-------+-------------+-------+-------|\n|     1 | electronics | JAN   |   100 |\n|     1 | electronics | FEB   |   200 |\n|     1 | electronics | MAR   |   300 |\n|     1 | electronics | APR   |   100 |\n|     2 | clothes     | JAN   |   100 |\n|     2 | clothes     | FEB   |   300 |\n|     2 | clothes     | MAR   |   150 |\n|     2 | clothes     | APR   |   200 |\n|     3 | cars        | JAN   |   200 |\n|     3 | cars        | FEB   |   400 |\n|     3 | cars        | MAR   |   100 |\n|     3 | cars        | APR   |    50 |\n|     4 | appliances  | JAN   |   100 |\n|     4 | appliances  | FEB   |  NULL |\n|     4 | appliances  | MAR   |   100 |\n|     4 | appliances  | APR   |    50 |\n+-------+-------------+-------+-------+\n\nSELECT dept, month, sales\n  FROM monthly_sales\n    UNPIVOT INCLUDE NULLS (sales FOR month IN (jan, feb, mar, apr))\n  ORDER BY dept;\n\n+-------------+-------+-------+\n| DEPT        | MONTH | SALES |\n|-------------+-------+-------|\n| appliances  | JAN   |   100 |\n| appliances  | FEB   |  NULL |\n| appliances  | MAR   |   100 |\n| appliances  | APR   |    50 |\n| cars        | JAN   |   200 |\n| cars        | FEB   |   400 |\n| cars        | MAR   |   100 |\n| cars        | APR   |    50 |\n| clothes     | JAN   |   100 |\n| clothes     | FEB   |   300 |\n| clothes     | MAR   |   150 |\n| clothes     | APR   |   200 |\n| electronics | JAN   |   100 |\n| electronics | FEB   |   200 |\n| electronics | MAR   |   300 |\n| electronics | APR   |   100 |\n+-------------+-------+-------+"
},
{
    "url": "https://docs.snowflake.com/en/sql-reference/constructs/pivot",
    "title": "PIVOT",
    "description": "Rotates a table by turning the unique values from one column in the input expression into multiple columns and aggregating results\nwhere required on any remaining column values. In a query, it is specified in the",
    "syntax": "SELECT ...\nFROM ...\n   PIVOT ( <aggregate_function> ( <pivot_column> )\n            FOR <value_column> IN (\n              <pivot_value_1> [ , <pivot_value_2> ... ]\n              | ANY [ ORDER BY ... ]\n              | <subquery>\n            )\n            [ DEFAULT ON NULL (<value>) ]\n         )\n\n[ ... ]",
    "example": "CREATE OR REPLACE TABLE quarterly_sales(\n  empid INT,\n  amount INT,\n  quarter TEXT)\n  AS SELECT * FROM VALUES\n    (1, 10000, '2023_Q1'),\n    (1, 400, '2023_Q1'),\n    (2, 4500, '2023_Q1'),\n    (2, 35000, '2023_Q1'),\n    (1, 5000, '2023_Q2'),\n    (1, 3000, '2023_Q2'),\n    (2, 200, '2023_Q2'),\n    (2, 90500, '2023_Q2'),\n    (1, 6000, '2023_Q3'),\n    (1, 5000, '2023_Q3'),\n    (2, 2500, '2023_Q3'),\n    (2, 9500, '2023_Q3'),\n    (3, 2700, '2023_Q3'),\n    (1, 8000, '2023_Q4'),\n    (1, 10000, '2023_Q4'),\n    (2, 800, '2023_Q4'),\n    (2, 4500, '2023_Q4'),\n    (3, 2700, '2023_Q4'),\n    (3, 16000, '2023_Q4'),\n    (3, 10200, '2023_Q4');\n\nSELECT *\n  FROM quarterly_sales\n    PIVOT(SUM(amount) FOR quarter IN (ANY ORDER BY quarter))\n  ORDER BY empid;\n\n+-------+-----------+-----------+-----------+-----------+\n| EMPID | '2023_Q1' | '2023_Q2' | '2023_Q3' | '2023_Q4' |\n|-------+-----------+-----------+-----------+-----------|\n|     1 |     10400 |      8000 |     11000 |     18000 |\n|     2 |     39500 |     90700 |     12000 |      5300 |\n|     3 |      NULL |      NULL |      2700 |     28900 |\n+-------+-----------+-----------+-----------+-----------+\n\nCREATE OR REPLACE TABLE ad_campaign_types_by_quarter(\n  quarter VARCHAR,\n  television BOOLEAN,\n  radio BOOLEAN,\n  print BOOLEAN)\n  AS SELECT * FROM VALUES\n    ('2023_Q1', TRUE, FALSE, FALSE),\n    ('2023_Q2', FALSE, TRUE, TRUE),\n    ('2023_Q3', FALSE, TRUE, FALSE),\n    ('2023_Q4', TRUE, FALSE, TRUE);\n\nSELECT *\n  FROM quarterly_sales\n    PIVOT(SUM(amount) FOR quarter IN (\n      SELECT DISTINCT quarter\n        FROM ad_campaign_types_by_quarter\n        WHERE television = TRUE\n        ORDER BY quarter))\n  ORDER BY empid;\n\n+-------+-----------+-----------+\n| EMPID | '2023_Q1' | '2023_Q4' |\n|-------+-----------+-----------|\n|     1 |     10400 |     18000 |\n|     2 |     39500 |      5300 |\n|     3 |      NULL |     28900 |\n+-------+-----------+-----------+\n\nSELECT 'Average sale amount' AS aggregate, *\n  FROM quarterly_sales\n    PIVOT(AVG(amount) FOR quarter IN (ANY ORDER BY quarter))\nUNION\nSELECT 'Highest value sale' AS aggregate, *\n  FROM quarterly_sales\n    PIVOT(MAX(amount) FOR quarter IN (ANY ORDER BY quarter))\nUNION\nSELECT 'Lowest value sale' AS aggregate, *\n  FROM quarterly_sales\n    PIVOT(MIN(amount) FOR quarter IN (ANY ORDER BY quarter))\nUNION\nSELECT 'Number of sales' AS aggregate, *\n  FROM quarterly_sales\n    PIVOT(COUNT(amount) FOR quarter IN (ANY ORDER BY quarter))\nUNION\nSELECT 'Total amount' AS aggregate, *\n  FROM quarterly_sales\n    PIVOT(SUM(amount) FOR quarter IN (ANY ORDER BY quarter))\nORDER BY aggregate, empid;\n\n+---------------------+-------+--------------+--------------+--------------+--------------+\n| AGGREGATE           | EMPID |    '2023_Q1' |    '2023_Q2' |    '2023_Q3' |    '2023_Q4' |\n|---------------------+-------+--------------+--------------+--------------+--------------|\n| Average sale amount |     1 |  5200.000000 |  4000.000000 |  5500.000000 |  9000.000000 |\n| Average sale amount |     2 | 19750.000000 | 45350.000000 |  6000.000000 |  2650.000000 |\n| Average sale amount |     3 |         NULL |         NULL |  2700.000000 |  9633.333333 |\n| Highest value sale  |     1 | 10000.000000 |  5000.000000 |  6000.000000 | 10000.000000 |\n| Highest value sale  |     2 | 35000.000000 | 90500.000000 |  9500.000000 |  4500.000000 |\n| Highest value sale  |     3 |         NULL |         NULL |  2700.000000 | 16000.000000 |\n| Lowest value sale   |     1 |   400.000000 |  3000.000000 |  5000.000000 |  8000.000000 |\n| Lowest value sale   |     2 |  4500.000000 |   200.000000 |  2500.000000 |   800.000000 |\n| Lowest value sale   |     3 |         NULL |         NULL |  2700.000000 |  2700.000000 |\n| Number of sales     |     1 |     2.000000 |     2.000000 |     2.000000 |     2.000000 |\n| Number of sales     |     2 |     2.000000 |     2.000000 |     2.000000 |     2.000000 |\n| Number of sales     |     3 |     0.000000 |     0.000000 |     1.000000 |     3.000000 |\n| Total amount        |     1 | 10400.000000 |  8000.000000 | 11000.000000 | 18000.000000 |\n| Total amount        |     2 | 39500.000000 | 90700.000000 | 12000.000000 |  5300.000000 |\n| Total amount        |     3 |         NULL |         NULL |  2700.000000 | 28900.000000 |\n+---------------------+-------+--------------+--------------+--------------+--------------+\n\nCREATE OR REPLACE TABLE emp_manager(\n    empid INT,\n    managerid INT)\n  AS SELECT * FROM VALUES\n    (1, 7),\n    (2, 8),\n    (3, 9);\n\nSELECT * from emp_manager;\n\n+-------+-----------+\n| EMPID | MANAGERID |\n|-------+-----------|\n|     1 |         7 |\n|     2 |         8 |\n|     3 |         9 |\n+-------+-----------+\n\nWITH\n  src AS\n  (\n    SELECT *\n      FROM quarterly_sales\n        PIVOT(SUM(amount) FOR quarter IN (ANY ORDER BY quarter))\n  )\nSELECT em.managerid, src.*\n  FROM emp_manager em\n  JOIN src ON em.empid = src.empid\n  ORDER BY empid;\n\n+-----------+-------+-----------+-----------+-----------+-----------+\n| MANAGERID | EMPID | '2023_Q1' | '2023_Q2' | '2023_Q3' | '2023_Q4' |\n|-----------+-------+-----------+-----------+-----------+-----------|\n|         7 |     1 |     10400 |      8000 |     11000 |     18000 |\n|         8 |     2 |     39500 |     90700 |     12000 |      5300 |\n|         9 |     3 |      NULL |      NULL |      2700 |     28900 |\n+-----------+-------+-----------+-----------+-----------+-----------+\n\nSELECT *\n  FROM quarterly_sales\n    PIVOT(SUM(amount) FOR quarter IN (\n      '2023_Q1',\n      '2023_Q2',\n      '2023_Q3'))\n  ORDER BY empid;\n\n+-------+-----------+-----------+-----------+\n| EMPID | '2023_Q1' | '2023_Q2' | '2023_Q3' |\n|-------+-----------+-----------+-----------|\n|     1 |     10400 |      8000 |     11000 |\n|     2 |     39500 |     90700 |     12000 |\n|     3 |      NULL |      NULL |      2700 |\n+-------+-----------+-----------+-----------+\n\nSELECT *\n  FROM quarterly_sales\n    PIVOT(SUM(amount) FOR quarter IN (\n      '2023_Q1',\n      '2023_Q2',\n      '2023_Q3',\n      '2023_Q4'))\n  ORDER BY empid;\n\n+-------+-----------+-----------+-----------+-----------+\n| EMPID | '2023_Q1' | '2023_Q2' | '2023_Q3' | '2023_Q4' |\n|-------+-----------+-----------+-----------+-----------|\n|     1 |     10400 |      8000 |     11000 |     18000 |\n|     2 |     39500 |     90700 |     12000 |      5300 |\n|     3 |      NULL |      NULL |      2700 |     28900 |\n+-------+-----------+-----------+-----------+-----------+\n\nSELECT *\n  FROM quarterly_sales\n    PIVOT(SUM(amount) FOR quarter IN (\n      '2023_Q1',\n      '2023_Q2',\n      '2023_Q3',\n      '2023_Q4')) AS p (employee, q1, q2, q3, q4)\n  ORDER BY employee;\n\n+----------+-------+-------+-------+-------+\n| EMPLOYEE |    Q1 |    Q2 |    Q3 |    Q4 |\n|----------+-------+-------+-------+-------|\n|        1 | 10400 |  8000 | 11000 | 18000 |\n|        2 | 39500 | 90700 | 12000 |  5300 |\n|        3 |  NULL |  NULL |  2700 | 28900 |\n+----------+-------+-------+-------+-------+\n\nSELECT empid,\n       \"'2023_Q1'\" AS q1,\n       \"'2023_Q2'\" AS q2,\n       \"'2023_Q3'\" AS q3,\n       \"'2023_Q4'\" AS q4\n  FROM quarterly_sales\n    PIVOT(sum(amount) FOR quarter IN (\n      '2023_Q1',\n      '2023_Q2',\n      '2023_Q3',\n      '2023_Q4'))\n  ORDER BY empid;\n\n+-------+-------+-------+-------+-------+\n| EMPID |    Q1 |    Q2 |    Q3 |    Q4 |\n|-------+-------+-------+-------+-------|\n|     1 | 10400 |  8000 | 11000 | 18000 |\n|     2 | 39500 | 90700 | 12000 |  5300 |\n|     3 |  NULL |  NULL |  2700 | 28900 |\n+-------+-------+-------+-------+-------+\n\nSELECT *\n  FROM quarterly_sales\n    PIVOT(SUM(amount) FOR quarter IN (ANY ORDER BY quarter)\n      DEFAULT ON NULL (0))\n  ORDER BY empid;\n\n+-------+-----------+-----------+-----------+-----------+\n| EMPID | '2023_Q1' | '2023_Q2' | '2023_Q3' | '2023_Q4' |\n|-------+-----------+-----------+-----------+-----------|\n|     1 |     10400 |      8000 |     11000 |     18000 |\n|     2 |     39500 |     90700 |     12000 |      5300 |\n|     3 |         0 |         0 |      2700 |     28900 |\n+-------+-----------+-----------+-----------+-----------+\n\nSELECT *\n  FROM quarterly_sales\n    PIVOT(SUM(amount)\n      FOR quarter IN (\n        '2023_Q1',\n        '2023_Q2')\n      DEFAULT ON NULL (0))\n  ORDER BY empid;\n\n+-------+-----------+-----------+\n| EMPID | '2023_Q1' | '2023_Q2' |\n|-------+-----------+-----------|\n|     1 |     10400 |      8000 |\n|     2 |     39500 |     90700 |\n|     3 |         0 |         0 |\n+-------+-----------+-----------+\n\nALTER TABLE quarterly_sales ADD COLUMN discount_percent INT DEFAULT 0;\n\nUPDATE quarterly_sales SET discount_percent = UNIFORM(0, 5, RANDOM());\n\nSELECT * FROM quarterly_sales;\n\n+-------+--------+---------+------------------+\n| EMPID | AMOUNT | QUARTER | DISCOUNT_PERCENT |\n|-------+--------+---------+------------------|\n|     1 |  10000 | 2023_Q1 |                0 |\n|     1 |    400 | 2023_Q1 |                1 |\n|     2 |   4500 | 2023_Q1 |                4 |\n|     2 |  35000 | 2023_Q1 |                2 |\n|     1 |   5000 | 2023_Q2 |                2 |\n|     1 |   3000 | 2023_Q2 |                1 |\n|     2 |    200 | 2023_Q2 |                2 |\n|     2 |  90500 | 2023_Q2 |                1 |\n|     1 |   6000 | 2023_Q3 |                1 |\n|     1 |   5000 | 2023_Q3 |                3 |\n|     2 |   2500 | 2023_Q3 |                1 |\n|     2 |   9500 | 2023_Q3 |                3 |\n|     3 |   2700 | 2023_Q3 |                1 |\n|     1 |   8000 | 2023_Q4 |                1 |\n|     1 |  10000 | 2023_Q4 |                4 |\n|     2 |    800 | 2023_Q4 |                3 |\n|     2 |   4500 | 2023_Q4 |                5 |\n|     3 |   2700 | 2023_Q4 |                3 |\n|     3 |  16000 | 2023_Q4 |                0 |\n|     3 |  10200 | 2023_Q4 |                1 |\n+-------+--------+---------+------------------+\n\nWITH\n  sales_without_discount AS\n    (SELECT * EXCLUDE(discount_percent) FROM quarterly_sales)\nSELECT *\n  FROM sales_without_discount\n    PIVOT(SUM(amount) FOR quarter IN (ANY ORDER BY quarter))\n  ORDER BY empid;\n\n+-------+-----------+-----------+-----------+-----------+\n| EMPID | '2023_Q1' | '2023_Q2' | '2023_Q3' | '2023_Q4' |\n|-------+-----------+-----------+-----------+-----------|\n|     1 |     10400 |      8000 |     11000 |     18000 |\n|     2 |     39500 |     90700 |     12000 |      5300 |\n|     3 |      NULL |      NULL |      2700 |     28900 |\n+-------+-----------+-----------+-----------+-----------+\n\nWITH\n  sales_without_amount AS\n    (SELECT * EXCLUDE(amount) FROM quarterly_sales)\nSELECT *\n  FROM sales_without_amount\n    PIVOT(AVG(discount_percent) FOR quarter IN (ANY ORDER BY quarter))\n  ORDER BY empid;\n\n+-------+-----------+-----------+-----------+-----------+\n| EMPID | '2023_Q1' | '2023_Q2' | '2023_Q3' | '2023_Q4' |\n|-------+-----------+-----------+-----------+-----------|\n|     1 |  0.500000 |  1.500000 |  2.000000 |  2.500000 |\n|     2 |  3.000000 |  1.500000 |  2.000000 |  4.000000 |\n|     3 |      NULL |      NULL |  1.000000 |  1.333333 |\n+-------+-----------+-----------+-----------+-----------+\n\nSELECT SUM($1) AS q1_sales_total,\n       SUM($2) AS q2_sales_total,\n       SUM($3) AS q3_sales_total,\n       SUM($4) AS q4_sales_total,\n       MAX($5) AS q1_maximum_discount,\n       MAX($6) AS q2_maximum_discount,\n       MAX($7) AS q3_maximum_discount,\n       MAX($8) AS q4_maximum_discount\n  FROM\n    (SELECT amount,\n            quarter AS quarter_amount,\n            quarter AS quarter_discount,\n            discount_percent\n      FROM quarterly_sales)\n  PIVOT (\n    SUM(amount)\n    FOR quarter_amount IN (\n      '2023_Q1',\n      '2023_Q2',\n      '2023_Q3',\n      '2023_Q4'))\n  PIVOT (\n    MAX(discount_percent)\n    FOR quarter_discount IN (\n      '2023_Q1',\n      '2023_Q2',\n      '2023_Q3',\n      '2023_Q4'));\n\n+----------------+----------------+----------------+----------------+---------------------+---------------------+---------------------+---------------------+\n| Q1_SALES_TOTAL | Q2_SALES_TOTAL | Q3_SALES_TOTAL | Q4_SALES_TOTAL | Q1_MAXIMUM_DISCOUNT | Q2_MAXIMUM_DISCOUNT | Q3_MAXIMUM_DISCOUNT | Q4_MAXIMUM_DISCOUNT |\n|----------------+----------------+----------------+----------------+---------------------+---------------------+---------------------+---------------------|\n|          49900 |          98700 |          25700 |          52200 |                   4 |                   2 |                   3 |                   5 |\n+----------------+----------------+----------------+----------------+---------------------+---------------------+---------------------+---------------------+"
},
{
    "url": "https://docs.snowflake.com/en/sql-reference/constructs/match_recognize",
    "title": "MATCH_RECOGNIZE",
    "description": "Recognizes matches of a pattern in a set of rows.",
    "syntax": "MATCH_RECOGNIZE (\n    [ PARTITION BY <expr> [, ... ] ]\n    [ ORDER BY <expr> [, ... ] ]\n    [ MEASURES <expr> [AS] <alias> [, ... ] ]\n    [ ONE ROW PER MATCH |\n      ALL ROWS PER MATCH [ { SHOW EMPTY MATCHES | OMIT EMPTY MATCHES | WITH UNMATCHED ROWS } ]\n      ]\n    [ AFTER MATCH SKIP\n          {\n          PAST LAST ROW   |\n          TO NEXT ROW   |\n          TO [ { FIRST | LAST} ] <symbol>\n          }\n      ]\n    PATTERN ( <pattern> )\n    DEFINE <symbol> AS <expr> [, ... ]\n)",
    "example": "create table stock_price_history (company TEXT, price_date DATE, price INT);\n\ninsert into stock_price_history values\n    ('ABCD', '2020-10-01', 50),\n    ('XYZ' , '2020-10-01', 89),\n    ('ABCD', '2020-10-02', 36),\n    ('XYZ' , '2020-10-02', 24),\n    ('ABCD', '2020-10-03', 39),\n    ('XYZ' , '2020-10-03', 37),\n    ('ABCD', '2020-10-04', 42),\n    ('XYZ' , '2020-10-04', 63),\n    ('ABCD', '2020-10-05', 30),\n    ('XYZ' , '2020-10-05', 65),\n    ('ABCD', '2020-10-06', 47),\n    ('XYZ' , '2020-10-06', 56),\n    ('ABCD', '2020-10-07', 71),\n    ('XYZ' , '2020-10-07', 50),\n    ('ABCD', '2020-10-08', 80),\n    ('XYZ' , '2020-10-08', 54),\n    ('ABCD', '2020-10-09', 75),\n    ('XYZ' , '2020-10-09', 30),\n    ('ABCD', '2020-10-10', 63),\n    ('XYZ' , '2020-10-10', 32);\n\nSELECT * FROM stock_price_history\n  MATCH_RECOGNIZE(\n    PARTITION BY company\n    ORDER BY price_date\n    MEASURES\n      MATCH_NUMBER() AS match_number,\n      FIRST(price_date) AS start_date,\n      LAST(price_date) AS end_date,\n      COUNT(*) AS rows_in_sequence,\n      COUNT(row_with_price_decrease.*) AS num_decreases,\n      COUNT(row_with_price_increase.*) AS num_increases\n    ONE ROW PER MATCH\n    AFTER MATCH SKIP TO LAST row_with_price_increase\n    PATTERN(row_before_decrease row_with_price_decrease+ row_with_price_increase+)\n    DEFINE\n      row_with_price_decrease AS price < LAG(price),\n      row_with_price_increase AS price > LAG(price)\n  )\nORDER BY company, match_number;\n+---------+--------------+------------+------------+------------------+---------------+---------------+\n| COMPANY | MATCH_NUMBER | START_DATE | END_DATE   | ROWS_IN_SEQUENCE | NUM_DECREASES | NUM_INCREASES |\n|---------+--------------+------------+------------+------------------+---------------+---------------|\n| ABCD    |            1 | 2020-10-01 | 2020-10-04 |                4 |             1 |             2 |\n| ABCD    |            2 | 2020-10-04 | 2020-10-08 |                5 |             1 |             3 |\n| XYZ     |            1 | 2020-10-01 | 2020-10-05 |                5 |             1 |             3 |\n| XYZ     |            2 | 2020-10-05 | 2020-10-08 |                4 |             2 |             1 |\n| XYZ     |            3 | 2020-10-08 | 2020-10-10 |                3 |             1 |             1 |\n+---------+--------------+------------+------------+------------------+---------------+---------------+\n\nselect price_date, match_number, msq, price, cl from\n  (select * from stock_price_history where company='ABCD') match_recognize(\n    order by price_date\n    measures\n        match_number() as \"MATCH_NUMBER\",\n        match_sequence_number() as msq,\n        classifier() as cl\n    all rows per match\n    pattern(ANY_ROW UP+)\n    define\n        ANY_ROW AS TRUE,\n        UP as price > lag(price)\n)\norder by match_number, msq;\n+------------+--------------+-----+-------+---------+\n| PRICE_DATE | MATCH_NUMBER | MSQ | PRICE | CL      |\n|------------+--------------+-----+-------+---------|\n| 2020-10-02 |            1 |   1 |    36 | ANY_ROW |\n| 2020-10-03 |            1 |   2 |    39 | UP      |\n| 2020-10-04 |            1 |   3 |    42 | UP      |\n| 2020-10-05 |            2 |   1 |    30 | ANY_ROW |\n| 2020-10-06 |            2 |   2 |    47 | UP      |\n| 2020-10-07 |            2 |   3 |    71 | UP      |\n| 2020-10-08 |            2 |   4 |    80 | UP      |\n+------------+--------------+-----+-------+---------+\n\nselect * from stock_price_history match_recognize(\n    partition by company\n    order by price_date\n    measures\n        match_number() as \"MATCH_NUMBER\"\n    all rows per match omit empty matches\n    pattern(OVERAVG*)\n    define\n        OVERAVG as price > avg(price) over (rows between unbounded\n                                  preceding and unbounded following)\n)\norder by company, price_date;\n+---------+------------+-------+--------------+\n| COMPANY | PRICE_DATE | PRICE | MATCH_NUMBER |\n|---------+------------+-------+--------------|\n| ABCD    | 2020-10-07 |    71 |            7 |\n| ABCD    | 2020-10-08 |    80 |            7 |\n| ABCD    | 2020-10-09 |    75 |            7 |\n| ABCD    | 2020-10-10 |    63 |            7 |\n| XYZ     | 2020-10-01 |    89 |            1 |\n| XYZ     | 2020-10-04 |    63 |            4 |\n| XYZ     | 2020-10-05 |    65 |            4 |\n| XYZ     | 2020-10-06 |    56 |            4 |\n| XYZ     | 2020-10-08 |    54 |            6 |\n+---------+------------+-------+--------------+\n\nselect * from stock_price_history match_recognize(\n    partition by company\n    order by price_date\n    measures\n        match_number() as \"MATCH_NUMBER\",\n        classifier() as cl\n    all rows per match with unmatched rows\n    pattern(OVERAVG+)\n    define\n        OVERAVG as price > avg(price) over (rows between unbounded\n                                 preceding and unbounded following)\n)\norder by company, price_date;\n+---------+------------+-------+--------------+---------+\n| COMPANY | PRICE_DATE | PRICE | MATCH_NUMBER | CL      |\n|---------+------------+-------+--------------+---------|\n| ABCD    | 2020-10-01 |    50 |         NULL | NULL    |\n| ABCD    | 2020-10-02 |    36 |         NULL | NULL    |\n| ABCD    | 2020-10-03 |    39 |         NULL | NULL    |\n| ABCD    | 2020-10-04 |    42 |         NULL | NULL    |\n| ABCD    | 2020-10-05 |    30 |         NULL | NULL    |\n| ABCD    | 2020-10-06 |    47 |         NULL | NULL    |\n| ABCD    | 2020-10-07 |    71 |            1 | OVERAVG |\n| ABCD    | 2020-10-08 |    80 |            1 | OVERAVG |\n| ABCD    | 2020-10-09 |    75 |            1 | OVERAVG |\n| ABCD    | 2020-10-10 |    63 |            1 | OVERAVG |\n| XYZ     | 2020-10-01 |    89 |            1 | OVERAVG |\n| XYZ     | 2020-10-02 |    24 |         NULL | NULL    |\n| XYZ     | 2020-10-03 |    37 |         NULL | NULL    |\n| XYZ     | 2020-10-04 |    63 |            2 | OVERAVG |\n| XYZ     | 2020-10-05 |    65 |            2 | OVERAVG |\n| XYZ     | 2020-10-06 |    56 |            2 | OVERAVG |\n| XYZ     | 2020-10-07 |    50 |         NULL | NULL    |\n| XYZ     | 2020-10-08 |    54 |            3 | OVERAVG |\n| XYZ     | 2020-10-09 |    30 |         NULL | NULL    |\n| XYZ     | 2020-10-10 |    32 |         NULL | NULL    |\n+---------+------------+-------+--------------+---------+\n\nSELECT company, price_date, price, \"FINAL FIRST(LT45.price)\", \"FINAL LAST(LT45.price)\"\n    FROM stock_price_history\n       MATCH_RECOGNIZE (\n           PARTITION BY company\n           ORDER BY price_date\n           MEASURES\n               FINAL FIRST(LT45.price) AS \"FINAL FIRST(LT45.price)\",\n               FINAL LAST(LT45.price)  AS \"FINAL LAST(LT45.price)\"\n           ALL ROWS PER MATCH\n           AFTER MATCH SKIP PAST LAST ROW\n           PATTERN (LT45 LT45)\n           DEFINE\n               LT45 AS price < 45.00\n           )\n    WHERE company = 'ABCD'\n    ORDER BY price_date;\n+---------+------------+-------+-------------------------+------------------------+\n| COMPANY | PRICE_DATE | PRICE | FINAL FIRST(LT45.price) | FINAL LAST(LT45.price) |\n|---------+------------+-------+-------------------------+------------------------|\n| ABCD    | 2020-10-02 |    36 |                      36 |                     39 |\n| ABCD    | 2020-10-03 |    39 |                      36 |                     39 |\n| ABCD    | 2020-10-04 |    42 |                      42 |                     30 |\n| ABCD    | 2020-10-05 |    30 |                      42 |                     30 |\n+---------+------------+-------+-------------------------+------------------------+"
},
{
    "url": "https://docs.snowflake.com/en/sql-reference/constructs/join-lateral",
    "title": "LATERAL",
    "description": "In a",
    "syntax": "SELECT ...\nFROM <left_hand_table_expression>, LATERAL ( <inline_view> )\n...",
    "example": "CREATE TABLE departments (department_id INTEGER, name VARCHAR);\nCREATE TABLE employees (employee_ID INTEGER, last_name VARCHAR,\n  department_ID INTEGER, project_names ARRAY);\n\nINSERT INTO departments (department_ID, name) VALUES\n  (1, 'Engineering'),\n  (2, 'Support');\nINSERT INTO employees (employee_ID, last_name, department_ID) VALUES\n  (101, 'Richards', 1),\n  (102, 'Paulson',  1),\n  (103, 'Johnson',  2);\n\nSELECT *\n  FROM departments AS d,\n    LATERAL (SELECT * FROM employees AS e WHERE e.department_ID = d.department_ID) AS iv2\n  ORDER BY employee_ID;\n\n+---------------+-------------+-------------+-----------+---------------+---------------+\n| DEPARTMENT_ID | NAME        | EMPLOYEE_ID | LAST_NAME | DEPARTMENT_ID | PROJECT_NAMES |\n|---------------+-------------+-------------+-----------+---------------+---------------|\n|             1 | Engineering |         101 | Richards  |             1 | NULL          |\n|             1 | Engineering |         102 | Paulson   |             1 | NULL          |\n|             2 | Support     |         103 | Johnson   |             2 | NULL          |\n+---------------+-------------+-------------+-----------+---------------+---------------+\n\nSELECT *\n  FROM departments AS d INNER JOIN\n    LATERAL (SELECT * FROM employees AS e WHERE e.department_ID = d.department_ID) AS iv2\n  ORDER BY employee_ID;"
},
{
    "url": "https://docs.snowflake.com/en/sql-reference/constructs/asof-join",
    "title": "ASOF JOIN",
    "description": "An ASOF JOIN operation combines rows from two tables based on timestamp values that follow each\nother, precede each other, or match exactly. For each row in the first (or left) table, the join finds a single\nrow in the second (or right) table that has the closest timestamp value. The qualifying row on the right side\nis the closest match, which could be equal in time, earlier in time, or later in time, depending on the specified\ncomparison operator.",
    "syntax": "FROM <left_table> ASOF JOIN <right_table>\n  MATCH_CONDITION ( <left_table.timecol> <comparison_operator> <right_table.timecol> )\n  [ ON <table.col> = <table.col> [ AND ... ] | USING ( <column_list> ) ]",
    "example": "INSERT INTO trades VALUES('SNOW','2023-09-30 12:02:55.000',3000);\n\n+-------------------------+\n| number of rows inserted |\n|-------------------------|\n|                       1 |\n+-------------------------+\n\nSELECT t.stock_symbol, t.trade_time, t.quantity, q.quote_time, q.price\n  FROM trades t ASOF JOIN quotes q\n    MATCH_CONDITION(t.trade_time >= quote_time)\n    ON t.stock_symbol=q.stock_symbol\n  ORDER BY t.stock_symbol;\n\n+--------------+-------------------------+----------+-------------------------+--------------+\n| STOCK_SYMBOL | TRADE_TIME              | QUANTITY | QUOTE_TIME              |        PRICE |\n|--------------+-------------------------+----------+-------------------------+--------------|\n| AAPL         | 2023-10-01 09:00:05.000 |     2000 | 2023-10-01 09:00:03.000 | 139.00000000 |\n| SNOW         | 2023-09-30 12:02:55.000 |     3000 | NULL                    |         NULL |\n| SNOW         | 2023-10-01 09:00:05.000 |     1000 | 2023-10-01 09:00:02.000 | 163.00000000 |\n| SNOW         | 2023-10-01 09:00:10.000 |     1500 | 2023-10-01 09:00:08.000 | 165.00000000 |\n+--------------+-------------------------+----------+-------------------------+--------------+\n\nSELECT t.stock_symbol, t.trade_time, t.quantity, q.quote_time, q.price\n  FROM trades t ASOF JOIN quotes q\n    MATCH_CONDITION(t.trade_time <= quote_time)\n    ON t.stock_symbol=q.stock_symbol\n  ORDER BY t.stock_symbol;\n\n+--------------+-------------------------+----------+-------------------------+--------------+\n| STOCK_SYMBOL | TRADE_TIME              | QUANTITY | QUOTE_TIME              |        PRICE |\n|--------------+-------------------------+----------+-------------------------+--------------|\n| AAPL         | 2023-10-01 09:00:05.000 |     2000 | 2023-10-01 09:00:07.000 | 142.00000000 |\n| SNOW         | 2023-10-01 09:00:10.000 |     1500 | NULL                    |         NULL |\n| SNOW         | 2023-10-01 09:00:05.000 |     1000 | 2023-10-01 09:00:07.000 | 166.00000000 |\n| SNOW         | 2023-09-30 12:02:55.000 |     3000 | 2023-10-01 09:00:01.000 | 166.00000000 |\n+--------------+-------------------------+----------+-------------------------+--------------+\n\nSELECT t.stock_symbol, t.trade_time, t.quantity, q.quote_time, q.price\n  FROM trades t ASOF JOIN quotes q\n    MATCH_CONDITION(t.trade_time <= quote_time)\n    USING(stock_symbol)\n  ORDER BY t.stock_symbol;\n\nCREATE OR REPLACE TABLE companies(\n  stock_symbol VARCHAR(4),\n  company_name VARCHAR(100)\n);\n\n INSERT INTO companies VALUES\n  ('NVDA','NVIDIA Corp'),\n  ('TSLA','Tesla Inc'),\n  ('SNOW','Snowflake Inc'),\n  ('AAPL','Apple Inc')\n;\n\nSELECT t.stock_symbol, c.company_name, t.trade_time, t.quantity, q.quote_time, q.price\n  FROM trades t ASOF JOIN quotes q\n    MATCH_CONDITION(t.trade_time >= quote_time)\n    ON t.stock_symbol=q.stock_symbol\n    INNER JOIN companies c ON c.stock_symbol=t.stock_symbol\n  ORDER BY t.stock_symbol;\n\n+--------------+---------------+-------------------------+----------+-------------------------+--------------+\n| STOCK_SYMBOL | COMPANY_NAME  | TRADE_TIME              | QUANTITY | QUOTE_TIME              |        PRICE |\n|--------------+---------------+-------------------------+----------+-------------------------+--------------|\n| AAPL         | Apple Inc     | 2023-10-01 09:00:05.000 |     2000 | 2023-10-01 09:00:03.000 | 139.00000000 |\n| SNOW         | Snowflake Inc | 2023-09-30 12:02:55.000 |     3000 | NULL                    |         NULL |\n| SNOW         | Snowflake Inc | 2023-10-01 09:00:05.000 |     1000 | 2023-10-01 09:00:02.000 | 163.00000000 |\n| SNOW         | Snowflake Inc | 2023-10-01 09:00:10.000 |     1500 | 2023-10-01 09:00:08.000 | 165.00000000 |\n+--------------+---------------+-------------------------+----------+-------------------------+--------------+\n\nSELECT * FROM trades_unixtime;\n\n+--------------+------------+----------+--------------+\n| STOCK_SYMBOL | TRADE_TIME | QUANTITY |        PRICE |\n|--------------+------------+----------+--------------|\n| SNOW         | 1696150805 |      100 | 165.33300000 |\n+--------------+------------+----------+--------------+\n\nSELECT * FROM quotes_unixtime;\n\n+--------------+------------+----------+--------------+--------------+\n| STOCK_SYMBOL | QUOTE_TIME | QUANTITY |          BID |          ASK |\n|--------------+------------+----------+--------------+--------------|\n| SNOW         | 1696150802 |      100 | 166.00000000 | 165.00000000 |\n+--------------+------------+----------+--------------+--------------+\n\nSELECT *\n  FROM trades_unixtime tu\n    ASOF JOIN quotes_unixtime qu\n    MATCH_CONDITION(tu.trade_time>=qu.quote_time);\n\n+--------------+------------+----------+--------------+--------------+------------+----------+--------------+--------------+\n| STOCK_SYMBOL | TRADE_TIME | QUANTITY |        PRICE | STOCK_SYMBOL | QUOTE_TIME | QUANTITY |          BID |          ASK |\n|--------------+------------+----------+--------------+--------------+------------+----------+--------------+--------------|\n| SNOW         | 1696150805 |      100 | 165.33300000 | SNOW         | 1696150802 |      100 | 166.00000000 | 165.00000000 |\n+--------------+------------+----------+--------------+--------------+------------+----------+--------------+--------------+\n\nCREATE OR REPLACE TABLE raintime(\n  observed TIME(9),\n  location VARCHAR(40),\n  state VARCHAR(2),\n  observation NUMBER(5,2)\n);\n\nINSERT INTO raintime VALUES\n  ('14:42:59.230', 'Ahwahnee', 'CA', 0.90),\n  ('14:42:59.001', 'Oakhurst', 'CA', 0.50),\n  ('14:42:44.435', 'Reno', 'NV', 0.00)\n;\n\nCREATE OR REPLACE TABLE preciptime(\n  observed TIME(9),\n  location VARCHAR(40),\n  state VARCHAR(2),\n  observation NUMBER(5,2)\n);\n\nINSERT INTO preciptime VALUES\n  ('14:42:59.230', 'Ahwahnee', 'CA', 0.91),\n  ('14:42:59.001', 'Oakhurst', 'CA', 0.51),\n  ('14:41:44.435', 'Las Vegas', 'NV', 0.01),\n  ('14:42:44.435', 'Reno', 'NV', 0.01),\n  ('14:40:34.000', 'Bozeman', 'MT', 1.11)\n;\n\nCREATE OR REPLACE TABLE snowtime(\n  observed TIME(9),\n  location VARCHAR(40),\n  state VARCHAR(2),\n  observation NUMBER(5,2)\n);\n\nINSERT INTO snowtime VALUES\n  ('14:42:59.199', 'Fish Camp', 'CA', 3.20),\n  ('14:42:44.435', 'Reno', 'NV', 3.00),\n  ('14:43:01.000', 'Lake Tahoe', 'CA', 4.20),\n  ('14:42:45.000', 'Bozeman', 'MT', 1.80)\n;\n\nSELECT * FROM preciptime p ASOF JOIN snowtime s MATCH_CONDITION(p.observed>=s.observed)\n  ORDER BY p.observed;\n\n+----------+-----------+-------+-------------+----------+-----------+-------+-------------+\n| OBSERVED | LOCATION  | STATE | OBSERVATION | OBSERVED | LOCATION  | STATE | OBSERVATION |\n|----------+-----------+-------+-------------+----------+-----------+-------+-------------|\n| 14:40:34 | Bozeman   | MT    |        1.11 | NULL     | NULL      | NULL  |        NULL |\n| 14:41:44 | Las Vegas | NV    |        0.01 | NULL     | NULL      | NULL  |        NULL |\n| 14:42:44 | Reno      | NV    |        0.01 | 14:42:44 | Reno      | NV    |        3.00 |\n| 14:42:59 | Oakhurst  | CA    |        0.51 | 14:42:45 | Bozeman   | MT    |        1.80 |\n| 14:42:59 | Ahwahnee  | CA    |        0.91 | 14:42:59 | Fish Camp | CA    |        3.20 |\n+----------+-----------+-------+-------------+----------+-----------+-------+-------------+\n\nALTER SESSION SET TIME_OUTPUT_FORMAT = 'HH24:MI:SS.FF3';\n\n+----------------------------------+\n| status                           |\n|----------------------------------|\n| Statement executed successfully. |\n+----------------------------------+\n\nSELECT * FROM preciptime p ASOF JOIN snowtime s MATCH_CONDITION(p.observed>=s.observed)\n  ORDER BY p.observed;\n\n+--------------+-----------+-------+-------------+--------------+-----------+-------+-------------+\n| OBSERVED     | LOCATION  | STATE | OBSERVATION | OBSERVED     | LOCATION  | STATE | OBSERVATION |\n|--------------+-----------+-------+-------------+--------------+-----------+-------+-------------|\n| 14:40:34.000 | Bozeman   | MT    |        1.11 | NULL         | NULL      | NULL  |        NULL |\n| 14:41:44.435 | Las Vegas | NV    |        0.01 | NULL         | NULL      | NULL  |        NULL |\n| 14:42:44.435 | Reno      | NV    |        0.01 | 14:42:44.435 | Reno      | NV    |        3.00 |\n| 14:42:59.001 | Oakhurst  | CA    |        0.51 | 14:42:45.000 | Bozeman   | MT    |        1.80 |\n| 14:42:59.230 | Ahwahnee  | CA    |        0.91 | 14:42:59.199 | Fish Camp | CA    |        3.20 |\n+--------------+-----------+-------+-------------+--------------+-----------+-------+-------------+\n\nALTER SESSION SET TIME_OUTPUT_FORMAT = 'HH24:MI:SS.FF3';\n\nSELECT *\n  FROM snowtime s\n    ASOF JOIN raintime r\n      MATCH_CONDITION(s.observed>=r.observed)\n      ON s.state=r.state\n    ASOF JOIN preciptime p\n      MATCH_CONDITION(s.observed>=p.observed)\n      ON s.state=p.state\n  ORDER BY s.observed;\n\n+--------------+------------+-------+-------------+--------------+----------+-------+-------------+--------------+----------+-------+-------------+\n| OBSERVED     | LOCATION   | STATE | OBSERVATION | OBSERVED     | LOCATION | STATE | OBSERVATION | OBSERVED     | LOCATION | STATE | OBSERVATION |\n|--------------+------------+-------+-------------+--------------+----------+-------+-------------+--------------+----------+-------+-------------|\n| 14:42:44.435 | Reno       | NV    |        3.00 | 14:42:44.435 | Reno     | NV    |        0.00 | 14:42:44.435 | Reno     | NV    |        0.01 |\n| 14:42:45.000 | Bozeman    | MT    |        1.80 | NULL         | NULL     | NULL  |        NULL | 14:40:34.000 | Bozeman  | MT    |        1.11 |\n| 14:42:59.199 | Fish Camp  | CA    |        3.20 | 14:42:59.001 | Oakhurst | CA    |        0.50 | 14:42:59.001 | Oakhurst | CA    |        0.51 |\n| 14:43:01.000 | Lake Tahoe | CA    |        4.20 | 14:42:59.230 | Ahwahnee | CA    |        0.90 | 14:42:59.230 | Ahwahnee | CA    |        0.91 |\n+--------------+------------+-------+-------------+--------------+----------+-------+-------------+--------------+----------+-------+-------------+\n\nSELECT *\n  FROM snowtime s\n    ASOF JOIN raintime r\n      MATCH_CONDITION(s.observed>r.observed)\n      ON s.state=r.state\n    ASOF JOIN preciptime p\n      MATCH_CONDITION(s.observed<p.observed)\n      ON s.state=p.state\n  ORDER BY s.observed;\n\n+--------------+------------+-------+-------------+--------------+-----------+-------+-------------+--------------+----------+-------+-------------+\n| OBSERVED     | LOCATION   | STATE | OBSERVATION | OBSERVED     | LOCATION  | STATE | OBSERVATION | OBSERVED     | LOCATION | STATE | OBSERVATION |\n|--------------+------------+-------+-------------+--------------+-----------+-------+-------------+--------------+----------+-------+-------------|\n| 14:42:44.435 | Reno       | NV    |        3.00 | 14:41:44.435 | Las Vegas | NV    |        0.00 | NULL         | NULL     | NULL  |        NULL |\n| 14:42:45.000 | Bozeman    | MT    |        1.80 | NULL         | NULL      | NULL  |        NULL | NULL         | NULL     | NULL  |        NULL |\n| 14:42:59.199 | Fish Camp  | CA    |        3.20 | 14:42:59.001 | Oakhurst  | CA    |        0.50 | 14:42:59.230 | Ahwahnee | CA    |        0.91 |\n| 14:43:01.000 | Lake Tahoe | CA    |        4.20 | 14:42:59.230 | Ahwahnee  | CA    |        0.90 | NULL         | NULL     | NULL  |        NULL |\n+--------------+------------+-------+-------------+--------------+-----------+-------+-------------+--------------+----------+-------+-------------+\n\nSELECT * FROM snowtime s ASOF JOIN preciptime p MATCH_CONDITION(p.observed>=s.observed);\n\n010002 (42601): SQL compilation error:\nMATCH_CONDITION clause is invalid: The left side allows only column references from the left side table, and the right side allows only column references from the right side table.\n\nSELECT * FROM preciptime p ASOF JOIN snowtime s MATCH_CONDITION(p.observed=s.observed);\n\n010001 (42601): SQL compilation error:\nMATCH_CONDITION clause is invalid: Only comparison operators '>=', '>', '<=' and '<' are allowed. Keywords such as AND and OR are not allowed.\n\nSELECT *\n  FROM preciptime p ASOF JOIN snowtime s\n  MATCH_CONDITION(p.observed>=s.observed)\n  ON s.state>=p.state;\n\n010010 (42601): SQL compilation error:\nON clause for ASOF JOIN must contain conjunctions of equality conditions only. Disjunctions are not allowed. Each side of an equality condition must only refer to either the left table or the right table. S.STATE >= P.STATE is invalid.\n\nSELECT *\n  FROM preciptime p ASOF JOIN snowtime s\n  MATCH_CONDITION(p.observed>=s.observed)\n  ON s.state=p.state OR s.location=p.location;\n\n010010 (42601): SQL compilation error:\nON clause for ASOF JOIN must contain conjunctions of equality conditions only. Disjunctions are not allowed. Each side of an equality condition must only refer to either the left table or the right table. (S.STATE = P.STATE) OR (S.LOCATION = P.LOCATION) is invalid.\n\nSELECT t1.a \"t1a\", t2.a \"t2a\"\n  FROM t1 ASOF JOIN\n    LATERAL(SELECT a FROM t2 WHERE t1.b = t2.b) t2\n    MATCH_CONDITION(t1.a >= t2.a)\n  ORDER BY 1,2;\n\n010004 (42601): SQL compilation error:\nASOF JOIN is not supported for joins with LATERAL table functions or LATERAL views."
},
{
    "url": "https://docs.snowflake.com/en/sql-reference/constructs/join",
    "title": "JOIN",
    "description": "A",
    "syntax": "SELECT ...\nFROM <object_ref1> [\n                     {\n                       INNER\n                       | { LEFT | RIGHT | FULL } [ OUTER ]\n                     }\n                   ]\n                   JOIN <object_ref2>\n  [ ON <condition> ]\n[ ... ]",
    "example": "CREATE TABLE t1 (col1 INTEGER);\nCREATE TABLE t2 (col1 INTEGER);\n\nINSERT INTO t1 (col1) VALUES \n   (2),\n   (3),\n   (4);\nINSERT INTO t2 (col1) VALUES \n   (1),\n   (2),\n   (2),\n   (3);\n\nSELECT t1.col1, t2.col1\n    FROM t1 INNER JOIN t2\n        ON t2.col1 = t1.col1\n    ORDER BY 1,2;\n+------+------+\n| COL1 | COL1 |\n|------+------|\n|    2 |    2 |\n|    2 |    2 |\n|    3 |    3 |\n+------+------+\n\nSELECT t1.col1, t2.col1\n    FROM t1 LEFT OUTER JOIN t2\n        ON t2.col1 = t1.col1\n    ORDER BY 1,2;\n+------+------+\n| COL1 | COL1 |\n|------+------|\n|    2 |    2 |\n|    2 |    2 |\n|    3 |    3 |\n|    4 | NULL |\n+------+------+\n\nSELECT t1.col1, t2.col1\n    FROM t1 RIGHT OUTER JOIN t2\n        ON t2.col1 = t1.col1\n    ORDER BY 1,2;\n+------+------+\n| COL1 | COL1 |\n|------+------|\n|    2 |    2 |\n|    2 |    2 |\n|    3 |    3 |\n| NULL |    1 |\n+------+------+\n\nSELECT t1.col1, t2.col1\n    FROM t1 FULL OUTER JOIN t2\n        ON t2.col1 = t1.col1\n    ORDER BY 1,2;\n+------+------+\n| COL1 | COL1 |\n|------+------|\n|    2 |    2 |\n|    2 |    2 |\n|    3 |    3 |\n|    4 | NULL |\n| NULL |    1 |\n+------+------+\n\nSELECT t1.col1, t2.col1\n    FROM t1 CROSS JOIN t2\n    ORDER BY 1, 2;\n+------+------+\n| COL1 | COL1 |\n|------+------|\n|    2 |    1 |\n|    2 |    2 |\n|    2 |    2 |\n|    2 |    3 |\n|    3 |    1 |\n|    3 |    2 |\n|    3 |    2 |\n|    3 |    3 |\n|    4 |    1 |\n|    4 |    2 |\n|    4 |    2 |\n|    4 |    3 |\n+------+------+\n\nSELECT t1.col1, t2.col1\n    FROM t1 CROSS JOIN t2\n    WHERE t2.col1 = t1.col1\n    ORDER BY 1, 2;\n+------+------+\n| COL1 | COL1 |\n|------+------|\n|    2 |    2 |\n|    2 |    2 |\n|    3 |    3 |\n+------+------+\n\nCREATE OR REPLACE TABLE d1 (\n  id number,\n  name string\n  );\n+--------------------------------+\n| status                         |\n|--------------------------------|\n| Table D1 successfully created. |\n+--------------------------------+\nINSERT INTO d1 (id, name) VALUES\n  (1,'a'),\n  (2,'b'),\n  (4,'c');\n+-------------------------+\n| number of rows inserted |\n|-------------------------|\n|                       3 |\n+-------------------------+\nCREATE OR REPLACE TABLE d2 (\n  id number,\n  value string\n  );\n+--------------------------------+\n| status                         |\n|--------------------------------|\n| Table D2 successfully created. |\n+--------------------------------+\nINSERT INTO d2 (id, value) VALUES\n  (1,'xx'),\n  (2,'yy'),\n  (5,'zz');\n+-------------------------+\n| number of rows inserted |\n|-------------------------|\n|                       3 |\n+-------------------------+\nSELECT *\n    FROM d1 NATURAL INNER JOIN d2\n    ORDER BY id;\n+----+------+-------+\n| ID | NAME | VALUE |\n|----+------+-------|\n|  1 | a    | xx    |\n|  2 | b    | yy    |\n+----+------+-------+\n\nSELECT *\n  FROM d1 NATURAL FULL OUTER JOIN d2\n  ORDER BY ID;\n+----+------+-------+\n| ID | NAME | VALUE |\n|----+------+-------|\n|  1 | a    | xx    |\n|  2 | b    | yy    |\n|  4 | c    | NULL  |\n|  5 | NULL | zz    |\n+----+------+-------+\n\nCREATE TABLE t3 (col1 INTEGER);\nINSERT INTO t3 (col1) VALUES \n   (2),\n   (6);\n\nSELECT t1.*, t2.*, t3.*\n  FROM t1\n     LEFT OUTER JOIN t2 ON (t1.col1 = t2.col1)\n     RIGHT OUTER JOIN t3 ON (t3.col1 = t2.col1)\n  ORDER BY t1.col1;\n+------+------+------+\n| COL1 | COL1 | COL1 |\n|------+------+------|\n|    2 |    2 |    2 |\n|    2 |    2 |    2 |\n| NULL | NULL |    6 |\n+------+------+------+\n\nSELECT t1.*, t2.*, t3.*\n  FROM t1\n     LEFT OUTER JOIN\n     (t2 RIGHT OUTER JOIN t3 ON (t3.col1 = t2.col1))\n     ON (t1.col1 = t2.col1)\n  ORDER BY t1.col1;\n+------+------+------+\n| COL1 | COL1 | COL1 |\n|------+------+------|\n|    2 |    2 |    2 |\n|    2 |    2 |    2 |\n|    3 | NULL | NULL |\n|    4 | NULL | NULL |\n+------+------+------+\n\nWITH\n    l AS (\n         SELECT 'a' AS userid\n         ),\n    r AS (\n         SELECT 'b' AS userid\n         )\n  SELECT *\n    FROM l LEFT JOIN r USING(userid)\n;\n+--------+\n| USERID |\n|--------|\n| a      |\n+--------+\n\nWITH\n    l AS (\n         SELECT 'a' AS userid\n       ),\n    r AS (\n         SELECT 'b' AS userid\n         )\n  SELECT l.userid as UI_L,\n         r.userid as UI_R\n    FROM l LEFT JOIN r USING(userid)\n;\n+------+------+\n| UI_L | UI_R |\n|------+------|\n| a    | NULL |\n+------+------+"
},
{
    "url": "https://docs.snowflake.com/en/sql-reference/constructs/connect-by",
    "title": "CONNECT BY",
    "description": "Joins a table to itself to process hierarchical data in the table. The",
    "syntax": "SELECT <column_list> [ , <level_expression> ]\n  FROM <data_source>\n    START WITH <predicate>\n    CONNECT BY [ PRIOR ] <col1_identifier> = [ PRIOR ] <col2_identifier>\n           [ , [ PRIOR ] <col3_identifier> = [ PRIOR ] <col4_identifier> ]\n           ...\n  ...",
    "example": "CREATE OR REPLACE TABLE employees (title VARCHAR, employee_ID INTEGER, manager_ID INTEGER);\n\nINSERT INTO employees (title, employee_ID, manager_ID) VALUES\n    ('President', 1, NULL),  -- The President has no manager.\n        ('Vice President Engineering', 10, 1),\n            ('Programmer', 100, 10),\n            ('QA Engineer', 101, 10),\n        ('Vice President HR', 20, 1),\n            ('Health Insurance Analyst', 200, 20);\n\nSELECT employee_ID, manager_ID, title\n  FROM employees\n    START WITH title = 'President'\n    CONNECT BY\n      manager_ID = PRIOR employee_id\n  ORDER BY employee_ID;\n+-------------+------------+----------------------------+\n| EMPLOYEE_ID | MANAGER_ID | TITLE                      |\n|-------------+------------+----------------------------|\n|           1 |       NULL | President                  |\n|          10 |          1 | Vice President Engineering |\n|          20 |          1 | Vice President HR          |\n|         100 |         10 | Programmer                 |\n|         101 |         10 | QA Engineer                |\n|         200 |         20 | Health Insurance Analyst   |\n+-------------+------------+----------------------------+\n\nSELECT SYS_CONNECT_BY_PATH(title, ' -> '), employee_ID, manager_ID, title\n  FROM employees\n    START WITH title = 'President'\n    CONNECT BY\n      manager_ID = PRIOR employee_id\n  ORDER BY employee_ID;\n+----------------------------------------------------------------+-------------+------------+----------------------------+\n| SYS_CONNECT_BY_PATH(TITLE, ' -> ')                             | EMPLOYEE_ID | MANAGER_ID | TITLE                      |\n|----------------------------------------------------------------+-------------+------------+----------------------------|\n|  -> President                                                  |           1 |       NULL | President                  |\n|  -> President -> Vice President Engineering                    |          10 |          1 | Vice President Engineering |\n|  -> President -> Vice President HR                             |          20 |          1 | Vice President HR          |\n|  -> President -> Vice President Engineering -> Programmer      |         100 |         10 | Programmer                 |\n|  -> President -> Vice President Engineering -> QA Engineer     |         101 |         10 | QA Engineer                |\n|  -> President -> Vice President HR -> Health Insurance Analyst |         200 |         20 | Health Insurance Analyst   |\n+----------------------------------------------------------------+-------------+------------+----------------------------+\n\nSELECT \nemployee_ID, manager_ID, title,\nCONNECT_BY_ROOT title AS root_title\n  FROM employees\n    START WITH title = 'President'\n    CONNECT BY\n      manager_ID = PRIOR employee_id\n  ORDER BY employee_ID;\n+-------------+------------+----------------------------+------------+\n| EMPLOYEE_ID | MANAGER_ID | TITLE                      | ROOT_TITLE |\n|-------------+------------+----------------------------+------------|\n|           1 |       NULL | President                  | President  |\n|          10 |          1 | Vice President Engineering | President  |\n|          20 |          1 | Vice President HR          | President  |\n|         100 |         10 | Programmer                 | President  |\n|         101 |         10 | QA Engineer                | President  |\n|         200 |         20 | Health Insurance Analyst   | President  |\n+-------------+------------+----------------------------+------------+\n\n-- The components of a car.\nCREATE TABLE components (\n    description VARCHAR,\n    quantity INTEGER,\n    component_ID INTEGER,\n    parent_component_ID INTEGER\n    );\n\nINSERT INTO components (description, quantity, component_ID, parent_component_ID) VALUES\n    ('car', 1, 1, 0),\n       ('wheel', 4, 11, 1),\n          ('tire', 1, 111, 11),\n          ('#112 bolt', 5, 112, 11),\n          ('brake', 1, 113, 11),\n             ('brake pad', 1, 1131, 113),\n       ('engine', 1, 12, 1),\n          ('piston', 4, 121, 12),\n          ('cylinder block', 1, 122, 12),\n          ('#112 bolt', 16, 112, 12)   -- Can use same type of bolt in multiple places\n    ;\n\nSELECT\n  description,\n  quantity,\n  component_id, \n  parent_component_ID,\n  SYS_CONNECT_BY_PATH(component_ID, ' -> ') AS path\n  FROM components\n    START WITH component_ID = 1\n    CONNECT BY \n      parent_component_ID = PRIOR component_ID\n  ORDER BY path\n  ;\n+----------------+----------+--------------+---------------------+----------------------------+\n| DESCRIPTION    | QUANTITY | COMPONENT_ID | PARENT_COMPONENT_ID | PATH                       |\n|----------------+----------+--------------+---------------------+----------------------------|\n| car            |        1 |            1 |                   0 |  -> 1                      |\n| wheel          |        4 |           11 |                   1 |  -> 1 -> 11                |\n| tire           |        1 |          111 |                  11 |  -> 1 -> 11 -> 111         |\n| #112 bolt      |        5 |          112 |                  11 |  -> 1 -> 11 -> 112         |\n| brake          |        1 |          113 |                  11 |  -> 1 -> 11 -> 113         |\n| brake pad      |        1 |         1131 |                 113 |  -> 1 -> 11 -> 113 -> 1131 |\n| engine         |        1 |           12 |                   1 |  -> 1 -> 12                |\n| #112 bolt      |       16 |          112 |                  12 |  -> 1 -> 12 -> 112         |\n| piston         |        4 |          121 |                  12 |  -> 1 -> 12 -> 121         |\n| cylinder block |        1 |          122 |                  12 |  -> 1 -> 12 -> 122         |\n+----------------+----------+--------------+---------------------+----------------------------+"
},
{
    "url": "https://docs.snowflake.com/en/sql-reference/constructs/changes",
    "title": "CHANGES",
    "description": "The CHANGES clause enables querying the change tracking metadata for a table or view within a specified interval of time\nwithout having to create a stream with an explicit transactional offset. Multiple queries can retrieve the change tracking\nmetadata between different transactional start and endpoints.",
    "syntax": "SELECT ...\nFROM ...\n   CHANGES ( INFORMATION => { DEFAULT | APPEND_ONLY } )\n   AT ( { TIMESTAMP => <timestamp> | OFFSET => <time_difference> | STATEMENT => <id> | STREAM => '<name>' } ) | BEFORE ( STATEMENT => <id> )\n   [ END( { TIMESTAMP => <timestamp> | OFFSET => <time_difference> | STATEMENT => <id> } ) ]\n[ ... ]",
    "example": "CREATE OR REPLACE TABLE t1 (\n   id number(8) NOT NULL,\n   c1 varchar(255) default NULL\n );\n\n-- Enable change tracking on the table.\n ALTER TABLE t1 SET CHANGE_TRACKING = TRUE;\n\n -- Initialize a session variable for the current timestamp.\n SET ts1 = (SELECT CURRENT_TIMESTAMP());\n\n INSERT INTO t1 (id,c1)\n VALUES\n (1,'red'),\n (2,'blue'),\n (3,'green');\n\n DELETE FROM t1 WHERE id = 1;\n\n UPDATE t1 SET c1 = 'purple' WHERE id = 2;\n\n -- Query the change tracking metadata in the table during the interval from $ts1 to the current time.\n -- Return the full delta of the changes.\n SELECT *\n FROM t1\n   CHANGES(INFORMATION => DEFAULT)\n   AT(TIMESTAMP => $ts1);\n\n +----+--------+-----------------+-------------------+------------------------------------------+\n | ID | C1     | METADATA$ACTION | METADATA$ISUPDATE | METADATA$ROW_ID                          |\n |----+--------+-----------------+-------------------+------------------------------------------|\n |  2 | purple | INSERT          | False             | 1614e92e93f86af6348f15af01a85c4229b42907 |\n |  3 | green  | INSERT          | False             | 86df000054a4d1dc64d5d74a44c3131c4c046a1f |\n +----+--------+-----------------+-------------------+------------------------------------------+\n\n -- Query the change tracking metadata in the table during the interval from $ts1 to the current time.\n -- Return the append-only changes.\n SELECT *\n FROM t1\n   CHANGES(INFORMATION => APPEND_ONLY)\n   AT(TIMESTAMP => $ts1);\n\n +----+-------+-----------------+-------------------+------------------------------------------+\n | ID | C1    | METADATA$ACTION | METADATA$ISUPDATE | METADATA$ROW_ID                          |\n |----+-------+-----------------+-------------------+------------------------------------------|\n |  1 | red   | INSERT          | False             | 6a964a652fa82974f3f20b4f49685de54eeb4093 |\n |  2 | blue  | INSERT          | False             | 1614e92e93f86af6348f15af01a85c4229b42907 |\n |  3 | green | INSERT          | False             | 86df000054a4d1dc64d5d74a44c3131c4c046a1f |\n +----+-------+-----------------+-------------------+------------------------------------------+\n\nCREATE OR REPLACE TABLE t1 (\n  id number(8) NOT NULL,\n  c1 varchar(255) default NULL\n);\n\n-- Enable change tracking on the table.\nALTER TABLE t1 SET CHANGE_TRACKING = TRUE;\n\n-- Initialize a session 'start timestamp' variable for the current timestamp.\nSET ts1 = (SELECT CURRENT_TIMESTAMP());\n\nINSERT INTO t1 (id,c1)\nVALUES\n(1,'red'),\n(2,'blue'),\n(3,'green');\n\n-- Initialize a session 'end timestamp' variable for the current timestamp.\nSET ts2 = (SELECT CURRENT_TIMESTAMP());\n\nDELETE FROM t1 WHERE id = 3;\nSET last_query_id = (SELECT LAST_QUERY_ID());\n\n-- Create a table populated by the change data between the start and end timestamps.\nCREATE OR REPLACE TABLE t2 (\n  c1 varchar(255) default NULL\n  )\nAS SELECT C1\n  FROM t1\n  CHANGES(INFORMATION => APPEND_ONLY)\n  AT(TIMESTAMP => $ts1)\n  END(TIMESTAMP => $ts2);\n\nSELECT * FROM t2;\n\n+-------+\n| C1    |\n|-------|\n| red   |\n| blue  |\n| green |\n+-------+\n\n-- Create a table populated by the change data between the start timestamp and end statement.\n-- This example demonstrates that END is inclusive of the statement passed in.\nCREATE OR REPLACE TABLE t3 (\n  c1 varchar(255) default NULL\n  )\nAS SELECT C1\n  FROM t1\n  CHANGES(INFORMATION => DEFAULT)\n  AT(TIMESTAMP => $ts1)\n  END(STATEMENT => $last_query_id);\n\n+-------+\n| C1    |\n|-------|\n| red   |\n| blue  |\n+-------+\n\nCREATE OR REPLACE TABLE t1 (\n  id number(8) NOT NULL,\n  c1 varchar(255) default NULL\n);\n\n-- Create a stream on the table.\nCREATE OR REPLACE STREAM s1 ON TABLE t1;\n\nINSERT INTO t1 (id,c1)\nVALUES\n(1,'red'),\n(2,'blue'),\n(3,'green');\n\n-- Initialize a session 'end timestamp' variable for the current timestamp.\nSET ts2 = (SELECT CURRENT_TIMESTAMP());\n\nDELETE FROM t1;\n\n-- Create a table populated by the change data between the current\n-- s1 offset and the end timestamp.\nCREATE OR REPLACE TABLE t2 (\n  c1 varchar(255) default NULL\n  )\nAS SELECT C1\n  FROM t1\n  CHANGES(INFORMATION => APPEND_ONLY)\n  AT(STREAM => 's1')\n  END(TIMESTAMP => $ts2);\n\nSELECT * FROM t2;\n\n+-------+\n| C1    |\n|-------|\n| red   |\n| blue  |\n| green |\n+-------+"
},
{
    "url": "https://docs.snowflake.com/en/sql-reference/constructs/at-before",
    "title": "AT | BEFORE",
    "description": "The AT or BEFORE clause is used for Snowflake Time Travel. In a query, it is specified in the",
    "syntax": "SELECT ...\nFROM ...\n  { AT | BEFORE }\n  (\n    { TIMESTAMP => <timestamp> |\n      OFFSET => <time_difference> |\n      STATEMENT => <id> |\n      STREAM => '<name>' }\n  )\n[ ... ]",
    "example": "SELECT * FROM my_table AT(TIMESTAMP => 'Wed, 26 Jun 2024 09:20:00 -0700'::TIMESTAMP_LTZ);\n\nSELECT * FROM my_table AT(TIMESTAMP => TO_TIMESTAMP(1432669154242, 3));\n\nSELECT * FROM my_table AT(OFFSET => -60*5) AS T WHERE T.flag = 'valid';\n\nSELECT * FROM my_table BEFORE(STATEMENT => '8e5d0ca9-005e-44e6-b858-a8f5b37c5726');\n\nSELECT oldt.* ,newt.*\n  FROM my_table BEFORE(STATEMENT => '8e5d0ca9-005e-44e6-b858-a8f5b37c5726') AS oldt\n    FULL OUTER JOIN my_table AT(STATEMENT => '8e5d0ca9-005e-44e6-b858-a8f5b37c5726') AS newt\n    ON oldt.id = newt.id\n  WHERE oldt.id IS NULL OR newt.id IS NULL;\n\nSELECT *\n  FROM db1.public.htt1\n    AT(TIMESTAMP => '2024-06-05 17:50:00'::TIMESTAMP_LTZ) h\n    JOIN db1.public.tt1\n    AT(TIMESTAMP => '2024-06-05 17:50:00'::TIMESTAMP_LTZ) t\n    ON h.c1=t.c1;"
},
{
    "url": "https://docs.snowflake.com/en/sql-reference/constructs/from",
    "title": "FROM",
    "description": "Specifies the tables, views, or table functions to use in a",
    "syntax": "SELECT ...\nFROM objectReference [ JOIN objectReference [ ... ] ]\n[ ... ]",
    "example": "CREATE TABLE ftable1 (retail_price FLOAT, wholesale_cost FLOAT, description VARCHAR);\nINSERT INTO ftable1 (retail_price, wholesale_cost, description) \n  VALUES (14.00, 6.00, 'bling');\n\nSELECT description, retail_price, wholesale_cost \n    FROM ftable1;\n+-------------+--------------+----------------+\n| DESCRIPTION | RETAIL_PRICE | WHOLESALE_COST |\n|-------------+--------------+----------------|\n| bling       |           14 |              6 |\n+-------------+--------------+----------------+\n\nSELECT description, retail_price, wholesale_cost \n    FROM temporary_doc_test.ftable1;\n+-------------+--------------+----------------+\n| DESCRIPTION | RETAIL_PRICE | WHOLESALE_COST |\n|-------------+--------------+----------------|\n| bling       |           14 |              6 |\n+-------------+--------------+----------------+\n\nSELECT v.profit \n    FROM (SELECT retail_price - wholesale_cost AS profit FROM ftable1) AS v;\n+--------+\n| PROFIT |\n|--------|\n|      8 |\n+--------+\n\nSELECT *\n    FROM sales SAMPLE(10);\n\nSELECT *\n    FROM TABLE(Fibonacci_Sequence_UDTF(6.0::FLOAT));\n\nSELECT *\n    FROM sales AT(OFFSET => -86400);\nSELECT *\n    FROM sales AT(TIMESTAMP => '2018-07-27 12:00:00'::TIMESTAMP);\n\nSELECT\n    v.$1, v.$2, ...\n  FROM\n    @my_stage( FILE_FORMAT => 'csv_format', PATTERN => '.*my_pattern.*') v;\n\nSELECT * FROM DIRECTORY(@mystage);\n\nSELECT FILE_URL FROM DIRECTORY(@mystage) WHERE SIZE > 100000;\n\nSELECT FILE_URL FROM DIRECTORY(@mystage) WHERE RELATIVE_PATH LIKE '%.csv';"
},
{
    "url": "https://docs.snowflake.com/en/sql-reference/constructs/into",
    "title": "INTO",
    "description": "Sets",
    "syntax": "SELECT <expression1>\n   [ , <expression2> ]\n   [ , <expressionN> ]\n[ INTO :<variable1> ]\n   [ , :<variable2> ]\n   [ , :<variableN> ]\nFROM ...\nWHERE ...\n[ ... ]"
},
{
    "url": "https://docs.snowflake.com/en/sql-reference/constructs/top_n",
    "title": "TOP",
    "description": "Constrains the maximum number of rows returned by a statement or subquery.",
    "syntax": "SELECT\n    [ TOP <n> ]\n    ...\nFROM ...\n[ ORDER BY ... ]\n[ ... ]",
    "example": "select c1 from testtable;\n\n+------+\n|   C1 |\n|------|\n|    1 |\n|    2 |\n|    3 |\n|   20 |\n|   19 |\n|   18 |\n|    1 |\n|    2 |\n|    3 |\n|    4 |\n| NULL |\n|   30 |\n| NULL |\n+------+\n\nselect TOP 4 c1 from testtable;\n\n+----+\n| C1 |\n|----|\n|  1 |\n|  2 |\n|  3 |\n| 20 |\n+----+"
}
]