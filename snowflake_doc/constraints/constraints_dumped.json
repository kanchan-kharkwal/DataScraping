[
    {
        "url": "https://docs.snowflake.com/en/sql-reference/constraints",
        "content": "# Constraints\n\nConstraints define integrity and consistency rules for data stored in tables.\nSnowflake provides support for constraints as defined in the ANSI SQL standard,\nas well as some extensions for compatibility with other databases, such as Oracle.\n\nImportant\n\nFor standard tables, Snowflake supports defining and maintaining constraints, but\ndoes not enforce them, except for NOT NULL constraints, which are always enforced.\n\nViolations of constraints may cause unexpected downstream effects. If you decide to create a\nconstraint that must be relied upon, make sure your downstream processes can maintain data\nintegrity. For more information, see Constraint properties .\n\nConstraints on standard tables are provided primarily for data modeling purposes and compatibility\nwith other databases, as well as to support client tools that utilize constraints. For example,\nTableau supports using constraints to perform join culling (join elimination), which can improve the\nperformance of generated queries and cube refresh.\n\nFor hybrid tables , Snowflake both supports and enforces\nconstraints. Primary key constraints are required and enforced on all hybrid tables, and other\nconstraints are enforced when used.\n\nNext Topics:"
    },
    {
        "url": "https://docs.snowflake.com/en/sql-reference/constraints-overview",
        "content": "# Overview of Constraints\n\nSnowflake provides the following constraint functionality:\n\nUnique, primary, and foreign keys, and NOT NULL columns.\n\nNamed constraints.\n\nSingle-column and multi-column constraints.\n\nCreation of constraints inline and out-of-line.\n\nCreation, modification, and deletion of constraints.\n\n## Supported Constraint Types\n\nSnowflake supports the following constraint types from the ANSI SQL standard:\n\nPRIMARY KEY\n\nFOREIGN KEY\n\nUNIQUE\n\nNOT NULL\n\nA table can have multiple unique keys and foreign keys, but only one primary key. A PRIMARY KEY constraint implies that the\ncolumn is both NOT NULL and UNIQUE.\n\nAll foreign keys must reference a corresponding primary or unique key that matches the column types of each column in the foreign key.\nThe primary key for a foreign key can be on a different table or the same table as the foreign key. When you define foreign key constraints across hybrid tables , the tables must be in the same database.\n\nThe following table summarizes the differences in behavior between standard tables and hybrid tables,\nwith respect to the enforcement of constraints and whether constraints are required.\n\nA constraint is enforced when it protects a column from being updated in certain ways.\nFor example, a column that is declared NOT NULL cannot contain a NULL value. An attempt to copy or insert a NULL value into a NOT NULL column always results in an error.\nFor hybrid tables, you cannot set the NOT ENFORCED property on PRIMARY KEY, FOREIGN KEY, and UNIQUE constraints. Setting this property results in an “invalid constraint property” error.\n\nA constraint is required when one or more columns in a table must have such a constraint, which is only true for\nPRIMARY KEY constraints on hybrid tables.\n\n| Feature | Hybrid tables | Standard tables |\n| --- | --- | --- |\n| PRIMARY KEY constraints | Required, enforced | Optional, not enforced |\n| FOREIGN KEY constraints | Optional, enforced (referential integrity) | Optional, not enforced |\n| UNIQUE constraints | Optional, enforced | Optional, not enforced |\n| NOT NULL constraints | Optional, enforced | Optional, enforced |\n\nFeature\n\nHybrid tables\n\nStandard tables\n\nPRIMARY KEY constraints\n\nRequired, enforced\n\nOptional, not enforced\n\nFOREIGN KEY constraints\n\nOptional, enforced (referential integrity)\n\nOptional, not enforced\n\nUNIQUE constraints\n\nOptional, enforced\n\nOptional, not enforced\n\nNOT NULL constraints\n\nOptional, enforced\n\nOptional, enforced\n\nSee also CREATE | ALTER TABLE … CONSTRAINT .\n\n## Table Constraints\n\nSnowflake supports constraints on permanent, transient, temporary, and hybrid\ntables. You can define constraints on columns of all data types, and you can\ninclude any number of columns in a single constraint.\n\nWhen you copy a table by using CREATE TABLE … LIKE or CREATE TABLE … CLONE,\nall existing constraints on the table, including foreign keys, are copied to the\nnew table. (CREATE TABLE … CLONE is not supported for hybrid tables.)\n\nAdditional commands and functions, such as DROP/UNDROP and GET_DDL are\nsupported for tables with constraints. They are also supported for schemas\nand databases.\n\nFor Snowflake Time Travel, when previous versions of a table are copied, the\ncurrent version of the constraints on the table are used because Snowflake\ndoes not store previous versions of constraints in table metadata.\n\n## Single-Column and Multi-Column Constraints\n\nConstraints can be defined on a single column or on multiple columns in the same\ntable.\n\nFor multi-column constraints (composite primary keys or unique keys), the\ncolumns are ordered, and each column has a corresponding key sequence.\n\n## Inline and Out-of-Line Constraints\n\nConstraints are defined either inline or out-of-line during table creation or\nmodification:\n\nInline constraints are created as part of the column definition and can only\nbe used for single-column constraints.\n\nOut-of-line constraints are defined using a separate clause that specifies the\ncolumn or columns on which the constraint is created. They can be used for creating\neither single-column or multi-column constraints, as well as for creating\nconstraints on existing columns.\n\n## Constraints in GET_DDL\n\nThe SQL statements that GET_DDL returns includes the\nclauses that define constraints; however, note the following:\n\nSingle-column constraints, such as NOT NULL and DEFAULT , are\nreconstructed inline with the definition of the column.\n\nTable constraints, such as unique/primary/foreign keys, are always reconstructed as\nout-of-line constraints, even if they consist of a single column.\n\nFor unnamed constraints (that is, constraints with a system-generated name), GET_DDL does not return the system-generated name.\n\nOn this page"
    },
    {
        "url": "https://docs.snowflake.com/en/sql-reference/constraints-create",
        "content": "# Creating Constraints\n\nA constraint can be created at table creation using CREATE TABLE , or added to a table later using ALTER TABLE :\n\nSingle-column constraints can be created inline as part of the column definition.\n\nMulti-column constraints must be created in a separate, i.e. out-of-line, clause that specifies the columns in the constraint.\n\nTo create a constraint, certain access control privileges must be granted on the role used to create the constraint. For more information, see Access control requirements .\n\n## Creating Constraints Inline\n\nThe following inline syntax can only be used for single-column constraints:\n\n```\nCREATE [ OR REPLACE ] TABLE <name> (<column_name> <column_type> [ <inline_constraint> ] , ... )\n\nALTER TABLE <name> ADD COLUMN <column_name> <column_type> [ <inline_constraint> ]\n\n```\n\nFor inline_constraint syntax details, see CREATE | ALTER TABLE … CONSTRAINT .\n\n## Creating Constraints Out-of-line\n\nThe following out-of-line syntax must be used for multi-column constraints, but can also be used for single-column constraints:\n\n```\nCREATE [ OR REPLACE ] TABLE <name> ( ... , [ <outofline_constraint> ], ... )\n\nALTER TABLE <name> ADD <outofline_constraint>\n\n```\n\nFor outofline_constraint syntax details, see CREATE | ALTER TABLE … CONSTRAINT .\n\n## Constraints in CREATE TABLE … LIKE and CLONE\n\nSnowflake supports creating copies of tables using CREATE TABLE :\n\nTo create an empty copy, use CREATE TABLE … LIKE.\n\nTo create a clone, use CREATE TABLE … CLONE.\n\nIn addition, copies of tables are automatically created when a schema or database is cloned.\n\nRegardless of how a copy is created for a table, the constraints on the original table are also copied. When copying a foreign key with a referencing table (foreign key table) and a referenced table (primary key table), the following scenarios may occur:\n\nIf both tables are copied in the same command (such as during cloning of a schema or database), a new foreign key is created between the new referencing table and the referenced table.\n\nIf only the referencing table is copied, a new foreign key is created on the referencing table, which points to the original primary key table as the referenced table.\n\nIf only the referenced table is copied, no new foreign keys are created, although the primary/unique keys are copied.\n\nAs a result, if you copy a referencing and referenced table separately, you must manually create a new foreign key, or change the primary key table for the new foreign key manually.\n\nOn this page"
    },
    {
        "url": "https://docs.snowflake.com/en/sql-reference/constraints-alter",
        "content": "# Modifying Constraints\n\nAfter a constraint is created:\n\nThe constraint can be renamed.\n\nSome properties can be modified, e.g. RELY.\n\nSome properties cannot be modified, e.g. such as DEFERRABLE. To modify these properties, the constraint must be dropped and recreated.\n\nThe column definition for a constraint cannot be modified, e.g. add new columns, drop existing columns, or change the order of columns. To make these types of changes, the constraint must be dropped\nand recreated.\n\nWhen modifying a constraint, the constraint can be identified using either the constraint name or the columns in the constraint definition along with the type of the constraint. Primary keys can also be\nidentified using the PRIMARY KEY keyword, because each table can have only a single primary key.\n\nIf a table with constraints is modified, e.g. rename table or swap table with another table, the constraints are updated to reflect the changes.\n\n## Renaming a Constraint\n\nUse the following syntax for the ALTER TABLE command to rename a constraint:\n\n```\nALTER TABLE <table_name> RENAME CONSTRAINT <old_name> TO <new_name>;\n\n```\n\n## Modifying Properties of a Constraint\n\nUse the following syntax for the ALTER TABLE command to modify the properties of a constraint:\n\n```\nALTER TABLE <table_name>\n    { ALTER | MODIFY } { CONSTRAINT <name> | PRIMARY KEY | { UNIQUE | FOREIGN KEY } (<column_name>, [ ... ] ) }\n    { [ [ NOT ] ENFORCED ] [ VALIDATE | NOVALIDATE ] [ RELY | NORELY ] };\n\n```\n\nCurrently, Snowflake only supports setting the following constraint properties:\n\nNOT ENFORCED\n\nNOVALIDATE\n\nRELY and NORELY\n\nNote that Snowflake does not support setting ENFORCED and VALIDATE. See also Non-default values for ENABLE and VALIDATE properties .\n\nFor descriptions of the constraint properties, see Constraint properties .\n\n## Modifying a Table with Constraints\n\nIf a table with constraints is renamed, the constraints for the table, as well as any foreign key constraints that reference the table are updated to reference the new name.\n\nLikewise, if a table is swapped with another, existing table, all the constraints on the table are maintained on the swapped table.\n\nFor more details about renaming or swapping tables, see ALTER TABLE .\n\nOn this page"
    },
    {
        "url": "https://docs.snowflake.com/en/sql-reference/constraints-drop",
        "content": "# Dropping Constraints\n\nConstraints are dropped using the ALTER TABLE command:\n\nALTER TABLE … DROP CONSTRAINT explicitly drops the specified constraint. Similar to modifying constraints, the constraint can be identified by the constraint name or column definition along with\nthe constraint type. For a primary key, they can also be identified using the PRIMARY KEY keyword.\n\nALTER TABLE … DROP COLUMN drops a column and its associated constraints.\n\nBy default, when a primary/unique key is dropped, all foreign keys referencing the key being dropped are also dropped, unless the RESTRICT drop option is specified.\n\nConstraints are also dropped when the associated tables/schemas/databases are dropped. The DROP commands support the CASCADE | RESTRICT drop options.\n\nNote\n\nDropped tables, schemas, and databases can be restored using the UNDROP command; dropped columns and constraints cannot be restored.\n\n## Dropping Constraints\n\nUnique/primary/foreign key constraints can be explicitly dropped (using ALTER TABLE … DROP CONSTRAINT):\n\n```\nALTER TABLE <table_name> DROP { CONSTRAINT <name> | PRIMARY KEY | { UNIQUE | FOREIGN KEY } (<column>, [ ... ] ) } [ CASCADE | RESTRICT ]\n\n```\n\nFor these constraints, when dropping a foreign key constraint or a primary/unique key constraint with no foreign key references, the constraints are dropped directly.\n\nThe default drop option is CASCADE, which means that dropping a unique/primary key with foreign key references drops all the referencing foreign keys together with the unique/primary key.\n\nIf the RESTRICT drop option is specified, when dropping a primary/unique key, an error is returned if there exist foreign keys that reference the keys being dropped.\n\n## Dropping Columns\n\nDropping columns using ALTER TABLE … DROP COLUMN behaves similarly to dropping constraints:\n\n```\nALTER TABLE <table_name> DROP COLUMN <name> [ CASCADE | RESTRICT ]\n\n```\n\nThe default drop option is CASCADE, which means any constraint that contains the column being dropped is also dropped. If a primary/unique key involving the column is referenced by other foreign key\nconstraints, all referencing foreign keys are dropped.\n\nIf the RESTRICT option is specified, an error is returned if the column has primary/unique keys with foreign keys references. The drop command only succeeds if there are no constraints defined on or\nreferring to the column being dropped.\n\n## Dropping Tables/Schemas/Databases\n\nThe DROP command drops the specified table, schema, or database and can also be specified to drop all constraints associated with the object:\n\n```\nDROP { TABLE | SCHEMA | DATABASE } <name> [ CASCADE | RESTRICT ]\n\n```\n\nSimilar to dropping columns and constraints, CASCADE is the default drop option, and all constraints that belong to or references the object being dropped will also be dropped.\n\nFor example, when dropping a database, if the database contains a primary/unique key which is referenced by a foreign key from another database, the referencing foreign keys are also dropped.\n\nIf the object is later undropped, all relevant constraints previously dropped will be restored.\n\nIf the RESTRICT option is specified, an error is returned if any primary/unique constraints under the object has foreign key references.\n\nOn this page"
    }
]